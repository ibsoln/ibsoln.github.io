<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv=content-security-policy content="default-src 'none'; script-src 'self' 'unsafe-eval' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; font-src 'self' https://fonts.gstatic.com; frame-src 'self' https:; img-src 'self' data: https:; connect-src 'self' https:; worker-src blob:;">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Documents&#8201;&#8212;&#8201;Data Model | Couchbase Docs</title>
<link rel="canonical" href="http://127.0.0.1:5000/couchbase-lite/current/android/document.html">
<link rel="stylesheet" href="../../../_/css/site.css">
<script src="../../../_/js/vendor/jquery.js"></script>
<meta name="description" content="Couchbase Lite concepts -- Data model -- Documents">
<link rel="schema.dcterms" href="https://purl.org/dc/terms/">


<meta name="dcterms.subject" content="couchbase-lite">
<meta name="dcterms.identifier" content="3.0">
<meta name="page-url" content="/couchbase-lite/current/android/document.html">
<meta name="generator" content="Antora 3.0.0-alpha.5">
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
</head>
<body class="article">
<header class="header fixed-top">
  <div class="header-top-row">
      <div class="container">
          <nav class="navbar navbar-expand-md flex-nowrap justify-content-between navbar-new-top">
              <ul class="navbar-brand-list">
                <li class="brand-logo">
                  <a class="navbar-brand" href="https://www.couchbase.com">
                    <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase" />
                  </a>
                </li>
                <li>
                  <a class="navbar-brand cb-documentation" href="http://127.0.0.1:5000/home/index.html">
                    <img src="../../../_/img/cb-documentation.svg" alt="Couchbase Documentation" class="cb-docs" />
                    <img src="../../../_/img/cb-docs-hover.svg" alt="Couchbase Documentation" class="hide cb-hover-docs" />
                  </a>
                </li>
              </ul>
              <button class="navbar-burger" data-target="topbar-menu">
                <span></span>
                <span></span>
                <span></span>
              </button>

          </nav>
      </div>
  </div>
  <div class="header-bottom-row" id="topbar-menu">
    <div class="container">
        <nav  class="navbar navbar-new-bottom">

              <div class="navbar-collapse collapse" id="navbar2">
                <ul class="navbar-nav w-100 justify-content-start">
                  <li class="nav-item">
                    <a href="http://127.0.0.1:5000/home/index.html" class="nav-link">
                      <i class="fas fa-home"></i>
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/server.html">
                      Server
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/mobile.html">
                      Mobile Local
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/cloud.html">
                      Cloud
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/sdk.html">
                      SDKs
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../tutorials/index.html">
                      Tutorials
                      <span class="arrow">
                        <i class="fas fa-arrow-right"></i>
                      </span>
                    </a>
                  </li>
                </ul>
              </div>
              <div class="primary-action">
                <a class="btn btn-primary btn-grey-reverse" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Download'});" href="https://www.couchbase.com/downloads">
                  Downloads
                  <i class="far fa-arrow-to-bottom fa-fw"></i>
                </a>
                <a href="https://cloud.couchbase.com/sign-up" class="btn btn-primary" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Free Trial'});" >
                  Start Free Trial
                  <i class="far fa-cloud fa-fw"></i>
                </a>

              </div>

        </nav>
    </div>
   </div>
</header>
<div class="body container">
<aside class="nav left-sidebar">
  <div class="nav-container">
    <a href="#" class="menu-expand-toggle"><span>Navigation</span><i class="fas fa-times-circle"></i><i class="fas fa-chevron-circle-left"></i></a>
<div class="components">
  <div class="components_group-title">
    <a href="../../../home/mobile.html">Mobile Local</a>
  </div>
  <ul class="components_list">
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Couchbase Lite</span>
        <select class="version_list" data-component="couchbase-lite">
          <option value="3.0" data-url="../index.html" selected>3.0</option>
          <option value="2.8" data-url="../../2.8/index.html">2.8</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0">
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../index.html">Introduction</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../cbl-whatsnew.html">New in 3.0</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="quickstart.html">Android</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="kotlin.html">Kotlin</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list is-current-page" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link is-current-page" href="document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-n1ql-mobile.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-n1ql-mobile-server-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-n1ql-mobile-querybuilder-diffs.html">N1QL Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Data Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/3.0.0/couchbase-lite-android/">API References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/3.0.0/couchbase-lite-android-ktx">Kotlin Extensions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../c/quickstart.html">C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/gs-downloads.html">Download</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/c_fleece.html">Fleece API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/field-level-encryption.html">Field Level Encryption</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-n1ql-mobile.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-n1ql-mobile-server-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/replication.html">Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/{version-full}/couchbase-lite-c/">API&#160;References</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/quickstart.html">.Net</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-n1ql-mobile.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-n1ql-mobile-server-diffs.html">N1QL Mobile - Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-n1ql-mobile-querybuilder-diffs.html">N1QL Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Data Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/{version-full}/couchbase-lite-net/index.html">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/quickstart.html">Java</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-n1ql-mobile.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-n1ql-mobile-server-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-n1ql-mobile-querybuilder-diffs.html">N1QL Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Data Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/{version-full}/couchbase-lite-java/">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/quickstart.html">Objective-C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-n1ql-mobile.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-n1ql-mobile-server-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-n1ql-mobile-querybuilder-diffs.html">N1QL Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/{version-full}/couchbase-lite-objc/index.html">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-crashes.html">Troubleshooting Crashes</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/quickstart.html">Swift</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-n1ql-mobile.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-n1ql-mobile-server-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-n1ql-mobile-querybuilder-diffs.html">N1QL Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#swift:landing-replications.adoc">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/{version-full}/couchbase-lite-swift/index.html">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-crashes.html">Troubleshooting Crashes</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../javascript.html">JavaScript</a>
  </span>
</li>
</ul>
      </div>
      <div class="version_items hide" data-version="2.8">
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/index.html">Introduction</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../cbl-whatsnew.html">What&#8217;s New</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="quickstart.html">Android</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/android/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list is-current-page" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link is-current-page" href="document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/android/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-predictive.html">Predictive Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/android/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/android/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/android/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/android/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/android/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/android/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0.{base}/couchbase-lite-android/">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/android/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/quickstart.html">C#.Net</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/csharp/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:csharp:query-predictive.adoc">Predictive Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/csharp/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/csharp/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/csharp/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/csharp/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/csharp/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/csharp/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0.{base}/couchbase-lite-net">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/csharp/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/quickstart.html">Java</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/java/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/java/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-predictive.html">Predictive Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/java/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/java/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/java/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/java/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/java/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/java/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0.{base}/couchbase-lite-java/">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/java/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/quickstart.html">Objective-C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/objc/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/objc/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:objc:query-predictive.adoc">Predictive Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/objc/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/objc/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/objc/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/objc/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/objc/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/objc/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0.{base}/couchbase-lite-objc">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-crashes.html">Decoding Crash Logs</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/objc/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/quickstart.html">Swift</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/swift/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/swift/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-live.html">Live Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-predictive.html">Predictive Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/swift/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/swift/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/swift/dbreplica.html">Intra-Device</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/swift/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/swift/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/swift/p2psync-custom.html">Integrate a Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0.{base}/couchbase-lite-swift">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-crashes.html">Decoding Crash Logs</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/swift/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../2.8/javascript.html">JavaScript</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../2.8/javascript.html">JavaScript</a>
  </span>
</li>
</ul>
</li>
</ul>
      </div>
    </li>
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Sync Gateway</span>
        <select class="version_list" data-component="sync-gateway">
          <option value="3.0" data-url="../../../sync-gateway/current/index.html" selected>3.0</option>
          <option value="2.8" data-url="../../../sync-gateway/2.8/index.html">2.8</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0">
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/introduction.html">Introduction</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/whatsnew.html"><strong><em>New in 3.0</em></strong></a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/index.html">Quick Links</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-prepare.html">Prepare</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-verify-install.html">Verify</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/data-modeling.html">Data Modeling</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Configuration</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-bootstrap.html">Bootstrap</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-database.html">Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-db-security.html">Database Security</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-access-control.html">Access Control</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-import-filter.html">Import Filter</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-isgr.html">Inter-Sync&#160;Gateway Replication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-properties-legacy.html">Legacy Pre-3.0&#160;BETA Configuration</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-javascript-functions.html">Javascript Functions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-environment-variables.html">Environment Variables</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Security</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/secure-sgw-access.html">Secure Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-users.html">User Authentication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-certs.html">TLS Cert Authentication</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Access Control</span>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-concepts.html">Concepts</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-model.html">Access Control Model</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/channels.html">Channels</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/roles.html">Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/users.html">Users</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function.html">Sync Function</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api.html">API Reference</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-access-cmd.html">access()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-channel-cmd.html">channel()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-expiry-cmd.html">expiry()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-access-cmd.html">requireAccess()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-admin-cmd.html">requireAdmin()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-role-cmd.html">requireRole()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-user-cmd.html">requireUser()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-role-cmd.html">role()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-throw-cmd.html">throw()</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how.html">How-to</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-create-users.html">Create Users</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-create-roles.html">Create Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-assign-users-to-roles.html">Assign User to Role</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-control-document-access.html">Control Document Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-verify-access.html">Verify Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-use-xattrs-for-access-grants.html">Use XATTRS for Access Grants</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/auto-purge-channel-access-revocation.html">Auto-Purge Channel Access Revocation</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">REST API</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-access.html">Secure Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin.html">Admin REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-metrics.html">Metrics REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api.html">Public REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-access-rbac-roles.html">RBAC Role - Endpoint Cross-Reference</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-with-couchbase-server.html">Sync with Server</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-using-app.html">Sync with Application</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Inter-Sync Gateway Replication</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-run.html">Initialize</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-manage.html">Manage</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-monitor.html">Monitor</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-conflict-resolution.html">Inter Syncgateway Conflict Resolution</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/delta-sync.html">Delta Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/import-filter.html">Import Filter</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Manage</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/revisions.html">Revisions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/managing-tombstones.html">Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/resync.html">Resync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-monitoring.html">Stats Monitoring</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/database-offline.html">Database Offline</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Logging and Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/logging.html">Logging</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sgcollect-info.html">SG Collect Info</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Deploy</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deployment.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/command-line-options.html">Command Line Options</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/load-balancer.html">Load Balancer</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/os-level-tuning.html">OS Level Tuning</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/webhooks.html">Webhooks</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/changes-feed.html">Changes Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/integrating-external-stores.html">External Stores</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-prometheus.html">Prometheus Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/setting-up-dr-cluster.html">Disaster Recovery</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/upgrading.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Use Kubernetes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deploy-cluster-to-kubernetes.html">Deploy</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-operator::tutorial-sync-gateway-manage.adoc">Manage a Sync Gateway Cluster</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-operator::tutorial-sync-gateway-clients.adoc">Expose Sync Gateway to Couchbase Lite clients</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Server Compatibility</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-collections.html">Collections</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-eventing.html">Eventing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-transactions.html">Transactions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-xdcr.html">XDCR</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/supported-environments.html">Supported Environments</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/compatibility.html">Compatibility Matrix</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Legacy Features</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sg-replicate.html">SG Replicate</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sgreplicate-resolving-conflicts.html">SG Replicate - Resolving Conflicts (depr)</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-logging-pre2-1.html">Legacy Pre-2.1 Logging</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/glossary.html">Glossary</a>
  </span>
</li>
</ul>
      </div>
      <div class="version_items hide" data-version="2.8">
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/introduction.html">Introduction</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/2.8/index.html">Quick Start</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/whatsnew.html">What&#8217;s New</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-prepare.html">Prepare</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-verify-install.html">Verify</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/data-modeling.html">Data Modeling</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/data-modeling.html">Data Modeling</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Concepts</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/users.html">Users</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/roles.html">Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/channels.html">Channels</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/managing-tombstones.html">Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/revisions.html">Revisions</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-properties-legacy.html">Configuration</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">REST API</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-access.html">REST API Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api.html">Public REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin.html">Admin REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-metrics.html">Metrics REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#sync-gateway::rest-api-client-app.adoc">REST API Client</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Security</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-users.html">User Authentication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-certs.html">TLS Certificate Authentication</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Access Control</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function.html">Sync Function</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#sync-gateway::read-access.adoc">Read Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#sync-gateway::write-access.adoc">Write Access</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-with-couchbase-server.html">Sync with Couchbase Server</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-using-app.html">Sync with Couchbase Lite</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Inter-Sync Gateway Replication</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-run.html">Initialize</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-manage.html">Manage</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-monitor.html">Monitor</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-conflict-resolution.html">Conflict Resolution</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/managing-tombstones.html">Managing Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/delta-sync.html">Delta Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/resync.html">Resync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/import-filter.html">Import filter</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Manage</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-monitoring.html">Monitor</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Logging and Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/logging.html">Logging</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sgcollect-info.html">SG Collect</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/database-offline.html">Take Database Offline/Online</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deployment.html">Deploy</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/command-line-options.html">Command Line Options</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/load-balancer.html">Load Balancer</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/os-level-tuning.html">OS-level Tuning</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/webhooks.html">Webhooks</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/2.8/server-integration.html">Changes Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/integrating-external-stores.html">External Stores</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-prometheus.html">Prometheus Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/indexing.html">Indexing versus Views</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/setting-up-dr-cluster.html">Disaster Recovery</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/upgrading.html">Upgrade</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/upgrading.html">Upgrade</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Server Compatibility</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-collections.html">Collections</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-eventing.html">Eventing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-transactions.html">Transactions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-xdcr.html">XDCR</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Use Kubernetes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deploy-cluster-to-kubernetes.html">Deploy</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#operator::tutorial-sync-gateway-manage.adoc">Manage a Sync Gateway Cluster</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#operator::tutorial-sync-gateway-clients.adoc">Expose Sync Gateway to Couchbase Lite clients</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#sync-gateway::pn-supported-os.adoc">Supported OS</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/compatibility.html">Compatibility Matrix</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Legacy Features</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#sync-gateway::resolving-conflicts.adoc">Conflict Resolution 1.x Clients</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sg-replicate.html">SG-Replicate</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-logging-pre2-1.html">Log Rotation pre-2.1</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/glossary.html">Sync Gateway Glossary</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/glossary.html">Sync Gateway Glossary</a>
  </span>
</li>
</ul>
</li>
</ul>
      </div>
    </li>
  </ul>
</div>
  </div>
</aside>
<aside class="toc sidebar"
      data-title="Contents"
      data-levels="2@">
  <div class="sidebar-box">
    <div class="tools" role="navigation">
<ul>
<li class="tool edit"><a href="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/pages/document.adoc" title="Edit Page" target="_blank" rel="noopener" class="remove-ext-icon">Edit on GitHub</a></li>
</ul>
</div>
    <div class="toc-menu"></div>
    <div class="is-this-helpful-box">
      <h4> Is this page helpful?</h4>
      <div class="btn-row">
        <a href="#" class="like-btn helpful-btn" id="yesBtn" data-page-rating="like" >
                <i class="far fa-thumbs-up"></i>
            Yes

            </a>
        <a href="#" class="dislike-btn helpful-btn" id="noBtn"  data-page-rating="dislike"> <i class="far fa-thumbs-down"></i> No</a>
      </div>
      <div class="any-feedback">
        <a href="#" class="btn any-feedback-btn" id="myCustomTrigger">Leave Additional Feedback? </a>
      </div>
      <div class="dialog-box" id="dialogBox">
        <form>
            <div class="form-group " id="additionalFeedbackBox">
              <textarea class="input-control feed-back-msg" rows="8" placeholder="Any Additonal Feedback?"></textarea>

              <div class="action-btn-row ">
                <a href="#" class="skip-btn" id="skipBtnMsg">Skip</a>
                  <button class="submit-btn btn blue-btn disabled" > Submit  </button>
                  <a href="#" class="info-btn"><i class="fas fa-info-circle"></i></a>
              </div>


            </div>

        </form>

      </div>
    </div>
  </div>

</aside>

<div class="feedback-modal modal-popup">
  <div class="modal-popup-dialogue">
    <div class="popup-header">
      <a href="#" class="close-popup"><i class="fa fa-times"></i></a>
    </div>
    <div class="popup-content">
      <p>
        Please use the form below to provide your feedback. Because your feedback is valuable to us,
         the information you submit in this form is recorded in our issue tracking system (JIRA), which is publicly available.
        You can track the status of your feedback using the ticket number displayed in the dialog once you submit the form.
      </p>
    </div>
  </div>
</div>

<main class="article" data-ceiling="topbar">
<div class="article-header">
<nav class="crumbs" aria-label="breadcrumbs">
<ul>
<li class="crumb"><a href="../index.html">Couchbase Lite</a></li>
<li class="crumb"><a href="quickstart.html">Android</a></li>
<li class="crumb"><a href="document.html">Documents</a></li>
</ul>
</nav>
</div>
<article class="doc">
<div class="page-heading-title">
<h1 class="page">Documents&#8201;&#8212;&#8201;Data Model</h1>
</div>
<div class="contributor-list-box">
<span class="last-commit-date" id="commitdate">    </span>
<ul id="contributorList"></ul>
<span  id="otherContributor"> + </span>
</div><div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>Description&#8201;&#8212;&#8201;<em>Couchbase Lite concepts&#8201;&#8212;&#8201;Data model&#8201;&#8212;&#8201;Documents</em><br>
Related Content&#8201;&#8212;&#8201;<a href="database.html" class="page">Databases</a> | <a href="blob.html" class="page">Blobs</a> | <a href="indexing.html" class="page">Indexing</a> |</p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1">
<h2 id="overview"><a class="anchor" href="#overview"></a>Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Couchbase Lite the term 'document' is refers to an entry in the database; a record, or row in a table if you like.</p>
</div>
<div class="paragraph">
<p>Each document has an ID (primary key in other databases) by which it can be located.
This ID can be automatically generated (as a UUID) or specified programmatically;
the only constraints are that it must be unique within the database, and it can&#8217;t be changed.
The document also has a value which contains the actual application data.
This value is stored as a dictionary collection of key-value (k-v) pairs where the values themselves may comprise different types of data such as numbers, strings, arrays or even nested objects&#8201;&#8212;&#8201;see: <a href="#data-types">Data Types</a></p>
</div>
<div class="paragraph">
<p>The document body is stored in an internal, efficient, binary form (
<a href="https://github.com/couchbaselabs/fleece#readme">Fleece</a>
).<br>
This internal form is easily converted into a manageable native dictionary format for manipulation in applications.</p>
</div>
<div class="paragraph">
<p>Couchbase Lite also provides for the direct handling of JSON data implemented in most cases by the provision of a <code>toJSON()</code> method on appropriate API classes (for example, on MutableDocument, Dictionary, Blob and Array)&#8201;&#8212;&#8201;see <a href="#lbl-json-data">Working with JSON Data</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="constructing-a-document"><a class="anchor" href="#constructing-a-document"></a>Constructing a Document</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An individual document often represents a single instance of an object in application code.
A document might be considered equivalent to a row in a relational table; with each of the documents attributes being equivalent to a column.</p>
</div>
<div class="paragraph">
<p>Documents can contain nested structures.
This allows developers to express many-to-many relationships without requiring a reference or junction table; and is naturally expressive of hierarchical data.</p>
</div>
<div class="paragraph">
<p>Most apps will work with one or more documents, persisting them to a local database and optionally syncing the either centrally or to the cloud.</p>
</div>
<div class="paragraph">
<p>In this section we provide an example of how you might create a <code>hotel</code> document, which provides basic contact details and price data.</p>
</div>
<div class="listingblock">
<div class="title">Data Model</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">hotel: {
  type: string (value = `hotel`)
  name: string
  address: dictionary {
    street: string
    city: string
    state: string
    country: string
    code: string
  }
  phones: array
  rate: float
}</code></pre>
</div>
</div>
<div id="ex-usage" class="olist arabic">
<ol class="arabic">
<li>
<p>Open or create your database</p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset1_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset1_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset1_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">

// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.*
import com.couchbase.lite.internal.utils.PlatformUtils
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.io.InputStream
import java.net.URI
import java.net.URISyntaxException


private const val TAG = "REPLICATION"

@Throws(IOException::class)
fun InputStream.toByteArray(): ByteArray {
    val buffer = ByteArray(1024)
    val output = ByteArrayOutputStream()

    var n: Int
    while (-1 &lt; this.read(buffer).also { n = it }) {
        output.write(buffer, 0, n)
    }

    return output.toByteArray()
}

//
//        &lt;.&gt; The conflict handler code is provided as a lambda.
//
//        &lt;.&gt; If the handler cannot resolve a conflict, it can return false.
//        In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.
//
//        &lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.
//
//        &lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).
//
//        &lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method


// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
@Suppress("unused")
object LocalWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.localDocument
}

// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
@Suppress("unused")
object RemoteWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.remoteDocument
}

// Using replConfig.setConflictResolver(new MergeConflictResolver());
@Suppress("unused")
object MergeConflictResolver : ConflictResolver {
    override fun resolve(conflict: Conflict): Document {
        val localDoc = conflict.localDocument?.toMap()
        val remoteDoc = conflict.remoteDocument?.toMap()

        val merge: MutableMap&lt;String, Any&gt;?
        if (localDoc == null) {
            merge = remoteDoc
        } else {
            merge = localDoc
            if (remoteDoc != null) {
                merge.putAll(remoteDoc)
            }
        }

        return if (merge == null) {
            MutableDocument(conflict.documentId)
        } else {
            MutableDocument(conflict.documentId, merge)
        }
    }

    @Suppress("unused")
    class ReplicationExamples(private val database: Database) {
        private var replicator: Replicator? = null

        @Throws(URISyntaxException::class)
        fun testReplicationBasicAuthentication() {

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = BasicAuthenticator("username", "password".toCharArray())
                )
            )
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationSessionAuthentication() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447")
                )
            )
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationStatus() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            repl.addChangeListener { change -&gt;
                if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                    Log.i(TAG, "Replication stopped")
                }
            }

            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testHandlingNetworkErrors() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            repl.addChangeListener { change -&gt;
                change.status.error?.let {
                    Log.w(TAG, "Error code: ${it.code}")
                }
            }
            repl.start()
            replicator = repl

            repl.stop()
        }

        @Throws(URISyntaxException::class)
        fun testReplicatorDocumentEvent() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            val token = repl.addDocumentReplicationListener { replication -&gt;
                Log.i(TAG, "Replication type: ${if (replication.isPush) "push" else "pull"}")

                for (document in replication.documents) {
                    document.let { doc -&gt;
                        Log.i(TAG, "Doc ID: ${document.id}")
                        doc.error?.let {
                            // There was an error
                            Log.e(TAG, "Error replicating document: ", it)
                            return@addDocumentReplicationListener
                        }
                        if (doc.flags.contains(DocumentFlag.DELETED)) {
                            Log.i(TAG, "Successfully replicated a deleted document")
                        }
                    }
                }
            }

            repl.start()
            replicator = repl

            repl.removeChangeListener(token)
        }

        @Throws(URISyntaxException::class)
        fun testReplicationCustomHeader() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value")
                )
            )
            replicator = repl
        }

        // <mark># Certificate Pinning
        @Throws(URISyntaxException::class, IOException::class)
        fun testCertificatePinning() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value"),
                    pinnedServerCertificate = PlatformUtils.getAsset("cert.cer")?.toByteArray()
                )
            )
            replicator = repl
        }

        // </mark># Reset replicator checkpoint
        @Throws(URISyntaxException::class)
        fun testReplicationResetCheckpoint() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            val resetCheckpointRequired_Example = false
            repl.start(resetCheckpointRequired_Example) <i class="conum" data-value="1"></i><b>(1)</b>

            // ... at some later time

            repl.stop()

        }

        @Throws(URISyntaxException::class)
        fun testReplicationPushFilter() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { _, flags -&gt; flags.contains(DocumentFlag.DELETED) } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationPullFilter() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { document, _ -&gt; "draft" == document.getString("type") } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testCustomRetryConfig() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    //  other config params as required . .
                    heartbeat = 150, <i class="conum" data-value="1"></i><b>(1)</b>
                    maxAttempts = 20,
                    maxAttemptWaitTime = 600
                )
            )

            repl.start()
            replicator = repl
        }

        @Throws(CouchbaseLiteException::class)
        fun testDatabaseReplica() {
            val config = DatabaseConfiguration()
            val database1 = Database("mydb", config)
            val database2 = Database("db2", config)

            /* EE feature: code below might throw a compilation error
               if it's compiled against CBL Android Community. <strong>/
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database1,
                    target = DatabaseEndpoint(database2),
                    type = ReplicatorType.PULL
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationWithCustomConflictResolver() {
            val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
            val config = ReplicatorConfiguration(database, target)
            config.conflictResolver = LocalWinsResolver
            val replication = Replicator(config)
            replication.start()
        }

        @Throws(CouchbaseLiteException::class)
        fun testSaveWithCustomConflictResolver() {
            val mutableDocument = database.getDocument("xyz")?.toMutable() ?: return
            mutableDocument.setString("name", "apples")
            database.save(mutableDocument) { newDoc, curDoc -&gt;  <i class="conum" data-value="2"></i><b>(2)</b>
                if (curDoc == null) {
                    return@save false
                } <i class="conum" data-value="3"></i><b>(3)</b>
                val dataMap: MutableMap&lt;String, Any&gt; = curDoc.toMap()
                dataMap.putAll(newDoc.toMap()) <i class="conum" data-value="4"></i><b>(4)</b>
                newDoc.setData(dataMap)
                true <i class="conum" data-value="5"></i><b>(5)</b>
            } <i class="conum" data-value="6"></i><b>(6)</b>
        }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import android.widget.Toast
import com.couchbase.lite.</strong>
import com.couchbase.lite.internal.utils.PlatformUtils
import org.junit.Test
import java.io.File
import java.io.IOException
import java.net.URI
import java.net.URISyntaxException
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.*


private const val TAG = "BASIC"

class LogTestLogger(private val level: LogLevel) : Logger {
    override fun getLevel() = level

    override fun log(level: LogLevel, domain: LogDomain, message: String) {
        // this method will never be called if param level &lt; this.level
        // handle the message, for example piping it to a third party framework
    }
}

@Suppress("unused")
class BasicExamples(private val context: Context) {
    private val database: Database

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        // Get the database (and create it if it doesnt exist).
        database = Database(
          "getting-started",
          DatabaseConfigurationFactory.create(context.filesDir.absolutePath)
          )
    }

    @Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {

        // !!! Note the code moved from here to the init { } above.
        // Create a new document (i.e. a record) in the database.
        var mutableDoc = MutableDocument().setFloat("version", 2.0f).setString("type", "SDK")

        // Save it to the database.
        database.save(mutableDoc)

        // Update a document.
        mutableDoc = database.getDocument(mutableDoc.id)!!.toMutable().setString("language", "Java")
        database.save(mutableDoc)

        val document = database.getDocument(mutableDoc.id)!!
        // Log the document ID (generated by the database) and properties
        Log.i(TAG, "Document ID :: ${document.id}")
        Log.i(TAG, "Learning ${document.getString("language")}")

        // Create a query to fetch documents of type SDK.
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))
            .execute()
        Log.i(TAG, "Number of rows :: ${rs.allResults().size}")

        // Create a replicator to push and pull changes to and from the cloud.
        // Be sure to hold a reference somewhere to prevent the Replicator from being GCed
        val replicator =
          Replicator(
            ReplicatorConfigurationFactory.create(
              database = database,
              target = URLEndpoint(URI("ws://localhost:4984/getting-started-db")),
              type = ReplicatorType.PUSH_AND_PULL,
              authenticator = BasicAuthenticator("sync-gateway", "password".toCharArray())
              )
          )


        // Listen to replicator change events.
        replicator.addChangeListener { change -&gt;
            val err = change.status.error
            if (err != null) Log.i(TAG, "Error code ::  ${err.code}")
        }

        // Start replication.
        replicator.start()

        database.delete()
    }

    @Throws(CouchbaseLiteException::class, IOException::class)
    fun test1xAttachments() {
        // if db exist, delete it
        deleteDB("android-sqlite", context.filesDir)
        ZipUtils.unzip(
            PlatformUtils.getAsset("replacedb/android140-sqlite.cblite2.zip"),
            context.filesDir
        )

        val db = Database("android-sqlite")
        try {
            // For Validation
            Arrays.equals(
                "attach1".toByteArray(),
                db.getDocument("doc1")?.getDictionary("_attachments")?.getBlob("attach1")?.content
            )
        } finally {
            // close db
            db.close()
            // if db exist, delete it
            deleteDB("android-sqlite", context.filesDir)
        }
        val document = MutableDocument()

        val content = document.getDictionary("_attachments")?.getBlob("avatar")?.content
    }

    // <mark># Initializer
    fun testInitializer() {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)
    }

    // </mark># New Database
    @Throws(CouchbaseLiteException::class)
    fun testNewDatabase() {
        val database = Database(
            "my-db",
            DatabaseConfigurationFactory.create(
                context.filesDir.absolutePath
            )
        ) <i class="conum" data-value="7"></i><b>(7)</b>
        database.close()


        database.delete()
    }

    // <mark># Database Encryption
    @Throws(CouchbaseLiteException::class)
    fun testDatabaseEncryption() {
        val db = Database(
            "my-db",
            DatabaseConfigurationFactory.create(
                encryptionKey = EncryptionKey("PASSWORD")
            )
        )

    }

    // </mark># Logging
    // !!! OBSOLETE in 3.0
    fun testLogging() {
    }

    fun testEnableCustomLogging() {
        // this custom logger will not log an event with a log level &lt; WARNING
        Database.log.custom = LogTestLogger(LogLevel.WARNING) <i class="conum" data-value="8"></i><b>(8)</b>
    }

    // <mark># Console logging
    @Throws(CouchbaseLiteException::class)
    fun testConsoleLogging() {
        Database.log.console.domains = LogDomain.ALL_DOMAINS <i class="conum" data-value="9"></i><b>(9)</b>
        Database.log.console.level = LogLevel.VERBOSE <i class="conum" data-value="10"></i><b>(10)</b>

        Database.log.console.domains = EnumSet.of(LogDomain.DATABASE) <i class="conum" data-value="11"></i><b>(11)</b>
    }

    // </mark># File logging
    @Throws(CouchbaseLiteException::class)
    fun testFileLogging() {
        Database.log.file.let {
          it.config = LogFileConfigurationFactory.create(
            context.cacheDir.absolutePath, <i class="conum" data-value="12"></i><b>(12)</b>
            maxSize = 10240, <i class="conum" data-value="13"></i><b>(13)</b>
            maxRotateCount = 5, <i class="conum" data-value="14"></i><b>(14)</b>
            usePlainText = false
            ) <i class="conum" data-value="15"></i><b>(15)</b>
            it.level = LogLevel.INFO <i class="conum" data-value="16"></i><b>(16)</b>

          }
    }

    fun writeConsoleLog() {
        Database.log.console.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    fun writeCustomLog() {
        Database.log.custom?.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    fun writeFileLog() {
        Database.log.file.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    /* The <code>tag::replication[]</code> example is inlined in java.adoc <strong>/
    fun testTroubleshooting() {
        Database.log.console.let {
            it.level = LogLevel.VERBOSE
            it.domains = LogDomain.ALL_DOMAINS
        }
    }

    // <mark># Loading a pre-built database
    @Throws(IOException::class)
    fun testPreBuiltDatabase() {
        // Note: Getting the path to a database is platform-specific.
        // For Android you need to extract the database from your assets
        // to a temporary directory and then copy it, using Database.copy()
        if (Database.exists("travel-sample", context.filesDir)) {
            return
        }
        ZipUtils.unzip(PlatformUtils.getAsset("travel-sample.cblite2.zip"), context.filesDir)
        Database.copy(
            File(context.filesDir, "travel-sample"),
            "travel-sample",
            DatabaseConfiguration()
        )
    }

    // helper methods
    // if db exist, delete it
    fun deleteDB(name: String, dir: File) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            Database.delete(name, dir)
        }

        // </mark># Initializers
        fun testInitializers() {
            val doc = MutableDocument()
            doc.let {
                it.setString("type", "task")
                it.setString("owner", "todo")
                it.setDate("createdAt", Date())
            }
            database.save(doc)
        }
    }

    // <mark># Mutability
    fun testMutability() {
        database.save(MutableDocument("xyz"))

        database.getDocument("xyz")?.toMutable()?.let {
            it.setString("name", "apples")
            database.save(it)
        }
    }

    // </mark># Typed Accessors
    fun testTypedAccessors() {
        val doc = MutableDocument()

        doc.setValue("createdAt", Date())
        val date = doc.getDate("createdAt")
    }

    // <mark># Batch operations
    fun testBatchOperations() {
        database.inBatch(UnitOfWork {
            for (i in 0..9) {
                val doc = MutableDocument()
                doc.let {
                    it.setValue("type", "user")
                    it.setValue("name", "user $i")
                    it.setBoolean("admin", false)
                }
                Log.i(TAG, "saved user document: ${doc.getString("name")}")
            }
        })
    }


    // toJSON
    fun testToJsonOperations(argDb: Database) {
        val db = argDb

    }


    // </mark># Document Expiration
    @Throws(CouchbaseLiteException::class)
    fun documentExpiration() {
        // Purge the document one day from now
        database.setDocumentExpiration(
            "doc123",
            Date(Instant.now().plus(1, ChronoUnit.DAYS).toEpochMilli())
        )

        // Reset expiration
        database.setDocumentExpiration("doc1", null)

        // Query documents that will be expired in less than five minutes
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.longValue(Instant.now().plus(5, ChronoUnit.MINUTES).toEpochMilli())
                )
            )
    }

    @Throws(CouchbaseLiteException::class)
    fun testDocumentChangeListener() {
        database.addDocumentChangeListener("user.john") { change -&gt;
            database.getDocument(change.documentID)?.let {
                Toast.makeText(
                    context,
                    "Status: ${it.getString("verified_account")}",
                    Toast.LENGTH_SHORT
                ).show()
            }
        }
    }

    // <mark># Blobs
    fun testBlobs() {
        val mDoc = MutableDocument()

        PlatformUtils.getAsset("avatar.jpg")?.use { <i class="conum" data-value="17"></i><b>(17)</b>
            mDoc.setBlob("avatar", Blob("image/jpeg", it)) <i class="conum" data-value="18"></i><b>(18)</b> <i class="conum" data-value="19"></i><b>(19)</b>
            database.save(mDoc)
        }

        val doc = database.getDocument(mDoc.id)
        val bytes = doc?.getBlob("avatar")?.content
    }
}


class supportingDatatypes
{

    private val database  = Database("mydb")

    fun datatype_dictionary() {

        // NOTE: No error handling, for brevity (see getting started)
        val document = database!!.getDocument("doc1")

        // Getting a dictionary from the document's properties
        val dict = document?.getDictionary("address")

        // Access a value with a key from the dictionary
        val street = dict?.getString("street")

        // Iterate dictionary
        for (key in dict!!.keys) {
            println("Key ${key} = ${dict.getValue(key)}")
        }

    // Create a mutable copy
    val mutable_Dict = dict.toMutable()
}

    fun datatype_mutable_dictionary() {

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        val mutable_dict = MutableDictionary()
        mutable_dict.setString("street", "1 Main st.")
        mutable_dict.setString("city", "San Francisco")

        // Add the dictionary to a document's properties and save the document
        val mutable_doc = MutableDocument("doc1")
        mutable_doc.setDictionary("address", mutable_dict)
        database!!.save(mutable_doc)

}


    fun datatype_array() {

        // NOTE: No error handling, for brevity (see getting started)

        val document = database?.getDocument("doc1")

        // Getting a phones array from the document's properties
        val array = document?.getArray("phones")

        // Get element count
        val count = array?.count()

        // Access an array element by index
        val phone = array?.getString(1)

        // Iterate array
        for ( (index, item) in array!!) {
            println("Row  ${index} = ${item}")
        }

        // Create a mutable copy
        val mutable_array = array.toMutable()
    }

    fun datatype_mutable_array() {

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        val mutable_array = MutableArray()
        mutable_array.addString("650-000-0000")
        mutable_array.addString("650-000-0001")

        // Set the array to document's properties and save the document
        val mutable_doc = MutableDocument("doc1")
        mutable_doc.setArray("phones", mutable_array)
        database?.save(mutable_doc)
    }

} // end  class supporting_datatypes



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.Dictionary
import com.couchbase.lite.Expression
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.MutableDictionary
import com.couchbase.lite.PredictionFunction
import com.couchbase.lite.PredictiveIndex
import com.couchbase.lite.PredictiveModel
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.SelectResult
import com.couchbase.lite.ValueIndex
import com.couchbase.lite.ValueIndexItem


private const val TAG = "PREDICT"
// tensorFlowModel is a fake implementation

object TensorFlowModel {
    fun predictImage(data: ByteArray?) = mapOf&lt;String, Any?&gt;()
}

object ImageClassifierModel : PredictiveModel {
    const val name = "ImageClassifier"

    override fun predict(input: Dictionary): Dictionary? {
        val blob: Blob = input.getBlob("photo") ?: return null

        // this would be the implementation of the ml model you have chosen
        return MutableDictionary(TensorFlowModel.predictImage(blob.content)) <i class="conum" data-value="1"></i><b>(1)</b>
    }
}


@Suppress("unused")
class PredictiveQueryExamples {
    @Throws(CouchbaseLiteException::class)
    fun testPredictiveModel() {
        val database = Database("mydb")

        Database.prediction.registerModel("ImageClassifier", ImageClassifierModel)

        val index: ValueIndex = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")))
        database.createIndex("value-index-image-classifier", index)

        Database.prediction.unregisterModel("ImageClassifier")
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveIndex() {
        val database = Database("mydb")

        val inputMap: MutableMap&lt;String, Any&gt; = mutableMapOf()
        inputMap["numbers"] = Expression.property("photo")
        val input: Expression = Expression.map(inputMap)
        val index: PredictiveIndex = IndexBuilder.predictiveIndex("ImageClassifier", input, null)
        database.createIndex("predictive-index-image-classifier", index)
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveQuery() {
        val database = Database("mydb")

        val prediction: PredictionFunction = Function.prediction(
            ImageClassifierModel.name,
            Expression.map(mutableMapOf("photo" to Expression.property("photo")) as Map&lt;String, Any&gt;?) <i class="conum" data-value="1"></i><b>(1)</b>
        )

        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                .and(prediction.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))
                    )
            )
            .execute()

        Log.d(TAG, "Number of rows: ${rs.allResults().size}")
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/FlowExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import androidx.lifecycle.LiveData
import androidx.lifecycle.asLiveData
import com.couchbase.lite.</strong>
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.map


class FlowExamples(argDb: Database,
                   argRepl: Replicator,
                   argQuery: Query,
                   argDocOwner: String) {

    val replState: LiveData&lt;ReplicatorActivityLevel&gt; = argRepl.replicatorChangesFlow()
        .map { it.status.activityLevel }
        .asLiveData()

    val dbChanges: LiveData&lt;MutableList&lt;String&gt;&gt; = argDb.databaseChangeFlow()
        .map { it.documentIDs }
        .asLiveData()

    val docChanges: LiveData&lt;DocumentChange?&gt; = argDb.documentChangeFlow("1001")
        .map {
            it.takeUnless {
                it.database.getDocument(it.documentID)?.getString("owner").equals(argDocOwner)
            }
        }
        .asLiveData()

    var liveQuery: LiveData&lt;List&lt;Any&gt;?&gt;? = null

    @ExperimentalCoroutinesApi
    fun watchQuery(query: Query): LiveData&lt;List&lt;Any&gt;?&gt; {
        val queryFlow = query.queryChangeFlow()
            .map {
                val err = it.error
                if (err != null) {
                    throw err
                }
                it.results?.allResults()?.flatMap { it.toList() }
            }
            .asLiveData()
        liveQuery = queryFlow
        return queryFlow
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/FlowExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorStatus


private const val TAG = "PENDING"

@Suppress("unused")
class PendingDocsExample(private var replicator: Replicator) {
    //
    //
    private fun onStatusChanged(pendingDocs: Set&lt;String&gt;, status: ReplicatorStatus) {
        // ... sample onStatusChanged function
        //
        Log.i(TAG, "Replicator activity level is ${status.activityLevel}")

        // iterate and report-on previously
        // retrieved pending docids 'list'
        val itr = pendingDocs.iterator()
        while (itr.hasNext()) {
            val docId = itr.next()

            if (!replicator.isDocumentPending(docId)) { <i class="conum" data-value="20"></i><b>(20)</b>
                continue
            }

            Log.i(TAG, "Doc ID $docId has been pushed")
        }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Endpoint
import com.couchbase.lite.KeyStoreUtils
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.net.URI
import java.net.URISyntaxException
import java.security.KeyStore
import java.security.cert.Certificate

private const val TAG = "P2P"


@Suppress("unused")
class IBExamples(private val context: Context, private val caCert: Certificate) {
    private val database: Database
    private var thisReplicator: Replicator? = null
    private var thisListener: URLEndpointListener? = null

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        database = Database("p2p_demo")

        /* do some stuff here <strong>/
    }

    // PASSIVE PEER STUFF
    fun ibListenerSimple() {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database,
                authenticator
                = ListenerPasswordAuthenticator { user, pwd -&gt; (user == "daniel") &amp;&amp; (String(pwd) == "123") })
        ) <i class="conum" data-value="21"></i><b>(21)</b>
        listener.start() <i class="conum" data-value="22"></i><b>(22)</b>
        thisListener = listener

    }

    fun ibReplicatorSimple() {
        val theListenerEndpoint: Endpoint = URLEndpoint(URI("wss://10.0.2.2:4984/db")) <i class="conum" data-value="23"></i><b>(23)</b>
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,
                target = theListenerEndpoint,
                authenticator = BasicAuthenticator("valid.user", "valid.password.string".toCharArray()), <i class="conum" data-value="24"></i><b>(24)</b>
                acceptOnlySelfSignedServerCertificate = true
            )
        )
        repl.start() <i class="conum" data-value="25"></i><b>(25)</b>
        thisReplicator = repl
    }

    fun ibPassListener(validUser: String, validPassword: CharArray) {
        // EXAMPLE 1
        // Initialize the listener
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database, <i class="conum" data-value="26"></i><b>(26)</b>
                port = 55990, <i class="conum" data-value="27"></i><b>(27)</b>
                networkInterface = "10.1.1.10", <i class="conum" data-value="28"></i><b>(28)</b>

                enableDeltaSync = false, <i class="conum" data-value="29"></i><b>(29)</b>

                // Configure server security
                disableTls = false, <i class="conum" data-value="30"></i><b>(30)</b>

                // Use an Anonymous Self-Signed Cert
                identity = null, <i class="conum" data-value="31"></i><b>(31)</b>

                // Configure Client Security using an Authenticator
                // For example, Basic Authentication <i class="conum" data-value="32"></i><b>(32)</b>
                authenticator = ListenerPasswordAuthenticator { username, paassword -&gt;
                    (username === validUser) &amp;&amp; (paassword === validPassword)
                }
            ))

        // Start the listener
        listener.start() <i class="conum" data-value="33"></i><b>(33)</b>
        thisListener = listener

    }

    fun ibListenerGetNetworkInterfaces() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        listener.start()
        Log.i(TAG, "URLS are ${listener.urls}")
        thisListener = listener
    }

    fun ibListenerLocalDb() {
        // . . . preceding application logic . . .
        CouchbaseLite.init(context) <i class="conum" data-value="34"></i><b>(34)</b>
        val thisDB = Database("passivepeerdb")
    }

    fun ibListenerConfigTlsDisable() {
        URLEndpointListenerConfigurationFactory.create(database, disableTls = false) <i class="conum" data-value="35"></i><b>(35)</b>
    }


    // !!! USERS SHOULD BE CAUTIONED THAT THIS IS INSECURE
    // Android has much better ways of importing keys
    fun ibListenerConfigTlsIdFull() {
        // Use CA Cert
        // Import a key pair into secure storage
        // Create a TLSIdentity from the imported key-pair

        this.javaClass.getResourceAsStream("serverkeypair.p12")?.use { <i class="conum" data-value="36"></i><b>(36)</b>
            KeyStoreUtils.importEntry(
                "teststore.p12",  // KeyStore type, eg: "PKCS12"
                it,  // An InputStream from the keystore
                "let me in".toCharArray(),  // The keystore password
                "topSekritKey",  // The alias to be used (in external keystore)
                null,  // The key password or null if the key has none
                "test-alias" // The alias for the imported key
            )
        }


        // Set the TLS Identity
        URLEndpointListenerConfigurationFactory.create(
            database,
            identity = TLSIdentity.getIdentity("test-alias")
        ) <i class="conum" data-value="37"></i><b>(37)</b>

    }

    fun ibListenerConfigClientAuthRoot() {
        // Configure the client authenticator
        // to validate using ROOT CA
        // thisClientID.certs is a list containing a client cert to accept
        // and any other certs needed to complete a chain between the client cert
        // and a CA
        val validId = TLSIdentity.getIdentity("Our Corporate Id")
            ?: throw IllegalStateException("Cannot find corporate id")
        // accept only clients signed by the corp cert
        thisListener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                // get the identity <i class="conum" data-value="38"></i><b>(38)</b>
                database = database,
                identity = validId,
                authenticator = ListenerCertificateAuthenticator(validId.certs)
            )
        ) <i class="conum" data-value="39"></i><b>(39)</b>

    }

    fun ibListenerConfigTlsDisable2() {

        URLEndpointListenerConfigurationFactory.create(database = database, disableTls = true)
    }

    fun ibListenerStatusCheck() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        val connectionCount = listener.status?.connectionCount <i class="conum" data-value="40"></i><b>(40)</b>
        val activeConnectionCount = listener.status?.activeConnectionCount <i class="conum" data-value="41"></i><b>(41)</b>
    }

    fun ibListenerStop() {

        thisListener?.stop()

    }

    // ACTIVE PEER STUFF
// Replication code
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testActPeerSync() {
        // Create replicator
        // Consider holding a reference somewhere
        // to prevent the Replicator from being GCed
        val repl = Replicator( <i class="conum" data-value="42"></i><b>(42)</b>

            // initialize the replicator configuration
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(URI("wss://listener.com:8954")), <i class="conum" data-value="43"></i><b>(43)</b>

                // Set replicator type
                type = ReplicatorType.PUSH_AND_PULL,

                // Configure Sync Mode
                continuous = false, // default value


                // set auto-purge behavior
                // (here we override default)
                enableAutoPurge = false, <i class="conum" data-value="44"></i><b>(44)</b>



                // Configure Server Authentication --
                // only accept self-signed certs
                acceptOnlySelfSignedServerCertificate = true, <i class="conum" data-value="45"></i><b>(45)</b>

                // Configure the credentials the
                // client will provide if prompted
                authenticator = BasicAuthenticator("Our Username", "Our PasswordValue".toCharArray()), <i class="conum" data-value="46"></i><b>(46)</b>


                /</strong> Optionally set custom conflict resolver call back <strong>/
                conflictResolver = null <i class="conum" data-value="47"></i><b>(47)</b>
            )
        )


        // Optionally add a change listener <i class="conum" data-value="48"></i><b>(48)</b>
        val thisListener = repl.addChangeListener { change -&gt;
            val err: CouchbaseLiteException? = change.status.error
            if (err != null) {
                Log.i(TAG, "Error code ::  ${err.code}", err)
            }
        }

        // Start replicator
        repl.start(false) <i class="conum" data-value="49"></i><b>(49)</b>
        thisReplicator = repl

    }

    fun ibReplicatorConfig() {
        // BEGIN additional snippets

        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,

                // Configure Server Security
                // -- only accept CA attested certs
                acceptOnlySelfSignedServerCertificate = false, <i class="conum" data-value="50"></i><b>(50)</b>




                // Use the pinned certificate from the byte array (cert)
                pinnedServerCertificate = caCert.encoded, <i class="conum" data-value="51"></i><b>(51)</b>


                // ... other replicator configuration
                // Provide a client certificate to the server for authentication
                authenticator = ClientCertificateAuthenticator(
                    TLSIdentity.getIdentity("clientId")
                        ?: throw IllegalStateException("Cannot find client id")
                ) <i class="conum" data-value="52"></i><b>(52)</b>

                // ... other replicator configuration

            )
        )

        thisReplicator = repl
    }

    fun ibP2pReplicatorStatus() {
        thisReplicator?.status?.let {
            Log.i(TAG, "The Replicator is currently ${it.activityLevel}")
            Log.i(TAG, "The Replicator has processed ${it.progress}")
            Log.i(
                TAG,
                if (it.activityLevel === ReplicatorActivityLevel.BUSY) {
                    "Replication Processing"
                } else {
                    "It has completed ${it.progress.total} changes"
                }
            )
        }
    }

    fun ibP2pReplicatorStop() {
        // Stop replication.
        thisReplicator?.stop() <i class="conum" data-value="53"></i><b>(53)</b>
    }

    fun ibP2pListener() {
        CouchbaseLite.init(context)
        val thisDB = Database("passivepeerdb") <i class="conum" data-value="54"></i><b>(54)</b>


        // Initialize the listener
        val listener = URLEndpointListener( <i class="conum" data-value="55"></i><b>(55)</b>

            // Initialize the listener config
            URLEndpointListenerConfigurationFactory.create(
                database = thisDB,
                port = 55990, /</strong> &lt;.&gt;  Optional; defaults to auto <strong>/
                disableTls = false, /</strong> &lt;.&gt;  Optional; defaults to false <strong>/
                enableDeltaSync = true,  /</strong> &lt;.&gt; Optional; defaults to false <strong>/

                // Configure the client authenticator (if using basic auth)
                authenticator = ListenerPasswordAuthenticator { username, password -&gt;
                    ("username" === username) &amp;&amp; (password === "password".toCharArray())  <i class="conum" data-value="56"></i><b>(56)</b>
                }
            )
        )

        // Start the listener
        listener.start() <i class="conum" data-value="57"></i><b>(57)</b>



//        Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
//                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
//                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
//        );
        val thisIdentity = TLSIdentity.createIdentity(
            true,
            mapOf(
                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
            ),
            null,
            "test-alias"
        )




        val thisAlias = "alias-to-delete"
        val thisKeyStore = KeyStore.getInstance("AndroidKeyStore")
        thisKeyStore.load(null)
        thisKeyStore.deleteEntry(thisAlias)


        // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label
        val thatIdentity = TLSIdentity.getIdentity("couchbase-docs-cert")
    }

    fun ibRplicatorPull() {
        val database = Database("ian")

        val uri = URI("wss://10.0.2.2:4984/db") <i class="conum" data-value="58"></i><b>(58)</b>

        val repl = Replicator( <i class="conum" data-value="59"></i><b>(59)</b>
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(uri),
                type = ReplicatorType.PULL
            )
        )

        repl.start()
        thisReplicator = repl
    }

// initialize the replicator configuration
    val thisConfig = ReplicatorConfigurationFactory.create(
        database = database,
        target = URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))

/</strong> C A L L O U T S

// Listener Callouts


&lt;.&gt; Initialize the listener instance using the configuration settings.
&lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.



&lt;.&gt; <code>connectionCount</code> -- the total number of connections served by the listener
&lt;.&gt; <code>activeConnectionCount</code> -- the number of active (BUSY) connections currently being served by the listener
//



&lt;.&gt; Configure the pinned certificate using data from the byte array <code>cert</code>

&lt;.&gt; Attempt to get the identity from secure storage
&lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity


&lt;.&gt; A replication is an asynchronous operation.
To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
&lt;.&gt; The URL scheme for remote database URLs uses <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections over wb sockets.
In this example the hostname is <code>10.0.2.2</code> because the Android emulator runs in a VM that is generally accessible on <code>10.0.2.2</code> from the host machine (see <a href="https://developer.android.com/studio/run/emulator-networking">Android Emulator networking</a> documentation).
+
NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
Although <code>wss:</code> protocol URLs are not affected, in order to use the <code>ws:</code> protocol, applications must target API 27 or lower, or must configure application network security as described <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted">here</a>.

<strong>/
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.net.URI
import java.security.KeyStore
import java.security.KeyStoreException
import java.security.NoSuchAlgorithmException
import java.security.cert.Certificate
import java.security.cert.CertificateEncodingException
import java.security.cert.CertificateException
import java.util.concurrent.CountDownLatch

private const val TAG = "LISTEN"

@Suppress("unused")
class KtCertAuthListener {
    companion object {
        private val CERT_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "CBL Test",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>",
        )
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)

        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        remoteDb.save(doc)

        val serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server")

        val clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client")
        val uri = startServer(remoteDb, serverIdentity, clientIdentity.certs)
            ?: throw IOException("Failed to start the server")

        Thread {
            startClient(localDb, uri, clientIdentity, serverIdentity.certs[0])
            Log.e(TAG, "Success!!")
            deleteIdentity("server")
            Log.e(TAG, "Alias deleted: server")
            deleteIdentity("client")
            Log.e(TAG, "Alias deleted: client")
        }.start()
    }

    // start a client replicator
    @Throws(CertificateEncodingException::class, InterruptedException::class)
    fun startClient(db: Database, uri: URI, clientIdentity: TLSIdentity, cert: Certificate) {
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = db,
                target = URLEndpoint(uri),
                type = ReplicatorType.PUSH_AND_PULL,
                continuous = false,
                authenticator = ClientCertificateAuthenticator(clientIdentity),
                pinnedServerCertificate = cert.encoded
            )
        )

        val completionLatch = CountDownLatch(1)

        repl.addChangeListener { change -&gt;
            if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    /<strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     *
     *
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Throws(CouchbaseLiteException::class)
    fun startServer(db: Database, serverId: TLSIdentity, certs: List&lt;Certificate?&gt;): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0, // this is the default
                disableTls = false,
                identity = serverId,
                authenticator = ListenerCertificateAuthenticator(certs)
            )
        )
        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
    /</strong>
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    @Throws(
        KeyStoreException::class,
        CertificateException::class,
        NoSuchAlgorithmException::class,
        IOException::class
    )
    fun deleteIdentity(alias: String?) {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        keyStore.deleteEntry(alias) <i class="conum" data-value="60"></i><b>(60)</b>
    }
    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /<strong>
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     *
     *
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    @Throws(CertificateEncodingException::class)
    private fun configureClientCerts(
        config: ReplicatorConfiguration,
        cert: Certificate,
        clientIdentity: TLSIdentity
    ) {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(ClientCertificateAuthenticator(clientIdentity))

        // Configure the pinned certificate passing a byte array.
        config.pinnedServerCertificate = cert.encoded
    }
    // notend::p2p-tlsid-tlsidentity-with-label[]
    /</strong>
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     *
     *
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    @Throws(IOException::class)
    private fun readCertMaterialFromBundle(
        context: Context,
        resId: Int
    ): ByteArray {
        val out = ByteArrayOutputStream()
        val <code>in</code> = context.resources.openRawResource(resId)
        val buf = ByteArray(1024)
        var n: Int
        while (<code>in</code>.read(buf).also { n = it } &gt;= 0) {
            out.write(buf, 0, n)
        }
        return out.toByteArray()
    }
}

@Suppress("unused")
class KtPasswordAuthListener {
    companion object {
        private const val VALID_USER = "Minnie"
        private val VALID_PASSWORD = "let me in!".toCharArray()
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray())
            ?: throw IOException("Failed to start the server")
        Thread {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb)
                Log.e(TAG, "Success!!")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }.start()
    }

    // start a client replicator
    @Throws(InterruptedException::class)
    fun runClient(
        uri: URI,
        username: String,
        password: CharArray,
        db: Database
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.type = ReplicatorType.PUSH_AND_PULL
        config.isContinuous = false
        config.setAuthenticator(BasicAuthenticator(username, password))
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)

        repl.addChangeListener { change -&gt;
            if (change.status
                    .activityLevel == ReplicatorActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    /</strong>*
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     *
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    fun startServer(db: Database, username: String, password: CharArray): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0,// this is the default
                disableTls = true,
                authenticator = ListenerPasswordAuthenticator { usr, pwd -&gt;
                    (usr == username) &amp;&amp; pwd.contentEquals(password)
                })
        )

        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
}





// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Message
import com.couchbase.lite.MessageEndpoint
import com.couchbase.lite.MessageEndpointConnection
import com.couchbase.lite.MessageEndpointDelegate
import com.couchbase.lite.MessageEndpointListener
import com.couchbase.lite.MessageEndpointListenerConfigurationFactory
import com.couchbase.lite.MessagingCloseCompletion
import com.couchbase.lite.MessagingCompletion
import com.couchbase.lite.ProtocolType
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorConnection
import com.couchbase.lite.create


@Suppress("unused")
class BrowserSessionManager : MessageEndpointDelegate {
    private var replicator: Replicator? = null

    @Throws(CouchbaseLiteException::class)
    fun initCouchbase() {
        val database = Database("mydb")

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        val messageEndpoint = MessageEndpoint("UID:123", "active", ProtocolType.MESSAGE_STREAM, this)

        // Create the replicator object.
        val repl = Replicator(ReplicatorConfigurationFactory.create(database = database, target = messageEndpoint))
        // Start the replication.
        repl.start()
        replicator = repl
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    override fun createConnection(endpoint: MessageEndpoint) = ActivePeerConnection()
}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

@Suppress("unused")
class ActivePeerConnection : MessageEndpointConnection {
    private var replicatorConnection: ReplicatorConnection? = null

    fun disconnect() {
        replicatorConnection?.close(null)
        replicatorConnection = null
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete()
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun send(message: Message, completion: MessagingCompletion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null)
    }

    fun receive(message: Message) {
        replicatorConnection?.receive(message)
    }
}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

@Suppress("unused")
class PassivePeerConnection private constructor() : MessageEndpointConnection {
    private var messageEndpointListener: MessageEndpointListener? = null
    private var replicatorConnection: ReplicatorConnection? = null

    @Throws(CouchbaseLiteException::class)
    fun startListener() {
        val database = Database("mydb")
        messageEndpointListener = MessageEndpointListener(
            MessageEndpointListenerConfigurationFactory.create(database, ProtocolType.MESSAGE_STREAM)
        )
    }

    fun stopListener() {
        messageEndpointListener?.closeAll()
    }

    fun accept() {
        val connection = PassivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        messageEndpointListener?.accept(connection)
    }

    fun disconnect() {
        replicatorConnection?.close(null)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete()
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun send(message: Message, completion: MessagingCompletion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null)
    }

    fun receive(message: Message) {
        replicatorConnection?.receive(message)
    }

}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.</strong>
import com.couchbase.lite.Function
import com.fasterxml.jackson.databind.ObjectMapper
import org.json.JSONException


private const val TAG = "QUERY"
private const val DATABASE_NAME = "database"

data class Hotel(
    var description: String? = null,
    var country: String? = null,
    var city: String? = null,
    var name: String? = null,
    var type: String? = null,
    var id: String? = null
)

@Suppress("unused")
class QueryExamples(private val database: Database) {

    // </mark># Indexing
    @Throws(CouchbaseLiteException::class)
    fun testIndexing() {
        database.createIndex( "TypeNameIndex",
              ValueIndexConfiguration( "type", "name")
    }

    fun testIndexing_Querybuilder() {
        database.createIndex(
            "TypeNameIndex",
            IndexBuilder.valueIndex(
                ValueIndexItem.property("type"),
                ValueIndexItem.property("name")
            )
        )
    }

    // <mark># SELECT statement
    fun testSelectStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("type")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.expression(Meta.id))
            .execute()

        for (result in rs) {
            Log.i(TAG, "hotel id -&gt;${result.getString("id")}")
            Log.i(TAG, "hotel name -&gt; ${result.getString("name")}")
        }
      }

      // META function
      @Throws(CouchbaseLiteException::class)
      fun testMetaFunction() {
        val rs = QueryBuilder
        .select(SelectResult.expression(Meta.id))
        .from(DataSource.database(database))
        .where(Expression.property("type").equalTo(Expression.string("airport")))
        .orderBy(Ordering.expression(Meta.id))
        .execute()

        for (result in rs) {
          Log.w(TAG, "airport id -&gt;${result.getString("id")}")
          Log.w(TAG, "airport id -&gt; ${result.getString(0)}")
        }
      }

      // </mark># all(<strong>)
    @Throws(CouchbaseLiteException::class)
    fun testSelectAll() {
        val queryAll = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))

        val query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="61"></i><b>(61)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        val token = query.addChangeListener { change -&gt;
            change.results?.let {
                for (result in it) {
                    Log.d(TAG, "results: ${result.keys}")
                    /</strong> Update UI <strong>/
                }
            } <i class="conum" data-value="62"></i><b>(62)</b>
        }


        query.removeChangeListener(token)

        for (result in query.execute()) {
            Log.i(TAG, "hotel -&gt; ${result.getDictionary(DATABASE_NAME)?.toMap()}")
        }
    }


    // <mark>#WHERE statement
    @Throws(CouchbaseLiteException::class)
    fun testWhereStatement() {
        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.intValue(10))
            .execute()
        for (result in rs) {
            result.getDictionary(DATABASE_NAME)?.let {
                Log.i(TAG, "name -&gt; ${it.getString("name")}")
                Log.i(TAG, "type -&gt; ${it.getString("type")}")
            }
        }
    }

    fun testQueryDeletedDocuments() {
        // Query documents that have been deleted
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted)
    }

    // </mark><mark>Collection Operators
    @Throws(CouchbaseLiteException::class)
    fun testCollectionStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(
                        ArrayFunction.contains(
                            Expression.property("public_likes"),
                            Expression.string("Armani Langworth")
                        )
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.getArray("public_likes")?.toList()}")
        }
    }

    // IN operator
    @Throws(CouchbaseLiteException::class)
    fun testInOperator() {
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.string("Armani").<code>in</code>(
                    Expression.property("first"),
                    Expression.property("last"),
                    Expression.property("username")
                )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.toMap()}")
        }
    }

    // Pattern Matching
    @Throws(CouchbaseLiteException::class)
    fun testPatternMatching() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // </mark># Wildcard Match
    @Throws(CouchbaseLiteException::class)
    fun testWildcardMatch() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // Wildcard Character Match
    @Throws(CouchbaseLiteException::class)
    fun testWildCharacterMatch() {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng____r"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // <mark># Regex Match
    @Throws(CouchbaseLiteException::class)
    fun testRegexMatch() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .regex(Expression.string("\\beng.*r\\b"))
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // JOIN statement
    @Throws(CouchbaseLiteException::class)
    fun testJoinStatement() {
        val rs = QueryBuilder.select(
            SelectResult.expression(Expression.property("name").from("airline")),
            SelectResult.expression(Expression.property("callsign").from("airline")),
            SelectResult.expression(Expression.property("destinationairport").from("route")),
            SelectResult.expression(Expression.property("stops").from("route")),
            SelectResult.expression(Expression.property("airline").from("route"))
        )
            .from(DataSource.database(database).<code>as</code>("airline"))
            .join(
                Join.join(DataSource.database(database).<code>as</code>("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(
                        Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline"))
                    )
                    .and(
                        Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.toMap()}")
        }
    }


    // </mark># GROUPBY statement
    @Throws(CouchbaseLiteException::class)
    fun testGroupByStatement() {
        val rs = QueryBuilder.select(
            SelectResult.expression(Function.count(Expression.string("</strong>"))),
            SelectResult.property("country"),
            SelectResult.property("tz")
        )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300)))
            )
            .groupBy(
                Expression.property("country"), Expression.property("tz")
            )
            .orderBy(Ordering.expression(Function.count(Expression.string("<strong>"))).descending())
            .execute()

        for (result in rs) {
            result.let {
                Log.i(
                    TAG,
                    "There are ${it.getInt("$1")} airports on the ${
                        it.getString("tz")
                    } timezone located in ${
                        it.getString("country")
                    } and above 300ft"
                )
            }
        }
    }

    // <mark># ORDER BY statement
    @Throws(CouchbaseLiteException::class)
    fun testOrderByStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("name").ascending())
            .limit(Expression.intValue(10))
            .execute()

        for (result in rs) {
            Log.i(TAG, "${result.toMap()}")
        }
    }


    // </mark># EXPLAIN statement
    @Throws(CouchbaseLiteException::class)
    fun testExplainStatement() {
        var query: Query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").descending()) <i class="conum" data-value="63"></i><b>(63)</b>
        Log.i(TAG, query.explain()) <i class="conum" data-value="64"></i><b>(64)</b>

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%"))) <i class="conum" data-value="65"></i><b>(65)</b>
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="66"></i><b>(66)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%")))
            )
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Function.lower(
                    Expression.property("type").equalTo(Expression.string("hotel"))
                )
            ) <i class="conum" data-value="67"></i><b>(67)</b>
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))) <i class="conum" data-value="68"></i><b>(68)</b>
        Log.i(TAG, query.explain())
    }

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex() {
        val config = FullTextIndexConfiguration("overview").ignoreAccents(false)

        database.createIndex( "overviewFTSIndex", config);
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS() {

        val ftsQuery =
              database.createQuery(
                "SELECT _id, overview FROM _ WHERE MATCH(overviewFTSIndex, 'michigan') ORDER BY RANK(overviewFTSIndex)")

        ftsQuery.execute().allResults().forEach {
          Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}")
        }

    }

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex_Querybuilder() {
        database.createIndex(
            "overviewFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("overview")).ignoreAccents(false)
        )
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS_Querybuilder() {

        val ftsQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id),
                                  SelectResult.expression(overview))
                          .from(DataSource.database(database))
                          .where(FullTextFunction.match("overviewFTSIndex", "michigan"))
                          .execute()

        ftsQuery.execute().allResults().forEach {
          Log.i(TAG, "${result.getString("Meta.id")}: ${result.getString("overview")}")
          }



    }


    fun testQuerySyntaxAll(currentUser: String) {
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(openOrCreateDatabaseForUser(currentUser)))

        val hotels: HashMap&lt;String, Hotel&gt; = HashMap()

        for (result in listQuery.execute().allResults()) {
            // get the k-v pairs from the 'hotel' key's value into a dictionary
            val thisDocsProps = result.getDictionary(0) <i class="conum" data-value="69"></i><b>(69)</b>
            val thisDocsId = thisDocsProps!!.getString("id")
            val thisDocsName = thisDocsProps.getString("name")
            val thisDocsType = thisDocsProps.getString("type")
            val thisDocsCity = thisDocsProps.getString("city")

            // Alternatively, access results value dictionary directly
            val id = result.getDictionary(0)?.getString("id").toString() <i class="conum" data-value="70"></i><b>(70)</b>
            hotels[id] = Hotel(
                id,
                result.getDictionary(0)?.getString("type"),
                result.getDictionary(0)?.getString("name"),
                result.getDictionary(0)?.getString("city"),
                result.getDictionary(0)?.getString("country"),
                result.getDictionary(0)?.getString("description")
            )
        }

    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun testQuerySyntaxJson(currentUser: String, argDb: Database) {
        val db = argDb
        // Example assumes Hotel class object defined elsewhere

        // Build the query
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(db))

        // Uses Jackson JSON processor
        val mapper = ObjectMapper()
        val hotels: ArrayList&lt;Hotel&gt; = ArrayList()

        for (result in listQuery.execute()) {

            // Get result as JSON string
            val json = result.toJSON() <i class="conum" data-value="71"></i><b>(71)</b>

            // Get Hashmap from JSON string
            val dictFromJSONstring = mapper.readValue(json, HashMap::class.java) <i class="conum" data-value="72"></i><b>(72)</b>

            // Use created hashmap
            val hotelId = dictFromJSONstring["id"].toString() //
            val hotelType = dictFromJSONstring["type"].toString()
            val hotelname = dictFromJSONstring["name"].toString()


            // Get custom object from JSON string
            val thisHotel = mapper.readValue(json, Hotel::class.java) <i class="conum" data-value="73"></i><b>(73)</b>
            hotels.add(thisHotel)
        }
    }
/</strong> end func testQuerySyntaxJson <strong>/



    fun testQuerySyntaxProps(currentUser: String) {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
            Log.i(TAG, "Hotel name -&gt; ${result.getString("name")}, in ${result.getString("country")}" )
        }
    }

    fun testQuerySyntaxCount(currentUser: String) {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.string("</strong>"))).as("mycount")) <i class="conum" data-value="74"></i><b>(74)</b>
            .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
            Log.i(TAG, "name -&gt; ${result.getInt("mycount").toString()}")
        }
    }


    fun testQuerySyntaxId(currentUser: String) {
        // tag::query-select-meta

        val rs = QueryBuilder
        .select(
          SelectResult.expression(Meta.id).as("hotelId"))
          .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
          Log.i(TAG, "hotel id -&gt;${result.getString("hotelId")}")
        }
        // end::query-select-meta
    }


    fun docsOnlyQuerySyntaxN1QL(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      val db = argDb
      val thisQuery = db.createQuery(
            "SELECT META().id AS id FROM _ WHERE type = \"hotel\"") <i class="conum" data-value="75"></i><b>(75)</b>

      return thisQuery.execute().allResults()

  }

  fun docsOnlyQuerySyntaxN1QLParams(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      val db = argDb
      val thisQuery = db.createQuery(
            "SELECT META().id AS id FROM _ WHERE type = \$type") <i class="conum" data-value="76"></i><b>(76)</b>

      thisQuery.parameters = Parameters().setString("type", "hotel") <i class="conum" data-value="77"></i><b>(77)</b>

      return thisQuery.execute().allResults()

  }

  fun testQuerySyntaxPagination(currentUser: String) {
    val limit = 20
    val offset = 0

    val rs = QueryBuilder
      .select(SelectResult.all())
      .from(DataSource.database(database))
      .where(Expression.property("type").equalTo(Expression.string("hotel")))
      .limit(Expression.intValue(limit), Expression.intValue(offset))

  }

    fun openOrCreateDatabaseForUser(argUser: String): Database = Database(argUser) {

    }



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/JSONExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.*
import org.json.JSONException
import org.json.JSONObject


const val JSON = """[{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\",
        \"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},
        {\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\",
        \"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},
        {\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",
        \"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\",
        \"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]"""


class KtJSONExamples {
    private val TAG = "SNIPPETS"

    fun jsonArrayExample(db: Database) {
        // github tag=tojson-array
        val mArray = MutableArray(JSON) <i class="conum" data-value="78"></i><b>(78)</b>
        for (i in 0 until mArray.count()) {
            mArray.getDictionary(i)?.apply {
                Log.i(TAG, getString("name") ?: "unknown")
                db.save(MutableDocument(getString("id"), toMap()))
            } <i class="conum" data-value="79"></i><b>(79)</b>
        }

        db.getDocument("1002")?.getArray("features")?.apply {
            for (feature in toList()) {
                Log.i(TAG, "$feature")
            } <i class="conum" data-value="80"></i><b>(80)</b>
            Log.i(TAG, toJSON())
        } <i class="conum" data-value="81"></i><b>(81)</b>
    }

    fun jsonBlobExample(db: Database) {
        // github tag=tojson-blob
        val thisBlob = db.getDocument("thisdoc-id")!!.toMap()
        if (!Blob.isBlob(thisBlob)) {
          return
        }
        val blobType = thisBlob["content_type"].toString()
        val blobLength = thisBlob["length"] as Number?
    }

    fun jsonDictionaryExample() {
        // github tag=tojson-dictionary
        val mDict = MutableDictionary(JSON) <i class="conum" data-value="82"></i><b>(82)</b>
        Log.i(TAG, "$mDict")
        Log.i(TAG, "Details for: ${mDict.getString("name")}")
        for (key in mDict.keys) {
          Log.i(TAG, key + " =&gt; " + mDict.getValue(key))
        }
      }

      @Throws(CouchbaseLiteException::class)
      fun jsonDocumentExample(srcDb: Database, dstDb: Database) {
        QueryBuilder
        .select(SelectResult.expression(Meta.id).as("metaId"))
        .from(DataSource.database(srcDb))
        .execute()
        .forEach {
          it.getString("metaId")?.let { thisId -&gt;
            srcDb.getDocument(thisId)?.toJSON()?.let { json -&gt; <i class="conum" data-value="83"></i><b>(83)</b>
              Log.i(TAG, "JSON String = $json")
              val hotelFromJSON = MutableDocument(thisId, json) <i class="conum" data-value="84"></i><b>(84)</b>
              dstDb.save(hotelFromJSON)
              dstDb.getDocument(thisId)?.toMap()?.forEach { e -&gt;
                Log.i(TAG, "$e.key =&gt; $e.value")
              } <i class="conum" data-value="85"></i><b>(85)</b>
            }
          }
        }
    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun jsonQueryExample(query: Query) {
        query.execute().forEach {

            // Use a Json Object to populate Native object
            JSONObject(it.toJSON()).apply {
                val (description, country, city, name, type, id) = Hotel(
                    id = getString("id"),
                    type = getString("type"),
                    name = getString("name"),
                    city = getString("city"),
                    country = "Ghana, West Africa",
                    description = "this hotel"
                )
            }
        }
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/JSONExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.Database
import com.couchbase.lite.MutableDictionary

class KtBlobExamples {

    // Example 2: Using Blobs
    fun example2(context: Context, db: Database) {
        val doc = db.getDocument("1000") ?: return

        // Create a blob from an asset
        val blob = Blob("image/png", context.assets.open("couchbaseimage.png"))

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON()

        // Save the blob as part of a document
        db.save(doc.toMutable().setBlob("avatar", blob))

        // Experts only!!!
        db.saveBlob(blob)

        // Retrieve saved blob and get as JSON again
        val blobAsJSONString = db.getDocument("1000")?.getBlob("avatar")?.toJSON() ?: return

        // reconstitute
        val blobAsMap = MutableDictionary().setJSON(blobAsJSONString).toMap()

        // show the contents of the reconstituted blob
        for key, value) in blobAsMap) {             Log.d("BLOB", "Data: $key -&gt; $value")         }          // verify that the reconstitued thing is still blob         if (Blob.isBlob(blobAsMap {
            Log.d("BLOB", blobAsJSONString)
        }
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt </code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset1_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">

// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/PasswordAuthListener.java 
//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorActivityLevel;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorType;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);                 Log.e(TAG, "Success!!");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void runClient(         @NonNull URI uri,         @NonNull String username,         @NonNull char[] password,         @NonNull Database db) throws InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setType(ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }

    /<strong>
     * Snippet 1: create a ListenerPasswordAuthenticator and configure the listener with it
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     * NOTE: This requires the following, in the manifest
     *     &lt;application
     *         ...
     *         android:usesCleartextTraffic="true"
     *         ...
     *     &gt;
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password)
        throws CouchbaseLiteException {
        final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

        config.setPort(0); // this is the default
        config.setDisableTls(true);
        config.setAuthenticator(new ListenerPasswordAuthenticator(
            (user, pwd) -&gt; username.equals(user) &amp;&amp; Arrays.equals(password, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/PasswordAuthListener.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/BlobExamples.java 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.util.Log;

import java.io.IOException;
import java.util.Map;

import com.couchbase.lite.Blob;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.Document;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;


class BlobExamples {

    // Example 2: Using Blobs
    public void example2(final Context context, final Database db) throws IOException, CouchbaseLiteException {
        final Document doc = db.getDocument("1000");
        if (doc == null) { return; }

        // Create a blob from an asset
        final Blob blob = new Blob("image/png", context.getAssets().open("couchbaseimage.png"));

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON();

        // Save the blob as part of a document
        final MutableDocument mDoc = doc.toMutable();
        mDoc.setBlob("avatar", blob);
        db.save(mDoc);

        // Experts only!!!
        db.saveBlob(blob);

        // Retrieve saved blob
        final Document sameDoc = db.getDocument("1000");
        if (sameDoc == null) { return; }

        final Blob sameBlob = sameDoc.getBlob("avatar");
        if (sameBlob == null) { return; }

        // Get as JSON again
        final String blobAsJSONString = sameBlob.toJSON();

        // reconstitute
        final Map&lt;String, Object&gt; blobAsMap = new MutableDictionary().setJSON(blobAsJSONString).toMap();

        // show the contents of the reconstituted blob
        for (Map.Entry&lt;String, Object&gt; entry: blobAsMap.entrySet()) {
            Log.d("BLOB", "Data: " + entry.getKey() + " -&gt; " + entry.getValue());
        }

        // verify that the reconstitued thing is still blob
        if (Blob.isBlob(blobAsMap)) { Log.d("BLOB", blobAsJSONString); }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/BlobExamples.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/MainActivity.java 
package com.couchbase.code_snippets;

import android.os.Bundle;

import androidx.appcompat.app.AppCompatActivity;


public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/MainActivity.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/CertAuthListener.java 

//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorActivityLevel;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorType;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);                 Log.e(TAG, "Success!!");                 deleteIdentity("server");                 Log.e(TAG, "Alias deleted: server");                 deleteIdentity("client");                 Log.e(TAG, "Alias deleted: client");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void startClient(         @NonNull URI uri,         @NonNull Certificate cert,         @NonNull TLSIdentity clientIdentity,         @NonNull Database db) throws CertificateEncodingException, InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setType(ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }

    /</strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
        throws CouchbaseLiteException {
        final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

        config.setPort(0); // this is the default
        config.setDisableTls(false);
        config.setTlsIdentity(serverId);
        config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
    }

    /<strong>
     * Snippet 3: delete an identity from the keystore
     * (NOTE: a keystore doesn't contain TLSIdentities: I'm guessing that this is what you intend)
     * &lt;p&gt;
     * Delete an identity from the key store.
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
        throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

        final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);

        keyStore.deleteEntry(alias);
    }

    /</strong>
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     * &lt;p&gt;
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    private void configureClientCerts(
        ReplicatorConfiguration config,
        @NonNull Certificate cert,
        @NonNull TLSIdentity clientIdentity)
        throws CertificateEncodingException {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
    }

    /<strong>
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     * &lt;p&gt;
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte[] buf = new byte[1024];
        int n;
        while n = in.read(buf &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/CertAuthListener.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java 
//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import androidx.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;
import com.example.docsnippet.Datastore;
import com.example.docsnippet.Hotel;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class docOnly_Examples {
  private static final String TAG = "EXAMPLE";

  private static final String DATABASE_NAME = "database";

  private final Context context;
  private Database database;
  private Replicator replicator;

  public docOnly_Examples(Context context) { this.context = context; }

  //@Test
  public void testGettingStarted() throws CouchbaseLiteException, URISyntaxException {

    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);

    // Get the database (and create it if it doesnt exist).
    DatabaseConfiguration config = new DatabaseConfiguration();

    config.setDirectory(context.getFilesDir().getAbsolutePath());

    Database database = new Database("getting-started", config);


    // Create a new document (i.e. a record) in the database.
    MutableDocument mutableDoc = new MutableDocument()
    .setFloat("version", 2.0F)
    .setString("type", "SDK");

    // Save it to the database.
    database.save(mutableDoc);

    // Update a document.
    mutableDoc = database.getDocument(mutableDoc.getId()).toMutable();
    mutableDoc.setString("language", "Java");
    database.save(mutableDoc);
    Document document = database.getDocument(mutableDoc.getId());
    // Log the document ID (generated by the database) and properties
    Log.i(TAG, "Document ID :: " + document.getId());
    Log.i(TAG, "Learning " + document.getString("language"));

    // Create a query to fetch documents of type SDK.
    Query query = QueryBuilder.select(SelectResult.all())
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("SDK")));
    ResultSet result = query.execute();
    Log.i(TAG, "Number of rows ::  " + result.allResults().size());

    // Create replicators to push and pull changes to and from the cloud.
    Endpoint targetEndpoint = new URLEndpoint(new URI("ws://localhost:4984/getting-started-db"));
    ReplicatorConfiguration replConfig = new ReplicatorConfiguration(database, targetEndpoint);
    replConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Add authentication.
    replConfig.setAuthenticator(new BasicAuthenticator("sync-gateway", "password"));

    // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
    Replicator replicator = new Replicator(replConfig);

    // Listen to replicator change events.
    replicator.addChangeListener(change -&gt; {
      if (change.getStatus().getError() != null) {
        Log.i(TAG, "Error code ::  " + change.getStatus().getError().getCode());
      }
    });

    // Start replication.
    replicator.start();


    database.delete();
  }

  public void test1xAttachments() throws CouchbaseLiteException, IOException {
    // if db exist, delete it
    deleteDB("android-sqlite", context.getFilesDir());

    ZipUtils.unzip(getAsset("replacedb/android140-sqlite.cblite2.zip"), context.getFilesDir());

    Database db = new Database("android-sqlite", new DatabaseConfiguration());
    try {

      Document doc = db.getDocument("doc1");

      // For Validation
      Dictionary attachments = doc.getDictionary("_attachments");
      Blob blob = attachments.getBlob("attach1");
      byte[] content = blob.getContent();
      // For Validation

      byte[] attach = String.format(Locale.ENGLISH, "attach1").getBytes();
      Arrays.equals(attach, content);

    } finally {
      // close db
      db.close();
      // if db exist, delete it
      deleteDB("android-sqlite", context.getFilesDir());
    }

    Document document = new MutableDocument();

    Dictionary attachments = document.getDictionary("_attachments");
    Blob blob = attachments != null ? attachments.getBlob("avatar") : null;
    byte[] content = blob != null ? blob.getContent() : null;
  }

  // <mark># Initializer
  public void testInitializer() {
    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);
  }

  // </mark># New Database
  public void testNewDatabase() throws CouchbaseLiteException {
    final DatabaseConfiguration config = new DatabaseConfiguration();
    config.setDirectory(context.getFilesDir().getAbsolutePath()); <i class="conum" data-value="1"></i><b>(1)</b>

    Database database = new Database("my-database", config);

    database.close();


    database.delete();
  }

  // <mark># Database Encryption
  public void testDatabaseEncryption() throws CouchbaseLiteException {
    DatabaseConfiguration config = new DatabaseConfiguration();
    config.setEncryptionKey(new EncryptionKey("PASSWORD"));
    Database database = new Database("mydb", config);
  }

  // </mark># Logging
  public void testLogging() {
    Database.setLogLevel(LogDomain.DATABASE, LogLevel.VERBOSE);
    Database.setLogLevel(LogDomain.QUERY, LogLevel.VERBOSE);
    }

    public void testEnableCustomLogging() {
        Database.log.setCustom(new LogTestLogger(LogLevel.WARNING)); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    // <mark># Console logging
    public void testConsoleLogging() throws CouchbaseLiteException {
          Database.log.getConsole().setDomain(LogDomain.ALL_DOMAINS);  <i class="conum" data-value="3"></i><b>(3)</b>
          Database.log.getConsole().setLevel(LogLevel.VERBOSE); <i class="conum" data-value="4"></i><b>(4)</b>
          Database.log.getConsole().setDomain(LogDomain.DATABASE);

    }

    // </mark># File logging
    public void testFileLogging() throws CouchbaseLiteException {
        final File path = context.getCacheDir();

        LogFileConfiguration LogCfg =
          new LogFileConfiguration(path.toString()); <i class="conum" data-value="5"></i><b>(5)</b>
        LogCfg.setMaxSize(10240); <i class="conum" data-value="6"></i><b>(6)</b>
        LogCfg.setMaxRotateCount(5); <i class="conum" data-value="7"></i><b>(7)</b>
        LogCfg.setUsePlainText(false); <i class="conum" data-value="8"></i><b>(8)</b>
        Database.log.getFile().setConfig(LogCfg);
        Database.log.getFile().setLevel(LogLevel.INFO); <i class="conum" data-value="9"></i><b>(9)</b>
    }

    public void writeConsoleLog()
    {
        Database.log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }
    public void writeCustomLog()
    {
        Database.log.Custom?.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }


    public void writeFileLog()
    {
        Database.log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }




    // <mark># Loading a pre-built database
    public void testPreBuiltDatabase() throws IOException {
      // Note: Getting the path to a database is platform-specific.
      // For Android you need to extract it from your
      // assets to a temporary directory and then pass that path to Database.copy()
      DatabaseConfiguration configuration = new DatabaseConfiguration();
      if (!Database.exists("travel-sample", context.getFilesDir())) {
            ZipUtils.unzip(getAsset("travel-sample.cblite2.zip"), context.getFilesDir());
            File path = new File(context.getFilesDir(), "travel-sample");
            try {
                Database.copy(path, "travel-sample", configuration);
            } catch (CouchbaseLiteException e) {
                e.printStackTrace();
            }
        }
    }

    // helper methods

    // if db exist, delete it
    private void deleteDB(String name, File dir) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            // sometimes, db is still in used, wait for a while. Maximum 3 sec
            for (int i = 0; i &lt; 10; i) {
                try {
                    Database.delete(name, dir);
                    break;
                } catch (CouchbaseLiteException ex) {
                    try { Thread.sleep(300); }
                    catch (InterruptedException ignore) { }
                }
            }
        }
    }

    // ### Initializers
    public void testInitializers() {
        MutableDocument newTask = new MutableDocument();
        newTask.setString("type", "task");
        newTask.setString("owner", "todo");
        newTask.setDate("createdAt", new Date());
        try {
            database.save(newTask);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // ### Mutability
    public void testMutability() {
        try { database.save(new MutableDocument("xyz")); }
        catch (CouchbaseLiteException ignore) { }

        Document document = database.getDocument("xyz");
        MutableDocument mutableDocument = document.toMutable();
        mutableDocument.setString("name", "apples");
        try {
            database.save(mutableDocument);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // ### Typed Accessors
    public void testTypedAccessors() {
        MutableDocument newTask = new MutableDocument();

        newTask.setValue("createdAt", new Date());
        Date date = newTask.getDate("createdAt");
    }

    // ### Batch operations
    public void testBatchOperations() {
        try {
            database.inBatch(() -&gt; {
                for (int i = 0; i &lt; 10; i) {
                    MutableDocument doc = new MutableDocument();
                    doc.setValue("type", "user");
                    doc.setValue("name", "user " + i);
                    doc.setBoolean("admin", false);
                    try {
                        database.save(doc);
                    } catch (CouchbaseLiteException e) {
                        Log.e(TAG, e.toString());
                    }
                    Log.i(TAG, String.format("saved user document %s", doc.getString("name")));
                }
            });
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // </mark># Document Expiration
    public void DocumentExpiration() throws CouchbaseLiteException {
        // Purge the document one day from now
        Instant ttl = Instant.now().plus(1, ChronoUnit.DAYS);
        database.setDocumentExpiration("doc123", new Date(ttl.toEpochMilli()));

        // Reset expiration
        database.setDocumentExpiration("doc1", null);

        // Query documents that will be expired in less than five minutes
        Instant fiveMinutesFromNow = Instant.now().plus(5, ChronoUnit.MINUTES);
        Query query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.expiration.lessThan(Expression.doubleValue(fiveMinutesFromNow.toEpochMilli())));
    }

    public void testDocumentChangeListener() throws CouchbaseLiteException {
        database.addDocumentChangeListener(
            "user.john",
            change -&gt; {
                Document doc = database.getDocument(change.getDocumentID());
                if (doc != null) {
                    Toast.makeText(context, "Status: " + doc.getString("verified_account"), Toast.LENGTH_SHORT).show();
                }
            });
    }

    // <mark># Blobs
    public void testBlobs() {
        MutableDocument newTask = new MutableDocument();

        InputStream is = getAsset("avatar.jpg"); <i class="conum" data-value="10"></i><b>(10)</b>
        if (is == null) { return; }
        try {
            Blob blob = new Blob("image/jpeg", is); <i class="conum" data-value="11"></i><b>(11)</b>
            newTask.setBlob("avatar", blob); <i class="conum" data-value="12"></i><b>(12)</b>
            database.save(newTask);

            Blob taskBlob = newTask.getBlob("avatar");
            byte[] bytes = taskBlob.getContent();
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        } finally {
            try { is.close(); }
            catch (IOException ignore) { }
        }
    }

    // </mark># Indexing
    public void testIndexing() throws CouchbaseLiteException {
        // For Documentation
        {

            database.createIndex(ValueIndexConfiguration(["type", "name"]), "TypeNameIndex");

        }
    }

    public void testIndexing_Querybuilder() throws CouchbaseLiteException {
        // For Documentation
        {
            database.createIndex(
                "TypeNameIndex",
                IndexBuilder.valueIndex(
                    ValueIndexItem.property("type"),
                    ValueIndexItem.property("name")));
        }
    }

    // <mark># SELECT statement
    public void testSelectStatement() {
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("type"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.expression(Meta.id));

            try {
                ResultSet rs = query.execute();
                for (Result result : rs) {
                    Log.i("Sample", String.format("hotel id -&gt; %s", result.getString("id")));
                    Log.i("Sample", String.format("hotel name -&gt; %s", result.getString("name")));
                }
            } catch (CouchbaseLiteException e) {
                Log.e("Sample", e.getLocalizedMessage());
            }
          }
        }

        // META function
        public void testMetaFunction() throws CouchbaseLiteException {
          // For Documentation
          {
          Query query = QueryBuilder
          .select(SelectResult.expression(Meta.id))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("airport")))
          .orderBy(Ordering.expression(Meta.id));
          ResultSet rs = query.execute();
          for (Result result : rs) {
            Log.w("Sample", String.format("airport id -&gt; %s", result.getString("id")));
            Log.w("Sample", String.format("airport id -&gt; %s", result.getString(0)));
          }
        }
    }

    // </mark># all(</strong>)
    public void testSelectAll() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")));

            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database)); <i class="conum" data-value="13"></i><b>(13)</b>

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            ListenerToken token = query.addChangeListener(change -&gt; { <i class="conum" data-value="14"></i><b>(14)</b>
                for (Result result : change.getResults()) {
                    Log.d(TAG, "results: " + result.getKeys());
                    /* Update UI <strong>/
                }
            });


            query.removeChangeListener(token); <i class="conum" data-value="15"></i><b>(15)</b>


            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("hotel -&gt; %s", result.getDictionary(DATABASE_NAME).toMap()));
            }
        }
    }

    // <mark>#WHERE statement
    public void testWhereStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .limit(Expression.intValue(10));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Dictionary all = result.getDictionary(DATABASE_NAME);
                Log.i("Sample", String.format("name -&gt; %s", all.getString("name")));
                Log.i("Sample", String.format("type -&gt; %s", all.getString("type")));
            }
        }
    }

    public void testQueryDeletedDocuments() {
        // Query documents that have been deleted
        Where query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted);
    }


    // </mark><mark>Collection Operators
    public void testCollectionStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("public_likes"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction
                        .contains(Expression.property("public_likes"), Expression.string("Armani Langworth"))));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("public_likes -&gt; %s", result.getArray("public_likes").toList()));
            }
        }
    }

    // IN operator
    public void testInOperator() throws CouchbaseLiteException {
        // For Documentation
        {
            Expression[] values = new Expression[] {
                Expression.property("first"),
                Expression.property("last"),
                Expression.property("username")
            };

            Query query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.string("Armani").in(values));

            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // Pattern Matching
    public void testPatternMatching() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Function.Expression.string("royal engineers museum")))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // </mark># Wildcard Match
    public void testWildcardMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng%e%"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // Wildcard Character Match
    public void testWildCharacterMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng____r"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // <mark># Regex Match
    public void testRegexMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).regex(Expression.string("\\beng.*r\\b"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // JOIN statement
    public void testJoinStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder.select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route")))
                .from(DataSource.database(database).as("airline"))
                .join(Join.join(DataSource.database(database).as("route"))
                    .on(Meta.id.from("airline").equalTo(Expression.property("airlineid").from("route"))))
                .where(Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline").equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route").equalTo(Expression.string("RIX"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // </mark># GROUPBY statement
    public void testGroupByStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder.select(
                SelectResult.expression(Function.count(Expression.string("</strong>"))),
                SelectResult.property("country"),
                SelectResult.property("tz"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300))))
                .groupBy(
                    Expression.property("country"),
                    Expression.property("tz"))
                .orderBy(Ordering.expression(Function.count(Expression.string("<strong>"))).descending());
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format(
                        "There are %d airports on the %s timezone located in %s and above 300ft",
                        result.getInt("$1"),
                        result.getString("tz"),
                        result.getString("country")));
            }
        }
    }

    // <mark># ORDER BY statement
    public void testOrderByStatement() throws CouchbaseLiteException {
      // For Documentation
      {
        Query query = QueryBuilder
        .select(
          SelectResult.expression(Meta.id),
          SelectResult.property("name"))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("hotel")))
          .orderBy(Ordering.property("name").ascending())
          .limit(Expression.intValue(10));
          ResultSet rs = query.execute();
          for (Result result : rs) { Log.i("Sample", String.format("%s", result.toMap())); }
        }
      }
      // </mark># EXPLAIN statement
      public void testExplainStatement() throws CouchbaseLiteException {
          // For Documentation
          {
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("university")))
                .groupBy(Expression.property("country"))
                .orderBy(Ordering.property("name").descending()); <i class="conum" data-value="16"></i><b>(16)</b>
              Log.i(query.explain()); <i class="conum" data-value="17"></i><b>(17)</b>
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("%hotel%"))); <i class="conum" data-value="18"></i><b>(18)</b>
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="19"></i><b>(19)</b>
                  .and(Expression.property("name").like(Expression.string("%royal%"))));
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))); <i class="conum" data-value="20"></i><b>(20)</b>
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="21"></i><b>(21)</b>
              Log.i(query.explain());
          }
      }
      // end query-explain

    void prepareIndex() throws CouchbaseLiteException {

        FullTextIndexConfiguration config = new FullTextIndexConfiguration("Overview").ignoreAccents(false)

        database.createIndex( config, "overviewFTSIndex")

    }

    void prepareIndex_Querybuilder() throws CouchbaseLiteException {
      database.createIndex(
          "overviewFTSIndex",
          IndexBuilder.fullTextIndex(FullTextIndexItem.property("overview")).ignoreAccents(false));
  }

    public void testFTS() throws CouchbaseLiteException {

        Query ftsQuery =
                database.createQuery(
                "SELECT _id, overview FROM _ WHERE MATCH(overviewFTSIndex, 'michigan') ORDER BY RANK(overviewFTSIndex)");

        for (result in ftsQuery.execute().allResults()) {
          Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}");
        }

    }
    public void testFTS_Querybuilder() throws CouchbaseLiteException {
        Expression whereClause = FullTextFunction.match("overviewFTSIndex", "'michigan'");
        Query ftsQuery =
                QueryBuilder.select(SelectResult.expression(Meta.id),
                                    SelectResult.expression(overview)
                                  )
            .from(DataSource.database(database))
            .where(whereClause);

            for (result in ftsQuery.execute().allResults()) {
              Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}");
            }

    }

    /</strong> The <code>tag::replication[]</code> example is inlined in java.adoc <strong>/

    public void testTroubleshooting() {
        Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE);
    }

    public void testReplicationBasicAuthentication() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new BasicAuthenticator("username", "password"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationSessionAuthentication() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationStatus() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        replicator.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == Replicator.ActivityLevel.STOPPED) {
                Log.i(TAG, "Replication stopped");
            }
          });
        }

    //  BEGIN PendingDocuments BM -- 19/Feb/21 --
    import android.support.annotation.NonNull;
    import android.util.Log;

    import java.net.URI;
    import java.net.URISyntaxException;
    import java.util.Iterator;
    import java.util.Set;

    import com.couchbase.lite.CouchbaseLiteException;
    import com.couchbase.lite.Database;
    import com.couchbase.lite.Endpoint;
    import com.couchbase.lite.Replicator;
    import com.couchbase.lite.ReplicatorConfiguration;
    import com.couchbase.lite.URLEndpoint;

    class PendingDocsExample {
        private static final String TAG = "SCRATCH";

        private Database database;
        private Replicator replicator;

        //  BEGIN PendingDocuments IB -- 11/Feb/21 --
        public void testReplicationPendingDocs() throws URISyntaxException, CouchbaseLiteException {
            // nottag::replication-pendingdocuments[]
            // ... include other code as required
            //
            final Endpoint endpoint =
              new URLEndpoint(new URI("ws://localhost:4984/db"));

            final ReplicatorConfiguration config =
              new ReplicatorConfiguration(database, endpoint)
            .setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

            replicator = new Replicator(config);
            final Set&lt;String&gt; pendingDocs =
              replicator.getPendingDocumentIds(); <i class="conum" data-value="22"></i><b>(22)</b>


            replicator.addChangeListener(change -&gt; {
              onStatusChanged(pendingDocs, change.getStatus()); });

            replicator.start();

            // ... include other code as required
            // notend::replication-pendingdocuments[]
          }
        //
        //
        private void onStatusChanged(
          @NonNull final Set&lt;String&gt; pendingDocs,
          @NonNull final Replicator.Status status) {
          // ... sample onStatusChanged function
          //
          Log.i(TAG,
            "Replicator activity level is " + status.getActivityLevel().toString());

          // iterate and report-on previously
          // retrieved pending docids 'list'
          for (Iterator&lt;String&gt; itr = pendingDocs.iterator(); itr.hasNext(); ) {
            final String docId = itr.next();
            try {
              if (!replicator.isDocumentPending(docId)) { continue; } <i class="conum" data-value="23"></i><b>(23)</b>

              itr.remove();
              Log.i(TAG, "Doc ID " + docId + " has been pushed");
            }
            catch (CouchbaseLiteException e) {
              Log.w(TAG, "isDocumentPending failed", e); }
          }
        }
        //  END PendingDocuments BM -- 19/Feb/21 --
    }


    public void testHandlingNetworkErrors() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        replicator.addChangeListener(change -&gt; {
            CouchbaseLiteException error = change.getStatus().getError();
            if (error != null) { Log.w(TAG, "Error code:: %d", error); }
        });
        replicator.start();

        replicator.stop();
    }

    public void testReplicatorDocumentEvent() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        ListenerToken token = replicator.addDocumentReplicationListener(replication -&gt; {

            Log.i(TAG, "Replication type: " + replication.isPush( ? "Push" : "Pull"));
            for (ReplicatedDocument document : replication.getDocuments()) {
                Log.i(TAG, "Doc ID: " + document.getID());

                CouchbaseLiteException err = document.getError();
                if (err != null) {
                    // There was an error
                    Log.e(TAG, "Error replicating document: ", err);
                    return;
                }

                if (document.flags().contains(DocumentFlag.DocumentFlagsDeleted)) {
                    Log.i(TAG, "Successfully replicated a deleted document");
                }
            }
        });

        replicator.start();

        replicator.removeChangeListener(token);
    }

    public void testReplicationCustomHeader() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();
        headers.put("CustomHeaderName", "Value");
        config.setHeaders(headers);
    }

    // <mark># Certificate Pinning

    public void testCertificatePinning() throws URISyntaxException, IOException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);

        InputStream is = getAsset("cert.cer");
        byte[] cert = IOUtils.toByteArray(is);
        if (is != null) {
            try { is.close(); }
            catch (IOException ignore) {}
        }

        config.setPinnedServerCertificate(cert);
    }

    // </mark># Reset replicator checkpoint
    public void testReplicationResetCheckpoint() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        if (resetCheckpointRequired_Example) {
          replicator.start(true); <i class="conum" data-value="24"></i><b>(24)</b>
        else
          replicator.start(false);
        }

        // ... at some later time

        replicator.stop();
    }

    public void testReplicationPushFilter() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPushFilterdocument, flags) -&gt; flags.contains(DocumentFlag.DocumentFlagsDeleted; <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationPullFilter() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPullFilterdocument, flags) -&gt; "draft".equals(document.getString("type"); <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testCustomRetryConfig() throws URISyntaxException {
    URLEndpoint target =
    new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

    ReplicatorConfiguration config =
    new ReplicatorConfiguration(database, target);

    //  other config as required . . .
    config.setHeartbeat(150L); <i class="conum" data-value="25"></i><b>(25)</b>
    config.setMaxattempts(20L); <i class="conum" data-value="26"></i><b>(26)</b>
    config.setMaxAttemptWaitTime(600L); <i class="conum" data-value="27"></i><b>(27)</b>

    Replicator repl = new Replicator(config);

    }


    public void docsSetAutoPurge() throws CouchbaseliteException {

      DatabaseConfiguration config = new DatabaseConfiguration();
      Database database1 = new Database("mydb", config);

      ReplicatorConfiguration repcfg =
      new ReplicatorConfiguration(database, target);

      repcfg.setAutoPurgeEnabled(true); <i class="conum" data-value="28"></i><b>(28)</b>

    }


    public void testDatabaseReplica() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database1 = new Database("mydb", config);

        config = new DatabaseConfiguration();
        Database database2 = new Database("db2", config);

        /</strong> EE feature: code below might throw a compilation error
           if it's compiled against CBL Android Community. <strong>/
        DatabaseEndpoint targetDatabase = new DatabaseEndpoint(database2);
        ReplicatorConfiguration replicatorConfig = new ReplicatorConfiguration(database1, targetDatabase);
        replicatorConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(replicatorConfig);
        replicator.start();
    }

    public void testPredictiveModel() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Database.prediction.registerModel("ImageClassifier", new ImageClassifierModel());

        ValueIndex index = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")));
        database.createIndex("value-index-image-classifier", index);

        Database.prediction.unregisterModel("ImageClassifier");
    }

    public void testPredictiveIndex() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Map&lt;String, Object&gt; inputMap = new HashMap&lt;&gt;();
        inputMap.put("numbers", Expression.property("photo"));
        Expression input = Expression.map(inputMap);

        PredictiveIndex index = IndexBuilder.predictiveIndex("ImageClassifier", input, null);
        database.createIndex("predictive-index-image-classifier", index);
    }

    public void testPredictiveQuery() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Map&lt;String, Object&gt; inputProperties = new HashMap&lt;&gt;();
        inputProperties.put("photo", Expression.property("photo"));
        Expression input = Expression.map(inputProperties);
        PredictionFunction prediction = PredictiveModel.predict("ImageClassifier", input); <i class="conum" data-value="1"></i><b>(1)</b>

        Query query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("label").equalTo(Expression.string("car"))
                .and(Expression.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))));

        // Run the query.
        ResultSet result = query.execute();
        Log.d(TAG, "Number of rows: " + result.allResults().size());
    }

    public void testReplicationWithCustomConflictResolver() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setConflictResolver(new LocalWinConflictResolver());

        Replicator replication = new Replicator(config);
        replication.start();
    }

    public void testSaveWithCustomConflictResolver() throws CouchbaseLiteException {
        Document doc = database.getDocument("xyz");
        if (doc == null) { return; }
        MutableDocument mutableDocument = doc.toMutable();
        mutableDocument.setString("name", "apples");

        database.save(
            mutableDocument,
            (newDoc, curDoc) -&gt; { <i class="conum" data-value="29"></i><b>(29)</b>
                if (curDoc == null) { return false; } <i class="conum" data-value="30"></i><b>(30)</b>
                Map&lt;String, Object&gt; dataMap = curDoc.toMap();
                dataMap.putAll(newDoc.toMap()); <i class="conum" data-value="31"></i><b>(31)</b>
                newDoc.setData(dataMap);
                return true; <i class="conum" data-value="32"></i><b>(32)</b>
            }); <i class="conum" data-value="33"></i><b>(33)</b>
      }
    }


&lt;.&gt; The conflict handler code is provided as a lambda.

&lt;.&gt; If the handler cannot resolve a conflict, it can return false.
In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.

&lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.

&lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).

&lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method

// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
class LocalWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getLocalDocument();
    }
}

// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
class RemoteWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getRemoteDocument();
    }
}

// Using replConfig.setConflictResolver(new MergeConflictResolver());
class MergeConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        Map&lt;String, Object&gt; merge = conflict.getLocalDocument().toMap();
        merge.putAll(conflict.getRemoteDocument().toMap());
        return new MutableDocument(conflict.getDocumentId(), merge);
    }
}


/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

class BrowserSessionManager implements MessageEndpointDelegate {
    private final Context context;
    private Replicator replicator;

    private BrowserSessionManager(Context context) { this.context = context; }

    public void initCouchbase() throws CouchbaseLiteException {
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration(context);
        Database database = new Database("mydb", databaseConfiguration);

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        MessageEndpoint messageEndpointTarget = new MessageEndpoint(
            "UID:123",
            "active",
            ProtocolType.MESSAGE_STREAM,
            this);

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, messageEndpointTarget);

        // Create the replicator object.
        replicator = new Replicator(config);
        // Start the replication.
        replicator.start();
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    @NonNull
    @Override
    public MessageEndpointConnection createConnection(@NonNull MessageEndpoint endpoint) {
        return new ActivePeerConnection(); /</strong> implements MessageEndpointConnection <strong>/
    }
}

class ActivePeerConnection implements MessageEndpointConnection {

    private ReplicatorConnection replicatorConnection;

    public void disconnect() {
        replicatorConnection.close(null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }

    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete();
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null);
    }

    public void receive(Message message) {
        replicatorConnection.receive(message);
    }

}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

class PassivePeerConnection implements MessageEndpointConnection {
    private final Context context;

    private MessageEndpointListener messageEndpointListener;
    private ReplicatorConnection replicatorConnection;

    private PassivePeerConnection(Context context) { this.context = context; }

    public void startListener() throws CouchbaseLiteException {
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration();
        Database database = new Database("mydb", databaseConfiguration);
        MessageEndpointListenerConfiguration listenerConfiguration = new MessageEndpointListenerConfiguration(
            database,
            ProtocolType.MESSAGE_STREAM);
        this.messageEndpointListener = new MessageEndpointListener(listenerConfiguration);
    }

    public void stopListener() {
        messageEndpointListener.closeAll();
    }

    public void accept() {
        PassivePeerConnection connection = new PassivePeerConnection(context); /</strong> implements
        MessageEndpointConnection <strong>/
        messageEndpointListener.accept(connection);
    }

    public void disconnect() {
        replicatorConnection.close(null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete();
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null);
    }

    public void receive(Message message) {
        replicatorConnection.receive(message);
    }
}

// tensorFlowModel is a fake implementation
// this would be the implementation of the ml model you have chosen
class ImageClassifierModel implements PredictiveModel {
    @Override
    public Dictionary predict(@NonNull Dictionary input) {
        Blob blob = input.getBlob("photo");
        if (blob == null) { return null; }

        // tensorFlowModel is a fake implementation
        // this would be the implementation of the ml model you have chosen
        return new MutableDictionary(TensorFlowModel.predictImage(blob.getContent())); <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

class TensorFlowModel {
    public static Map&lt;String, Object&gt; predictImage(byte[] data) {
        return null;
    }
}

class LogTestLogger implements Logger {
    @NonNull
    private final LogLevel level;

    public LogTestLogger(@NonNull LogLevel level) { this.level = level; }

    @NonNull
    @Override
    public LogLevel getLevel() { return level; }

    @Override
    public void log(@NonNull LogLevel level, @NonNull LogDomain domain, @NonNull String message) {
    }
}





//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);                 Log.e(TAG, "Success!!");                 deleteIdentity("server");                 Log.e(TAG, "Alias deleted: server");                 deleteIdentity("client");                 Log.e(TAG, "Alias deleted: client");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void startClient(         @NonNull URI uri,         @NonNull Certificate cert,         @NonNull TLSIdentity clientIdentity,         @NonNull Database db) throws CertificateEncodingException, InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    /</strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(false);
      config.setTlsIdentity(serverId);
      config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

      final URLEndpointListener listener = new URLEndpointListener(config);
      listener.start();

      final List&lt;URI&gt; urls = listener.getUrls();
      if (urls.isEmpty()) { return null; }
      return urls.get(0);
    }

    /<strong>
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
    throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

      final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
      keyStore.load(null);

      keyStore.deleteEntry(alias); <i class="conum" data-value="34"></i><b>(34)</b>
    }

    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /</strong> Configure Client (active) side certificates
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     <strong>/
    private void configureClientCerts(
      ReplicatorConfiguration config,
      @NonNull Certificate cert,
      @NonNull TLSIdentity clientIdentity)
      throws CertificateEncodingException {

        // Create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
      }
      // notend::p2p-tlsid-tlsidentity-with-label[]

    /</strong>
     * Copy a cert from a resource bundle
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte buf[] = new byte[1024];
        int n;
        while n = in.read(buf &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}



//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);                 Log.e(TAG, "Success!!");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void runClient(         @NonNull URI uri,         @NonNull String username,         @NonNull char[] password,         @NonNull Database db) throws InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    /</strong>*
     *
     * Start a listener for db that accepts connections using exactly the passed username and password

     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password) <i class="conum" data-value="35"></i><b>(35)</b>
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(true);
      config.setAuthenticator(new ListenerPasswordAuthenticator(
        (validUser, pwd) -&gt; username.equals(validUser) &amp;&amp; Arrays.equals(validPassword, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
      }
    }






// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.support.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;

public class docOnly_ReplicationExamples {
  private static final String TAG = "EXAMPLE ACTIVE PEER";
  private static final String thisDBNAME = "local-database";
  private final Context context;
  // private Database database;
  // private Replicator replicator;

  public docOnly_ReplicationExamples(Context context) { this.context = context; }

  String user = "syncuser";
  String password = "sync9455";
  SecCertificate cert=null;
  String passivePeerEndpoint = "10.1.1.12:8920";
  String passivePeerPort = "8920";
  String passiveDbName = "userdb";
  Database thisDB;
  Replicator thisReplicator;
  ListenerToken replicatorListener;




// PASSIVE PEER STUFF
// Stuff I adapted
//
// BEGIN new stuff 90420temp cache
  private URLEndpointListener createListener() {
  final URLEndpointListenerConfiguration listenerConfig = new URLEndpointListenerConfiguration(db);

  listenerConfig.setDisableTls(false);

  listenerConfig.setEnableDeltaSync(true);

  listenerConfig.setTlsIdentity(null); // Use with anonymous self signed cert

  listenerConfig.setAuthenticator(new ListenerPasswordAuthenticator(this::isWhitelistedUser));

  return new URLEndpointListener(listenerConfig);
}

public void startListener(@NotNull URLEndpointListener listener) {
  executor.submit) -&gt; {       CouchbaseLiteException err = null;       try { listener.start(); }       catch (CouchbaseLiteException e) { err = e; }       onStart(err);   }); }  private void stopListener(@NotNull URLEndpointListener listener) {   listener.stop(); } // END new stuff 90420temp cache   private void ibListenerSimple() {   final URLEndpointListenerConfiguration thisConfig =     new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="36"></i><b>(36)</b>    thisConfig.setAuthenticator(     new ListenerPasswordAuthenticator(       (username, password) -&gt;         username.equals("valid.User") &amp;&amp;         Arrays.equals(password, valid.password.string)       )     ); <i class="conum" data-value="37"></i><b>(37)</b>    final URLEndpointListener thisListener =     new URLEndpointListener(thisConfig); <i class="conum" data-value="38"></i><b>(38)</b>    thisListener.start(); <i class="conum" data-value="39"></i><b>(39)</b>  }  private void ibReplicatorSimple() {   URI uri = null;   try {       uri = new URI("wss://10.0.2.2:4984/db");   } catch (URISyntaxException e) {       e.printStackTrace();   }   Endpoint theListenerEndpoint = new URLEndpoint(uri); <i class="conum" data-value="40"></i><b>(40)</b>    ReplicatorConfiguration thisConfig =     new ReplicatorConfiguration(database, theListenerEndpoint); <i class="conum" data-value="41"></i><b>(41)</b>    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="42"></i><b>(42)</b>    final BasicAuthenticator thisAuth   = new BasicAuthenticator(       "valid.user",       "valid.password.string");   thisConfig.setAuthenticator(thisAuth) <i class="conum" data-value="43"></i><b>(43)</b>    this.replicator = new Replicator(config); <i class="conum" data-value="44"></i><b>(44)</b>   this.replicator.start(); <i class="conum" data-value="45"></i><b>(45)</b>  }   private void ibPassListener() { // EXAMPLE 1     // Initialize the listener config     final URLEndpointListenerConfiguration thisConfig        = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="46"></i><b>(46)</b>      thisConfig.setPort(55990); <i class="conum" data-value="47"></i><b>(47)</b>      thisConfig.setNetworkInterface("10.1.1.10"); <i class="conum" data-value="48"></i><b>(48)</b>      thisConfig.setEnableDeltaSync(false); <i class="conum" data-value="49"></i><b>(49)</b>      // Configure server security     thisConfig.setDisableTls(false); <i class="conum" data-value="50"></i><b>(50)</b>      // Use an Anonymous Self-Signed Cert     thisConfig.setTlsIdentity(null); <i class="conum" data-value="51"></i><b>(51)</b>       // Configure Client Security using an Authenticator     // For example, Basic Authentication <i class="conum" data-value="52"></i><b>(52)</b>     thisConfig.setAuthenticator(new ListenerPasswordAuthenticator(       (validUser, validPassword) -&gt;         username.equals(validUser) &amp;&amp;         Arrays.equals(password, validPassword);

    // Initialize the listener
    final URLEndpointListener thisListener
      = new URLEndpointListener(thisConfig); <i class="conum" data-value="53"></i><b>(53)</b>

    // Start the listener
    thisListener.start(); <i class="conum" data-value="54"></i><b>(54)</b>

}

private void ibListenerGetNetworkInterfaces() {
  final URLEndpointListenerConfiguration thisConfig =
    URLEndpointListenerConfiguration(database: self.oDB)
  final URLEndpointListener thisListener
    = new URLEndpointListener(thisConfig);
  thisListener.start()
  Log.i(TAG, "URLS are " + thisListener.getUrls());

}

private void ibListenerLocalDb() {
// . . . preceding application logic . . .
CouchbaseLite.init(context); <i class="conum" data-value="55"></i><b>(55)</b>
Database thisDB = new Database("passivepeerdb");

}

private void ibListenerConfigTlsDisable() {
thisConfig.setDisableTls(true); <i class="conum" data-value="56"></i><b>(56)</b>

}

private void ibListenerConfigTlsIdFull() {
  // Use CA Cert
  // Import a key pair into secure storage
  // Create a TLSIdentity from the imported key-pair
  InputStream thisKeyPair = new FileInputStream();

  thisKeyPair.getClass().getResourceAsStream("serverkeypair.p12"); <i class="conum" data-value="57"></i><b>(57)</b>

  TLSIdentity thisIdentity = new TLSIdentity.importIdentity(
    EXTERNAL_KEY_STORE_TYPE,  // KeyStore type, eg: "PKCS12"
    thisKeyPair,              // An InputStream from the keystore
    password,                 // The keystore password
    EXTERNAL_KEY_ALIAS,       // The alias to be used (in external keystore)
    null,                     // The key password
    "test-alias"              // The alias for the imported key
    );


  // Use a self-signed certificate
  // Create a TLSIdentity for the server using convenience API.
  // System generates self-signed cert
  // Work-in-progress. Code snippet coming soon.
  private static final Map&lt;String, String&gt; CERT_ATTRIBUTES; <i class="conum" data-value="58"></i><b>(58)</b>
  static {
    final Map&lt;String, String&gt; thisMap = new HashMap&lt;&gt;();
    m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "Couchbase Demo");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
    m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>");
    CERT_ATTRIBUTES = Collections.unmodifiableMap(thisMap);
  }

  // Store the TLS identity in secure storage
  // under the label 'couchbase-docs-cert'
  TLSIdentity thisIdentity =
    new TLSIdentity.createIdentity(
      true,
      CERT_ATTRIBUTES,
      null,
      "couchbase-docs-cert"); <i class="conum" data-value="59"></i><b>(59)</b>


  // Set the TLS Identity
  thisConfig.setTlsIdentity(thisIdentity); <i class="conum" data-value="60"></i><b>(60)</b>

}

private void ibListenerConfigClientAuthRoot() {
  // Configure the client authenticator
  // to validate using ROOT CA
  // thisClientID.certs is a list containing a client cert to accept
  // and any other certs needed to complete a chain between the client cert
  // and a CA
  final TLSIdentity validId =
    TLSIdentity.getIdentity("Our Corporate Id");  // get the identity <i class="conum" data-value="61"></i><b>(61)</b>

  if (validId == null) { throw new IllegalStateException("Cannot find corporate id"); }

  thisConfig.setTlsIdentity(validId);

  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(validId.getCerts())); <i class="conum" data-value="62"></i><b>(62)</b> <i class="conum" data-value="63"></i><b>(63)</b>
    // accept only clients signed by the corp cert

  final URLEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

}

private void ibListenerConfigClientAuthLambda() {
// Configure authentication using application logic
  final TLSIdentity thisCorpId = TLSIdentity.getIdentity("OurCorp"); <i class="conum" data-value="64"></i><b>(64)</b>
  if (thisCorpId == null) {
    throw new IllegalStateException("Cannot find corporate id"); }
  thisConfig.setTlsIdentity(thisCorpId);
  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(
      (thisCorpId.getCerts()) -&gt; {
      // use supplied logic that resolves to boolean
      // true=valid, false=invalid
      }
    )); <i class="conum" data-value="65"></i><b>(65)</b> <i class="conum" data-value="66"></i><b>(66)</b>
  final ULEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

}


private void ibListenerConfigTlsDisable() {

  thisConfig.disableTLS(true);

}


private void ibListenerStatusCheck() {
  int connectionCount =
    thisListener.getStatus().getConnectionCount(); <i class="conum" data-value="67"></i><b>(67)</b>

  int activeConnectionCount =
    thisListener.getStatus().getActiveConnectionCount();  <i class="conum" data-value="68"></i><b>(68)</b>

}

private void ibListenerStop() {

  thisListener.stop();

}

// Listener Callouts
/</strong>

    &lt;.&gt; Initialize the listener instance using the configuration settings.
    &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.



  &lt;.&gt; <code>connectionCount</code> -- the total number of connections served by the listener
  &lt;.&gt; <code>activeConnectionCount</code> -- the number of active (BUSY) connections currently being served by the listener
  //

<strong>/
/</strong> END CALLOUTS TEXT <strong>/


private void ibP2PUrlEndpointListener() {

  public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
  }
}



// ACTIVE PEER STUFF
// Replication code
//

  //@Test
  public void testActPeerSync() throws CouchbaseLiteException, URISyntaxException {
    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://listener.com:8954"))); <i class="conum" data-value="69"></i><b>(69)</b> <i class="conum" data-value="70"></i><b>(70)</b>

    // Set replicator type
    thisConfig.setReplicatorType(
      ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Configure Sync Mode
    thisConfig.setContinuous(false); // default value

    // set auto-purge behavior (here we override default)
    thisConfig.setAutoPurgeEnabled(false); <i class="conum" data-value="71"></i><b>(71)</b>

    // Configure Server Authentication --
    // only accept self-signed certs
    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="72"></i><b>(72)</b>

    // Configure the credentials the
    // client will provide if prompted
    final BasicAuthenticator thisAuth
      = new BasicAuthenticator(
          "Our Username",
          "Our PasswordValue")); <i class="conum" data-value="73"></i><b>(73)</b>

    thisConfig.setAuthenticator(thisAuth)

    /</strong> Optionally set custom conflict resolver call back <strong>/
    thisConfig.setConflictResolver( /</strong> define resolver function <strong>/); <i class="conum" data-value="74"></i><b>(74)</b>

    // Create replicator
    // Consider holding a reference somewhere
    // to prevent the Replicator from being GCed
    final Replicator thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="75"></i><b>(75)</b>

    // Optionally add a change listener <i class="conum" data-value="76"></i><b>(76)</b>
    ListenerToken thisListener =
      new thisReplicator.addChangeListener(change -&gt; {
        final CouchbaseLiteException err =
         change.getStatus().getError();
         if (err != null) {
           Log.i(TAG, "Error code ::  " + err.getCode(), e);
         }
      }); <i class="conum" data-value="77"></i><b>(77)</b>

    // Start replicator
    thisReplicator.start(false); <i class="conum" data-value="78"></i><b>(78)</b>


  public void ibReplicatorConfig() {
  // BEGIN additional snippets
      // Configure Server Security
      // -- only accept CA attested certs
      thisConfig.setAcceptOnlySelfSignedServerCertificate(false); <i class="conum" data-value="79"></i><b>(79)</b>


    // Return the remote pinned cert (the listener's cert)
    byte returnedCert
     = new byte(thisConfig.getPinnedCertificate()); // Get listener cert if pinned

    // ... your other replicator configuration

    // Provide a client certificate to the server for authentication
    final TLSIdentity thisClientId = TLSIdentity.getIdentity("clientId"); <i class="conum" data-value="80"></i><b>(80)</b>

    if (thisClientId == null) { throw new IllegalStateException("Cannot find client id"); }

    thisConfig.setAuthenticator(new ClientCertificateAuthenticator(thisClientId)); <i class="conum" data-value="81"></i><b>(81)</b>

    // ... your other replicator configuration
    final thisReplicator= new Replicator(thisConfig);


    // Use the pinned certificate from the byte array (cert)
    thisConfig.setPinnedServerCertificate(cert.getEncoded()); <i class="conum" data-value="82"></i><b>(82)</b>
}
// END additional snippets








    Log.i(TAG, "The Replicator is currently " +
      thisReplicator.getStatus().getActivityLevel());

    Log.i(TAG, "The Replicator has processed " + t);

    if (thisReplicator.getStatus().getActivityLevel() ==
      Replicator.ActivityLevel.BUSY) {
        Log.i(TAG, "Replication Processing");
        Log.i(TAG, "It has completed " +
          thisReplicator.getStatus().getProgess().getTotal() +
          " changes");
      }

      // Stop replication.
      thisReplicator.stop(); <i class="conum" data-value="83"></i><b>(83)</b>


  CouchbaseLite.init(context);
  Database thisDB = new Database("passivepeerdb");  <i class="conum" data-value="84"></i><b>(84)</b>
  // Initialize the listener config
  final URLEndpointListenerConfiguration thisConfig = new URLEndpointListenerConfiguration(database);
  thisConfig.setPort(55990)           // &lt;.&gt; Optional; defaults to auto
  thisConfig.setDisableTls(false)     // &lt;.&gt; Optional; defaults to false
  thisConfig.setEnableDeltaSync(true) // &lt;.&gt; Optional; Defaults to false

  // Configure the client authenticator (if using basic auth)
  ListenerPasswordAuthenticator auth = new ListenerPasswordAuthenticator { "username", "password"}; <i class="conum" data-value="85"></i><b>(85)</b>
  thisConfig.setAuthenticator(auth); <i class="conum" data-value="86"></i><b>(86)</b>

  // Initialize the listener
  final URLEndpointListener listener = new URLEndpointListener( thisConfig ); <i class="conum" data-value="87"></i><b>(87)</b>

  // Start the listener
  listener.start(); <i class="conum" data-value="88"></i><b>(88)</b>




  Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
        )

  TLSIdentity thisIdentity = new TLSIdentity.createIdentity(true, X509_ATTRIBUTES, null, "test-alias");




  String thisAlias = "alias-to-delete";
  final KeyStore thisKeyStore
    =  KeyStore.getInstance("AndroidKeyStore");
  thisKeyStore.load(null);
  thisKeyStore.deleteEntry(thisAlias);


  // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label

  TLSIdentity thisIdentity =
    new TLSIdentity.getIdentity("couchbase-docs-cert")


  public void ibRplicatorPull() {
    Database database;
    Replicator replicator; <i class="conum" data-value="89"></i><b>(89)</b>

    URI uri = null;
    try {
        uri = new URI("wss://10.0.2.2:4984/db"); <i class="conum" data-value="90"></i><b>(90)</b>
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
    Endpoint endpoint = new URLEndpoint(uri);
    ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
    config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
    this.replicator = new Replicator(config);
    this.replicator.start();
  }

    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))); <i class="conum" data-value="91"></i><b>(91)</b>



  /</strong> C A L L O U T S

  &lt;.&gt; Configure the pinned certificate using data from the byte array <code>cert</code>

  &lt;.&gt; Attempt to get the identity from secure storage
  &lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity


  &lt;.&gt; A replication is an asynchronous operation.
  To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
  &lt;.&gt; The URL scheme for remote database URLs uses <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections over wb sockets.
  In this example the hostname is <code>10.0.2.2</code> because the Android emulator runs in a VM that is generally accessible on <code>10.0.2.2</code> from the host machine (see <a href="https://developer.android.com/studio/run/emulator-networking">Android Emulator networking</a> documentation).
  +
  NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
  Although <code>wss:</code> protocol URLs are not affected, in order to use the <code>ws:</code> protocol, applications must target API 27 or lower, or must configure application network security as described <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted">here</a>.

  <strong>/

}
/</strong>

Snippets demonstrating use of resultsets

<strong>/
package com.example.docsnippet;
        import android.app.Application.</strong>;
        import android.content.Context;
        import android.content.Context.<strong>;
        import java.lang.Object;
        import java.security.Key;
        import java.util.</strong>;
        import com.couchbase.lite.<strong>;
        import com.couchbase.lite.Dictionary;

public class TestQueries {

    // For Documentation

    Datastore ds = new Datastore();

    Database this_Db = ds.getDB();

    String dbName = this_Db.getName();

    HashMap&lt;String, Object&gt; hotels = new HashMap&lt;&gt;();

    Dictionary thisDocsProps;
    String thisDocsId;
    String thisDocsName;
    String thisDocsType;
    String thisDocsCity;



    static {
        init();
    }

    private static void init() {
    }



    public void testQuerySyntaxAll() throws CouchbaseLiteException {

        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

      Query listQuery = QueryBuilder.select(SelectResult.all())
              .from(DataSource.database(this_Db));

        try {
            for (Result result : listQuery.execute().allResults()) {
                             // get the k-v pairs from the 'hotel' key's value into a dictionary
                thisDocsProps = result.getDictionary(0); <i class="conum" data-value="92"></i><b>(92)</b>
                thisDocsId = thisDocsProps.getString("id");
                thisDocsName = thisDocsProps.getString("Name");
                thisDocsType = thisDocsProps.getString("Type");
                thisDocsCity = thisDocsProps.getString("City");

                // Alternatively, access results value dictionary directly
                final Hotel hotel = new Hotel();
                hotel.Id = result.getDictionary(0).getString("id"); <i class="conum" data-value="93"></i><b>(93)</b>
                hotel.Type = result.getDictionary(0).getString("Type");
                hotel.Name = result.getDictionary(0).getString("Name");
                hotel.City = result.getDictionary(0).getString("City");
                hotel.Country= result.getDictionary(0).getString("Country");
                hotel.Description = result.getDictionary(0).getString("Description");
                hotels.put(hotel.Id, hotel);
            }

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }



    // Uses Jackson JSON processor

    ArrayList&lt;Hotel&gt; hotels = new ArrayList&lt;Hotel&gt;();
    HashMap&lt;String, Object&gt; dictFromJSONstring;
    for (Result result : listQuery.execute()) {

      // Get result as JSON string
      String thisJsonString = result.toJSON(); <i class="conum" data-value="94"></i><b>(94)</b>

      // Get Java  Hashmap from JSON string
      HashMap&lt;String, Object&gt; dictFromJSONstring =
              mapper.readValue(thisJsonString, HashMap.class); <i class="conum" data-value="95"></i><b>(95)</b>


      // Use created hashmap
      String hotelId = dictFromJSONstring.get("id").toString();
      String hotelType = dictFromJSONstring.get("type").toString();
      String hotelname = dictFromJSONstring.get("name").toString();


      // Get custom object from JSON string
      Hotel thisHotel =
              mapper.readValue(thisJsonString, Hotel.class); <i class="conum" data-value="96"></i><b>(96)</b>
      hotels.add(thisHotel);



            }
        }


    public void testQuerySyntaxProps() throws CouchbaseLiteException {
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        Query listQuery =
        QueryBuilder.select(SelectResult.expression(Meta.id),
        SelectResult.property("name"),
        SelectResult.property("Name"),
        SelectResult.property("Type"),
        SelectResult.property("City"))
        .from(DataSource.database(this_Db));



        try {
          for (Result result : listQuery.execute().allResults()) {

            // get data direct from result k-v pairs
            final Hotel hotel = new Hotel();
            hotel.Id = result.getString("id");
            hotel.Type = result.getString("Type");
            hotel.Name = result.getString("Name");
            hotel.City = result.getString("City");

            // Store created hotel object in a hashmap of hotels
            hotels.put(hotel.Id, hotel);

            // Get result k-v pairs into a 'dictionary' object
            Map &lt;String, Object&gt; thisDocsProps = result.toMap();
            thisDocsId =
            thisDocsProps.getOrDefault("id",null).toString();
            thisDocsName =
            thisDocsProps.getOrDefault("Name",null).toString();
            thisDocsType =
            thisDocsProps.getOrDefault("Type",null).toString();
            thisDocsCity =
            thisDocsProps.getOrDefault("City",null).toString();

          }
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

    }


    public void testQuerySyntaxCount() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery = QueryBuilder.select(
              SelectResult.expression(Function.count(Expression.string("</strong>"))).as("mycount")) <i class="conum" data-value="97"></i><b>(97)</b>
              .from(DataSource.database(this_Db));



        try {
            for (Result result : listQuery.execute()) {

                // Retrieve count using key 'mycount'
                Integer altDocId = result.getInt("mycount");

                // Alternatively, use the index
                Integer orDocId = result.getInt(0);
            }
            // Or even miss out the for-loop altogether
            Integer resultCount = listQuery.execute().next().getInt("mycount");

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }
    }


    public void testQuerySyntaxId() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id).as("metaID"))
                      .from(DataSource.database(this_Db));




        try {
            for (Result result : listQuery.execute().allResults()) {

                // get the ID form the result's k-v pair array
                thisDocsId = result.getString("metaID"); <i class="conum" data-value="98"></i><b>(98)</b>

                // Get document from DB using retrieved ID
                Document thisDoc = this_Db.getDocument(thisDocsId);

                // Process document as required
                thisDocsName = thisDoc.getString("Name");

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }


    }


    public void testQueryPagination() throws CouchbaseLiteException {


        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        int thisOffset = 0;
        int thisLimit = 20;

        Query listQuery =
                QueryBuilder
                        .select(SelectResult.all())
                        .from(DataSource.database(this_Db))
                        .limit(Expression.intValue(thisLimit),
                                  Expression.intValue(thisOffset)); <i class="conum" data-value="99"></i><b>(99)</b>


    }



    public List&lt;Result&gt; docsonly_QuerySyntaxN1QL (Database argDB)
    {
      // For Documentation -- N1QL Query using parameters
      //  Declared elsewhere: Database argDB

      Database thisDb = argDB;

      Query thisQuery =
      thisDb.createQuery(
        "SELECT META().id AS thisId FROM _ WHERE type = \"hotel\""); // &lt;.

        return thisQuery.execute().allResults();

      }


    public List&lt;Result&gt; docsonly_QuerySyntaxN1QLParams (Database argDB)
    {
      // For Documentation -- N1QL Query using parameters
      //  Declared elsewhere: Database argDB

      Database thisDb = argDB;

      Query thisQuery =
          thisDb.createQuery(
              "SELECT META().id AS thisId FROM _ WHERE type = $type"); // &lt;.

      thisQuery.parameters =
          Parameters.setString("type", "hotel"); <i class="conum" data-value="100"></i><b>(100)</b>

      return thisQuery.execute().allResults();

  }

} // class



public class supportingDatatypes
{
    private static final String TAG = "info";

    public void datatype_dictionary() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)
        Document document = database.getDocument("doc1");

        // Getting a dictionary from the document's properties
        Dictionary dict = document.getDictionary("address");

        // Access a value with a key from the dictionary
        String street = dict.getString("street");

        // Iterate dictionary
        for (String key : dict) {
            dict.getValue(key);
            Log.i("x", "Key %s, = %s", key, dict.getValue(key));
        }

        // Create a mutable copy
        MutableDictionary mutable_Dict = dict.toMutable();
    }

    public void datatype_mutable_dictionary() throws CouchbaseLiteException {

        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        MutableDictionary mutable_dict = new MutableDictionary();
        mutable_dict.setString("street", "1 Main st.");
        mutable_dict.setString("city", "San Francisco");

        // Add the dictionary to a document's properties and save the document
        MutableDocument mutable_doc = new MutableDocument("doc1");
        mutable_doc.setDictionary("address", mutable_dict);
        database.save(mutable_doc);

    }


    public void datatype_array() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        Document document = database.getDocument("doc1");

        // Getting a phones array from the document's properties
        Array array = document.getArray("phones");

        // Get element count
        int count = array.count();

        // Access an array element by index
        if (count &gt;= 0) { String phone = array.getString(1); }

        // Iterate dictionary
        for (int i = 0; i &lt; count; i)
        {
            Log.i("tag", "Item %d = %s", i, array.getString(i));
        }

        // Create a mutable copy
        MutableArray mutable_array = array.toMutable();


    }

    public void datatype_mutable_array() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        MutableArray mutable_array = new MutableArray();
        mutable_array.addString("650-000-0000");
        mutable_array.addString("650-000-0001");

        // Set the array to document's properties and save the document
        MutableDocument mutable_doc = new MutableDocument("doc1");
        mutable_doc.setArray("phones", mutable_array);
        database.save(mutable_doc);
    }

} // end  class supporting_datatypes



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/ZipUtils.java 
package com.couchbase.code_snippets;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class ZipUtils {
    public static void unzip(InputStream in, File destination) throws IOException {
        byte[] buffer = new byte[1024];
        ZipInputStream zis = new ZipInputStream(in);
        ZipEntry ze = zis.getNextEntry();
        while (ze != null) {
            String fileName = ze.getName();
            File newFile = new File(destination, fileName);
            if (ze.isDirectory()) {
                newFile.mkdirs();
            } else {
                new File(newFile.getParent()).mkdirs();
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) &gt; 0) {
                    fos.write(buffer, 0, len);
                }
                fos.close();
            }
            ze = zis.getNextEntry();
        }
        zis.closeEntry();
        zis.close();
        in.close();
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/ZipUtils.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/JSONExamples.java 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.util.Log;

import java.util.Map;

import org.json.JSONException;
import org.json.JSONObject;

import com.couchbase.lite.Array;
import com.couchbase.lite.Blob;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableArray;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.Result;
import com.couchbase.lite.SelectResult;


public class JSONExamples {
    private static final String TAG = "SNIPPETS";

    public static final String JSON
        = "[{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\","
        + "\"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},"
        + "{\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\","
        + "\"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},"
        + "{\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\","
        + "\"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\","
        + "\"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]";

    public void jsonArrayExample(Database db) throws CouchbaseLiteException {
        // github tag=tojson-array
        final MutableArray mArray = new MutableArray(JSON); // &lt;.&gt;

        for (int i = 0; i &lt; mArray.count(); i) { <i class="conum" data-value="101"></i><b>(101)</b>
          final Dictionary dict = mArray.getDictionary(i);
          Log.i(TAG, dict.getString("name"));
          db.save(new MutableDocument(dict.getString("id"), dict.toMap()));
        }

        final Array features = db.getDocument("1002").getArray("features"); <i class="conum" data-value="102"></i><b>(102)</b>
        for (Object feature: features.toList()) { Log.i(TAG, feature.toString()); }
        Log.i(TAG, features.toJSON()); <i class="conum" data-value="103"></i><b>(103)</b>
      }

      public void jsonBlobExample(Database db) {
        // github tag=tojson-blob
        final Map&lt;String, ?&gt; thisBlob = db.getDocument("thisdoc-id").toMap();
        if (!Blob.isBlob(thisBlob)) { return; }

        final String blobType = thisBlob.get("content_type").toString();
        final Number blobLength = (Number) thisBlob.get("length");
      }

      public void jsonDictionaryExample(Database db) {
        // github tag=tojson-dictionary
        final MutableDictionary mDict = new MutableDictionary(JSON); <i class="conum" data-value="104"></i><b>(104)</b>
        Log.i(TAG, mDict.toString());

        Log.i(TAG, "Details for: " + mDict.getString("name"));
        for (String key: mDict.getKeys()) {
          Log.i(TAG, key + " =&gt; " + mDict.getValue(key));
        }
    }

    public void jsonDocumentExample(Database srcDb, Database dstDb) throws CouchbaseLiteException {
        // github tag=tojson-document
        final Query listQuery = QueryBuilder
        .select(SelectResult.expression(Meta.id).as("metaId"))
        .from(DataSource.database(srcDb));

        for (Result row: listQuery.execute()) {
          final String thisId = row.getString("metaId");

          final String json = srcDb.getDocument(thisId).toJSON(); <i class="conum" data-value="105"></i><b>(105)</b>
          Log.i(TAG, "JSON String = " + json);

          final MutableDocument hotelFromJSON = new MutableDocument(thisId, json); <i class="conum" data-value="106"></i><b>(106)</b>

          dstDb.save(hotelFromJSON);

          for (Map.Entry entry: dstDb.getDocument(thisId).toMap().entrySet()) {
            Log.i(TAG, entry.getKey() + " =&gt; " + entry.getValue());
          } <i class="conum" data-value="107"></i><b>(107)</b>
        }
      }


    public void jsonQueryExample(Query query) throws CouchbaseLiteException, JSONException {
        for (Result row: query.execute()) {

            // get the result into a JSON String
            final String jsonString = row.toJSON();

            final JSONObject thisJsonObj = new JSONObject(jsonString);

            // Use Json Object to populate Native object
            // Use Codable class to unpack JSON data to native object
            final Hotel thisHotel = new Hotel(
                "this hotel",
                "Ghana, West Africa",
                thisJsonObj.getString("city"),
                thisJsonObj.getString("name"),
                thisJsonObj.getString("type"),
                thisJsonObj.getString("id"));
        }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/JSONExamples.java </code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>+
See: <a href="database.html" class="page">Databases</a> for more information</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Initialize a new mutable document</p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset2_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset2_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset2_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">

// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.*
import com.couchbase.lite.internal.utils.PlatformUtils
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.io.InputStream
import java.net.URI
import java.net.URISyntaxException


private const val TAG = "REPLICATION"

@Throws(IOException::class)
fun InputStream.toByteArray(): ByteArray {
    val buffer = ByteArray(1024)
    val output = ByteArrayOutputStream()

    var n: Int
    while (-1 &lt; this.read(buffer).also { n = it }) {
        output.write(buffer, 0, n)
    }

    return output.toByteArray()
}

//
//        &lt;.&gt; The conflict handler code is provided as a lambda.
//
//        &lt;.&gt; If the handler cannot resolve a conflict, it can return false.
//        In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.
//
//        &lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.
//
//        &lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).
//
//        &lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method


// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
@Suppress("unused")
object LocalWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.localDocument
}

// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
@Suppress("unused")
object RemoteWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.remoteDocument
}

// Using replConfig.setConflictResolver(new MergeConflictResolver());
@Suppress("unused")
object MergeConflictResolver : ConflictResolver {
    override fun resolve(conflict: Conflict): Document {
        val localDoc = conflict.localDocument?.toMap()
        val remoteDoc = conflict.remoteDocument?.toMap()

        val merge: MutableMap&lt;String, Any&gt;?
        if (localDoc == null) {
            merge = remoteDoc
        } else {
            merge = localDoc
            if (remoteDoc != null) {
                merge.putAll(remoteDoc)
            }
        }

        return if (merge == null) {
            MutableDocument(conflict.documentId)
        } else {
            MutableDocument(conflict.documentId, merge)
        }
    }

    @Suppress("unused")
    class ReplicationExamples(private val database: Database) {
        private var replicator: Replicator? = null

        @Throws(URISyntaxException::class)
        fun testReplicationBasicAuthentication() {

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = BasicAuthenticator("username", "password".toCharArray())
                )
            )
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationSessionAuthentication() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447")
                )
            )
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationStatus() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            repl.addChangeListener { change -&gt;
                if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                    Log.i(TAG, "Replication stopped")
                }
            }

            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testHandlingNetworkErrors() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            repl.addChangeListener { change -&gt;
                change.status.error?.let {
                    Log.w(TAG, "Error code: ${it.code}")
                }
            }
            repl.start()
            replicator = repl

            repl.stop()
        }

        @Throws(URISyntaxException::class)
        fun testReplicatorDocumentEvent() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            val token = repl.addDocumentReplicationListener { replication -&gt;
                Log.i(TAG, "Replication type: ${if (replication.isPush) "push" else "pull"}")

                for (document in replication.documents) {
                    document.let { doc -&gt;
                        Log.i(TAG, "Doc ID: ${document.id}")
                        doc.error?.let {
                            // There was an error
                            Log.e(TAG, "Error replicating document: ", it)
                            return@addDocumentReplicationListener
                        }
                        if (doc.flags.contains(DocumentFlag.DELETED)) {
                            Log.i(TAG, "Successfully replicated a deleted document")
                        }
                    }
                }
            }

            repl.start()
            replicator = repl

            repl.removeChangeListener(token)
        }

        @Throws(URISyntaxException::class)
        fun testReplicationCustomHeader() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value")
                )
            )
            replicator = repl
        }

        // <mark># Certificate Pinning
        @Throws(URISyntaxException::class, IOException::class)
        fun testCertificatePinning() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value"),
                    pinnedServerCertificate = PlatformUtils.getAsset("cert.cer")?.toByteArray()
                )
            )
            replicator = repl
        }

        // </mark># Reset replicator checkpoint
        @Throws(URISyntaxException::class)
        fun testReplicationResetCheckpoint() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            val resetCheckpointRequired_Example = false
            repl.start(resetCheckpointRequired_Example) <i class="conum" data-value="1"></i><b>(1)</b>

            // ... at some later time

            repl.stop()

        }

        @Throws(URISyntaxException::class)
        fun testReplicationPushFilter() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { _, flags -&gt; flags.contains(DocumentFlag.DELETED) } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationPullFilter() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { document, _ -&gt; "draft" == document.getString("type") } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testCustomRetryConfig() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    //  other config params as required . .
                    heartbeat = 150, <i class="conum" data-value="1"></i><b>(1)</b>
                    maxAttempts = 20,
                    maxAttemptWaitTime = 600
                )
            )

            repl.start()
            replicator = repl
        }

        @Throws(CouchbaseLiteException::class)
        fun testDatabaseReplica() {
            val config = DatabaseConfiguration()
            val database1 = Database("mydb", config)
            val database2 = Database("db2", config)

            /* EE feature: code below might throw a compilation error
               if it's compiled against CBL Android Community. <strong>/
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database1,
                    target = DatabaseEndpoint(database2),
                    type = ReplicatorType.PULL
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationWithCustomConflictResolver() {
            val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
            val config = ReplicatorConfiguration(database, target)
            config.conflictResolver = LocalWinsResolver
            val replication = Replicator(config)
            replication.start()
        }

        @Throws(CouchbaseLiteException::class)
        fun testSaveWithCustomConflictResolver() {
            val mutableDocument = database.getDocument("xyz")?.toMutable() ?: return
            mutableDocument.setString("name", "apples")
            database.save(mutableDocument) { newDoc, curDoc -&gt;  <i class="conum" data-value="2"></i><b>(2)</b>
                if (curDoc == null) {
                    return@save false
                } <i class="conum" data-value="3"></i><b>(3)</b>
                val dataMap: MutableMap&lt;String, Any&gt; = curDoc.toMap()
                dataMap.putAll(newDoc.toMap()) <i class="conum" data-value="4"></i><b>(4)</b>
                newDoc.setData(dataMap)
                true <i class="conum" data-value="5"></i><b>(5)</b>
            } <i class="conum" data-value="6"></i><b>(6)</b>
        }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import android.widget.Toast
import com.couchbase.lite.</strong>
import com.couchbase.lite.internal.utils.PlatformUtils
import org.junit.Test
import java.io.File
import java.io.IOException
import java.net.URI
import java.net.URISyntaxException
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.*


private const val TAG = "BASIC"

class LogTestLogger(private val level: LogLevel) : Logger {
    override fun getLevel() = level

    override fun log(level: LogLevel, domain: LogDomain, message: String) {
        // this method will never be called if param level &lt; this.level
        // handle the message, for example piping it to a third party framework
    }
}

@Suppress("unused")
class BasicExamples(private val context: Context) {
    private val database: Database

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        // Get the database (and create it if it doesnt exist).
        database = Database(
          "getting-started",
          DatabaseConfigurationFactory.create(context.filesDir.absolutePath)
          )
    }

    @Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {

        // !!! Note the code moved from here to the init { } above.
        // Create a new document (i.e. a record) in the database.
        var mutableDoc = MutableDocument().setFloat("version", 2.0f).setString("type", "SDK")

        // Save it to the database.
        database.save(mutableDoc)

        // Update a document.
        mutableDoc = database.getDocument(mutableDoc.id)!!.toMutable().setString("language", "Java")
        database.save(mutableDoc)

        val document = database.getDocument(mutableDoc.id)!!
        // Log the document ID (generated by the database) and properties
        Log.i(TAG, "Document ID :: ${document.id}")
        Log.i(TAG, "Learning ${document.getString("language")}")

        // Create a query to fetch documents of type SDK.
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))
            .execute()
        Log.i(TAG, "Number of rows :: ${rs.allResults().size}")

        // Create a replicator to push and pull changes to and from the cloud.
        // Be sure to hold a reference somewhere to prevent the Replicator from being GCed
        val replicator =
          Replicator(
            ReplicatorConfigurationFactory.create(
              database = database,
              target = URLEndpoint(URI("ws://localhost:4984/getting-started-db")),
              type = ReplicatorType.PUSH_AND_PULL,
              authenticator = BasicAuthenticator("sync-gateway", "password".toCharArray())
              )
          )


        // Listen to replicator change events.
        replicator.addChangeListener { change -&gt;
            val err = change.status.error
            if (err != null) Log.i(TAG, "Error code ::  ${err.code}")
        }

        // Start replication.
        replicator.start()

        database.delete()
    }

    @Throws(CouchbaseLiteException::class, IOException::class)
    fun test1xAttachments() {
        // if db exist, delete it
        deleteDB("android-sqlite", context.filesDir)
        ZipUtils.unzip(
            PlatformUtils.getAsset("replacedb/android140-sqlite.cblite2.zip"),
            context.filesDir
        )

        val db = Database("android-sqlite")
        try {
            // For Validation
            Arrays.equals(
                "attach1".toByteArray(),
                db.getDocument("doc1")?.getDictionary("_attachments")?.getBlob("attach1")?.content
            )
        } finally {
            // close db
            db.close()
            // if db exist, delete it
            deleteDB("android-sqlite", context.filesDir)
        }
        val document = MutableDocument()

        val content = document.getDictionary("_attachments")?.getBlob("avatar")?.content
    }

    // <mark># Initializer
    fun testInitializer() {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)
    }

    // </mark># New Database
    @Throws(CouchbaseLiteException::class)
    fun testNewDatabase() {
        val database = Database(
            "my-db",
            DatabaseConfigurationFactory.create(
                context.filesDir.absolutePath
            )
        ) <i class="conum" data-value="7"></i><b>(7)</b>
        database.close()


        database.delete()
    }

    // <mark># Database Encryption
    @Throws(CouchbaseLiteException::class)
    fun testDatabaseEncryption() {
        val db = Database(
            "my-db",
            DatabaseConfigurationFactory.create(
                encryptionKey = EncryptionKey("PASSWORD")
            )
        )

    }

    // </mark># Logging
    // !!! OBSOLETE in 3.0
    fun testLogging() {
    }

    fun testEnableCustomLogging() {
        // this custom logger will not log an event with a log level &lt; WARNING
        Database.log.custom = LogTestLogger(LogLevel.WARNING) <i class="conum" data-value="8"></i><b>(8)</b>
    }

    // <mark># Console logging
    @Throws(CouchbaseLiteException::class)
    fun testConsoleLogging() {
        Database.log.console.domains = LogDomain.ALL_DOMAINS <i class="conum" data-value="9"></i><b>(9)</b>
        Database.log.console.level = LogLevel.VERBOSE <i class="conum" data-value="10"></i><b>(10)</b>

        Database.log.console.domains = EnumSet.of(LogDomain.DATABASE) <i class="conum" data-value="11"></i><b>(11)</b>
    }

    // </mark># File logging
    @Throws(CouchbaseLiteException::class)
    fun testFileLogging() {
        Database.log.file.let {
          it.config = LogFileConfigurationFactory.create(
            context.cacheDir.absolutePath, <i class="conum" data-value="12"></i><b>(12)</b>
            maxSize = 10240, <i class="conum" data-value="13"></i><b>(13)</b>
            maxRotateCount = 5, <i class="conum" data-value="14"></i><b>(14)</b>
            usePlainText = false
            ) <i class="conum" data-value="15"></i><b>(15)</b>
            it.level = LogLevel.INFO <i class="conum" data-value="16"></i><b>(16)</b>

          }
    }

    fun writeConsoleLog() {
        Database.log.console.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    fun writeCustomLog() {
        Database.log.custom?.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    fun writeFileLog() {
        Database.log.file.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    /* The <code>tag::replication[]</code> example is inlined in java.adoc <strong>/
    fun testTroubleshooting() {
        Database.log.console.let {
            it.level = LogLevel.VERBOSE
            it.domains = LogDomain.ALL_DOMAINS
        }
    }

    // <mark># Loading a pre-built database
    @Throws(IOException::class)
    fun testPreBuiltDatabase() {
        // Note: Getting the path to a database is platform-specific.
        // For Android you need to extract the database from your assets
        // to a temporary directory and then copy it, using Database.copy()
        if (Database.exists("travel-sample", context.filesDir)) {
            return
        }
        ZipUtils.unzip(PlatformUtils.getAsset("travel-sample.cblite2.zip"), context.filesDir)
        Database.copy(
            File(context.filesDir, "travel-sample"),
            "travel-sample",
            DatabaseConfiguration()
        )
    }

    // helper methods
    // if db exist, delete it
    fun deleteDB(name: String, dir: File) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            Database.delete(name, dir)
        }

        // </mark># Initializers
        fun testInitializers() {
            val doc = MutableDocument()
            doc.let {
                it.setString("type", "task")
                it.setString("owner", "todo")
                it.setDate("createdAt", Date())
            }
            database.save(doc)
        }
    }

    // <mark># Mutability
    fun testMutability() {
        database.save(MutableDocument("xyz"))

        database.getDocument("xyz")?.toMutable()?.let {
            it.setString("name", "apples")
            database.save(it)
        }
    }

    // </mark># Typed Accessors
    fun testTypedAccessors() {
        val doc = MutableDocument()

        doc.setValue("createdAt", Date())
        val date = doc.getDate("createdAt")
    }

    // <mark># Batch operations
    fun testBatchOperations() {
        database.inBatch(UnitOfWork {
            for (i in 0..9) {
                val doc = MutableDocument()
                doc.let {
                    it.setValue("type", "user")
                    it.setValue("name", "user $i")
                    it.setBoolean("admin", false)
                }
                Log.i(TAG, "saved user document: ${doc.getString("name")}")
            }
        })
    }


    // toJSON
    fun testToJsonOperations(argDb: Database) {
        val db = argDb

    }


    // </mark># Document Expiration
    @Throws(CouchbaseLiteException::class)
    fun documentExpiration() {
        // Purge the document one day from now
        database.setDocumentExpiration(
            "doc123",
            Date(Instant.now().plus(1, ChronoUnit.DAYS).toEpochMilli())
        )

        // Reset expiration
        database.setDocumentExpiration("doc1", null)

        // Query documents that will be expired in less than five minutes
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.longValue(Instant.now().plus(5, ChronoUnit.MINUTES).toEpochMilli())
                )
            )
    }

    @Throws(CouchbaseLiteException::class)
    fun testDocumentChangeListener() {
        database.addDocumentChangeListener("user.john") { change -&gt;
            database.getDocument(change.documentID)?.let {
                Toast.makeText(
                    context,
                    "Status: ${it.getString("verified_account")}",
                    Toast.LENGTH_SHORT
                ).show()
            }
        }
    }

    // <mark># Blobs
    fun testBlobs() {
        val mDoc = MutableDocument()

        PlatformUtils.getAsset("avatar.jpg")?.use { <i class="conum" data-value="17"></i><b>(17)</b>
            mDoc.setBlob("avatar", Blob("image/jpeg", it)) <i class="conum" data-value="18"></i><b>(18)</b> <i class="conum" data-value="19"></i><b>(19)</b>
            database.save(mDoc)
        }

        val doc = database.getDocument(mDoc.id)
        val bytes = doc?.getBlob("avatar")?.content
    }
}


class supportingDatatypes
{

    private val database  = Database("mydb")

    fun datatype_dictionary() {

        // NOTE: No error handling, for brevity (see getting started)
        val document = database!!.getDocument("doc1")

        // Getting a dictionary from the document's properties
        val dict = document?.getDictionary("address")

        // Access a value with a key from the dictionary
        val street = dict?.getString("street")

        // Iterate dictionary
        for (key in dict!!.keys) {
            println("Key ${key} = ${dict.getValue(key)}")
        }

    // Create a mutable copy
    val mutable_Dict = dict.toMutable()
}

    fun datatype_mutable_dictionary() {

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        val mutable_dict = MutableDictionary()
        mutable_dict.setString("street", "1 Main st.")
        mutable_dict.setString("city", "San Francisco")

        // Add the dictionary to a document's properties and save the document
        val mutable_doc = MutableDocument("doc1")
        mutable_doc.setDictionary("address", mutable_dict)
        database!!.save(mutable_doc)

}


    fun datatype_array() {

        // NOTE: No error handling, for brevity (see getting started)

        val document = database?.getDocument("doc1")

        // Getting a phones array from the document's properties
        val array = document?.getArray("phones")

        // Get element count
        val count = array?.count()

        // Access an array element by index
        val phone = array?.getString(1)

        // Iterate array
        for ( (index, item) in array!!) {
            println("Row  ${index} = ${item}")
        }

        // Create a mutable copy
        val mutable_array = array.toMutable()
    }

    fun datatype_mutable_array() {

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        val mutable_array = MutableArray()
        mutable_array.addString("650-000-0000")
        mutable_array.addString("650-000-0001")

        // Set the array to document's properties and save the document
        val mutable_doc = MutableDocument("doc1")
        mutable_doc.setArray("phones", mutable_array)
        database?.save(mutable_doc)
    }

} // end  class supporting_datatypes



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.Dictionary
import com.couchbase.lite.Expression
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.MutableDictionary
import com.couchbase.lite.PredictionFunction
import com.couchbase.lite.PredictiveIndex
import com.couchbase.lite.PredictiveModel
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.SelectResult
import com.couchbase.lite.ValueIndex
import com.couchbase.lite.ValueIndexItem


private const val TAG = "PREDICT"
// tensorFlowModel is a fake implementation

object TensorFlowModel {
    fun predictImage(data: ByteArray?) = mapOf&lt;String, Any?&gt;()
}

object ImageClassifierModel : PredictiveModel {
    const val name = "ImageClassifier"

    override fun predict(input: Dictionary): Dictionary? {
        val blob: Blob = input.getBlob("photo") ?: return null

        // this would be the implementation of the ml model you have chosen
        return MutableDictionary(TensorFlowModel.predictImage(blob.content)) <i class="conum" data-value="1"></i><b>(1)</b>
    }
}


@Suppress("unused")
class PredictiveQueryExamples {
    @Throws(CouchbaseLiteException::class)
    fun testPredictiveModel() {
        val database = Database("mydb")

        Database.prediction.registerModel("ImageClassifier", ImageClassifierModel)

        val index: ValueIndex = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")))
        database.createIndex("value-index-image-classifier", index)

        Database.prediction.unregisterModel("ImageClassifier")
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveIndex() {
        val database = Database("mydb")

        val inputMap: MutableMap&lt;String, Any&gt; = mutableMapOf()
        inputMap["numbers"] = Expression.property("photo")
        val input: Expression = Expression.map(inputMap)
        val index: PredictiveIndex = IndexBuilder.predictiveIndex("ImageClassifier", input, null)
        database.createIndex("predictive-index-image-classifier", index)
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveQuery() {
        val database = Database("mydb")

        val prediction: PredictionFunction = Function.prediction(
            ImageClassifierModel.name,
            Expression.map(mutableMapOf("photo" to Expression.property("photo")) as Map&lt;String, Any&gt;?) <i class="conum" data-value="1"></i><b>(1)</b>
        )

        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                .and(prediction.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))
                    )
            )
            .execute()

        Log.d(TAG, "Number of rows: ${rs.allResults().size}")
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/FlowExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import androidx.lifecycle.LiveData
import androidx.lifecycle.asLiveData
import com.couchbase.lite.</strong>
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.map


class FlowExamples(argDb: Database,
                   argRepl: Replicator,
                   argQuery: Query,
                   argDocOwner: String) {

    val replState: LiveData&lt;ReplicatorActivityLevel&gt; = argRepl.replicatorChangesFlow()
        .map { it.status.activityLevel }
        .asLiveData()

    val dbChanges: LiveData&lt;MutableList&lt;String&gt;&gt; = argDb.databaseChangeFlow()
        .map { it.documentIDs }
        .asLiveData()

    val docChanges: LiveData&lt;DocumentChange?&gt; = argDb.documentChangeFlow("1001")
        .map {
            it.takeUnless {
                it.database.getDocument(it.documentID)?.getString("owner").equals(argDocOwner)
            }
        }
        .asLiveData()

    var liveQuery: LiveData&lt;List&lt;Any&gt;?&gt;? = null

    @ExperimentalCoroutinesApi
    fun watchQuery(query: Query): LiveData&lt;List&lt;Any&gt;?&gt; {
        val queryFlow = query.queryChangeFlow()
            .map {
                val err = it.error
                if (err != null) {
                    throw err
                }
                it.results?.allResults()?.flatMap { it.toList() }
            }
            .asLiveData()
        liveQuery = queryFlow
        return queryFlow
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/FlowExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorStatus


private const val TAG = "PENDING"

@Suppress("unused")
class PendingDocsExample(private var replicator: Replicator) {
    //
    //
    private fun onStatusChanged(pendingDocs: Set&lt;String&gt;, status: ReplicatorStatus) {
        // ... sample onStatusChanged function
        //
        Log.i(TAG, "Replicator activity level is ${status.activityLevel}")

        // iterate and report-on previously
        // retrieved pending docids 'list'
        val itr = pendingDocs.iterator()
        while (itr.hasNext()) {
            val docId = itr.next()

            if (!replicator.isDocumentPending(docId)) { <i class="conum" data-value="20"></i><b>(20)</b>
                continue
            }

            Log.i(TAG, "Doc ID $docId has been pushed")
        }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Endpoint
import com.couchbase.lite.KeyStoreUtils
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.net.URI
import java.net.URISyntaxException
import java.security.KeyStore
import java.security.cert.Certificate

private const val TAG = "P2P"


@Suppress("unused")
class IBExamples(private val context: Context, private val caCert: Certificate) {
    private val database: Database
    private var thisReplicator: Replicator? = null
    private var thisListener: URLEndpointListener? = null

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        database = Database("p2p_demo")

        /* do some stuff here <strong>/
    }

    // PASSIVE PEER STUFF
    fun ibListenerSimple() {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database,
                authenticator
                = ListenerPasswordAuthenticator { user, pwd -&gt; (user == "daniel") &amp;&amp; (String(pwd) == "123") })
        ) <i class="conum" data-value="21"></i><b>(21)</b>
        listener.start() <i class="conum" data-value="22"></i><b>(22)</b>
        thisListener = listener

    }

    fun ibReplicatorSimple() {
        val theListenerEndpoint: Endpoint = URLEndpoint(URI("wss://10.0.2.2:4984/db")) <i class="conum" data-value="23"></i><b>(23)</b>
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,
                target = theListenerEndpoint,
                authenticator = BasicAuthenticator("valid.user", "valid.password.string".toCharArray()), <i class="conum" data-value="24"></i><b>(24)</b>
                acceptOnlySelfSignedServerCertificate = true
            )
        )
        repl.start() <i class="conum" data-value="25"></i><b>(25)</b>
        thisReplicator = repl
    }

    fun ibPassListener(validUser: String, validPassword: CharArray) {
        // EXAMPLE 1
        // Initialize the listener
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database, <i class="conum" data-value="26"></i><b>(26)</b>
                port = 55990, <i class="conum" data-value="27"></i><b>(27)</b>
                networkInterface = "10.1.1.10", <i class="conum" data-value="28"></i><b>(28)</b>

                enableDeltaSync = false, <i class="conum" data-value="29"></i><b>(29)</b>

                // Configure server security
                disableTls = false, <i class="conum" data-value="30"></i><b>(30)</b>

                // Use an Anonymous Self-Signed Cert
                identity = null, <i class="conum" data-value="31"></i><b>(31)</b>

                // Configure Client Security using an Authenticator
                // For example, Basic Authentication <i class="conum" data-value="32"></i><b>(32)</b>
                authenticator = ListenerPasswordAuthenticator { username, paassword -&gt;
                    (username === validUser) &amp;&amp; (paassword === validPassword)
                }
            ))

        // Start the listener
        listener.start() <i class="conum" data-value="33"></i><b>(33)</b>
        thisListener = listener

    }

    fun ibListenerGetNetworkInterfaces() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        listener.start()
        Log.i(TAG, "URLS are ${listener.urls}")
        thisListener = listener
    }

    fun ibListenerLocalDb() {
        // . . . preceding application logic . . .
        CouchbaseLite.init(context) <i class="conum" data-value="34"></i><b>(34)</b>
        val thisDB = Database("passivepeerdb")
    }

    fun ibListenerConfigTlsDisable() {
        URLEndpointListenerConfigurationFactory.create(database, disableTls = false) <i class="conum" data-value="35"></i><b>(35)</b>
    }


    // !!! USERS SHOULD BE CAUTIONED THAT THIS IS INSECURE
    // Android has much better ways of importing keys
    fun ibListenerConfigTlsIdFull() {
        // Use CA Cert
        // Import a key pair into secure storage
        // Create a TLSIdentity from the imported key-pair

        this.javaClass.getResourceAsStream("serverkeypair.p12")?.use { <i class="conum" data-value="36"></i><b>(36)</b>
            KeyStoreUtils.importEntry(
                "teststore.p12",  // KeyStore type, eg: "PKCS12"
                it,  // An InputStream from the keystore
                "let me in".toCharArray(),  // The keystore password
                "topSekritKey",  // The alias to be used (in external keystore)
                null,  // The key password or null if the key has none
                "test-alias" // The alias for the imported key
            )
        }


        // Set the TLS Identity
        URLEndpointListenerConfigurationFactory.create(
            database,
            identity = TLSIdentity.getIdentity("test-alias")
        ) <i class="conum" data-value="37"></i><b>(37)</b>

    }

    fun ibListenerConfigClientAuthRoot() {
        // Configure the client authenticator
        // to validate using ROOT CA
        // thisClientID.certs is a list containing a client cert to accept
        // and any other certs needed to complete a chain between the client cert
        // and a CA
        val validId = TLSIdentity.getIdentity("Our Corporate Id")
            ?: throw IllegalStateException("Cannot find corporate id")
        // accept only clients signed by the corp cert
        thisListener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                // get the identity <i class="conum" data-value="38"></i><b>(38)</b>
                database = database,
                identity = validId,
                authenticator = ListenerCertificateAuthenticator(validId.certs)
            )
        ) <i class="conum" data-value="39"></i><b>(39)</b>

    }

    fun ibListenerConfigTlsDisable2() {

        URLEndpointListenerConfigurationFactory.create(database = database, disableTls = true)
    }

    fun ibListenerStatusCheck() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        val connectionCount = listener.status?.connectionCount <i class="conum" data-value="40"></i><b>(40)</b>
        val activeConnectionCount = listener.status?.activeConnectionCount <i class="conum" data-value="41"></i><b>(41)</b>
    }

    fun ibListenerStop() {

        thisListener?.stop()

    }

    // ACTIVE PEER STUFF
// Replication code
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testActPeerSync() {
        // Create replicator
        // Consider holding a reference somewhere
        // to prevent the Replicator from being GCed
        val repl = Replicator( <i class="conum" data-value="42"></i><b>(42)</b>

            // initialize the replicator configuration
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(URI("wss://listener.com:8954")), <i class="conum" data-value="43"></i><b>(43)</b>

                // Set replicator type
                type = ReplicatorType.PUSH_AND_PULL,

                // Configure Sync Mode
                continuous = false, // default value


                // set auto-purge behavior
                // (here we override default)
                enableAutoPurge = false, <i class="conum" data-value="44"></i><b>(44)</b>



                // Configure Server Authentication --
                // only accept self-signed certs
                acceptOnlySelfSignedServerCertificate = true, <i class="conum" data-value="45"></i><b>(45)</b>

                // Configure the credentials the
                // client will provide if prompted
                authenticator = BasicAuthenticator("Our Username", "Our PasswordValue".toCharArray()), <i class="conum" data-value="46"></i><b>(46)</b>


                /</strong> Optionally set custom conflict resolver call back <strong>/
                conflictResolver = null <i class="conum" data-value="47"></i><b>(47)</b>
            )
        )


        // Optionally add a change listener <i class="conum" data-value="48"></i><b>(48)</b>
        val thisListener = repl.addChangeListener { change -&gt;
            val err: CouchbaseLiteException? = change.status.error
            if (err != null) {
                Log.i(TAG, "Error code ::  ${err.code}", err)
            }
        }

        // Start replicator
        repl.start(false) <i class="conum" data-value="49"></i><b>(49)</b>
        thisReplicator = repl

    }

    fun ibReplicatorConfig() {
        // BEGIN additional snippets

        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,

                // Configure Server Security
                // -- only accept CA attested certs
                acceptOnlySelfSignedServerCertificate = false, <i class="conum" data-value="50"></i><b>(50)</b>




                // Use the pinned certificate from the byte array (cert)
                pinnedServerCertificate = caCert.encoded, <i class="conum" data-value="51"></i><b>(51)</b>


                // ... other replicator configuration
                // Provide a client certificate to the server for authentication
                authenticator = ClientCertificateAuthenticator(
                    TLSIdentity.getIdentity("clientId")
                        ?: throw IllegalStateException("Cannot find client id")
                ) <i class="conum" data-value="52"></i><b>(52)</b>

                // ... other replicator configuration

            )
        )

        thisReplicator = repl
    }

    fun ibP2pReplicatorStatus() {
        thisReplicator?.status?.let {
            Log.i(TAG, "The Replicator is currently ${it.activityLevel}")
            Log.i(TAG, "The Replicator has processed ${it.progress}")
            Log.i(
                TAG,
                if (it.activityLevel === ReplicatorActivityLevel.BUSY) {
                    "Replication Processing"
                } else {
                    "It has completed ${it.progress.total} changes"
                }
            )
        }
    }

    fun ibP2pReplicatorStop() {
        // Stop replication.
        thisReplicator?.stop() <i class="conum" data-value="53"></i><b>(53)</b>
    }

    fun ibP2pListener() {
        CouchbaseLite.init(context)
        val thisDB = Database("passivepeerdb") <i class="conum" data-value="54"></i><b>(54)</b>


        // Initialize the listener
        val listener = URLEndpointListener( <i class="conum" data-value="55"></i><b>(55)</b>

            // Initialize the listener config
            URLEndpointListenerConfigurationFactory.create(
                database = thisDB,
                port = 55990, /</strong> &lt;.&gt;  Optional; defaults to auto <strong>/
                disableTls = false, /</strong> &lt;.&gt;  Optional; defaults to false <strong>/
                enableDeltaSync = true,  /</strong> &lt;.&gt; Optional; defaults to false <strong>/

                // Configure the client authenticator (if using basic auth)
                authenticator = ListenerPasswordAuthenticator { username, password -&gt;
                    ("username" === username) &amp;&amp; (password === "password".toCharArray())  <i class="conum" data-value="56"></i><b>(56)</b>
                }
            )
        )

        // Start the listener
        listener.start() <i class="conum" data-value="57"></i><b>(57)</b>



//        Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
//                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
//                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
//        );
        val thisIdentity = TLSIdentity.createIdentity(
            true,
            mapOf(
                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
            ),
            null,
            "test-alias"
        )




        val thisAlias = "alias-to-delete"
        val thisKeyStore = KeyStore.getInstance("AndroidKeyStore")
        thisKeyStore.load(null)
        thisKeyStore.deleteEntry(thisAlias)


        // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label
        val thatIdentity = TLSIdentity.getIdentity("couchbase-docs-cert")
    }

    fun ibRplicatorPull() {
        val database = Database("ian")

        val uri = URI("wss://10.0.2.2:4984/db") <i class="conum" data-value="58"></i><b>(58)</b>

        val repl = Replicator( <i class="conum" data-value="59"></i><b>(59)</b>
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(uri),
                type = ReplicatorType.PULL
            )
        )

        repl.start()
        thisReplicator = repl
    }

// initialize the replicator configuration
    val thisConfig = ReplicatorConfigurationFactory.create(
        database = database,
        target = URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))

/</strong> C A L L O U T S

// Listener Callouts


&lt;.&gt; Initialize the listener instance using the configuration settings.
&lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.



&lt;.&gt; <code>connectionCount</code> -- the total number of connections served by the listener
&lt;.&gt; <code>activeConnectionCount</code> -- the number of active (BUSY) connections currently being served by the listener
//



&lt;.&gt; Configure the pinned certificate using data from the byte array <code>cert</code>

&lt;.&gt; Attempt to get the identity from secure storage
&lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity


&lt;.&gt; A replication is an asynchronous operation.
To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
&lt;.&gt; The URL scheme for remote database URLs uses <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections over wb sockets.
In this example the hostname is <code>10.0.2.2</code> because the Android emulator runs in a VM that is generally accessible on <code>10.0.2.2</code> from the host machine (see <a href="https://developer.android.com/studio/run/emulator-networking">Android Emulator networking</a> documentation).
+
NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
Although <code>wss:</code> protocol URLs are not affected, in order to use the <code>ws:</code> protocol, applications must target API 27 or lower, or must configure application network security as described <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted">here</a>.

<strong>/
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.net.URI
import java.security.KeyStore
import java.security.KeyStoreException
import java.security.NoSuchAlgorithmException
import java.security.cert.Certificate
import java.security.cert.CertificateEncodingException
import java.security.cert.CertificateException
import java.util.concurrent.CountDownLatch

private const val TAG = "LISTEN"

@Suppress("unused")
class KtCertAuthListener {
    companion object {
        private val CERT_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "CBL Test",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>",
        )
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)

        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        remoteDb.save(doc)

        val serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server")

        val clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client")
        val uri = startServer(remoteDb, serverIdentity, clientIdentity.certs)
            ?: throw IOException("Failed to start the server")

        Thread {
            startClient(localDb, uri, clientIdentity, serverIdentity.certs[0])
            Log.e(TAG, "Success!!")
            deleteIdentity("server")
            Log.e(TAG, "Alias deleted: server")
            deleteIdentity("client")
            Log.e(TAG, "Alias deleted: client")
        }.start()
    }

    // start a client replicator
    @Throws(CertificateEncodingException::class, InterruptedException::class)
    fun startClient(db: Database, uri: URI, clientIdentity: TLSIdentity, cert: Certificate) {
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = db,
                target = URLEndpoint(uri),
                type = ReplicatorType.PUSH_AND_PULL,
                continuous = false,
                authenticator = ClientCertificateAuthenticator(clientIdentity),
                pinnedServerCertificate = cert.encoded
            )
        )

        val completionLatch = CountDownLatch(1)

        repl.addChangeListener { change -&gt;
            if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    /<strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     *
     *
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Throws(CouchbaseLiteException::class)
    fun startServer(db: Database, serverId: TLSIdentity, certs: List&lt;Certificate?&gt;): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0, // this is the default
                disableTls = false,
                identity = serverId,
                authenticator = ListenerCertificateAuthenticator(certs)
            )
        )
        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
    /</strong>
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    @Throws(
        KeyStoreException::class,
        CertificateException::class,
        NoSuchAlgorithmException::class,
        IOException::class
    )
    fun deleteIdentity(alias: String?) {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        keyStore.deleteEntry(alias) <i class="conum" data-value="60"></i><b>(60)</b>
    }
    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /<strong>
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     *
     *
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    @Throws(CertificateEncodingException::class)
    private fun configureClientCerts(
        config: ReplicatorConfiguration,
        cert: Certificate,
        clientIdentity: TLSIdentity
    ) {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(ClientCertificateAuthenticator(clientIdentity))

        // Configure the pinned certificate passing a byte array.
        config.pinnedServerCertificate = cert.encoded
    }
    // notend::p2p-tlsid-tlsidentity-with-label[]
    /</strong>
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     *
     *
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    @Throws(IOException::class)
    private fun readCertMaterialFromBundle(
        context: Context,
        resId: Int
    ): ByteArray {
        val out = ByteArrayOutputStream()
        val <code>in</code> = context.resources.openRawResource(resId)
        val buf = ByteArray(1024)
        var n: Int
        while (<code>in</code>.read(buf).also { n = it } &gt;= 0) {
            out.write(buf, 0, n)
        }
        return out.toByteArray()
    }
}

@Suppress("unused")
class KtPasswordAuthListener {
    companion object {
        private const val VALID_USER = "Minnie"
        private val VALID_PASSWORD = "let me in!".toCharArray()
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray())
            ?: throw IOException("Failed to start the server")
        Thread {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb)
                Log.e(TAG, "Success!!")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }.start()
    }

    // start a client replicator
    @Throws(InterruptedException::class)
    fun runClient(
        uri: URI,
        username: String,
        password: CharArray,
        db: Database
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.type = ReplicatorType.PUSH_AND_PULL
        config.isContinuous = false
        config.setAuthenticator(BasicAuthenticator(username, password))
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)

        repl.addChangeListener { change -&gt;
            if (change.status
                    .activityLevel == ReplicatorActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    /</strong>*
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     *
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    fun startServer(db: Database, username: String, password: CharArray): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0,// this is the default
                disableTls = true,
                authenticator = ListenerPasswordAuthenticator { usr, pwd -&gt;
                    (usr == username) &amp;&amp; pwd.contentEquals(password)
                })
        )

        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
}





// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Message
import com.couchbase.lite.MessageEndpoint
import com.couchbase.lite.MessageEndpointConnection
import com.couchbase.lite.MessageEndpointDelegate
import com.couchbase.lite.MessageEndpointListener
import com.couchbase.lite.MessageEndpointListenerConfigurationFactory
import com.couchbase.lite.MessagingCloseCompletion
import com.couchbase.lite.MessagingCompletion
import com.couchbase.lite.ProtocolType
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorConnection
import com.couchbase.lite.create


@Suppress("unused")
class BrowserSessionManager : MessageEndpointDelegate {
    private var replicator: Replicator? = null

    @Throws(CouchbaseLiteException::class)
    fun initCouchbase() {
        val database = Database("mydb")

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        val messageEndpoint = MessageEndpoint("UID:123", "active", ProtocolType.MESSAGE_STREAM, this)

        // Create the replicator object.
        val repl = Replicator(ReplicatorConfigurationFactory.create(database = database, target = messageEndpoint))
        // Start the replication.
        repl.start()
        replicator = repl
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    override fun createConnection(endpoint: MessageEndpoint) = ActivePeerConnection()
}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

@Suppress("unused")
class ActivePeerConnection : MessageEndpointConnection {
    private var replicatorConnection: ReplicatorConnection? = null

    fun disconnect() {
        replicatorConnection?.close(null)
        replicatorConnection = null
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete()
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun send(message: Message, completion: MessagingCompletion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null)
    }

    fun receive(message: Message) {
        replicatorConnection?.receive(message)
    }
}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

@Suppress("unused")
class PassivePeerConnection private constructor() : MessageEndpointConnection {
    private var messageEndpointListener: MessageEndpointListener? = null
    private var replicatorConnection: ReplicatorConnection? = null

    @Throws(CouchbaseLiteException::class)
    fun startListener() {
        val database = Database("mydb")
        messageEndpointListener = MessageEndpointListener(
            MessageEndpointListenerConfigurationFactory.create(database, ProtocolType.MESSAGE_STREAM)
        )
    }

    fun stopListener() {
        messageEndpointListener?.closeAll()
    }

    fun accept() {
        val connection = PassivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        messageEndpointListener?.accept(connection)
    }

    fun disconnect() {
        replicatorConnection?.close(null)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete()
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun send(message: Message, completion: MessagingCompletion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null)
    }

    fun receive(message: Message) {
        replicatorConnection?.receive(message)
    }

}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.</strong>
import com.couchbase.lite.Function
import com.fasterxml.jackson.databind.ObjectMapper
import org.json.JSONException


private const val TAG = "QUERY"
private const val DATABASE_NAME = "database"

data class Hotel(
    var description: String? = null,
    var country: String? = null,
    var city: String? = null,
    var name: String? = null,
    var type: String? = null,
    var id: String? = null
)

@Suppress("unused")
class QueryExamples(private val database: Database) {

    // </mark># Indexing
    @Throws(CouchbaseLiteException::class)
    fun testIndexing() {
        database.createIndex( "TypeNameIndex",
              ValueIndexConfiguration( "type", "name")
    }

    fun testIndexing_Querybuilder() {
        database.createIndex(
            "TypeNameIndex",
            IndexBuilder.valueIndex(
                ValueIndexItem.property("type"),
                ValueIndexItem.property("name")
            )
        )
    }

    // <mark># SELECT statement
    fun testSelectStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("type")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.expression(Meta.id))
            .execute()

        for (result in rs) {
            Log.i(TAG, "hotel id -&gt;${result.getString("id")}")
            Log.i(TAG, "hotel name -&gt; ${result.getString("name")}")
        }
      }

      // META function
      @Throws(CouchbaseLiteException::class)
      fun testMetaFunction() {
        val rs = QueryBuilder
        .select(SelectResult.expression(Meta.id))
        .from(DataSource.database(database))
        .where(Expression.property("type").equalTo(Expression.string("airport")))
        .orderBy(Ordering.expression(Meta.id))
        .execute()

        for (result in rs) {
          Log.w(TAG, "airport id -&gt;${result.getString("id")}")
          Log.w(TAG, "airport id -&gt; ${result.getString(0)}")
        }
      }

      // </mark># all(<strong>)
    @Throws(CouchbaseLiteException::class)
    fun testSelectAll() {
        val queryAll = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))

        val query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="61"></i><b>(61)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        val token = query.addChangeListener { change -&gt;
            change.results?.let {
                for (result in it) {
                    Log.d(TAG, "results: ${result.keys}")
                    /</strong> Update UI <strong>/
                }
            } <i class="conum" data-value="62"></i><b>(62)</b>
        }


        query.removeChangeListener(token)

        for (result in query.execute()) {
            Log.i(TAG, "hotel -&gt; ${result.getDictionary(DATABASE_NAME)?.toMap()}")
        }
    }


    // <mark>#WHERE statement
    @Throws(CouchbaseLiteException::class)
    fun testWhereStatement() {
        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.intValue(10))
            .execute()
        for (result in rs) {
            result.getDictionary(DATABASE_NAME)?.let {
                Log.i(TAG, "name -&gt; ${it.getString("name")}")
                Log.i(TAG, "type -&gt; ${it.getString("type")}")
            }
        }
    }

    fun testQueryDeletedDocuments() {
        // Query documents that have been deleted
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted)
    }

    // </mark><mark>Collection Operators
    @Throws(CouchbaseLiteException::class)
    fun testCollectionStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(
                        ArrayFunction.contains(
                            Expression.property("public_likes"),
                            Expression.string("Armani Langworth")
                        )
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.getArray("public_likes")?.toList()}")
        }
    }

    // IN operator
    @Throws(CouchbaseLiteException::class)
    fun testInOperator() {
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.string("Armani").<code>in</code>(
                    Expression.property("first"),
                    Expression.property("last"),
                    Expression.property("username")
                )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.toMap()}")
        }
    }

    // Pattern Matching
    @Throws(CouchbaseLiteException::class)
    fun testPatternMatching() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // </mark># Wildcard Match
    @Throws(CouchbaseLiteException::class)
    fun testWildcardMatch() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // Wildcard Character Match
    @Throws(CouchbaseLiteException::class)
    fun testWildCharacterMatch() {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng____r"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // <mark># Regex Match
    @Throws(CouchbaseLiteException::class)
    fun testRegexMatch() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .regex(Expression.string("\\beng.*r\\b"))
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // JOIN statement
    @Throws(CouchbaseLiteException::class)
    fun testJoinStatement() {
        val rs = QueryBuilder.select(
            SelectResult.expression(Expression.property("name").from("airline")),
            SelectResult.expression(Expression.property("callsign").from("airline")),
            SelectResult.expression(Expression.property("destinationairport").from("route")),
            SelectResult.expression(Expression.property("stops").from("route")),
            SelectResult.expression(Expression.property("airline").from("route"))
        )
            .from(DataSource.database(database).<code>as</code>("airline"))
            .join(
                Join.join(DataSource.database(database).<code>as</code>("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(
                        Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline"))
                    )
                    .and(
                        Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.toMap()}")
        }
    }


    // </mark># GROUPBY statement
    @Throws(CouchbaseLiteException::class)
    fun testGroupByStatement() {
        val rs = QueryBuilder.select(
            SelectResult.expression(Function.count(Expression.string("</strong>"))),
            SelectResult.property("country"),
            SelectResult.property("tz")
        )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300)))
            )
            .groupBy(
                Expression.property("country"), Expression.property("tz")
            )
            .orderBy(Ordering.expression(Function.count(Expression.string("<strong>"))).descending())
            .execute()

        for (result in rs) {
            result.let {
                Log.i(
                    TAG,
                    "There are ${it.getInt("$1")} airports on the ${
                        it.getString("tz")
                    } timezone located in ${
                        it.getString("country")
                    } and above 300ft"
                )
            }
        }
    }

    // <mark># ORDER BY statement
    @Throws(CouchbaseLiteException::class)
    fun testOrderByStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("name").ascending())
            .limit(Expression.intValue(10))
            .execute()

        for (result in rs) {
            Log.i(TAG, "${result.toMap()}")
        }
    }


    // </mark># EXPLAIN statement
    @Throws(CouchbaseLiteException::class)
    fun testExplainStatement() {
        var query: Query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").descending()) <i class="conum" data-value="63"></i><b>(63)</b>
        Log.i(TAG, query.explain()) <i class="conum" data-value="64"></i><b>(64)</b>

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%"))) <i class="conum" data-value="65"></i><b>(65)</b>
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="66"></i><b>(66)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%")))
            )
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Function.lower(
                    Expression.property("type").equalTo(Expression.string("hotel"))
                )
            ) <i class="conum" data-value="67"></i><b>(67)</b>
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))) <i class="conum" data-value="68"></i><b>(68)</b>
        Log.i(TAG, query.explain())
    }

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex() {
        val config = FullTextIndexConfiguration("overview").ignoreAccents(false)

        database.createIndex( "overviewFTSIndex", config);
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS() {

        val ftsQuery =
              database.createQuery(
                "SELECT _id, overview FROM _ WHERE MATCH(overviewFTSIndex, 'michigan') ORDER BY RANK(overviewFTSIndex)")

        ftsQuery.execute().allResults().forEach {
          Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}")
        }

    }

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex_Querybuilder() {
        database.createIndex(
            "overviewFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("overview")).ignoreAccents(false)
        )
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS_Querybuilder() {

        val ftsQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id),
                                  SelectResult.expression(overview))
                          .from(DataSource.database(database))
                          .where(FullTextFunction.match("overviewFTSIndex", "michigan"))
                          .execute()

        ftsQuery.execute().allResults().forEach {
          Log.i(TAG, "${result.getString("Meta.id")}: ${result.getString("overview")}")
          }



    }


    fun testQuerySyntaxAll(currentUser: String) {
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(openOrCreateDatabaseForUser(currentUser)))

        val hotels: HashMap&lt;String, Hotel&gt; = HashMap()

        for (result in listQuery.execute().allResults()) {
            // get the k-v pairs from the 'hotel' key's value into a dictionary
            val thisDocsProps = result.getDictionary(0) <i class="conum" data-value="69"></i><b>(69)</b>
            val thisDocsId = thisDocsProps!!.getString("id")
            val thisDocsName = thisDocsProps.getString("name")
            val thisDocsType = thisDocsProps.getString("type")
            val thisDocsCity = thisDocsProps.getString("city")

            // Alternatively, access results value dictionary directly
            val id = result.getDictionary(0)?.getString("id").toString() <i class="conum" data-value="70"></i><b>(70)</b>
            hotels[id] = Hotel(
                id,
                result.getDictionary(0)?.getString("type"),
                result.getDictionary(0)?.getString("name"),
                result.getDictionary(0)?.getString("city"),
                result.getDictionary(0)?.getString("country"),
                result.getDictionary(0)?.getString("description")
            )
        }

    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun testQuerySyntaxJson(currentUser: String, argDb: Database) {
        val db = argDb
        // Example assumes Hotel class object defined elsewhere

        // Build the query
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(db))

        // Uses Jackson JSON processor
        val mapper = ObjectMapper()
        val hotels: ArrayList&lt;Hotel&gt; = ArrayList()

        for (result in listQuery.execute()) {

            // Get result as JSON string
            val json = result.toJSON() <i class="conum" data-value="71"></i><b>(71)</b>

            // Get Hashmap from JSON string
            val dictFromJSONstring = mapper.readValue(json, HashMap::class.java) <i class="conum" data-value="72"></i><b>(72)</b>

            // Use created hashmap
            val hotelId = dictFromJSONstring["id"].toString() //
            val hotelType = dictFromJSONstring["type"].toString()
            val hotelname = dictFromJSONstring["name"].toString()


            // Get custom object from JSON string
            val thisHotel = mapper.readValue(json, Hotel::class.java) <i class="conum" data-value="73"></i><b>(73)</b>
            hotels.add(thisHotel)
        }
    }
/</strong> end func testQuerySyntaxJson <strong>/



    fun testQuerySyntaxProps(currentUser: String) {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
            Log.i(TAG, "Hotel name -&gt; ${result.getString("name")}, in ${result.getString("country")}" )
        }
    }

    fun testQuerySyntaxCount(currentUser: String) {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.string("</strong>"))).as("mycount")) <i class="conum" data-value="74"></i><b>(74)</b>
            .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
            Log.i(TAG, "name -&gt; ${result.getInt("mycount").toString()}")
        }
    }


    fun testQuerySyntaxId(currentUser: String) {
        // tag::query-select-meta

        val rs = QueryBuilder
        .select(
          SelectResult.expression(Meta.id).as("hotelId"))
          .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
          Log.i(TAG, "hotel id -&gt;${result.getString("hotelId")}")
        }
        // end::query-select-meta
    }


    fun docsOnlyQuerySyntaxN1QL(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      val db = argDb
      val thisQuery = db.createQuery(
            "SELECT META().id AS id FROM _ WHERE type = \"hotel\"") <i class="conum" data-value="75"></i><b>(75)</b>

      return thisQuery.execute().allResults()

  }

  fun docsOnlyQuerySyntaxN1QLParams(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      val db = argDb
      val thisQuery = db.createQuery(
            "SELECT META().id AS id FROM _ WHERE type = \$type") <i class="conum" data-value="76"></i><b>(76)</b>

      thisQuery.parameters = Parameters().setString("type", "hotel") <i class="conum" data-value="77"></i><b>(77)</b>

      return thisQuery.execute().allResults()

  }

  fun testQuerySyntaxPagination(currentUser: String) {
    val limit = 20
    val offset = 0

    val rs = QueryBuilder
      .select(SelectResult.all())
      .from(DataSource.database(database))
      .where(Expression.property("type").equalTo(Expression.string("hotel")))
      .limit(Expression.intValue(limit), Expression.intValue(offset))

  }

    fun openOrCreateDatabaseForUser(argUser: String): Database = Database(argUser) {

    }



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/JSONExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.*
import org.json.JSONException
import org.json.JSONObject


const val JSON = """[{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\",
        \"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},
        {\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\",
        \"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},
        {\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",
        \"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\",
        \"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]"""


class KtJSONExamples {
    private val TAG = "SNIPPETS"

    fun jsonArrayExample(db: Database) {
        // github tag=tojson-array
        val mArray = MutableArray(JSON) <i class="conum" data-value="78"></i><b>(78)</b>
        for (i in 0 until mArray.count()) {
            mArray.getDictionary(i)?.apply {
                Log.i(TAG, getString("name") ?: "unknown")
                db.save(MutableDocument(getString("id"), toMap()))
            } <i class="conum" data-value="79"></i><b>(79)</b>
        }

        db.getDocument("1002")?.getArray("features")?.apply {
            for (feature in toList()) {
                Log.i(TAG, "$feature")
            } <i class="conum" data-value="80"></i><b>(80)</b>
            Log.i(TAG, toJSON())
        } <i class="conum" data-value="81"></i><b>(81)</b>
    }

    fun jsonBlobExample(db: Database) {
        // github tag=tojson-blob
        val thisBlob = db.getDocument("thisdoc-id")!!.toMap()
        if (!Blob.isBlob(thisBlob)) {
          return
        }
        val blobType = thisBlob["content_type"].toString()
        val blobLength = thisBlob["length"] as Number?
    }

    fun jsonDictionaryExample() {
        // github tag=tojson-dictionary
        val mDict = MutableDictionary(JSON) <i class="conum" data-value="82"></i><b>(82)</b>
        Log.i(TAG, "$mDict")
        Log.i(TAG, "Details for: ${mDict.getString("name")}")
        for (key in mDict.keys) {
          Log.i(TAG, key + " =&gt; " + mDict.getValue(key))
        }
      }

      @Throws(CouchbaseLiteException::class)
      fun jsonDocumentExample(srcDb: Database, dstDb: Database) {
        QueryBuilder
        .select(SelectResult.expression(Meta.id).as("metaId"))
        .from(DataSource.database(srcDb))
        .execute()
        .forEach {
          it.getString("metaId")?.let { thisId -&gt;
            srcDb.getDocument(thisId)?.toJSON()?.let { json -&gt; <i class="conum" data-value="83"></i><b>(83)</b>
              Log.i(TAG, "JSON String = $json")
              val hotelFromJSON = MutableDocument(thisId, json) <i class="conum" data-value="84"></i><b>(84)</b>
              dstDb.save(hotelFromJSON)
              dstDb.getDocument(thisId)?.toMap()?.forEach { e -&gt;
                Log.i(TAG, "$e.key =&gt; $e.value")
              } <i class="conum" data-value="85"></i><b>(85)</b>
            }
          }
        }
    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun jsonQueryExample(query: Query) {
        query.execute().forEach {

            // Use a Json Object to populate Native object
            JSONObject(it.toJSON()).apply {
                val (description, country, city, name, type, id) = Hotel(
                    id = getString("id"),
                    type = getString("type"),
                    name = getString("name"),
                    city = getString("city"),
                    country = "Ghana, West Africa",
                    description = "this hotel"
                )
            }
        }
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/JSONExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.Database
import com.couchbase.lite.MutableDictionary

class KtBlobExamples {

    // Example 2: Using Blobs
    fun example2(context: Context, db: Database) {
        val doc = db.getDocument("1000") ?: return

        // Create a blob from an asset
        val blob = Blob("image/png", context.assets.open("couchbaseimage.png"))

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON()

        // Save the blob as part of a document
        db.save(doc.toMutable().setBlob("avatar", blob))

        // Experts only!!!
        db.saveBlob(blob)

        // Retrieve saved blob and get as JSON again
        val blobAsJSONString = db.getDocument("1000")?.getBlob("avatar")?.toJSON() ?: return

        // reconstitute
        val blobAsMap = MutableDictionary().setJSON(blobAsJSONString).toMap()

        // show the contents of the reconstituted blob
        for key, value) in blobAsMap) {             Log.d("BLOB", "Data: $key -&gt; $value")         }          // verify that the reconstitued thing is still blob         if (Blob.isBlob(blobAsMap {
            Log.d("BLOB", blobAsJSONString)
        }
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt </code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset2_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">

// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/PasswordAuthListener.java 
//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorActivityLevel;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorType;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);                 Log.e(TAG, "Success!!");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void runClient(         @NonNull URI uri,         @NonNull String username,         @NonNull char[] password,         @NonNull Database db) throws InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setType(ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }

    /<strong>
     * Snippet 1: create a ListenerPasswordAuthenticator and configure the listener with it
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     * NOTE: This requires the following, in the manifest
     *     &lt;application
     *         ...
     *         android:usesCleartextTraffic="true"
     *         ...
     *     &gt;
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password)
        throws CouchbaseLiteException {
        final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

        config.setPort(0); // this is the default
        config.setDisableTls(true);
        config.setAuthenticator(new ListenerPasswordAuthenticator(
            (user, pwd) -&gt; username.equals(user) &amp;&amp; Arrays.equals(password, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/PasswordAuthListener.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/BlobExamples.java 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.util.Log;

import java.io.IOException;
import java.util.Map;

import com.couchbase.lite.Blob;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.Document;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;


class BlobExamples {

    // Example 2: Using Blobs
    public void example2(final Context context, final Database db) throws IOException, CouchbaseLiteException {
        final Document doc = db.getDocument("1000");
        if (doc == null) { return; }

        // Create a blob from an asset
        final Blob blob = new Blob("image/png", context.getAssets().open("couchbaseimage.png"));

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON();

        // Save the blob as part of a document
        final MutableDocument mDoc = doc.toMutable();
        mDoc.setBlob("avatar", blob);
        db.save(mDoc);

        // Experts only!!!
        db.saveBlob(blob);

        // Retrieve saved blob
        final Document sameDoc = db.getDocument("1000");
        if (sameDoc == null) { return; }

        final Blob sameBlob = sameDoc.getBlob("avatar");
        if (sameBlob == null) { return; }

        // Get as JSON again
        final String blobAsJSONString = sameBlob.toJSON();

        // reconstitute
        final Map&lt;String, Object&gt; blobAsMap = new MutableDictionary().setJSON(blobAsJSONString).toMap();

        // show the contents of the reconstituted blob
        for (Map.Entry&lt;String, Object&gt; entry: blobAsMap.entrySet()) {
            Log.d("BLOB", "Data: " + entry.getKey() + " -&gt; " + entry.getValue());
        }

        // verify that the reconstitued thing is still blob
        if (Blob.isBlob(blobAsMap)) { Log.d("BLOB", blobAsJSONString); }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/BlobExamples.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/MainActivity.java 
package com.couchbase.code_snippets;

import android.os.Bundle;

import androidx.appcompat.app.AppCompatActivity;


public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/MainActivity.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/CertAuthListener.java 

//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorActivityLevel;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorType;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);                 Log.e(TAG, "Success!!");                 deleteIdentity("server");                 Log.e(TAG, "Alias deleted: server");                 deleteIdentity("client");                 Log.e(TAG, "Alias deleted: client");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void startClient(         @NonNull URI uri,         @NonNull Certificate cert,         @NonNull TLSIdentity clientIdentity,         @NonNull Database db) throws CertificateEncodingException, InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setType(ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }

    /</strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
        throws CouchbaseLiteException {
        final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

        config.setPort(0); // this is the default
        config.setDisableTls(false);
        config.setTlsIdentity(serverId);
        config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
    }

    /<strong>
     * Snippet 3: delete an identity from the keystore
     * (NOTE: a keystore doesn't contain TLSIdentities: I'm guessing that this is what you intend)
     * &lt;p&gt;
     * Delete an identity from the key store.
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
        throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

        final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);

        keyStore.deleteEntry(alias);
    }

    /</strong>
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     * &lt;p&gt;
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    private void configureClientCerts(
        ReplicatorConfiguration config,
        @NonNull Certificate cert,
        @NonNull TLSIdentity clientIdentity)
        throws CertificateEncodingException {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
    }

    /<strong>
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     * &lt;p&gt;
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte[] buf = new byte[1024];
        int n;
        while n = in.read(buf &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/CertAuthListener.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java 
//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import androidx.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;
import com.example.docsnippet.Datastore;
import com.example.docsnippet.Hotel;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class docOnly_Examples {
  private static final String TAG = "EXAMPLE";

  private static final String DATABASE_NAME = "database";

  private final Context context;
  private Database database;
  private Replicator replicator;

  public docOnly_Examples(Context context) { this.context = context; }

  //@Test
  public void testGettingStarted() throws CouchbaseLiteException, URISyntaxException {

    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);

    // Get the database (and create it if it doesnt exist).
    DatabaseConfiguration config = new DatabaseConfiguration();

    config.setDirectory(context.getFilesDir().getAbsolutePath());

    Database database = new Database("getting-started", config);


    // Create a new document (i.e. a record) in the database.
    MutableDocument mutableDoc = new MutableDocument()
    .setFloat("version", 2.0F)
    .setString("type", "SDK");

    // Save it to the database.
    database.save(mutableDoc);

    // Update a document.
    mutableDoc = database.getDocument(mutableDoc.getId()).toMutable();
    mutableDoc.setString("language", "Java");
    database.save(mutableDoc);
    Document document = database.getDocument(mutableDoc.getId());
    // Log the document ID (generated by the database) and properties
    Log.i(TAG, "Document ID :: " + document.getId());
    Log.i(TAG, "Learning " + document.getString("language"));

    // Create a query to fetch documents of type SDK.
    Query query = QueryBuilder.select(SelectResult.all())
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("SDK")));
    ResultSet result = query.execute();
    Log.i(TAG, "Number of rows ::  " + result.allResults().size());

    // Create replicators to push and pull changes to and from the cloud.
    Endpoint targetEndpoint = new URLEndpoint(new URI("ws://localhost:4984/getting-started-db"));
    ReplicatorConfiguration replConfig = new ReplicatorConfiguration(database, targetEndpoint);
    replConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Add authentication.
    replConfig.setAuthenticator(new BasicAuthenticator("sync-gateway", "password"));

    // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
    Replicator replicator = new Replicator(replConfig);

    // Listen to replicator change events.
    replicator.addChangeListener(change -&gt; {
      if (change.getStatus().getError() != null) {
        Log.i(TAG, "Error code ::  " + change.getStatus().getError().getCode());
      }
    });

    // Start replication.
    replicator.start();


    database.delete();
  }

  public void test1xAttachments() throws CouchbaseLiteException, IOException {
    // if db exist, delete it
    deleteDB("android-sqlite", context.getFilesDir());

    ZipUtils.unzip(getAsset("replacedb/android140-sqlite.cblite2.zip"), context.getFilesDir());

    Database db = new Database("android-sqlite", new DatabaseConfiguration());
    try {

      Document doc = db.getDocument("doc1");

      // For Validation
      Dictionary attachments = doc.getDictionary("_attachments");
      Blob blob = attachments.getBlob("attach1");
      byte[] content = blob.getContent();
      // For Validation

      byte[] attach = String.format(Locale.ENGLISH, "attach1").getBytes();
      Arrays.equals(attach, content);

    } finally {
      // close db
      db.close();
      // if db exist, delete it
      deleteDB("android-sqlite", context.getFilesDir());
    }

    Document document = new MutableDocument();

    Dictionary attachments = document.getDictionary("_attachments");
    Blob blob = attachments != null ? attachments.getBlob("avatar") : null;
    byte[] content = blob != null ? blob.getContent() : null;
  }

  // <mark># Initializer
  public void testInitializer() {
    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);
  }

  // </mark># New Database
  public void testNewDatabase() throws CouchbaseLiteException {
    final DatabaseConfiguration config = new DatabaseConfiguration();
    config.setDirectory(context.getFilesDir().getAbsolutePath()); <i class="conum" data-value="1"></i><b>(1)</b>

    Database database = new Database("my-database", config);

    database.close();


    database.delete();
  }

  // <mark># Database Encryption
  public void testDatabaseEncryption() throws CouchbaseLiteException {
    DatabaseConfiguration config = new DatabaseConfiguration();
    config.setEncryptionKey(new EncryptionKey("PASSWORD"));
    Database database = new Database("mydb", config);
  }

  // </mark># Logging
  public void testLogging() {
    Database.setLogLevel(LogDomain.DATABASE, LogLevel.VERBOSE);
    Database.setLogLevel(LogDomain.QUERY, LogLevel.VERBOSE);
    }

    public void testEnableCustomLogging() {
        Database.log.setCustom(new LogTestLogger(LogLevel.WARNING)); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    // <mark># Console logging
    public void testConsoleLogging() throws CouchbaseLiteException {
          Database.log.getConsole().setDomain(LogDomain.ALL_DOMAINS);  <i class="conum" data-value="3"></i><b>(3)</b>
          Database.log.getConsole().setLevel(LogLevel.VERBOSE); <i class="conum" data-value="4"></i><b>(4)</b>
          Database.log.getConsole().setDomain(LogDomain.DATABASE);

    }

    // </mark># File logging
    public void testFileLogging() throws CouchbaseLiteException {
        final File path = context.getCacheDir();

        LogFileConfiguration LogCfg =
          new LogFileConfiguration(path.toString()); <i class="conum" data-value="5"></i><b>(5)</b>
        LogCfg.setMaxSize(10240); <i class="conum" data-value="6"></i><b>(6)</b>
        LogCfg.setMaxRotateCount(5); <i class="conum" data-value="7"></i><b>(7)</b>
        LogCfg.setUsePlainText(false); <i class="conum" data-value="8"></i><b>(8)</b>
        Database.log.getFile().setConfig(LogCfg);
        Database.log.getFile().setLevel(LogLevel.INFO); <i class="conum" data-value="9"></i><b>(9)</b>
    }

    public void writeConsoleLog()
    {
        Database.log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }
    public void writeCustomLog()
    {
        Database.log.Custom?.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }


    public void writeFileLog()
    {
        Database.log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }




    // <mark># Loading a pre-built database
    public void testPreBuiltDatabase() throws IOException {
      // Note: Getting the path to a database is platform-specific.
      // For Android you need to extract it from your
      // assets to a temporary directory and then pass that path to Database.copy()
      DatabaseConfiguration configuration = new DatabaseConfiguration();
      if (!Database.exists("travel-sample", context.getFilesDir())) {
            ZipUtils.unzip(getAsset("travel-sample.cblite2.zip"), context.getFilesDir());
            File path = new File(context.getFilesDir(), "travel-sample");
            try {
                Database.copy(path, "travel-sample", configuration);
            } catch (CouchbaseLiteException e) {
                e.printStackTrace();
            }
        }
    }

    // helper methods

    // if db exist, delete it
    private void deleteDB(String name, File dir) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            // sometimes, db is still in used, wait for a while. Maximum 3 sec
            for (int i = 0; i &lt; 10; i) {
                try {
                    Database.delete(name, dir);
                    break;
                } catch (CouchbaseLiteException ex) {
                    try { Thread.sleep(300); }
                    catch (InterruptedException ignore) { }
                }
            }
        }
    }

    // ### Initializers
    public void testInitializers() {
        MutableDocument newTask = new MutableDocument();
        newTask.setString("type", "task");
        newTask.setString("owner", "todo");
        newTask.setDate("createdAt", new Date());
        try {
            database.save(newTask);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // ### Mutability
    public void testMutability() {
        try { database.save(new MutableDocument("xyz")); }
        catch (CouchbaseLiteException ignore) { }

        Document document = database.getDocument("xyz");
        MutableDocument mutableDocument = document.toMutable();
        mutableDocument.setString("name", "apples");
        try {
            database.save(mutableDocument);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // ### Typed Accessors
    public void testTypedAccessors() {
        MutableDocument newTask = new MutableDocument();

        newTask.setValue("createdAt", new Date());
        Date date = newTask.getDate("createdAt");
    }

    // ### Batch operations
    public void testBatchOperations() {
        try {
            database.inBatch(() -&gt; {
                for (int i = 0; i &lt; 10; i) {
                    MutableDocument doc = new MutableDocument();
                    doc.setValue("type", "user");
                    doc.setValue("name", "user " + i);
                    doc.setBoolean("admin", false);
                    try {
                        database.save(doc);
                    } catch (CouchbaseLiteException e) {
                        Log.e(TAG, e.toString());
                    }
                    Log.i(TAG, String.format("saved user document %s", doc.getString("name")));
                }
            });
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // </mark># Document Expiration
    public void DocumentExpiration() throws CouchbaseLiteException {
        // Purge the document one day from now
        Instant ttl = Instant.now().plus(1, ChronoUnit.DAYS);
        database.setDocumentExpiration("doc123", new Date(ttl.toEpochMilli()));

        // Reset expiration
        database.setDocumentExpiration("doc1", null);

        // Query documents that will be expired in less than five minutes
        Instant fiveMinutesFromNow = Instant.now().plus(5, ChronoUnit.MINUTES);
        Query query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.expiration.lessThan(Expression.doubleValue(fiveMinutesFromNow.toEpochMilli())));
    }

    public void testDocumentChangeListener() throws CouchbaseLiteException {
        database.addDocumentChangeListener(
            "user.john",
            change -&gt; {
                Document doc = database.getDocument(change.getDocumentID());
                if (doc != null) {
                    Toast.makeText(context, "Status: " + doc.getString("verified_account"), Toast.LENGTH_SHORT).show();
                }
            });
    }

    // <mark># Blobs
    public void testBlobs() {
        MutableDocument newTask = new MutableDocument();

        InputStream is = getAsset("avatar.jpg"); <i class="conum" data-value="10"></i><b>(10)</b>
        if (is == null) { return; }
        try {
            Blob blob = new Blob("image/jpeg", is); <i class="conum" data-value="11"></i><b>(11)</b>
            newTask.setBlob("avatar", blob); <i class="conum" data-value="12"></i><b>(12)</b>
            database.save(newTask);

            Blob taskBlob = newTask.getBlob("avatar");
            byte[] bytes = taskBlob.getContent();
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        } finally {
            try { is.close(); }
            catch (IOException ignore) { }
        }
    }

    // </mark># Indexing
    public void testIndexing() throws CouchbaseLiteException {
        // For Documentation
        {

            database.createIndex(ValueIndexConfiguration(["type", "name"]), "TypeNameIndex");

        }
    }

    public void testIndexing_Querybuilder() throws CouchbaseLiteException {
        // For Documentation
        {
            database.createIndex(
                "TypeNameIndex",
                IndexBuilder.valueIndex(
                    ValueIndexItem.property("type"),
                    ValueIndexItem.property("name")));
        }
    }

    // <mark># SELECT statement
    public void testSelectStatement() {
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("type"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.expression(Meta.id));

            try {
                ResultSet rs = query.execute();
                for (Result result : rs) {
                    Log.i("Sample", String.format("hotel id -&gt; %s", result.getString("id")));
                    Log.i("Sample", String.format("hotel name -&gt; %s", result.getString("name")));
                }
            } catch (CouchbaseLiteException e) {
                Log.e("Sample", e.getLocalizedMessage());
            }
          }
        }

        // META function
        public void testMetaFunction() throws CouchbaseLiteException {
          // For Documentation
          {
          Query query = QueryBuilder
          .select(SelectResult.expression(Meta.id))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("airport")))
          .orderBy(Ordering.expression(Meta.id));
          ResultSet rs = query.execute();
          for (Result result : rs) {
            Log.w("Sample", String.format("airport id -&gt; %s", result.getString("id")));
            Log.w("Sample", String.format("airport id -&gt; %s", result.getString(0)));
          }
        }
    }

    // </mark># all(</strong>)
    public void testSelectAll() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")));

            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database)); <i class="conum" data-value="13"></i><b>(13)</b>

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            ListenerToken token = query.addChangeListener(change -&gt; { <i class="conum" data-value="14"></i><b>(14)</b>
                for (Result result : change.getResults()) {
                    Log.d(TAG, "results: " + result.getKeys());
                    /* Update UI <strong>/
                }
            });


            query.removeChangeListener(token); <i class="conum" data-value="15"></i><b>(15)</b>


            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("hotel -&gt; %s", result.getDictionary(DATABASE_NAME).toMap()));
            }
        }
    }

    // <mark>#WHERE statement
    public void testWhereStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .limit(Expression.intValue(10));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Dictionary all = result.getDictionary(DATABASE_NAME);
                Log.i("Sample", String.format("name -&gt; %s", all.getString("name")));
                Log.i("Sample", String.format("type -&gt; %s", all.getString("type")));
            }
        }
    }

    public void testQueryDeletedDocuments() {
        // Query documents that have been deleted
        Where query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted);
    }


    // </mark><mark>Collection Operators
    public void testCollectionStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("public_likes"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction
                        .contains(Expression.property("public_likes"), Expression.string("Armani Langworth"))));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("public_likes -&gt; %s", result.getArray("public_likes").toList()));
            }
        }
    }

    // IN operator
    public void testInOperator() throws CouchbaseLiteException {
        // For Documentation
        {
            Expression[] values = new Expression[] {
                Expression.property("first"),
                Expression.property("last"),
                Expression.property("username")
            };

            Query query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.string("Armani").in(values));

            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // Pattern Matching
    public void testPatternMatching() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Function.Expression.string("royal engineers museum")))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // </mark># Wildcard Match
    public void testWildcardMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng%e%"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // Wildcard Character Match
    public void testWildCharacterMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng____r"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // <mark># Regex Match
    public void testRegexMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).regex(Expression.string("\\beng.*r\\b"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // JOIN statement
    public void testJoinStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder.select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route")))
                .from(DataSource.database(database).as("airline"))
                .join(Join.join(DataSource.database(database).as("route"))
                    .on(Meta.id.from("airline").equalTo(Expression.property("airlineid").from("route"))))
                .where(Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline").equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route").equalTo(Expression.string("RIX"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // </mark># GROUPBY statement
    public void testGroupByStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder.select(
                SelectResult.expression(Function.count(Expression.string("</strong>"))),
                SelectResult.property("country"),
                SelectResult.property("tz"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300))))
                .groupBy(
                    Expression.property("country"),
                    Expression.property("tz"))
                .orderBy(Ordering.expression(Function.count(Expression.string("<strong>"))).descending());
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format(
                        "There are %d airports on the %s timezone located in %s and above 300ft",
                        result.getInt("$1"),
                        result.getString("tz"),
                        result.getString("country")));
            }
        }
    }

    // <mark># ORDER BY statement
    public void testOrderByStatement() throws CouchbaseLiteException {
      // For Documentation
      {
        Query query = QueryBuilder
        .select(
          SelectResult.expression(Meta.id),
          SelectResult.property("name"))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("hotel")))
          .orderBy(Ordering.property("name").ascending())
          .limit(Expression.intValue(10));
          ResultSet rs = query.execute();
          for (Result result : rs) { Log.i("Sample", String.format("%s", result.toMap())); }
        }
      }
      // </mark># EXPLAIN statement
      public void testExplainStatement() throws CouchbaseLiteException {
          // For Documentation
          {
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("university")))
                .groupBy(Expression.property("country"))
                .orderBy(Ordering.property("name").descending()); <i class="conum" data-value="16"></i><b>(16)</b>
              Log.i(query.explain()); <i class="conum" data-value="17"></i><b>(17)</b>
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("%hotel%"))); <i class="conum" data-value="18"></i><b>(18)</b>
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="19"></i><b>(19)</b>
                  .and(Expression.property("name").like(Expression.string("%royal%"))));
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))); <i class="conum" data-value="20"></i><b>(20)</b>
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="21"></i><b>(21)</b>
              Log.i(query.explain());
          }
      }
      // end query-explain

    void prepareIndex() throws CouchbaseLiteException {

        FullTextIndexConfiguration config = new FullTextIndexConfiguration("Overview").ignoreAccents(false)

        database.createIndex( config, "overviewFTSIndex")

    }

    void prepareIndex_Querybuilder() throws CouchbaseLiteException {
      database.createIndex(
          "overviewFTSIndex",
          IndexBuilder.fullTextIndex(FullTextIndexItem.property("overview")).ignoreAccents(false));
  }

    public void testFTS() throws CouchbaseLiteException {

        Query ftsQuery =
                database.createQuery(
                "SELECT _id, overview FROM _ WHERE MATCH(overviewFTSIndex, 'michigan') ORDER BY RANK(overviewFTSIndex)");

        for (result in ftsQuery.execute().allResults()) {
          Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}");
        }

    }
    public void testFTS_Querybuilder() throws CouchbaseLiteException {
        Expression whereClause = FullTextFunction.match("overviewFTSIndex", "'michigan'");
        Query ftsQuery =
                QueryBuilder.select(SelectResult.expression(Meta.id),
                                    SelectResult.expression(overview)
                                  )
            .from(DataSource.database(database))
            .where(whereClause);

            for (result in ftsQuery.execute().allResults()) {
              Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}");
            }

    }

    /</strong> The <code>tag::replication[]</code> example is inlined in java.adoc <strong>/

    public void testTroubleshooting() {
        Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE);
    }

    public void testReplicationBasicAuthentication() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new BasicAuthenticator("username", "password"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationSessionAuthentication() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationStatus() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        replicator.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == Replicator.ActivityLevel.STOPPED) {
                Log.i(TAG, "Replication stopped");
            }
          });
        }

    //  BEGIN PendingDocuments BM -- 19/Feb/21 --
    import android.support.annotation.NonNull;
    import android.util.Log;

    import java.net.URI;
    import java.net.URISyntaxException;
    import java.util.Iterator;
    import java.util.Set;

    import com.couchbase.lite.CouchbaseLiteException;
    import com.couchbase.lite.Database;
    import com.couchbase.lite.Endpoint;
    import com.couchbase.lite.Replicator;
    import com.couchbase.lite.ReplicatorConfiguration;
    import com.couchbase.lite.URLEndpoint;

    class PendingDocsExample {
        private static final String TAG = "SCRATCH";

        private Database database;
        private Replicator replicator;

        //  BEGIN PendingDocuments IB -- 11/Feb/21 --
        public void testReplicationPendingDocs() throws URISyntaxException, CouchbaseLiteException {
            // nottag::replication-pendingdocuments[]
            // ... include other code as required
            //
            final Endpoint endpoint =
              new URLEndpoint(new URI("ws://localhost:4984/db"));

            final ReplicatorConfiguration config =
              new ReplicatorConfiguration(database, endpoint)
            .setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

            replicator = new Replicator(config);
            final Set&lt;String&gt; pendingDocs =
              replicator.getPendingDocumentIds(); <i class="conum" data-value="22"></i><b>(22)</b>


            replicator.addChangeListener(change -&gt; {
              onStatusChanged(pendingDocs, change.getStatus()); });

            replicator.start();

            // ... include other code as required
            // notend::replication-pendingdocuments[]
          }
        //
        //
        private void onStatusChanged(
          @NonNull final Set&lt;String&gt; pendingDocs,
          @NonNull final Replicator.Status status) {
          // ... sample onStatusChanged function
          //
          Log.i(TAG,
            "Replicator activity level is " + status.getActivityLevel().toString());

          // iterate and report-on previously
          // retrieved pending docids 'list'
          for (Iterator&lt;String&gt; itr = pendingDocs.iterator(); itr.hasNext(); ) {
            final String docId = itr.next();
            try {
              if (!replicator.isDocumentPending(docId)) { continue; } <i class="conum" data-value="23"></i><b>(23)</b>

              itr.remove();
              Log.i(TAG, "Doc ID " + docId + " has been pushed");
            }
            catch (CouchbaseLiteException e) {
              Log.w(TAG, "isDocumentPending failed", e); }
          }
        }
        //  END PendingDocuments BM -- 19/Feb/21 --
    }


    public void testHandlingNetworkErrors() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        replicator.addChangeListener(change -&gt; {
            CouchbaseLiteException error = change.getStatus().getError();
            if (error != null) { Log.w(TAG, "Error code:: %d", error); }
        });
        replicator.start();

        replicator.stop();
    }

    public void testReplicatorDocumentEvent() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        ListenerToken token = replicator.addDocumentReplicationListener(replication -&gt; {

            Log.i(TAG, "Replication type: " + replication.isPush( ? "Push" : "Pull"));
            for (ReplicatedDocument document : replication.getDocuments()) {
                Log.i(TAG, "Doc ID: " + document.getID());

                CouchbaseLiteException err = document.getError();
                if (err != null) {
                    // There was an error
                    Log.e(TAG, "Error replicating document: ", err);
                    return;
                }

                if (document.flags().contains(DocumentFlag.DocumentFlagsDeleted)) {
                    Log.i(TAG, "Successfully replicated a deleted document");
                }
            }
        });

        replicator.start();

        replicator.removeChangeListener(token);
    }

    public void testReplicationCustomHeader() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();
        headers.put("CustomHeaderName", "Value");
        config.setHeaders(headers);
    }

    // <mark># Certificate Pinning

    public void testCertificatePinning() throws URISyntaxException, IOException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);

        InputStream is = getAsset("cert.cer");
        byte[] cert = IOUtils.toByteArray(is);
        if (is != null) {
            try { is.close(); }
            catch (IOException ignore) {}
        }

        config.setPinnedServerCertificate(cert);
    }

    // </mark># Reset replicator checkpoint
    public void testReplicationResetCheckpoint() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        if (resetCheckpointRequired_Example) {
          replicator.start(true); <i class="conum" data-value="24"></i><b>(24)</b>
        else
          replicator.start(false);
        }

        // ... at some later time

        replicator.stop();
    }

    public void testReplicationPushFilter() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPushFilterdocument, flags) -&gt; flags.contains(DocumentFlag.DocumentFlagsDeleted; <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationPullFilter() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPullFilterdocument, flags) -&gt; "draft".equals(document.getString("type"); <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testCustomRetryConfig() throws URISyntaxException {
    URLEndpoint target =
    new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

    ReplicatorConfiguration config =
    new ReplicatorConfiguration(database, target);

    //  other config as required . . .
    config.setHeartbeat(150L); <i class="conum" data-value="25"></i><b>(25)</b>
    config.setMaxattempts(20L); <i class="conum" data-value="26"></i><b>(26)</b>
    config.setMaxAttemptWaitTime(600L); <i class="conum" data-value="27"></i><b>(27)</b>

    Replicator repl = new Replicator(config);

    }


    public void docsSetAutoPurge() throws CouchbaseliteException {

      DatabaseConfiguration config = new DatabaseConfiguration();
      Database database1 = new Database("mydb", config);

      ReplicatorConfiguration repcfg =
      new ReplicatorConfiguration(database, target);

      repcfg.setAutoPurgeEnabled(true); <i class="conum" data-value="28"></i><b>(28)</b>

    }


    public void testDatabaseReplica() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database1 = new Database("mydb", config);

        config = new DatabaseConfiguration();
        Database database2 = new Database("db2", config);

        /</strong> EE feature: code below might throw a compilation error
           if it's compiled against CBL Android Community. <strong>/
        DatabaseEndpoint targetDatabase = new DatabaseEndpoint(database2);
        ReplicatorConfiguration replicatorConfig = new ReplicatorConfiguration(database1, targetDatabase);
        replicatorConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(replicatorConfig);
        replicator.start();
    }

    public void testPredictiveModel() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Database.prediction.registerModel("ImageClassifier", new ImageClassifierModel());

        ValueIndex index = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")));
        database.createIndex("value-index-image-classifier", index);

        Database.prediction.unregisterModel("ImageClassifier");
    }

    public void testPredictiveIndex() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Map&lt;String, Object&gt; inputMap = new HashMap&lt;&gt;();
        inputMap.put("numbers", Expression.property("photo"));
        Expression input = Expression.map(inputMap);

        PredictiveIndex index = IndexBuilder.predictiveIndex("ImageClassifier", input, null);
        database.createIndex("predictive-index-image-classifier", index);
    }

    public void testPredictiveQuery() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Map&lt;String, Object&gt; inputProperties = new HashMap&lt;&gt;();
        inputProperties.put("photo", Expression.property("photo"));
        Expression input = Expression.map(inputProperties);
        PredictionFunction prediction = PredictiveModel.predict("ImageClassifier", input); <i class="conum" data-value="1"></i><b>(1)</b>

        Query query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("label").equalTo(Expression.string("car"))
                .and(Expression.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))));

        // Run the query.
        ResultSet result = query.execute();
        Log.d(TAG, "Number of rows: " + result.allResults().size());
    }

    public void testReplicationWithCustomConflictResolver() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setConflictResolver(new LocalWinConflictResolver());

        Replicator replication = new Replicator(config);
        replication.start();
    }

    public void testSaveWithCustomConflictResolver() throws CouchbaseLiteException {
        Document doc = database.getDocument("xyz");
        if (doc == null) { return; }
        MutableDocument mutableDocument = doc.toMutable();
        mutableDocument.setString("name", "apples");

        database.save(
            mutableDocument,
            (newDoc, curDoc) -&gt; { <i class="conum" data-value="29"></i><b>(29)</b>
                if (curDoc == null) { return false; } <i class="conum" data-value="30"></i><b>(30)</b>
                Map&lt;String, Object&gt; dataMap = curDoc.toMap();
                dataMap.putAll(newDoc.toMap()); <i class="conum" data-value="31"></i><b>(31)</b>
                newDoc.setData(dataMap);
                return true; <i class="conum" data-value="32"></i><b>(32)</b>
            }); <i class="conum" data-value="33"></i><b>(33)</b>
      }
    }


&lt;.&gt; The conflict handler code is provided as a lambda.

&lt;.&gt; If the handler cannot resolve a conflict, it can return false.
In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.

&lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.

&lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).

&lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method

// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
class LocalWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getLocalDocument();
    }
}

// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
class RemoteWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getRemoteDocument();
    }
}

// Using replConfig.setConflictResolver(new MergeConflictResolver());
class MergeConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        Map&lt;String, Object&gt; merge = conflict.getLocalDocument().toMap();
        merge.putAll(conflict.getRemoteDocument().toMap());
        return new MutableDocument(conflict.getDocumentId(), merge);
    }
}


/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

class BrowserSessionManager implements MessageEndpointDelegate {
    private final Context context;
    private Replicator replicator;

    private BrowserSessionManager(Context context) { this.context = context; }

    public void initCouchbase() throws CouchbaseLiteException {
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration(context);
        Database database = new Database("mydb", databaseConfiguration);

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        MessageEndpoint messageEndpointTarget = new MessageEndpoint(
            "UID:123",
            "active",
            ProtocolType.MESSAGE_STREAM,
            this);

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, messageEndpointTarget);

        // Create the replicator object.
        replicator = new Replicator(config);
        // Start the replication.
        replicator.start();
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    @NonNull
    @Override
    public MessageEndpointConnection createConnection(@NonNull MessageEndpoint endpoint) {
        return new ActivePeerConnection(); /</strong> implements MessageEndpointConnection <strong>/
    }
}

class ActivePeerConnection implements MessageEndpointConnection {

    private ReplicatorConnection replicatorConnection;

    public void disconnect() {
        replicatorConnection.close(null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }

    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete();
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null);
    }

    public void receive(Message message) {
        replicatorConnection.receive(message);
    }

}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

class PassivePeerConnection implements MessageEndpointConnection {
    private final Context context;

    private MessageEndpointListener messageEndpointListener;
    private ReplicatorConnection replicatorConnection;

    private PassivePeerConnection(Context context) { this.context = context; }

    public void startListener() throws CouchbaseLiteException {
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration();
        Database database = new Database("mydb", databaseConfiguration);
        MessageEndpointListenerConfiguration listenerConfiguration = new MessageEndpointListenerConfiguration(
            database,
            ProtocolType.MESSAGE_STREAM);
        this.messageEndpointListener = new MessageEndpointListener(listenerConfiguration);
    }

    public void stopListener() {
        messageEndpointListener.closeAll();
    }

    public void accept() {
        PassivePeerConnection connection = new PassivePeerConnection(context); /</strong> implements
        MessageEndpointConnection <strong>/
        messageEndpointListener.accept(connection);
    }

    public void disconnect() {
        replicatorConnection.close(null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete();
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null);
    }

    public void receive(Message message) {
        replicatorConnection.receive(message);
    }
}

// tensorFlowModel is a fake implementation
// this would be the implementation of the ml model you have chosen
class ImageClassifierModel implements PredictiveModel {
    @Override
    public Dictionary predict(@NonNull Dictionary input) {
        Blob blob = input.getBlob("photo");
        if (blob == null) { return null; }

        // tensorFlowModel is a fake implementation
        // this would be the implementation of the ml model you have chosen
        return new MutableDictionary(TensorFlowModel.predictImage(blob.getContent())); <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

class TensorFlowModel {
    public static Map&lt;String, Object&gt; predictImage(byte[] data) {
        return null;
    }
}

class LogTestLogger implements Logger {
    @NonNull
    private final LogLevel level;

    public LogTestLogger(@NonNull LogLevel level) { this.level = level; }

    @NonNull
    @Override
    public LogLevel getLevel() { return level; }

    @Override
    public void log(@NonNull LogLevel level, @NonNull LogDomain domain, @NonNull String message) {
    }
}





//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);                 Log.e(TAG, "Success!!");                 deleteIdentity("server");                 Log.e(TAG, "Alias deleted: server");                 deleteIdentity("client");                 Log.e(TAG, "Alias deleted: client");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void startClient(         @NonNull URI uri,         @NonNull Certificate cert,         @NonNull TLSIdentity clientIdentity,         @NonNull Database db) throws CertificateEncodingException, InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    /</strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(false);
      config.setTlsIdentity(serverId);
      config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

      final URLEndpointListener listener = new URLEndpointListener(config);
      listener.start();

      final List&lt;URI&gt; urls = listener.getUrls();
      if (urls.isEmpty()) { return null; }
      return urls.get(0);
    }

    /<strong>
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
    throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

      final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
      keyStore.load(null);

      keyStore.deleteEntry(alias); <i class="conum" data-value="34"></i><b>(34)</b>
    }

    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /</strong> Configure Client (active) side certificates
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     <strong>/
    private void configureClientCerts(
      ReplicatorConfiguration config,
      @NonNull Certificate cert,
      @NonNull TLSIdentity clientIdentity)
      throws CertificateEncodingException {

        // Create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
      }
      // notend::p2p-tlsid-tlsidentity-with-label[]

    /</strong>
     * Copy a cert from a resource bundle
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte buf[] = new byte[1024];
        int n;
        while n = in.read(buf &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}



//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);                 Log.e(TAG, "Success!!");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void runClient(         @NonNull URI uri,         @NonNull String username,         @NonNull char[] password,         @NonNull Database db) throws InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    /</strong>*
     *
     * Start a listener for db that accepts connections using exactly the passed username and password

     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password) <i class="conum" data-value="35"></i><b>(35)</b>
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(true);
      config.setAuthenticator(new ListenerPasswordAuthenticator(
        (validUser, pwd) -&gt; username.equals(validUser) &amp;&amp; Arrays.equals(validPassword, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
      }
    }






// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.support.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;

public class docOnly_ReplicationExamples {
  private static final String TAG = "EXAMPLE ACTIVE PEER";
  private static final String thisDBNAME = "local-database";
  private final Context context;
  // private Database database;
  // private Replicator replicator;

  public docOnly_ReplicationExamples(Context context) { this.context = context; }

  String user = "syncuser";
  String password = "sync9455";
  SecCertificate cert=null;
  String passivePeerEndpoint = "10.1.1.12:8920";
  String passivePeerPort = "8920";
  String passiveDbName = "userdb";
  Database thisDB;
  Replicator thisReplicator;
  ListenerToken replicatorListener;




// PASSIVE PEER STUFF
// Stuff I adapted
//
// BEGIN new stuff 90420temp cache
  private URLEndpointListener createListener() {
  final URLEndpointListenerConfiguration listenerConfig = new URLEndpointListenerConfiguration(db);

  listenerConfig.setDisableTls(false);

  listenerConfig.setEnableDeltaSync(true);

  listenerConfig.setTlsIdentity(null); // Use with anonymous self signed cert

  listenerConfig.setAuthenticator(new ListenerPasswordAuthenticator(this::isWhitelistedUser));

  return new URLEndpointListener(listenerConfig);
}

public void startListener(@NotNull URLEndpointListener listener) {
  executor.submit) -&gt; {       CouchbaseLiteException err = null;       try { listener.start(); }       catch (CouchbaseLiteException e) { err = e; }       onStart(err);   }); }  private void stopListener(@NotNull URLEndpointListener listener) {   listener.stop(); } // END new stuff 90420temp cache   private void ibListenerSimple() {   final URLEndpointListenerConfiguration thisConfig =     new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="36"></i><b>(36)</b>    thisConfig.setAuthenticator(     new ListenerPasswordAuthenticator(       (username, password) -&gt;         username.equals("valid.User") &amp;&amp;         Arrays.equals(password, valid.password.string)       )     ); <i class="conum" data-value="37"></i><b>(37)</b>    final URLEndpointListener thisListener =     new URLEndpointListener(thisConfig); <i class="conum" data-value="38"></i><b>(38)</b>    thisListener.start(); <i class="conum" data-value="39"></i><b>(39)</b>  }  private void ibReplicatorSimple() {   URI uri = null;   try {       uri = new URI("wss://10.0.2.2:4984/db");   } catch (URISyntaxException e) {       e.printStackTrace();   }   Endpoint theListenerEndpoint = new URLEndpoint(uri); <i class="conum" data-value="40"></i><b>(40)</b>    ReplicatorConfiguration thisConfig =     new ReplicatorConfiguration(database, theListenerEndpoint); <i class="conum" data-value="41"></i><b>(41)</b>    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="42"></i><b>(42)</b>    final BasicAuthenticator thisAuth   = new BasicAuthenticator(       "valid.user",       "valid.password.string");   thisConfig.setAuthenticator(thisAuth) <i class="conum" data-value="43"></i><b>(43)</b>    this.replicator = new Replicator(config); <i class="conum" data-value="44"></i><b>(44)</b>   this.replicator.start(); <i class="conum" data-value="45"></i><b>(45)</b>  }   private void ibPassListener() { // EXAMPLE 1     // Initialize the listener config     final URLEndpointListenerConfiguration thisConfig        = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="46"></i><b>(46)</b>      thisConfig.setPort(55990); <i class="conum" data-value="47"></i><b>(47)</b>      thisConfig.setNetworkInterface("10.1.1.10"); <i class="conum" data-value="48"></i><b>(48)</b>      thisConfig.setEnableDeltaSync(false); <i class="conum" data-value="49"></i><b>(49)</b>      // Configure server security     thisConfig.setDisableTls(false); <i class="conum" data-value="50"></i><b>(50)</b>      // Use an Anonymous Self-Signed Cert     thisConfig.setTlsIdentity(null); <i class="conum" data-value="51"></i><b>(51)</b>       // Configure Client Security using an Authenticator     // For example, Basic Authentication <i class="conum" data-value="52"></i><b>(52)</b>     thisConfig.setAuthenticator(new ListenerPasswordAuthenticator(       (validUser, validPassword) -&gt;         username.equals(validUser) &amp;&amp;         Arrays.equals(password, validPassword);

    // Initialize the listener
    final URLEndpointListener thisListener
      = new URLEndpointListener(thisConfig); <i class="conum" data-value="53"></i><b>(53)</b>

    // Start the listener
    thisListener.start(); <i class="conum" data-value="54"></i><b>(54)</b>

}

private void ibListenerGetNetworkInterfaces() {
  final URLEndpointListenerConfiguration thisConfig =
    URLEndpointListenerConfiguration(database: self.oDB)
  final URLEndpointListener thisListener
    = new URLEndpointListener(thisConfig);
  thisListener.start()
  Log.i(TAG, "URLS are " + thisListener.getUrls());

}

private void ibListenerLocalDb() {
// . . . preceding application logic . . .
CouchbaseLite.init(context); <i class="conum" data-value="55"></i><b>(55)</b>
Database thisDB = new Database("passivepeerdb");

}

private void ibListenerConfigTlsDisable() {
thisConfig.setDisableTls(true); <i class="conum" data-value="56"></i><b>(56)</b>

}

private void ibListenerConfigTlsIdFull() {
  // Use CA Cert
  // Import a key pair into secure storage
  // Create a TLSIdentity from the imported key-pair
  InputStream thisKeyPair = new FileInputStream();

  thisKeyPair.getClass().getResourceAsStream("serverkeypair.p12"); <i class="conum" data-value="57"></i><b>(57)</b>

  TLSIdentity thisIdentity = new TLSIdentity.importIdentity(
    EXTERNAL_KEY_STORE_TYPE,  // KeyStore type, eg: "PKCS12"
    thisKeyPair,              // An InputStream from the keystore
    password,                 // The keystore password
    EXTERNAL_KEY_ALIAS,       // The alias to be used (in external keystore)
    null,                     // The key password
    "test-alias"              // The alias for the imported key
    );


  // Use a self-signed certificate
  // Create a TLSIdentity for the server using convenience API.
  // System generates self-signed cert
  // Work-in-progress. Code snippet coming soon.
  private static final Map&lt;String, String&gt; CERT_ATTRIBUTES; <i class="conum" data-value="58"></i><b>(58)</b>
  static {
    final Map&lt;String, String&gt; thisMap = new HashMap&lt;&gt;();
    m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "Couchbase Demo");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
    m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>");
    CERT_ATTRIBUTES = Collections.unmodifiableMap(thisMap);
  }

  // Store the TLS identity in secure storage
  // under the label 'couchbase-docs-cert'
  TLSIdentity thisIdentity =
    new TLSIdentity.createIdentity(
      true,
      CERT_ATTRIBUTES,
      null,
      "couchbase-docs-cert"); <i class="conum" data-value="59"></i><b>(59)</b>


  // Set the TLS Identity
  thisConfig.setTlsIdentity(thisIdentity); <i class="conum" data-value="60"></i><b>(60)</b>

}

private void ibListenerConfigClientAuthRoot() {
  // Configure the client authenticator
  // to validate using ROOT CA
  // thisClientID.certs is a list containing a client cert to accept
  // and any other certs needed to complete a chain between the client cert
  // and a CA
  final TLSIdentity validId =
    TLSIdentity.getIdentity("Our Corporate Id");  // get the identity <i class="conum" data-value="61"></i><b>(61)</b>

  if (validId == null) { throw new IllegalStateException("Cannot find corporate id"); }

  thisConfig.setTlsIdentity(validId);

  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(validId.getCerts())); <i class="conum" data-value="62"></i><b>(62)</b> <i class="conum" data-value="63"></i><b>(63)</b>
    // accept only clients signed by the corp cert

  final URLEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

}

private void ibListenerConfigClientAuthLambda() {
// Configure authentication using application logic
  final TLSIdentity thisCorpId = TLSIdentity.getIdentity("OurCorp"); <i class="conum" data-value="64"></i><b>(64)</b>
  if (thisCorpId == null) {
    throw new IllegalStateException("Cannot find corporate id"); }
  thisConfig.setTlsIdentity(thisCorpId);
  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(
      (thisCorpId.getCerts()) -&gt; {
      // use supplied logic that resolves to boolean
      // true=valid, false=invalid
      }
    )); <i class="conum" data-value="65"></i><b>(65)</b> <i class="conum" data-value="66"></i><b>(66)</b>
  final ULEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

}


private void ibListenerConfigTlsDisable() {

  thisConfig.disableTLS(true);

}


private void ibListenerStatusCheck() {
  int connectionCount =
    thisListener.getStatus().getConnectionCount(); <i class="conum" data-value="67"></i><b>(67)</b>

  int activeConnectionCount =
    thisListener.getStatus().getActiveConnectionCount();  <i class="conum" data-value="68"></i><b>(68)</b>

}

private void ibListenerStop() {

  thisListener.stop();

}

// Listener Callouts
/</strong>

    &lt;.&gt; Initialize the listener instance using the configuration settings.
    &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.



  &lt;.&gt; <code>connectionCount</code> -- the total number of connections served by the listener
  &lt;.&gt; <code>activeConnectionCount</code> -- the number of active (BUSY) connections currently being served by the listener
  //

<strong>/
/</strong> END CALLOUTS TEXT <strong>/


private void ibP2PUrlEndpointListener() {

  public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
  }
}



// ACTIVE PEER STUFF
// Replication code
//

  //@Test
  public void testActPeerSync() throws CouchbaseLiteException, URISyntaxException {
    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://listener.com:8954"))); <i class="conum" data-value="69"></i><b>(69)</b> <i class="conum" data-value="70"></i><b>(70)</b>

    // Set replicator type
    thisConfig.setReplicatorType(
      ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Configure Sync Mode
    thisConfig.setContinuous(false); // default value

    // set auto-purge behavior (here we override default)
    thisConfig.setAutoPurgeEnabled(false); <i class="conum" data-value="71"></i><b>(71)</b>

    // Configure Server Authentication --
    // only accept self-signed certs
    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="72"></i><b>(72)</b>

    // Configure the credentials the
    // client will provide if prompted
    final BasicAuthenticator thisAuth
      = new BasicAuthenticator(
          "Our Username",
          "Our PasswordValue")); <i class="conum" data-value="73"></i><b>(73)</b>

    thisConfig.setAuthenticator(thisAuth)

    /</strong> Optionally set custom conflict resolver call back <strong>/
    thisConfig.setConflictResolver( /</strong> define resolver function <strong>/); <i class="conum" data-value="74"></i><b>(74)</b>

    // Create replicator
    // Consider holding a reference somewhere
    // to prevent the Replicator from being GCed
    final Replicator thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="75"></i><b>(75)</b>

    // Optionally add a change listener <i class="conum" data-value="76"></i><b>(76)</b>
    ListenerToken thisListener =
      new thisReplicator.addChangeListener(change -&gt; {
        final CouchbaseLiteException err =
         change.getStatus().getError();
         if (err != null) {
           Log.i(TAG, "Error code ::  " + err.getCode(), e);
         }
      }); <i class="conum" data-value="77"></i><b>(77)</b>

    // Start replicator
    thisReplicator.start(false); <i class="conum" data-value="78"></i><b>(78)</b>


  public void ibReplicatorConfig() {
  // BEGIN additional snippets
      // Configure Server Security
      // -- only accept CA attested certs
      thisConfig.setAcceptOnlySelfSignedServerCertificate(false); <i class="conum" data-value="79"></i><b>(79)</b>


    // Return the remote pinned cert (the listener's cert)
    byte returnedCert
     = new byte(thisConfig.getPinnedCertificate()); // Get listener cert if pinned

    // ... your other replicator configuration

    // Provide a client certificate to the server for authentication
    final TLSIdentity thisClientId = TLSIdentity.getIdentity("clientId"); <i class="conum" data-value="80"></i><b>(80)</b>

    if (thisClientId == null) { throw new IllegalStateException("Cannot find client id"); }

    thisConfig.setAuthenticator(new ClientCertificateAuthenticator(thisClientId)); <i class="conum" data-value="81"></i><b>(81)</b>

    // ... your other replicator configuration
    final thisReplicator= new Replicator(thisConfig);


    // Use the pinned certificate from the byte array (cert)
    thisConfig.setPinnedServerCertificate(cert.getEncoded()); <i class="conum" data-value="82"></i><b>(82)</b>
}
// END additional snippets








    Log.i(TAG, "The Replicator is currently " +
      thisReplicator.getStatus().getActivityLevel());

    Log.i(TAG, "The Replicator has processed " + t);

    if (thisReplicator.getStatus().getActivityLevel() ==
      Replicator.ActivityLevel.BUSY) {
        Log.i(TAG, "Replication Processing");
        Log.i(TAG, "It has completed " +
          thisReplicator.getStatus().getProgess().getTotal() +
          " changes");
      }

      // Stop replication.
      thisReplicator.stop(); <i class="conum" data-value="83"></i><b>(83)</b>


  CouchbaseLite.init(context);
  Database thisDB = new Database("passivepeerdb");  <i class="conum" data-value="84"></i><b>(84)</b>
  // Initialize the listener config
  final URLEndpointListenerConfiguration thisConfig = new URLEndpointListenerConfiguration(database);
  thisConfig.setPort(55990)           // &lt;.&gt; Optional; defaults to auto
  thisConfig.setDisableTls(false)     // &lt;.&gt; Optional; defaults to false
  thisConfig.setEnableDeltaSync(true) // &lt;.&gt; Optional; Defaults to false

  // Configure the client authenticator (if using basic auth)
  ListenerPasswordAuthenticator auth = new ListenerPasswordAuthenticator { "username", "password"}; <i class="conum" data-value="85"></i><b>(85)</b>
  thisConfig.setAuthenticator(auth); <i class="conum" data-value="86"></i><b>(86)</b>

  // Initialize the listener
  final URLEndpointListener listener = new URLEndpointListener( thisConfig ); <i class="conum" data-value="87"></i><b>(87)</b>

  // Start the listener
  listener.start(); <i class="conum" data-value="88"></i><b>(88)</b>




  Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
        )

  TLSIdentity thisIdentity = new TLSIdentity.createIdentity(true, X509_ATTRIBUTES, null, "test-alias");




  String thisAlias = "alias-to-delete";
  final KeyStore thisKeyStore
    =  KeyStore.getInstance("AndroidKeyStore");
  thisKeyStore.load(null);
  thisKeyStore.deleteEntry(thisAlias);


  // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label

  TLSIdentity thisIdentity =
    new TLSIdentity.getIdentity("couchbase-docs-cert")


  public void ibRplicatorPull() {
    Database database;
    Replicator replicator; <i class="conum" data-value="89"></i><b>(89)</b>

    URI uri = null;
    try {
        uri = new URI("wss://10.0.2.2:4984/db"); <i class="conum" data-value="90"></i><b>(90)</b>
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
    Endpoint endpoint = new URLEndpoint(uri);
    ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
    config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
    this.replicator = new Replicator(config);
    this.replicator.start();
  }

    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))); <i class="conum" data-value="91"></i><b>(91)</b>



  /</strong> C A L L O U T S

  &lt;.&gt; Configure the pinned certificate using data from the byte array <code>cert</code>

  &lt;.&gt; Attempt to get the identity from secure storage
  &lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity


  &lt;.&gt; A replication is an asynchronous operation.
  To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
  &lt;.&gt; The URL scheme for remote database URLs uses <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections over wb sockets.
  In this example the hostname is <code>10.0.2.2</code> because the Android emulator runs in a VM that is generally accessible on <code>10.0.2.2</code> from the host machine (see <a href="https://developer.android.com/studio/run/emulator-networking">Android Emulator networking</a> documentation).
  +
  NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
  Although <code>wss:</code> protocol URLs are not affected, in order to use the <code>ws:</code> protocol, applications must target API 27 or lower, or must configure application network security as described <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted">here</a>.

  <strong>/

}
/</strong>

Snippets demonstrating use of resultsets

<strong>/
package com.example.docsnippet;
        import android.app.Application.</strong>;
        import android.content.Context;
        import android.content.Context.<strong>;
        import java.lang.Object;
        import java.security.Key;
        import java.util.</strong>;
        import com.couchbase.lite.<strong>;
        import com.couchbase.lite.Dictionary;

public class TestQueries {

    // For Documentation

    Datastore ds = new Datastore();

    Database this_Db = ds.getDB();

    String dbName = this_Db.getName();

    HashMap&lt;String, Object&gt; hotels = new HashMap&lt;&gt;();

    Dictionary thisDocsProps;
    String thisDocsId;
    String thisDocsName;
    String thisDocsType;
    String thisDocsCity;



    static {
        init();
    }

    private static void init() {
    }



    public void testQuerySyntaxAll() throws CouchbaseLiteException {

        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

      Query listQuery = QueryBuilder.select(SelectResult.all())
              .from(DataSource.database(this_Db));

        try {
            for (Result result : listQuery.execute().allResults()) {
                             // get the k-v pairs from the 'hotel' key's value into a dictionary
                thisDocsProps = result.getDictionary(0); <i class="conum" data-value="92"></i><b>(92)</b>
                thisDocsId = thisDocsProps.getString("id");
                thisDocsName = thisDocsProps.getString("Name");
                thisDocsType = thisDocsProps.getString("Type");
                thisDocsCity = thisDocsProps.getString("City");

                // Alternatively, access results value dictionary directly
                final Hotel hotel = new Hotel();
                hotel.Id = result.getDictionary(0).getString("id"); <i class="conum" data-value="93"></i><b>(93)</b>
                hotel.Type = result.getDictionary(0).getString("Type");
                hotel.Name = result.getDictionary(0).getString("Name");
                hotel.City = result.getDictionary(0).getString("City");
                hotel.Country= result.getDictionary(0).getString("Country");
                hotel.Description = result.getDictionary(0).getString("Description");
                hotels.put(hotel.Id, hotel);
            }

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }



    // Uses Jackson JSON processor

    ArrayList&lt;Hotel&gt; hotels = new ArrayList&lt;Hotel&gt;();
    HashMap&lt;String, Object&gt; dictFromJSONstring;
    for (Result result : listQuery.execute()) {

      // Get result as JSON string
      String thisJsonString = result.toJSON(); <i class="conum" data-value="94"></i><b>(94)</b>

      // Get Java  Hashmap from JSON string
      HashMap&lt;String, Object&gt; dictFromJSONstring =
              mapper.readValue(thisJsonString, HashMap.class); <i class="conum" data-value="95"></i><b>(95)</b>


      // Use created hashmap
      String hotelId = dictFromJSONstring.get("id").toString();
      String hotelType = dictFromJSONstring.get("type").toString();
      String hotelname = dictFromJSONstring.get("name").toString();


      // Get custom object from JSON string
      Hotel thisHotel =
              mapper.readValue(thisJsonString, Hotel.class); <i class="conum" data-value="96"></i><b>(96)</b>
      hotels.add(thisHotel);



            }
        }


    public void testQuerySyntaxProps() throws CouchbaseLiteException {
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        Query listQuery =
        QueryBuilder.select(SelectResult.expression(Meta.id),
        SelectResult.property("name"),
        SelectResult.property("Name"),
        SelectResult.property("Type"),
        SelectResult.property("City"))
        .from(DataSource.database(this_Db));



        try {
          for (Result result : listQuery.execute().allResults()) {

            // get data direct from result k-v pairs
            final Hotel hotel = new Hotel();
            hotel.Id = result.getString("id");
            hotel.Type = result.getString("Type");
            hotel.Name = result.getString("Name");
            hotel.City = result.getString("City");

            // Store created hotel object in a hashmap of hotels
            hotels.put(hotel.Id, hotel);

            // Get result k-v pairs into a 'dictionary' object
            Map &lt;String, Object&gt; thisDocsProps = result.toMap();
            thisDocsId =
            thisDocsProps.getOrDefault("id",null).toString();
            thisDocsName =
            thisDocsProps.getOrDefault("Name",null).toString();
            thisDocsType =
            thisDocsProps.getOrDefault("Type",null).toString();
            thisDocsCity =
            thisDocsProps.getOrDefault("City",null).toString();

          }
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

    }


    public void testQuerySyntaxCount() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery = QueryBuilder.select(
              SelectResult.expression(Function.count(Expression.string("</strong>"))).as("mycount")) <i class="conum" data-value="97"></i><b>(97)</b>
              .from(DataSource.database(this_Db));



        try {
            for (Result result : listQuery.execute()) {

                // Retrieve count using key 'mycount'
                Integer altDocId = result.getInt("mycount");

                // Alternatively, use the index
                Integer orDocId = result.getInt(0);
            }
            // Or even miss out the for-loop altogether
            Integer resultCount = listQuery.execute().next().getInt("mycount");

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }
    }


    public void testQuerySyntaxId() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id).as("metaID"))
                      .from(DataSource.database(this_Db));




        try {
            for (Result result : listQuery.execute().allResults()) {

                // get the ID form the result's k-v pair array
                thisDocsId = result.getString("metaID"); <i class="conum" data-value="98"></i><b>(98)</b>

                // Get document from DB using retrieved ID
                Document thisDoc = this_Db.getDocument(thisDocsId);

                // Process document as required
                thisDocsName = thisDoc.getString("Name");

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }


    }


    public void testQueryPagination() throws CouchbaseLiteException {


        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        int thisOffset = 0;
        int thisLimit = 20;

        Query listQuery =
                QueryBuilder
                        .select(SelectResult.all())
                        .from(DataSource.database(this_Db))
                        .limit(Expression.intValue(thisLimit),
                                  Expression.intValue(thisOffset)); <i class="conum" data-value="99"></i><b>(99)</b>


    }



    public List&lt;Result&gt; docsonly_QuerySyntaxN1QL (Database argDB)
    {
      // For Documentation -- N1QL Query using parameters
      //  Declared elsewhere: Database argDB

      Database thisDb = argDB;

      Query thisQuery =
      thisDb.createQuery(
        "SELECT META().id AS thisId FROM _ WHERE type = \"hotel\""); // &lt;.

        return thisQuery.execute().allResults();

      }


    public List&lt;Result&gt; docsonly_QuerySyntaxN1QLParams (Database argDB)
    {
      // For Documentation -- N1QL Query using parameters
      //  Declared elsewhere: Database argDB

      Database thisDb = argDB;

      Query thisQuery =
          thisDb.createQuery(
              "SELECT META().id AS thisId FROM _ WHERE type = $type"); // &lt;.

      thisQuery.parameters =
          Parameters.setString("type", "hotel"); <i class="conum" data-value="100"></i><b>(100)</b>

      return thisQuery.execute().allResults();

  }

} // class



public class supportingDatatypes
{
    private static final String TAG = "info";

    public void datatype_dictionary() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)
        Document document = database.getDocument("doc1");

        // Getting a dictionary from the document's properties
        Dictionary dict = document.getDictionary("address");

        // Access a value with a key from the dictionary
        String street = dict.getString("street");

        // Iterate dictionary
        for (String key : dict) {
            dict.getValue(key);
            Log.i("x", "Key %s, = %s", key, dict.getValue(key));
        }

        // Create a mutable copy
        MutableDictionary mutable_Dict = dict.toMutable();
    }

    public void datatype_mutable_dictionary() throws CouchbaseLiteException {

        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        MutableDictionary mutable_dict = new MutableDictionary();
        mutable_dict.setString("street", "1 Main st.");
        mutable_dict.setString("city", "San Francisco");

        // Add the dictionary to a document's properties and save the document
        MutableDocument mutable_doc = new MutableDocument("doc1");
        mutable_doc.setDictionary("address", mutable_dict);
        database.save(mutable_doc);

    }


    public void datatype_array() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        Document document = database.getDocument("doc1");

        // Getting a phones array from the document's properties
        Array array = document.getArray("phones");

        // Get element count
        int count = array.count();

        // Access an array element by index
        if (count &gt;= 0) { String phone = array.getString(1); }

        // Iterate dictionary
        for (int i = 0; i &lt; count; i)
        {
            Log.i("tag", "Item %d = %s", i, array.getString(i));
        }

        // Create a mutable copy
        MutableArray mutable_array = array.toMutable();


    }

    public void datatype_mutable_array() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        MutableArray mutable_array = new MutableArray();
        mutable_array.addString("650-000-0000");
        mutable_array.addString("650-000-0001");

        // Set the array to document's properties and save the document
        MutableDocument mutable_doc = new MutableDocument("doc1");
        mutable_doc.setArray("phones", mutable_array);
        database.save(mutable_doc);
    }

} // end  class supporting_datatypes



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/ZipUtils.java 
package com.couchbase.code_snippets;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class ZipUtils {
    public static void unzip(InputStream in, File destination) throws IOException {
        byte[] buffer = new byte[1024];
        ZipInputStream zis = new ZipInputStream(in);
        ZipEntry ze = zis.getNextEntry();
        while (ze != null) {
            String fileName = ze.getName();
            File newFile = new File(destination, fileName);
            if (ze.isDirectory()) {
                newFile.mkdirs();
            } else {
                new File(newFile.getParent()).mkdirs();
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) &gt; 0) {
                    fos.write(buffer, 0, len);
                }
                fos.close();
            }
            ze = zis.getNextEntry();
        }
        zis.closeEntry();
        zis.close();
        in.close();
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/ZipUtils.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/JSONExamples.java 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.util.Log;

import java.util.Map;

import org.json.JSONException;
import org.json.JSONObject;

import com.couchbase.lite.Array;
import com.couchbase.lite.Blob;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableArray;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.Result;
import com.couchbase.lite.SelectResult;


public class JSONExamples {
    private static final String TAG = "SNIPPETS";

    public static final String JSON
        = "[{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\","
        + "\"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},"
        + "{\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\","
        + "\"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},"
        + "{\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\","
        + "\"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\","
        + "\"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]";

    public void jsonArrayExample(Database db) throws CouchbaseLiteException {
        // github tag=tojson-array
        final MutableArray mArray = new MutableArray(JSON); // &lt;.&gt;

        for (int i = 0; i &lt; mArray.count(); i) { <i class="conum" data-value="101"></i><b>(101)</b>
          final Dictionary dict = mArray.getDictionary(i);
          Log.i(TAG, dict.getString("name"));
          db.save(new MutableDocument(dict.getString("id"), dict.toMap()));
        }

        final Array features = db.getDocument("1002").getArray("features"); <i class="conum" data-value="102"></i><b>(102)</b>
        for (Object feature: features.toList()) { Log.i(TAG, feature.toString()); }
        Log.i(TAG, features.toJSON()); <i class="conum" data-value="103"></i><b>(103)</b>
      }

      public void jsonBlobExample(Database db) {
        // github tag=tojson-blob
        final Map&lt;String, ?&gt; thisBlob = db.getDocument("thisdoc-id").toMap();
        if (!Blob.isBlob(thisBlob)) { return; }

        final String blobType = thisBlob.get("content_type").toString();
        final Number blobLength = (Number) thisBlob.get("length");
      }

      public void jsonDictionaryExample(Database db) {
        // github tag=tojson-dictionary
        final MutableDictionary mDict = new MutableDictionary(JSON); <i class="conum" data-value="104"></i><b>(104)</b>
        Log.i(TAG, mDict.toString());

        Log.i(TAG, "Details for: " + mDict.getString("name"));
        for (String key: mDict.getKeys()) {
          Log.i(TAG, key + " =&gt; " + mDict.getValue(key));
        }
    }

    public void jsonDocumentExample(Database srcDb, Database dstDb) throws CouchbaseLiteException {
        // github tag=tojson-document
        final Query listQuery = QueryBuilder
        .select(SelectResult.expression(Meta.id).as("metaId"))
        .from(DataSource.database(srcDb));

        for (Result row: listQuery.execute()) {
          final String thisId = row.getString("metaId");

          final String json = srcDb.getDocument(thisId).toJSON(); <i class="conum" data-value="105"></i><b>(105)</b>
          Log.i(TAG, "JSON String = " + json);

          final MutableDocument hotelFromJSON = new MutableDocument(thisId, json); <i class="conum" data-value="106"></i><b>(106)</b>

          dstDb.save(hotelFromJSON);

          for (Map.Entry entry: dstDb.getDocument(thisId).toMap().entrySet()) {
            Log.i(TAG, entry.getKey() + " =&gt; " + entry.getValue());
          } <i class="conum" data-value="107"></i><b>(107)</b>
        }
      }


    public void jsonQueryExample(Query query) throws CouchbaseLiteException, JSONException {
        for (Result row: query.execute()) {

            // get the result into a JSON String
            final String jsonString = row.toJSON();

            final JSONObject thisJsonObj = new JSONObject(jsonString);

            // Use Json Object to populate Native object
            // Use Codable class to unpack JSON data to native object
            final Hotel thisHotel = new Hotel(
                "this hotel",
                "Ghana, West Africa",
                thisJsonObj.getString("city"),
                thisJsonObj.getString("name"),
                thisJsonObj.getString("type"),
                thisJsonObj.getString("id"));
        }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/JSONExamples.java </code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create and populate a mutable dictionary <code>address</code></p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset3_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset3_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset3_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">

// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.*
import com.couchbase.lite.internal.utils.PlatformUtils
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.io.InputStream
import java.net.URI
import java.net.URISyntaxException


private const val TAG = "REPLICATION"

@Throws(IOException::class)
fun InputStream.toByteArray(): ByteArray {
    val buffer = ByteArray(1024)
    val output = ByteArrayOutputStream()

    var n: Int
    while (-1 &lt; this.read(buffer).also { n = it }) {
        output.write(buffer, 0, n)
    }

    return output.toByteArray()
}

//
//        &lt;.&gt; The conflict handler code is provided as a lambda.
//
//        &lt;.&gt; If the handler cannot resolve a conflict, it can return false.
//        In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.
//
//        &lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.
//
//        &lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).
//
//        &lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method


// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
@Suppress("unused")
object LocalWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.localDocument
}

// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
@Suppress("unused")
object RemoteWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.remoteDocument
}

// Using replConfig.setConflictResolver(new MergeConflictResolver());
@Suppress("unused")
object MergeConflictResolver : ConflictResolver {
    override fun resolve(conflict: Conflict): Document {
        val localDoc = conflict.localDocument?.toMap()
        val remoteDoc = conflict.remoteDocument?.toMap()

        val merge: MutableMap&lt;String, Any&gt;?
        if (localDoc == null) {
            merge = remoteDoc
        } else {
            merge = localDoc
            if (remoteDoc != null) {
                merge.putAll(remoteDoc)
            }
        }

        return if (merge == null) {
            MutableDocument(conflict.documentId)
        } else {
            MutableDocument(conflict.documentId, merge)
        }
    }

    @Suppress("unused")
    class ReplicationExamples(private val database: Database) {
        private var replicator: Replicator? = null

        @Throws(URISyntaxException::class)
        fun testReplicationBasicAuthentication() {

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = BasicAuthenticator("username", "password".toCharArray())
                )
            )
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationSessionAuthentication() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447")
                )
            )
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationStatus() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            repl.addChangeListener { change -&gt;
                if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                    Log.i(TAG, "Replication stopped")
                }
            }

            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testHandlingNetworkErrors() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            repl.addChangeListener { change -&gt;
                change.status.error?.let {
                    Log.w(TAG, "Error code: ${it.code}")
                }
            }
            repl.start()
            replicator = repl

            repl.stop()
        }

        @Throws(URISyntaxException::class)
        fun testReplicatorDocumentEvent() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            val token = repl.addDocumentReplicationListener { replication -&gt;
                Log.i(TAG, "Replication type: ${if (replication.isPush) "push" else "pull"}")

                for (document in replication.documents) {
                    document.let { doc -&gt;
                        Log.i(TAG, "Doc ID: ${document.id}")
                        doc.error?.let {
                            // There was an error
                            Log.e(TAG, "Error replicating document: ", it)
                            return@addDocumentReplicationListener
                        }
                        if (doc.flags.contains(DocumentFlag.DELETED)) {
                            Log.i(TAG, "Successfully replicated a deleted document")
                        }
                    }
                }
            }

            repl.start()
            replicator = repl

            repl.removeChangeListener(token)
        }

        @Throws(URISyntaxException::class)
        fun testReplicationCustomHeader() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value")
                )
            )
            replicator = repl
        }

        // <mark># Certificate Pinning
        @Throws(URISyntaxException::class, IOException::class)
        fun testCertificatePinning() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value"),
                    pinnedServerCertificate = PlatformUtils.getAsset("cert.cer")?.toByteArray()
                )
            )
            replicator = repl
        }

        // </mark># Reset replicator checkpoint
        @Throws(URISyntaxException::class)
        fun testReplicationResetCheckpoint() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            val resetCheckpointRequired_Example = false
            repl.start(resetCheckpointRequired_Example) <i class="conum" data-value="1"></i><b>(1)</b>

            // ... at some later time

            repl.stop()

        }

        @Throws(URISyntaxException::class)
        fun testReplicationPushFilter() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { _, flags -&gt; flags.contains(DocumentFlag.DELETED) } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationPullFilter() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { document, _ -&gt; "draft" == document.getString("type") } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testCustomRetryConfig() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    //  other config params as required . .
                    heartbeat = 150, <i class="conum" data-value="1"></i><b>(1)</b>
                    maxAttempts = 20,
                    maxAttemptWaitTime = 600
                )
            )

            repl.start()
            replicator = repl
        }

        @Throws(CouchbaseLiteException::class)
        fun testDatabaseReplica() {
            val config = DatabaseConfiguration()
            val database1 = Database("mydb", config)
            val database2 = Database("db2", config)

            /* EE feature: code below might throw a compilation error
               if it's compiled against CBL Android Community. <strong>/
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database1,
                    target = DatabaseEndpoint(database2),
                    type = ReplicatorType.PULL
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationWithCustomConflictResolver() {
            val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
            val config = ReplicatorConfiguration(database, target)
            config.conflictResolver = LocalWinsResolver
            val replication = Replicator(config)
            replication.start()
        }

        @Throws(CouchbaseLiteException::class)
        fun testSaveWithCustomConflictResolver() {
            val mutableDocument = database.getDocument("xyz")?.toMutable() ?: return
            mutableDocument.setString("name", "apples")
            database.save(mutableDocument) { newDoc, curDoc -&gt;  <i class="conum" data-value="2"></i><b>(2)</b>
                if (curDoc == null) {
                    return@save false
                } <i class="conum" data-value="3"></i><b>(3)</b>
                val dataMap: MutableMap&lt;String, Any&gt; = curDoc.toMap()
                dataMap.putAll(newDoc.toMap()) <i class="conum" data-value="4"></i><b>(4)</b>
                newDoc.setData(dataMap)
                true <i class="conum" data-value="5"></i><b>(5)</b>
            } <i class="conum" data-value="6"></i><b>(6)</b>
        }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import android.widget.Toast
import com.couchbase.lite.</strong>
import com.couchbase.lite.internal.utils.PlatformUtils
import org.junit.Test
import java.io.File
import java.io.IOException
import java.net.URI
import java.net.URISyntaxException
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.*


private const val TAG = "BASIC"

class LogTestLogger(private val level: LogLevel) : Logger {
    override fun getLevel() = level

    override fun log(level: LogLevel, domain: LogDomain, message: String) {
        // this method will never be called if param level &lt; this.level
        // handle the message, for example piping it to a third party framework
    }
}

@Suppress("unused")
class BasicExamples(private val context: Context) {
    private val database: Database

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        // Get the database (and create it if it doesnt exist).
        database = Database(
          "getting-started",
          DatabaseConfigurationFactory.create(context.filesDir.absolutePath)
          )
    }

    @Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {

        // !!! Note the code moved from here to the init { } above.
        // Create a new document (i.e. a record) in the database.
        var mutableDoc = MutableDocument().setFloat("version", 2.0f).setString("type", "SDK")

        // Save it to the database.
        database.save(mutableDoc)

        // Update a document.
        mutableDoc = database.getDocument(mutableDoc.id)!!.toMutable().setString("language", "Java")
        database.save(mutableDoc)

        val document = database.getDocument(mutableDoc.id)!!
        // Log the document ID (generated by the database) and properties
        Log.i(TAG, "Document ID :: ${document.id}")
        Log.i(TAG, "Learning ${document.getString("language")}")

        // Create a query to fetch documents of type SDK.
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))
            .execute()
        Log.i(TAG, "Number of rows :: ${rs.allResults().size}")

        // Create a replicator to push and pull changes to and from the cloud.
        // Be sure to hold a reference somewhere to prevent the Replicator from being GCed
        val replicator =
          Replicator(
            ReplicatorConfigurationFactory.create(
              database = database,
              target = URLEndpoint(URI("ws://localhost:4984/getting-started-db")),
              type = ReplicatorType.PUSH_AND_PULL,
              authenticator = BasicAuthenticator("sync-gateway", "password".toCharArray())
              )
          )


        // Listen to replicator change events.
        replicator.addChangeListener { change -&gt;
            val err = change.status.error
            if (err != null) Log.i(TAG, "Error code ::  ${err.code}")
        }

        // Start replication.
        replicator.start()

        database.delete()
    }

    @Throws(CouchbaseLiteException::class, IOException::class)
    fun test1xAttachments() {
        // if db exist, delete it
        deleteDB("android-sqlite", context.filesDir)
        ZipUtils.unzip(
            PlatformUtils.getAsset("replacedb/android140-sqlite.cblite2.zip"),
            context.filesDir
        )

        val db = Database("android-sqlite")
        try {
            // For Validation
            Arrays.equals(
                "attach1".toByteArray(),
                db.getDocument("doc1")?.getDictionary("_attachments")?.getBlob("attach1")?.content
            )
        } finally {
            // close db
            db.close()
            // if db exist, delete it
            deleteDB("android-sqlite", context.filesDir)
        }
        val document = MutableDocument()

        val content = document.getDictionary("_attachments")?.getBlob("avatar")?.content
    }

    // <mark># Initializer
    fun testInitializer() {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)
    }

    // </mark># New Database
    @Throws(CouchbaseLiteException::class)
    fun testNewDatabase() {
        val database = Database(
            "my-db",
            DatabaseConfigurationFactory.create(
                context.filesDir.absolutePath
            )
        ) <i class="conum" data-value="7"></i><b>(7)</b>
        database.close()


        database.delete()
    }

    // <mark># Database Encryption
    @Throws(CouchbaseLiteException::class)
    fun testDatabaseEncryption() {
        val db = Database(
            "my-db",
            DatabaseConfigurationFactory.create(
                encryptionKey = EncryptionKey("PASSWORD")
            )
        )

    }

    // </mark># Logging
    // !!! OBSOLETE in 3.0
    fun testLogging() {
    }

    fun testEnableCustomLogging() {
        // this custom logger will not log an event with a log level &lt; WARNING
        Database.log.custom = LogTestLogger(LogLevel.WARNING) <i class="conum" data-value="8"></i><b>(8)</b>
    }

    // <mark># Console logging
    @Throws(CouchbaseLiteException::class)
    fun testConsoleLogging() {
        Database.log.console.domains = LogDomain.ALL_DOMAINS <i class="conum" data-value="9"></i><b>(9)</b>
        Database.log.console.level = LogLevel.VERBOSE <i class="conum" data-value="10"></i><b>(10)</b>

        Database.log.console.domains = EnumSet.of(LogDomain.DATABASE) <i class="conum" data-value="11"></i><b>(11)</b>
    }

    // </mark># File logging
    @Throws(CouchbaseLiteException::class)
    fun testFileLogging() {
        Database.log.file.let {
          it.config = LogFileConfigurationFactory.create(
            context.cacheDir.absolutePath, <i class="conum" data-value="12"></i><b>(12)</b>
            maxSize = 10240, <i class="conum" data-value="13"></i><b>(13)</b>
            maxRotateCount = 5, <i class="conum" data-value="14"></i><b>(14)</b>
            usePlainText = false
            ) <i class="conum" data-value="15"></i><b>(15)</b>
            it.level = LogLevel.INFO <i class="conum" data-value="16"></i><b>(16)</b>

          }
    }

    fun writeConsoleLog() {
        Database.log.console.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    fun writeCustomLog() {
        Database.log.custom?.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    fun writeFileLog() {
        Database.log.file.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    /* The <code>tag::replication[]</code> example is inlined in java.adoc <strong>/
    fun testTroubleshooting() {
        Database.log.console.let {
            it.level = LogLevel.VERBOSE
            it.domains = LogDomain.ALL_DOMAINS
        }
    }

    // <mark># Loading a pre-built database
    @Throws(IOException::class)
    fun testPreBuiltDatabase() {
        // Note: Getting the path to a database is platform-specific.
        // For Android you need to extract the database from your assets
        // to a temporary directory and then copy it, using Database.copy()
        if (Database.exists("travel-sample", context.filesDir)) {
            return
        }
        ZipUtils.unzip(PlatformUtils.getAsset("travel-sample.cblite2.zip"), context.filesDir)
        Database.copy(
            File(context.filesDir, "travel-sample"),
            "travel-sample",
            DatabaseConfiguration()
        )
    }

    // helper methods
    // if db exist, delete it
    fun deleteDB(name: String, dir: File) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            Database.delete(name, dir)
        }

        // </mark># Initializers
        fun testInitializers() {
            val doc = MutableDocument()
            doc.let {
                it.setString("type", "task")
                it.setString("owner", "todo")
                it.setDate("createdAt", Date())
            }
            database.save(doc)
        }
    }

    // <mark># Mutability
    fun testMutability() {
        database.save(MutableDocument("xyz"))

        database.getDocument("xyz")?.toMutable()?.let {
            it.setString("name", "apples")
            database.save(it)
        }
    }

    // </mark># Typed Accessors
    fun testTypedAccessors() {
        val doc = MutableDocument()

        doc.setValue("createdAt", Date())
        val date = doc.getDate("createdAt")
    }

    // <mark># Batch operations
    fun testBatchOperations() {
        database.inBatch(UnitOfWork {
            for (i in 0..9) {
                val doc = MutableDocument()
                doc.let {
                    it.setValue("type", "user")
                    it.setValue("name", "user $i")
                    it.setBoolean("admin", false)
                }
                Log.i(TAG, "saved user document: ${doc.getString("name")}")
            }
        })
    }


    // toJSON
    fun testToJsonOperations(argDb: Database) {
        val db = argDb

    }


    // </mark># Document Expiration
    @Throws(CouchbaseLiteException::class)
    fun documentExpiration() {
        // Purge the document one day from now
        database.setDocumentExpiration(
            "doc123",
            Date(Instant.now().plus(1, ChronoUnit.DAYS).toEpochMilli())
        )

        // Reset expiration
        database.setDocumentExpiration("doc1", null)

        // Query documents that will be expired in less than five minutes
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.longValue(Instant.now().plus(5, ChronoUnit.MINUTES).toEpochMilli())
                )
            )
    }

    @Throws(CouchbaseLiteException::class)
    fun testDocumentChangeListener() {
        database.addDocumentChangeListener("user.john") { change -&gt;
            database.getDocument(change.documentID)?.let {
                Toast.makeText(
                    context,
                    "Status: ${it.getString("verified_account")}",
                    Toast.LENGTH_SHORT
                ).show()
            }
        }
    }

    // <mark># Blobs
    fun testBlobs() {
        val mDoc = MutableDocument()

        PlatformUtils.getAsset("avatar.jpg")?.use { <i class="conum" data-value="17"></i><b>(17)</b>
            mDoc.setBlob("avatar", Blob("image/jpeg", it)) <i class="conum" data-value="18"></i><b>(18)</b> <i class="conum" data-value="19"></i><b>(19)</b>
            database.save(mDoc)
        }

        val doc = database.getDocument(mDoc.id)
        val bytes = doc?.getBlob("avatar")?.content
    }
}


class supportingDatatypes
{

    private val database  = Database("mydb")

    fun datatype_dictionary() {

        // NOTE: No error handling, for brevity (see getting started)
        val document = database!!.getDocument("doc1")

        // Getting a dictionary from the document's properties
        val dict = document?.getDictionary("address")

        // Access a value with a key from the dictionary
        val street = dict?.getString("street")

        // Iterate dictionary
        for (key in dict!!.keys) {
            println("Key ${key} = ${dict.getValue(key)}")
        }

    // Create a mutable copy
    val mutable_Dict = dict.toMutable()
}

    fun datatype_mutable_dictionary() {

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        val mutable_dict = MutableDictionary()
        mutable_dict.setString("street", "1 Main st.")
        mutable_dict.setString("city", "San Francisco")

        // Add the dictionary to a document's properties and save the document
        val mutable_doc = MutableDocument("doc1")
        mutable_doc.setDictionary("address", mutable_dict)
        database!!.save(mutable_doc)

}


    fun datatype_array() {

        // NOTE: No error handling, for brevity (see getting started)

        val document = database?.getDocument("doc1")

        // Getting a phones array from the document's properties
        val array = document?.getArray("phones")

        // Get element count
        val count = array?.count()

        // Access an array element by index
        val phone = array?.getString(1)

        // Iterate array
        for ( (index, item) in array!!) {
            println("Row  ${index} = ${item}")
        }

        // Create a mutable copy
        val mutable_array = array.toMutable()
    }

    fun datatype_mutable_array() {

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        val mutable_array = MutableArray()
        mutable_array.addString("650-000-0000")
        mutable_array.addString("650-000-0001")

        // Set the array to document's properties and save the document
        val mutable_doc = MutableDocument("doc1")
        mutable_doc.setArray("phones", mutable_array)
        database?.save(mutable_doc)
    }

} // end  class supporting_datatypes



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.Dictionary
import com.couchbase.lite.Expression
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.MutableDictionary
import com.couchbase.lite.PredictionFunction
import com.couchbase.lite.PredictiveIndex
import com.couchbase.lite.PredictiveModel
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.SelectResult
import com.couchbase.lite.ValueIndex
import com.couchbase.lite.ValueIndexItem


private const val TAG = "PREDICT"
// tensorFlowModel is a fake implementation

object TensorFlowModel {
    fun predictImage(data: ByteArray?) = mapOf&lt;String, Any?&gt;()
}

object ImageClassifierModel : PredictiveModel {
    const val name = "ImageClassifier"

    override fun predict(input: Dictionary): Dictionary? {
        val blob: Blob = input.getBlob("photo") ?: return null

        // this would be the implementation of the ml model you have chosen
        return MutableDictionary(TensorFlowModel.predictImage(blob.content)) <i class="conum" data-value="1"></i><b>(1)</b>
    }
}


@Suppress("unused")
class PredictiveQueryExamples {
    @Throws(CouchbaseLiteException::class)
    fun testPredictiveModel() {
        val database = Database("mydb")

        Database.prediction.registerModel("ImageClassifier", ImageClassifierModel)

        val index: ValueIndex = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")))
        database.createIndex("value-index-image-classifier", index)

        Database.prediction.unregisterModel("ImageClassifier")
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveIndex() {
        val database = Database("mydb")

        val inputMap: MutableMap&lt;String, Any&gt; = mutableMapOf()
        inputMap["numbers"] = Expression.property("photo")
        val input: Expression = Expression.map(inputMap)
        val index: PredictiveIndex = IndexBuilder.predictiveIndex("ImageClassifier", input, null)
        database.createIndex("predictive-index-image-classifier", index)
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveQuery() {
        val database = Database("mydb")

        val prediction: PredictionFunction = Function.prediction(
            ImageClassifierModel.name,
            Expression.map(mutableMapOf("photo" to Expression.property("photo")) as Map&lt;String, Any&gt;?) <i class="conum" data-value="1"></i><b>(1)</b>
        )

        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                .and(prediction.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))
                    )
            )
            .execute()

        Log.d(TAG, "Number of rows: ${rs.allResults().size}")
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/FlowExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import androidx.lifecycle.LiveData
import androidx.lifecycle.asLiveData
import com.couchbase.lite.</strong>
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.map


class FlowExamples(argDb: Database,
                   argRepl: Replicator,
                   argQuery: Query,
                   argDocOwner: String) {

    val replState: LiveData&lt;ReplicatorActivityLevel&gt; = argRepl.replicatorChangesFlow()
        .map { it.status.activityLevel }
        .asLiveData()

    val dbChanges: LiveData&lt;MutableList&lt;String&gt;&gt; = argDb.databaseChangeFlow()
        .map { it.documentIDs }
        .asLiveData()

    val docChanges: LiveData&lt;DocumentChange?&gt; = argDb.documentChangeFlow("1001")
        .map {
            it.takeUnless {
                it.database.getDocument(it.documentID)?.getString("owner").equals(argDocOwner)
            }
        }
        .asLiveData()

    var liveQuery: LiveData&lt;List&lt;Any&gt;?&gt;? = null

    @ExperimentalCoroutinesApi
    fun watchQuery(query: Query): LiveData&lt;List&lt;Any&gt;?&gt; {
        val queryFlow = query.queryChangeFlow()
            .map {
                val err = it.error
                if (err != null) {
                    throw err
                }
                it.results?.allResults()?.flatMap { it.toList() }
            }
            .asLiveData()
        liveQuery = queryFlow
        return queryFlow
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/FlowExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorStatus


private const val TAG = "PENDING"

@Suppress("unused")
class PendingDocsExample(private var replicator: Replicator) {
    //
    //
    private fun onStatusChanged(pendingDocs: Set&lt;String&gt;, status: ReplicatorStatus) {
        // ... sample onStatusChanged function
        //
        Log.i(TAG, "Replicator activity level is ${status.activityLevel}")

        // iterate and report-on previously
        // retrieved pending docids 'list'
        val itr = pendingDocs.iterator()
        while (itr.hasNext()) {
            val docId = itr.next()

            if (!replicator.isDocumentPending(docId)) { <i class="conum" data-value="20"></i><b>(20)</b>
                continue
            }

            Log.i(TAG, "Doc ID $docId has been pushed")
        }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Endpoint
import com.couchbase.lite.KeyStoreUtils
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.net.URI
import java.net.URISyntaxException
import java.security.KeyStore
import java.security.cert.Certificate

private const val TAG = "P2P"


@Suppress("unused")
class IBExamples(private val context: Context, private val caCert: Certificate) {
    private val database: Database
    private var thisReplicator: Replicator? = null
    private var thisListener: URLEndpointListener? = null

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        database = Database("p2p_demo")

        /* do some stuff here <strong>/
    }

    // PASSIVE PEER STUFF
    fun ibListenerSimple() {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database,
                authenticator
                = ListenerPasswordAuthenticator { user, pwd -&gt; (user == "daniel") &amp;&amp; (String(pwd) == "123") })
        ) <i class="conum" data-value="21"></i><b>(21)</b>
        listener.start() <i class="conum" data-value="22"></i><b>(22)</b>
        thisListener = listener

    }

    fun ibReplicatorSimple() {
        val theListenerEndpoint: Endpoint = URLEndpoint(URI("wss://10.0.2.2:4984/db")) <i class="conum" data-value="23"></i><b>(23)</b>
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,
                target = theListenerEndpoint,
                authenticator = BasicAuthenticator("valid.user", "valid.password.string".toCharArray()), <i class="conum" data-value="24"></i><b>(24)</b>
                acceptOnlySelfSignedServerCertificate = true
            )
        )
        repl.start() <i class="conum" data-value="25"></i><b>(25)</b>
        thisReplicator = repl
    }

    fun ibPassListener(validUser: String, validPassword: CharArray) {
        // EXAMPLE 1
        // Initialize the listener
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database, <i class="conum" data-value="26"></i><b>(26)</b>
                port = 55990, <i class="conum" data-value="27"></i><b>(27)</b>
                networkInterface = "10.1.1.10", <i class="conum" data-value="28"></i><b>(28)</b>

                enableDeltaSync = false, <i class="conum" data-value="29"></i><b>(29)</b>

                // Configure server security
                disableTls = false, <i class="conum" data-value="30"></i><b>(30)</b>

                // Use an Anonymous Self-Signed Cert
                identity = null, <i class="conum" data-value="31"></i><b>(31)</b>

                // Configure Client Security using an Authenticator
                // For example, Basic Authentication <i class="conum" data-value="32"></i><b>(32)</b>
                authenticator = ListenerPasswordAuthenticator { username, paassword -&gt;
                    (username === validUser) &amp;&amp; (paassword === validPassword)
                }
            ))

        // Start the listener
        listener.start() <i class="conum" data-value="33"></i><b>(33)</b>
        thisListener = listener

    }

    fun ibListenerGetNetworkInterfaces() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        listener.start()
        Log.i(TAG, "URLS are ${listener.urls}")
        thisListener = listener
    }

    fun ibListenerLocalDb() {
        // . . . preceding application logic . . .
        CouchbaseLite.init(context) <i class="conum" data-value="34"></i><b>(34)</b>
        val thisDB = Database("passivepeerdb")
    }

    fun ibListenerConfigTlsDisable() {
        URLEndpointListenerConfigurationFactory.create(database, disableTls = false) <i class="conum" data-value="35"></i><b>(35)</b>
    }


    // !!! USERS SHOULD BE CAUTIONED THAT THIS IS INSECURE
    // Android has much better ways of importing keys
    fun ibListenerConfigTlsIdFull() {
        // Use CA Cert
        // Import a key pair into secure storage
        // Create a TLSIdentity from the imported key-pair

        this.javaClass.getResourceAsStream("serverkeypair.p12")?.use { <i class="conum" data-value="36"></i><b>(36)</b>
            KeyStoreUtils.importEntry(
                "teststore.p12",  // KeyStore type, eg: "PKCS12"
                it,  // An InputStream from the keystore
                "let me in".toCharArray(),  // The keystore password
                "topSekritKey",  // The alias to be used (in external keystore)
                null,  // The key password or null if the key has none
                "test-alias" // The alias for the imported key
            )
        }


        // Set the TLS Identity
        URLEndpointListenerConfigurationFactory.create(
            database,
            identity = TLSIdentity.getIdentity("test-alias")
        ) <i class="conum" data-value="37"></i><b>(37)</b>

    }

    fun ibListenerConfigClientAuthRoot() {
        // Configure the client authenticator
        // to validate using ROOT CA
        // thisClientID.certs is a list containing a client cert to accept
        // and any other certs needed to complete a chain between the client cert
        // and a CA
        val validId = TLSIdentity.getIdentity("Our Corporate Id")
            ?: throw IllegalStateException("Cannot find corporate id")
        // accept only clients signed by the corp cert
        thisListener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                // get the identity <i class="conum" data-value="38"></i><b>(38)</b>
                database = database,
                identity = validId,
                authenticator = ListenerCertificateAuthenticator(validId.certs)
            )
        ) <i class="conum" data-value="39"></i><b>(39)</b>

    }

    fun ibListenerConfigTlsDisable2() {

        URLEndpointListenerConfigurationFactory.create(database = database, disableTls = true)
    }

    fun ibListenerStatusCheck() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        val connectionCount = listener.status?.connectionCount <i class="conum" data-value="40"></i><b>(40)</b>
        val activeConnectionCount = listener.status?.activeConnectionCount <i class="conum" data-value="41"></i><b>(41)</b>
    }

    fun ibListenerStop() {

        thisListener?.stop()

    }

    // ACTIVE PEER STUFF
// Replication code
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testActPeerSync() {
        // Create replicator
        // Consider holding a reference somewhere
        // to prevent the Replicator from being GCed
        val repl = Replicator( <i class="conum" data-value="42"></i><b>(42)</b>

            // initialize the replicator configuration
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(URI("wss://listener.com:8954")), <i class="conum" data-value="43"></i><b>(43)</b>

                // Set replicator type
                type = ReplicatorType.PUSH_AND_PULL,

                // Configure Sync Mode
                continuous = false, // default value


                // set auto-purge behavior
                // (here we override default)
                enableAutoPurge = false, <i class="conum" data-value="44"></i><b>(44)</b>



                // Configure Server Authentication --
                // only accept self-signed certs
                acceptOnlySelfSignedServerCertificate = true, <i class="conum" data-value="45"></i><b>(45)</b>

                // Configure the credentials the
                // client will provide if prompted
                authenticator = BasicAuthenticator("Our Username", "Our PasswordValue".toCharArray()), <i class="conum" data-value="46"></i><b>(46)</b>


                /</strong> Optionally set custom conflict resolver call back <strong>/
                conflictResolver = null <i class="conum" data-value="47"></i><b>(47)</b>
            )
        )


        // Optionally add a change listener <i class="conum" data-value="48"></i><b>(48)</b>
        val thisListener = repl.addChangeListener { change -&gt;
            val err: CouchbaseLiteException? = change.status.error
            if (err != null) {
                Log.i(TAG, "Error code ::  ${err.code}", err)
            }
        }

        // Start replicator
        repl.start(false) <i class="conum" data-value="49"></i><b>(49)</b>
        thisReplicator = repl

    }

    fun ibReplicatorConfig() {
        // BEGIN additional snippets

        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,

                // Configure Server Security
                // -- only accept CA attested certs
                acceptOnlySelfSignedServerCertificate = false, <i class="conum" data-value="50"></i><b>(50)</b>




                // Use the pinned certificate from the byte array (cert)
                pinnedServerCertificate = caCert.encoded, <i class="conum" data-value="51"></i><b>(51)</b>


                // ... other replicator configuration
                // Provide a client certificate to the server for authentication
                authenticator = ClientCertificateAuthenticator(
                    TLSIdentity.getIdentity("clientId")
                        ?: throw IllegalStateException("Cannot find client id")
                ) <i class="conum" data-value="52"></i><b>(52)</b>

                // ... other replicator configuration

            )
        )

        thisReplicator = repl
    }

    fun ibP2pReplicatorStatus() {
        thisReplicator?.status?.let {
            Log.i(TAG, "The Replicator is currently ${it.activityLevel}")
            Log.i(TAG, "The Replicator has processed ${it.progress}")
            Log.i(
                TAG,
                if (it.activityLevel === ReplicatorActivityLevel.BUSY) {
                    "Replication Processing"
                } else {
                    "It has completed ${it.progress.total} changes"
                }
            )
        }
    }

    fun ibP2pReplicatorStop() {
        // Stop replication.
        thisReplicator?.stop() <i class="conum" data-value="53"></i><b>(53)</b>
    }

    fun ibP2pListener() {
        CouchbaseLite.init(context)
        val thisDB = Database("passivepeerdb") <i class="conum" data-value="54"></i><b>(54)</b>


        // Initialize the listener
        val listener = URLEndpointListener( <i class="conum" data-value="55"></i><b>(55)</b>

            // Initialize the listener config
            URLEndpointListenerConfigurationFactory.create(
                database = thisDB,
                port = 55990, /</strong> &lt;.&gt;  Optional; defaults to auto <strong>/
                disableTls = false, /</strong> &lt;.&gt;  Optional; defaults to false <strong>/
                enableDeltaSync = true,  /</strong> &lt;.&gt; Optional; defaults to false <strong>/

                // Configure the client authenticator (if using basic auth)
                authenticator = ListenerPasswordAuthenticator { username, password -&gt;
                    ("username" === username) &amp;&amp; (password === "password".toCharArray())  <i class="conum" data-value="56"></i><b>(56)</b>
                }
            )
        )

        // Start the listener
        listener.start() <i class="conum" data-value="57"></i><b>(57)</b>



//        Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
//                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
//                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
//        );
        val thisIdentity = TLSIdentity.createIdentity(
            true,
            mapOf(
                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
            ),
            null,
            "test-alias"
        )




        val thisAlias = "alias-to-delete"
        val thisKeyStore = KeyStore.getInstance("AndroidKeyStore")
        thisKeyStore.load(null)
        thisKeyStore.deleteEntry(thisAlias)


        // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label
        val thatIdentity = TLSIdentity.getIdentity("couchbase-docs-cert")
    }

    fun ibRplicatorPull() {
        val database = Database("ian")

        val uri = URI("wss://10.0.2.2:4984/db") <i class="conum" data-value="58"></i><b>(58)</b>

        val repl = Replicator( <i class="conum" data-value="59"></i><b>(59)</b>
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(uri),
                type = ReplicatorType.PULL
            )
        )

        repl.start()
        thisReplicator = repl
    }

// initialize the replicator configuration
    val thisConfig = ReplicatorConfigurationFactory.create(
        database = database,
        target = URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))

/</strong> C A L L O U T S

// Listener Callouts


&lt;.&gt; Initialize the listener instance using the configuration settings.
&lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.



&lt;.&gt; <code>connectionCount</code> -- the total number of connections served by the listener
&lt;.&gt; <code>activeConnectionCount</code> -- the number of active (BUSY) connections currently being served by the listener
//



&lt;.&gt; Configure the pinned certificate using data from the byte array <code>cert</code>

&lt;.&gt; Attempt to get the identity from secure storage
&lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity


&lt;.&gt; A replication is an asynchronous operation.
To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
&lt;.&gt; The URL scheme for remote database URLs uses <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections over wb sockets.
In this example the hostname is <code>10.0.2.2</code> because the Android emulator runs in a VM that is generally accessible on <code>10.0.2.2</code> from the host machine (see <a href="https://developer.android.com/studio/run/emulator-networking">Android Emulator networking</a> documentation).
+
NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
Although <code>wss:</code> protocol URLs are not affected, in order to use the <code>ws:</code> protocol, applications must target API 27 or lower, or must configure application network security as described <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted">here</a>.

<strong>/
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.net.URI
import java.security.KeyStore
import java.security.KeyStoreException
import java.security.NoSuchAlgorithmException
import java.security.cert.Certificate
import java.security.cert.CertificateEncodingException
import java.security.cert.CertificateException
import java.util.concurrent.CountDownLatch

private const val TAG = "LISTEN"

@Suppress("unused")
class KtCertAuthListener {
    companion object {
        private val CERT_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "CBL Test",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>",
        )
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)

        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        remoteDb.save(doc)

        val serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server")

        val clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client")
        val uri = startServer(remoteDb, serverIdentity, clientIdentity.certs)
            ?: throw IOException("Failed to start the server")

        Thread {
            startClient(localDb, uri, clientIdentity, serverIdentity.certs[0])
            Log.e(TAG, "Success!!")
            deleteIdentity("server")
            Log.e(TAG, "Alias deleted: server")
            deleteIdentity("client")
            Log.e(TAG, "Alias deleted: client")
        }.start()
    }

    // start a client replicator
    @Throws(CertificateEncodingException::class, InterruptedException::class)
    fun startClient(db: Database, uri: URI, clientIdentity: TLSIdentity, cert: Certificate) {
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = db,
                target = URLEndpoint(uri),
                type = ReplicatorType.PUSH_AND_PULL,
                continuous = false,
                authenticator = ClientCertificateAuthenticator(clientIdentity),
                pinnedServerCertificate = cert.encoded
            )
        )

        val completionLatch = CountDownLatch(1)

        repl.addChangeListener { change -&gt;
            if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    /<strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     *
     *
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Throws(CouchbaseLiteException::class)
    fun startServer(db: Database, serverId: TLSIdentity, certs: List&lt;Certificate?&gt;): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0, // this is the default
                disableTls = false,
                identity = serverId,
                authenticator = ListenerCertificateAuthenticator(certs)
            )
        )
        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
    /</strong>
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    @Throws(
        KeyStoreException::class,
        CertificateException::class,
        NoSuchAlgorithmException::class,
        IOException::class
    )
    fun deleteIdentity(alias: String?) {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        keyStore.deleteEntry(alias) <i class="conum" data-value="60"></i><b>(60)</b>
    }
    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /<strong>
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     *
     *
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    @Throws(CertificateEncodingException::class)
    private fun configureClientCerts(
        config: ReplicatorConfiguration,
        cert: Certificate,
        clientIdentity: TLSIdentity
    ) {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(ClientCertificateAuthenticator(clientIdentity))

        // Configure the pinned certificate passing a byte array.
        config.pinnedServerCertificate = cert.encoded
    }
    // notend::p2p-tlsid-tlsidentity-with-label[]
    /</strong>
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     *
     *
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    @Throws(IOException::class)
    private fun readCertMaterialFromBundle(
        context: Context,
        resId: Int
    ): ByteArray {
        val out = ByteArrayOutputStream()
        val <code>in</code> = context.resources.openRawResource(resId)
        val buf = ByteArray(1024)
        var n: Int
        while (<code>in</code>.read(buf).also { n = it } &gt;= 0) {
            out.write(buf, 0, n)
        }
        return out.toByteArray()
    }
}

@Suppress("unused")
class KtPasswordAuthListener {
    companion object {
        private const val VALID_USER = "Minnie"
        private val VALID_PASSWORD = "let me in!".toCharArray()
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray())
            ?: throw IOException("Failed to start the server")
        Thread {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb)
                Log.e(TAG, "Success!!")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }.start()
    }

    // start a client replicator
    @Throws(InterruptedException::class)
    fun runClient(
        uri: URI,
        username: String,
        password: CharArray,
        db: Database
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.type = ReplicatorType.PUSH_AND_PULL
        config.isContinuous = false
        config.setAuthenticator(BasicAuthenticator(username, password))
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)

        repl.addChangeListener { change -&gt;
            if (change.status
                    .activityLevel == ReplicatorActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    /</strong>*
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     *
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    fun startServer(db: Database, username: String, password: CharArray): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0,// this is the default
                disableTls = true,
                authenticator = ListenerPasswordAuthenticator { usr, pwd -&gt;
                    (usr == username) &amp;&amp; pwd.contentEquals(password)
                })
        )

        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
}





// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Message
import com.couchbase.lite.MessageEndpoint
import com.couchbase.lite.MessageEndpointConnection
import com.couchbase.lite.MessageEndpointDelegate
import com.couchbase.lite.MessageEndpointListener
import com.couchbase.lite.MessageEndpointListenerConfigurationFactory
import com.couchbase.lite.MessagingCloseCompletion
import com.couchbase.lite.MessagingCompletion
import com.couchbase.lite.ProtocolType
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorConnection
import com.couchbase.lite.create


@Suppress("unused")
class BrowserSessionManager : MessageEndpointDelegate {
    private var replicator: Replicator? = null

    @Throws(CouchbaseLiteException::class)
    fun initCouchbase() {
        val database = Database("mydb")

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        val messageEndpoint = MessageEndpoint("UID:123", "active", ProtocolType.MESSAGE_STREAM, this)

        // Create the replicator object.
        val repl = Replicator(ReplicatorConfigurationFactory.create(database = database, target = messageEndpoint))
        // Start the replication.
        repl.start()
        replicator = repl
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    override fun createConnection(endpoint: MessageEndpoint) = ActivePeerConnection()
}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

@Suppress("unused")
class ActivePeerConnection : MessageEndpointConnection {
    private var replicatorConnection: ReplicatorConnection? = null

    fun disconnect() {
        replicatorConnection?.close(null)
        replicatorConnection = null
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete()
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun send(message: Message, completion: MessagingCompletion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null)
    }

    fun receive(message: Message) {
        replicatorConnection?.receive(message)
    }
}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

@Suppress("unused")
class PassivePeerConnection private constructor() : MessageEndpointConnection {
    private var messageEndpointListener: MessageEndpointListener? = null
    private var replicatorConnection: ReplicatorConnection? = null

    @Throws(CouchbaseLiteException::class)
    fun startListener() {
        val database = Database("mydb")
        messageEndpointListener = MessageEndpointListener(
            MessageEndpointListenerConfigurationFactory.create(database, ProtocolType.MESSAGE_STREAM)
        )
    }

    fun stopListener() {
        messageEndpointListener?.closeAll()
    }

    fun accept() {
        val connection = PassivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        messageEndpointListener?.accept(connection)
    }

    fun disconnect() {
        replicatorConnection?.close(null)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete()
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun send(message: Message, completion: MessagingCompletion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null)
    }

    fun receive(message: Message) {
        replicatorConnection?.receive(message)
    }

}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.</strong>
import com.couchbase.lite.Function
import com.fasterxml.jackson.databind.ObjectMapper
import org.json.JSONException


private const val TAG = "QUERY"
private const val DATABASE_NAME = "database"

data class Hotel(
    var description: String? = null,
    var country: String? = null,
    var city: String? = null,
    var name: String? = null,
    var type: String? = null,
    var id: String? = null
)

@Suppress("unused")
class QueryExamples(private val database: Database) {

    // </mark># Indexing
    @Throws(CouchbaseLiteException::class)
    fun testIndexing() {
        database.createIndex( "TypeNameIndex",
              ValueIndexConfiguration( "type", "name")
    }

    fun testIndexing_Querybuilder() {
        database.createIndex(
            "TypeNameIndex",
            IndexBuilder.valueIndex(
                ValueIndexItem.property("type"),
                ValueIndexItem.property("name")
            )
        )
    }

    // <mark># SELECT statement
    fun testSelectStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("type")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.expression(Meta.id))
            .execute()

        for (result in rs) {
            Log.i(TAG, "hotel id -&gt;${result.getString("id")}")
            Log.i(TAG, "hotel name -&gt; ${result.getString("name")}")
        }
      }

      // META function
      @Throws(CouchbaseLiteException::class)
      fun testMetaFunction() {
        val rs = QueryBuilder
        .select(SelectResult.expression(Meta.id))
        .from(DataSource.database(database))
        .where(Expression.property("type").equalTo(Expression.string("airport")))
        .orderBy(Ordering.expression(Meta.id))
        .execute()

        for (result in rs) {
          Log.w(TAG, "airport id -&gt;${result.getString("id")}")
          Log.w(TAG, "airport id -&gt; ${result.getString(0)}")
        }
      }

      // </mark># all(<strong>)
    @Throws(CouchbaseLiteException::class)
    fun testSelectAll() {
        val queryAll = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))

        val query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="61"></i><b>(61)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        val token = query.addChangeListener { change -&gt;
            change.results?.let {
                for (result in it) {
                    Log.d(TAG, "results: ${result.keys}")
                    /</strong> Update UI <strong>/
                }
            } <i class="conum" data-value="62"></i><b>(62)</b>
        }


        query.removeChangeListener(token)

        for (result in query.execute()) {
            Log.i(TAG, "hotel -&gt; ${result.getDictionary(DATABASE_NAME)?.toMap()}")
        }
    }


    // <mark>#WHERE statement
    @Throws(CouchbaseLiteException::class)
    fun testWhereStatement() {
        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.intValue(10))
            .execute()
        for (result in rs) {
            result.getDictionary(DATABASE_NAME)?.let {
                Log.i(TAG, "name -&gt; ${it.getString("name")}")
                Log.i(TAG, "type -&gt; ${it.getString("type")}")
            }
        }
    }

    fun testQueryDeletedDocuments() {
        // Query documents that have been deleted
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted)
    }

    // </mark><mark>Collection Operators
    @Throws(CouchbaseLiteException::class)
    fun testCollectionStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(
                        ArrayFunction.contains(
                            Expression.property("public_likes"),
                            Expression.string("Armani Langworth")
                        )
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.getArray("public_likes")?.toList()}")
        }
    }

    // IN operator
    @Throws(CouchbaseLiteException::class)
    fun testInOperator() {
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.string("Armani").<code>in</code>(
                    Expression.property("first"),
                    Expression.property("last"),
                    Expression.property("username")
                )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.toMap()}")
        }
    }

    // Pattern Matching
    @Throws(CouchbaseLiteException::class)
    fun testPatternMatching() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // </mark># Wildcard Match
    @Throws(CouchbaseLiteException::class)
    fun testWildcardMatch() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // Wildcard Character Match
    @Throws(CouchbaseLiteException::class)
    fun testWildCharacterMatch() {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng____r"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // <mark># Regex Match
    @Throws(CouchbaseLiteException::class)
    fun testRegexMatch() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .regex(Expression.string("\\beng.*r\\b"))
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // JOIN statement
    @Throws(CouchbaseLiteException::class)
    fun testJoinStatement() {
        val rs = QueryBuilder.select(
            SelectResult.expression(Expression.property("name").from("airline")),
            SelectResult.expression(Expression.property("callsign").from("airline")),
            SelectResult.expression(Expression.property("destinationairport").from("route")),
            SelectResult.expression(Expression.property("stops").from("route")),
            SelectResult.expression(Expression.property("airline").from("route"))
        )
            .from(DataSource.database(database).<code>as</code>("airline"))
            .join(
                Join.join(DataSource.database(database).<code>as</code>("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(
                        Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline"))
                    )
                    .and(
                        Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.toMap()}")
        }
    }


    // </mark># GROUPBY statement
    @Throws(CouchbaseLiteException::class)
    fun testGroupByStatement() {
        val rs = QueryBuilder.select(
            SelectResult.expression(Function.count(Expression.string("</strong>"))),
            SelectResult.property("country"),
            SelectResult.property("tz")
        )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300)))
            )
            .groupBy(
                Expression.property("country"), Expression.property("tz")
            )
            .orderBy(Ordering.expression(Function.count(Expression.string("<strong>"))).descending())
            .execute()

        for (result in rs) {
            result.let {
                Log.i(
                    TAG,
                    "There are ${it.getInt("$1")} airports on the ${
                        it.getString("tz")
                    } timezone located in ${
                        it.getString("country")
                    } and above 300ft"
                )
            }
        }
    }

    // <mark># ORDER BY statement
    @Throws(CouchbaseLiteException::class)
    fun testOrderByStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("name").ascending())
            .limit(Expression.intValue(10))
            .execute()

        for (result in rs) {
            Log.i(TAG, "${result.toMap()}")
        }
    }


    // </mark># EXPLAIN statement
    @Throws(CouchbaseLiteException::class)
    fun testExplainStatement() {
        var query: Query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").descending()) <i class="conum" data-value="63"></i><b>(63)</b>
        Log.i(TAG, query.explain()) <i class="conum" data-value="64"></i><b>(64)</b>

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%"))) <i class="conum" data-value="65"></i><b>(65)</b>
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="66"></i><b>(66)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%")))
            )
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Function.lower(
                    Expression.property("type").equalTo(Expression.string("hotel"))
                )
            ) <i class="conum" data-value="67"></i><b>(67)</b>
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))) <i class="conum" data-value="68"></i><b>(68)</b>
        Log.i(TAG, query.explain())
    }

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex() {
        val config = FullTextIndexConfiguration("overview").ignoreAccents(false)

        database.createIndex( "overviewFTSIndex", config);
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS() {

        val ftsQuery =
              database.createQuery(
                "SELECT _id, overview FROM _ WHERE MATCH(overviewFTSIndex, 'michigan') ORDER BY RANK(overviewFTSIndex)")

        ftsQuery.execute().allResults().forEach {
          Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}")
        }

    }

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex_Querybuilder() {
        database.createIndex(
            "overviewFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("overview")).ignoreAccents(false)
        )
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS_Querybuilder() {

        val ftsQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id),
                                  SelectResult.expression(overview))
                          .from(DataSource.database(database))
                          .where(FullTextFunction.match("overviewFTSIndex", "michigan"))
                          .execute()

        ftsQuery.execute().allResults().forEach {
          Log.i(TAG, "${result.getString("Meta.id")}: ${result.getString("overview")}")
          }



    }


    fun testQuerySyntaxAll(currentUser: String) {
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(openOrCreateDatabaseForUser(currentUser)))

        val hotels: HashMap&lt;String, Hotel&gt; = HashMap()

        for (result in listQuery.execute().allResults()) {
            // get the k-v pairs from the 'hotel' key's value into a dictionary
            val thisDocsProps = result.getDictionary(0) <i class="conum" data-value="69"></i><b>(69)</b>
            val thisDocsId = thisDocsProps!!.getString("id")
            val thisDocsName = thisDocsProps.getString("name")
            val thisDocsType = thisDocsProps.getString("type")
            val thisDocsCity = thisDocsProps.getString("city")

            // Alternatively, access results value dictionary directly
            val id = result.getDictionary(0)?.getString("id").toString() <i class="conum" data-value="70"></i><b>(70)</b>
            hotels[id] = Hotel(
                id,
                result.getDictionary(0)?.getString("type"),
                result.getDictionary(0)?.getString("name"),
                result.getDictionary(0)?.getString("city"),
                result.getDictionary(0)?.getString("country"),
                result.getDictionary(0)?.getString("description")
            )
        }

    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun testQuerySyntaxJson(currentUser: String, argDb: Database) {
        val db = argDb
        // Example assumes Hotel class object defined elsewhere

        // Build the query
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(db))

        // Uses Jackson JSON processor
        val mapper = ObjectMapper()
        val hotels: ArrayList&lt;Hotel&gt; = ArrayList()

        for (result in listQuery.execute()) {

            // Get result as JSON string
            val json = result.toJSON() <i class="conum" data-value="71"></i><b>(71)</b>

            // Get Hashmap from JSON string
            val dictFromJSONstring = mapper.readValue(json, HashMap::class.java) <i class="conum" data-value="72"></i><b>(72)</b>

            // Use created hashmap
            val hotelId = dictFromJSONstring["id"].toString() //
            val hotelType = dictFromJSONstring["type"].toString()
            val hotelname = dictFromJSONstring["name"].toString()


            // Get custom object from JSON string
            val thisHotel = mapper.readValue(json, Hotel::class.java) <i class="conum" data-value="73"></i><b>(73)</b>
            hotels.add(thisHotel)
        }
    }
/</strong> end func testQuerySyntaxJson <strong>/



    fun testQuerySyntaxProps(currentUser: String) {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
            Log.i(TAG, "Hotel name -&gt; ${result.getString("name")}, in ${result.getString("country")}" )
        }
    }

    fun testQuerySyntaxCount(currentUser: String) {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.string("</strong>"))).as("mycount")) <i class="conum" data-value="74"></i><b>(74)</b>
            .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
            Log.i(TAG, "name -&gt; ${result.getInt("mycount").toString()}")
        }
    }


    fun testQuerySyntaxId(currentUser: String) {
        // tag::query-select-meta

        val rs = QueryBuilder
        .select(
          SelectResult.expression(Meta.id).as("hotelId"))
          .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
          Log.i(TAG, "hotel id -&gt;${result.getString("hotelId")}")
        }
        // end::query-select-meta
    }


    fun docsOnlyQuerySyntaxN1QL(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      val db = argDb
      val thisQuery = db.createQuery(
            "SELECT META().id AS id FROM _ WHERE type = \"hotel\"") <i class="conum" data-value="75"></i><b>(75)</b>

      return thisQuery.execute().allResults()

  }

  fun docsOnlyQuerySyntaxN1QLParams(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      val db = argDb
      val thisQuery = db.createQuery(
            "SELECT META().id AS id FROM _ WHERE type = \$type") <i class="conum" data-value="76"></i><b>(76)</b>

      thisQuery.parameters = Parameters().setString("type", "hotel") <i class="conum" data-value="77"></i><b>(77)</b>

      return thisQuery.execute().allResults()

  }

  fun testQuerySyntaxPagination(currentUser: String) {
    val limit = 20
    val offset = 0

    val rs = QueryBuilder
      .select(SelectResult.all())
      .from(DataSource.database(database))
      .where(Expression.property("type").equalTo(Expression.string("hotel")))
      .limit(Expression.intValue(limit), Expression.intValue(offset))

  }

    fun openOrCreateDatabaseForUser(argUser: String): Database = Database(argUser) {

    }



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/JSONExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.*
import org.json.JSONException
import org.json.JSONObject


const val JSON = """[{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\",
        \"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},
        {\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\",
        \"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},
        {\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",
        \"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\",
        \"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]"""


class KtJSONExamples {
    private val TAG = "SNIPPETS"

    fun jsonArrayExample(db: Database) {
        // github tag=tojson-array
        val mArray = MutableArray(JSON) <i class="conum" data-value="78"></i><b>(78)</b>
        for (i in 0 until mArray.count()) {
            mArray.getDictionary(i)?.apply {
                Log.i(TAG, getString("name") ?: "unknown")
                db.save(MutableDocument(getString("id"), toMap()))
            } <i class="conum" data-value="79"></i><b>(79)</b>
        }

        db.getDocument("1002")?.getArray("features")?.apply {
            for (feature in toList()) {
                Log.i(TAG, "$feature")
            } <i class="conum" data-value="80"></i><b>(80)</b>
            Log.i(TAG, toJSON())
        } <i class="conum" data-value="81"></i><b>(81)</b>
    }

    fun jsonBlobExample(db: Database) {
        // github tag=tojson-blob
        val thisBlob = db.getDocument("thisdoc-id")!!.toMap()
        if (!Blob.isBlob(thisBlob)) {
          return
        }
        val blobType = thisBlob["content_type"].toString()
        val blobLength = thisBlob["length"] as Number?
    }

    fun jsonDictionaryExample() {
        // github tag=tojson-dictionary
        val mDict = MutableDictionary(JSON) <i class="conum" data-value="82"></i><b>(82)</b>
        Log.i(TAG, "$mDict")
        Log.i(TAG, "Details for: ${mDict.getString("name")}")
        for (key in mDict.keys) {
          Log.i(TAG, key + " =&gt; " + mDict.getValue(key))
        }
      }

      @Throws(CouchbaseLiteException::class)
      fun jsonDocumentExample(srcDb: Database, dstDb: Database) {
        QueryBuilder
        .select(SelectResult.expression(Meta.id).as("metaId"))
        .from(DataSource.database(srcDb))
        .execute()
        .forEach {
          it.getString("metaId")?.let { thisId -&gt;
            srcDb.getDocument(thisId)?.toJSON()?.let { json -&gt; <i class="conum" data-value="83"></i><b>(83)</b>
              Log.i(TAG, "JSON String = $json")
              val hotelFromJSON = MutableDocument(thisId, json) <i class="conum" data-value="84"></i><b>(84)</b>
              dstDb.save(hotelFromJSON)
              dstDb.getDocument(thisId)?.toMap()?.forEach { e -&gt;
                Log.i(TAG, "$e.key =&gt; $e.value")
              } <i class="conum" data-value="85"></i><b>(85)</b>
            }
          }
        }
    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun jsonQueryExample(query: Query) {
        query.execute().forEach {

            // Use a Json Object to populate Native object
            JSONObject(it.toJSON()).apply {
                val (description, country, city, name, type, id) = Hotel(
                    id = getString("id"),
                    type = getString("type"),
                    name = getString("name"),
                    city = getString("city"),
                    country = "Ghana, West Africa",
                    description = "this hotel"
                )
            }
        }
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/JSONExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.Database
import com.couchbase.lite.MutableDictionary

class KtBlobExamples {

    // Example 2: Using Blobs
    fun example2(context: Context, db: Database) {
        val doc = db.getDocument("1000") ?: return

        // Create a blob from an asset
        val blob = Blob("image/png", context.assets.open("couchbaseimage.png"))

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON()

        // Save the blob as part of a document
        db.save(doc.toMutable().setBlob("avatar", blob))

        // Experts only!!!
        db.saveBlob(blob)

        // Retrieve saved blob and get as JSON again
        val blobAsJSONString = db.getDocument("1000")?.getBlob("avatar")?.toJSON() ?: return

        // reconstitute
        val blobAsMap = MutableDictionary().setJSON(blobAsJSONString).toMap()

        // show the contents of the reconstituted blob
        for key, value) in blobAsMap) {             Log.d("BLOB", "Data: $key -&gt; $value")         }          // verify that the reconstitued thing is still blob         if (Blob.isBlob(blobAsMap {
            Log.d("BLOB", blobAsJSONString)
        }
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt </code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset3_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">

// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/PasswordAuthListener.java 
//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorActivityLevel;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorType;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);                 Log.e(TAG, "Success!!");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void runClient(         @NonNull URI uri,         @NonNull String username,         @NonNull char[] password,         @NonNull Database db) throws InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setType(ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }

    /<strong>
     * Snippet 1: create a ListenerPasswordAuthenticator and configure the listener with it
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     * NOTE: This requires the following, in the manifest
     *     &lt;application
     *         ...
     *         android:usesCleartextTraffic="true"
     *         ...
     *     &gt;
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password)
        throws CouchbaseLiteException {
        final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

        config.setPort(0); // this is the default
        config.setDisableTls(true);
        config.setAuthenticator(new ListenerPasswordAuthenticator(
            (user, pwd) -&gt; username.equals(user) &amp;&amp; Arrays.equals(password, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/PasswordAuthListener.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/BlobExamples.java 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.util.Log;

import java.io.IOException;
import java.util.Map;

import com.couchbase.lite.Blob;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.Document;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;


class BlobExamples {

    // Example 2: Using Blobs
    public void example2(final Context context, final Database db) throws IOException, CouchbaseLiteException {
        final Document doc = db.getDocument("1000");
        if (doc == null) { return; }

        // Create a blob from an asset
        final Blob blob = new Blob("image/png", context.getAssets().open("couchbaseimage.png"));

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON();

        // Save the blob as part of a document
        final MutableDocument mDoc = doc.toMutable();
        mDoc.setBlob("avatar", blob);
        db.save(mDoc);

        // Experts only!!!
        db.saveBlob(blob);

        // Retrieve saved blob
        final Document sameDoc = db.getDocument("1000");
        if (sameDoc == null) { return; }

        final Blob sameBlob = sameDoc.getBlob("avatar");
        if (sameBlob == null) { return; }

        // Get as JSON again
        final String blobAsJSONString = sameBlob.toJSON();

        // reconstitute
        final Map&lt;String, Object&gt; blobAsMap = new MutableDictionary().setJSON(blobAsJSONString).toMap();

        // show the contents of the reconstituted blob
        for (Map.Entry&lt;String, Object&gt; entry: blobAsMap.entrySet()) {
            Log.d("BLOB", "Data: " + entry.getKey() + " -&gt; " + entry.getValue());
        }

        // verify that the reconstitued thing is still blob
        if (Blob.isBlob(blobAsMap)) { Log.d("BLOB", blobAsJSONString); }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/BlobExamples.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/MainActivity.java 
package com.couchbase.code_snippets;

import android.os.Bundle;

import androidx.appcompat.app.AppCompatActivity;


public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/MainActivity.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/CertAuthListener.java 

//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorActivityLevel;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorType;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);                 Log.e(TAG, "Success!!");                 deleteIdentity("server");                 Log.e(TAG, "Alias deleted: server");                 deleteIdentity("client");                 Log.e(TAG, "Alias deleted: client");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void startClient(         @NonNull URI uri,         @NonNull Certificate cert,         @NonNull TLSIdentity clientIdentity,         @NonNull Database db) throws CertificateEncodingException, InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setType(ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }

    /</strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
        throws CouchbaseLiteException {
        final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

        config.setPort(0); // this is the default
        config.setDisableTls(false);
        config.setTlsIdentity(serverId);
        config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
    }

    /<strong>
     * Snippet 3: delete an identity from the keystore
     * (NOTE: a keystore doesn't contain TLSIdentities: I'm guessing that this is what you intend)
     * &lt;p&gt;
     * Delete an identity from the key store.
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
        throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

        final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);

        keyStore.deleteEntry(alias);
    }

    /</strong>
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     * &lt;p&gt;
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    private void configureClientCerts(
        ReplicatorConfiguration config,
        @NonNull Certificate cert,
        @NonNull TLSIdentity clientIdentity)
        throws CertificateEncodingException {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
    }

    /<strong>
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     * &lt;p&gt;
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte[] buf = new byte[1024];
        int n;
        while n = in.read(buf &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/CertAuthListener.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java 
//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import androidx.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;
import com.example.docsnippet.Datastore;
import com.example.docsnippet.Hotel;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class docOnly_Examples {
  private static final String TAG = "EXAMPLE";

  private static final String DATABASE_NAME = "database";

  private final Context context;
  private Database database;
  private Replicator replicator;

  public docOnly_Examples(Context context) { this.context = context; }

  //@Test
  public void testGettingStarted() throws CouchbaseLiteException, URISyntaxException {

    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);

    // Get the database (and create it if it doesnt exist).
    DatabaseConfiguration config = new DatabaseConfiguration();

    config.setDirectory(context.getFilesDir().getAbsolutePath());

    Database database = new Database("getting-started", config);


    // Create a new document (i.e. a record) in the database.
    MutableDocument mutableDoc = new MutableDocument()
    .setFloat("version", 2.0F)
    .setString("type", "SDK");

    // Save it to the database.
    database.save(mutableDoc);

    // Update a document.
    mutableDoc = database.getDocument(mutableDoc.getId()).toMutable();
    mutableDoc.setString("language", "Java");
    database.save(mutableDoc);
    Document document = database.getDocument(mutableDoc.getId());
    // Log the document ID (generated by the database) and properties
    Log.i(TAG, "Document ID :: " + document.getId());
    Log.i(TAG, "Learning " + document.getString("language"));

    // Create a query to fetch documents of type SDK.
    Query query = QueryBuilder.select(SelectResult.all())
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("SDK")));
    ResultSet result = query.execute();
    Log.i(TAG, "Number of rows ::  " + result.allResults().size());

    // Create replicators to push and pull changes to and from the cloud.
    Endpoint targetEndpoint = new URLEndpoint(new URI("ws://localhost:4984/getting-started-db"));
    ReplicatorConfiguration replConfig = new ReplicatorConfiguration(database, targetEndpoint);
    replConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Add authentication.
    replConfig.setAuthenticator(new BasicAuthenticator("sync-gateway", "password"));

    // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
    Replicator replicator = new Replicator(replConfig);

    // Listen to replicator change events.
    replicator.addChangeListener(change -&gt; {
      if (change.getStatus().getError() != null) {
        Log.i(TAG, "Error code ::  " + change.getStatus().getError().getCode());
      }
    });

    // Start replication.
    replicator.start();


    database.delete();
  }

  public void test1xAttachments() throws CouchbaseLiteException, IOException {
    // if db exist, delete it
    deleteDB("android-sqlite", context.getFilesDir());

    ZipUtils.unzip(getAsset("replacedb/android140-sqlite.cblite2.zip"), context.getFilesDir());

    Database db = new Database("android-sqlite", new DatabaseConfiguration());
    try {

      Document doc = db.getDocument("doc1");

      // For Validation
      Dictionary attachments = doc.getDictionary("_attachments");
      Blob blob = attachments.getBlob("attach1");
      byte[] content = blob.getContent();
      // For Validation

      byte[] attach = String.format(Locale.ENGLISH, "attach1").getBytes();
      Arrays.equals(attach, content);

    } finally {
      // close db
      db.close();
      // if db exist, delete it
      deleteDB("android-sqlite", context.getFilesDir());
    }

    Document document = new MutableDocument();

    Dictionary attachments = document.getDictionary("_attachments");
    Blob blob = attachments != null ? attachments.getBlob("avatar") : null;
    byte[] content = blob != null ? blob.getContent() : null;
  }

  // <mark># Initializer
  public void testInitializer() {
    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);
  }

  // </mark># New Database
  public void testNewDatabase() throws CouchbaseLiteException {
    final DatabaseConfiguration config = new DatabaseConfiguration();
    config.setDirectory(context.getFilesDir().getAbsolutePath()); <i class="conum" data-value="1"></i><b>(1)</b>

    Database database = new Database("my-database", config);

    database.close();


    database.delete();
  }

  // <mark># Database Encryption
  public void testDatabaseEncryption() throws CouchbaseLiteException {
    DatabaseConfiguration config = new DatabaseConfiguration();
    config.setEncryptionKey(new EncryptionKey("PASSWORD"));
    Database database = new Database("mydb", config);
  }

  // </mark># Logging
  public void testLogging() {
    Database.setLogLevel(LogDomain.DATABASE, LogLevel.VERBOSE);
    Database.setLogLevel(LogDomain.QUERY, LogLevel.VERBOSE);
    }

    public void testEnableCustomLogging() {
        Database.log.setCustom(new LogTestLogger(LogLevel.WARNING)); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    // <mark># Console logging
    public void testConsoleLogging() throws CouchbaseLiteException {
          Database.log.getConsole().setDomain(LogDomain.ALL_DOMAINS);  <i class="conum" data-value="3"></i><b>(3)</b>
          Database.log.getConsole().setLevel(LogLevel.VERBOSE); <i class="conum" data-value="4"></i><b>(4)</b>
          Database.log.getConsole().setDomain(LogDomain.DATABASE);

    }

    // </mark># File logging
    public void testFileLogging() throws CouchbaseLiteException {
        final File path = context.getCacheDir();

        LogFileConfiguration LogCfg =
          new LogFileConfiguration(path.toString()); <i class="conum" data-value="5"></i><b>(5)</b>
        LogCfg.setMaxSize(10240); <i class="conum" data-value="6"></i><b>(6)</b>
        LogCfg.setMaxRotateCount(5); <i class="conum" data-value="7"></i><b>(7)</b>
        LogCfg.setUsePlainText(false); <i class="conum" data-value="8"></i><b>(8)</b>
        Database.log.getFile().setConfig(LogCfg);
        Database.log.getFile().setLevel(LogLevel.INFO); <i class="conum" data-value="9"></i><b>(9)</b>
    }

    public void writeConsoleLog()
    {
        Database.log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }
    public void writeCustomLog()
    {
        Database.log.Custom?.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }


    public void writeFileLog()
    {
        Database.log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }




    // <mark># Loading a pre-built database
    public void testPreBuiltDatabase() throws IOException {
      // Note: Getting the path to a database is platform-specific.
      // For Android you need to extract it from your
      // assets to a temporary directory and then pass that path to Database.copy()
      DatabaseConfiguration configuration = new DatabaseConfiguration();
      if (!Database.exists("travel-sample", context.getFilesDir())) {
            ZipUtils.unzip(getAsset("travel-sample.cblite2.zip"), context.getFilesDir());
            File path = new File(context.getFilesDir(), "travel-sample");
            try {
                Database.copy(path, "travel-sample", configuration);
            } catch (CouchbaseLiteException e) {
                e.printStackTrace();
            }
        }
    }

    // helper methods

    // if db exist, delete it
    private void deleteDB(String name, File dir) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            // sometimes, db is still in used, wait for a while. Maximum 3 sec
            for (int i = 0; i &lt; 10; i) {
                try {
                    Database.delete(name, dir);
                    break;
                } catch (CouchbaseLiteException ex) {
                    try { Thread.sleep(300); }
                    catch (InterruptedException ignore) { }
                }
            }
        }
    }

    // ### Initializers
    public void testInitializers() {
        MutableDocument newTask = new MutableDocument();
        newTask.setString("type", "task");
        newTask.setString("owner", "todo");
        newTask.setDate("createdAt", new Date());
        try {
            database.save(newTask);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // ### Mutability
    public void testMutability() {
        try { database.save(new MutableDocument("xyz")); }
        catch (CouchbaseLiteException ignore) { }

        Document document = database.getDocument("xyz");
        MutableDocument mutableDocument = document.toMutable();
        mutableDocument.setString("name", "apples");
        try {
            database.save(mutableDocument);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // ### Typed Accessors
    public void testTypedAccessors() {
        MutableDocument newTask = new MutableDocument();

        newTask.setValue("createdAt", new Date());
        Date date = newTask.getDate("createdAt");
    }

    // ### Batch operations
    public void testBatchOperations() {
        try {
            database.inBatch(() -&gt; {
                for (int i = 0; i &lt; 10; i) {
                    MutableDocument doc = new MutableDocument();
                    doc.setValue("type", "user");
                    doc.setValue("name", "user " + i);
                    doc.setBoolean("admin", false);
                    try {
                        database.save(doc);
                    } catch (CouchbaseLiteException e) {
                        Log.e(TAG, e.toString());
                    }
                    Log.i(TAG, String.format("saved user document %s", doc.getString("name")));
                }
            });
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // </mark># Document Expiration
    public void DocumentExpiration() throws CouchbaseLiteException {
        // Purge the document one day from now
        Instant ttl = Instant.now().plus(1, ChronoUnit.DAYS);
        database.setDocumentExpiration("doc123", new Date(ttl.toEpochMilli()));

        // Reset expiration
        database.setDocumentExpiration("doc1", null);

        // Query documents that will be expired in less than five minutes
        Instant fiveMinutesFromNow = Instant.now().plus(5, ChronoUnit.MINUTES);
        Query query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.expiration.lessThan(Expression.doubleValue(fiveMinutesFromNow.toEpochMilli())));
    }

    public void testDocumentChangeListener() throws CouchbaseLiteException {
        database.addDocumentChangeListener(
            "user.john",
            change -&gt; {
                Document doc = database.getDocument(change.getDocumentID());
                if (doc != null) {
                    Toast.makeText(context, "Status: " + doc.getString("verified_account"), Toast.LENGTH_SHORT).show();
                }
            });
    }

    // <mark># Blobs
    public void testBlobs() {
        MutableDocument newTask = new MutableDocument();

        InputStream is = getAsset("avatar.jpg"); <i class="conum" data-value="10"></i><b>(10)</b>
        if (is == null) { return; }
        try {
            Blob blob = new Blob("image/jpeg", is); <i class="conum" data-value="11"></i><b>(11)</b>
            newTask.setBlob("avatar", blob); <i class="conum" data-value="12"></i><b>(12)</b>
            database.save(newTask);

            Blob taskBlob = newTask.getBlob("avatar");
            byte[] bytes = taskBlob.getContent();
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        } finally {
            try { is.close(); }
            catch (IOException ignore) { }
        }
    }

    // </mark># Indexing
    public void testIndexing() throws CouchbaseLiteException {
        // For Documentation
        {

            database.createIndex(ValueIndexConfiguration(["type", "name"]), "TypeNameIndex");

        }
    }

    public void testIndexing_Querybuilder() throws CouchbaseLiteException {
        // For Documentation
        {
            database.createIndex(
                "TypeNameIndex",
                IndexBuilder.valueIndex(
                    ValueIndexItem.property("type"),
                    ValueIndexItem.property("name")));
        }
    }

    // <mark># SELECT statement
    public void testSelectStatement() {
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("type"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.expression(Meta.id));

            try {
                ResultSet rs = query.execute();
                for (Result result : rs) {
                    Log.i("Sample", String.format("hotel id -&gt; %s", result.getString("id")));
                    Log.i("Sample", String.format("hotel name -&gt; %s", result.getString("name")));
                }
            } catch (CouchbaseLiteException e) {
                Log.e("Sample", e.getLocalizedMessage());
            }
          }
        }

        // META function
        public void testMetaFunction() throws CouchbaseLiteException {
          // For Documentation
          {
          Query query = QueryBuilder
          .select(SelectResult.expression(Meta.id))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("airport")))
          .orderBy(Ordering.expression(Meta.id));
          ResultSet rs = query.execute();
          for (Result result : rs) {
            Log.w("Sample", String.format("airport id -&gt; %s", result.getString("id")));
            Log.w("Sample", String.format("airport id -&gt; %s", result.getString(0)));
          }
        }
    }

    // </mark># all(</strong>)
    public void testSelectAll() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")));

            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database)); <i class="conum" data-value="13"></i><b>(13)</b>

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            ListenerToken token = query.addChangeListener(change -&gt; { <i class="conum" data-value="14"></i><b>(14)</b>
                for (Result result : change.getResults()) {
                    Log.d(TAG, "results: " + result.getKeys());
                    /* Update UI <strong>/
                }
            });


            query.removeChangeListener(token); <i class="conum" data-value="15"></i><b>(15)</b>


            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("hotel -&gt; %s", result.getDictionary(DATABASE_NAME).toMap()));
            }
        }
    }

    // <mark>#WHERE statement
    public void testWhereStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .limit(Expression.intValue(10));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Dictionary all = result.getDictionary(DATABASE_NAME);
                Log.i("Sample", String.format("name -&gt; %s", all.getString("name")));
                Log.i("Sample", String.format("type -&gt; %s", all.getString("type")));
            }
        }
    }

    public void testQueryDeletedDocuments() {
        // Query documents that have been deleted
        Where query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted);
    }


    // </mark><mark>Collection Operators
    public void testCollectionStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("public_likes"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction
                        .contains(Expression.property("public_likes"), Expression.string("Armani Langworth"))));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("public_likes -&gt; %s", result.getArray("public_likes").toList()));
            }
        }
    }

    // IN operator
    public void testInOperator() throws CouchbaseLiteException {
        // For Documentation
        {
            Expression[] values = new Expression[] {
                Expression.property("first"),
                Expression.property("last"),
                Expression.property("username")
            };

            Query query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.string("Armani").in(values));

            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // Pattern Matching
    public void testPatternMatching() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Function.Expression.string("royal engineers museum")))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // </mark># Wildcard Match
    public void testWildcardMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng%e%"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // Wildcard Character Match
    public void testWildCharacterMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng____r"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // <mark># Regex Match
    public void testRegexMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).regex(Expression.string("\\beng.*r\\b"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // JOIN statement
    public void testJoinStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder.select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route")))
                .from(DataSource.database(database).as("airline"))
                .join(Join.join(DataSource.database(database).as("route"))
                    .on(Meta.id.from("airline").equalTo(Expression.property("airlineid").from("route"))))
                .where(Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline").equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route").equalTo(Expression.string("RIX"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // </mark># GROUPBY statement
    public void testGroupByStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder.select(
                SelectResult.expression(Function.count(Expression.string("</strong>"))),
                SelectResult.property("country"),
                SelectResult.property("tz"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300))))
                .groupBy(
                    Expression.property("country"),
                    Expression.property("tz"))
                .orderBy(Ordering.expression(Function.count(Expression.string("<strong>"))).descending());
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format(
                        "There are %d airports on the %s timezone located in %s and above 300ft",
                        result.getInt("$1"),
                        result.getString("tz"),
                        result.getString("country")));
            }
        }
    }

    // <mark># ORDER BY statement
    public void testOrderByStatement() throws CouchbaseLiteException {
      // For Documentation
      {
        Query query = QueryBuilder
        .select(
          SelectResult.expression(Meta.id),
          SelectResult.property("name"))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("hotel")))
          .orderBy(Ordering.property("name").ascending())
          .limit(Expression.intValue(10));
          ResultSet rs = query.execute();
          for (Result result : rs) { Log.i("Sample", String.format("%s", result.toMap())); }
        }
      }
      // </mark># EXPLAIN statement
      public void testExplainStatement() throws CouchbaseLiteException {
          // For Documentation
          {
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("university")))
                .groupBy(Expression.property("country"))
                .orderBy(Ordering.property("name").descending()); <i class="conum" data-value="16"></i><b>(16)</b>
              Log.i(query.explain()); <i class="conum" data-value="17"></i><b>(17)</b>
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("%hotel%"))); <i class="conum" data-value="18"></i><b>(18)</b>
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="19"></i><b>(19)</b>
                  .and(Expression.property("name").like(Expression.string("%royal%"))));
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))); <i class="conum" data-value="20"></i><b>(20)</b>
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="21"></i><b>(21)</b>
              Log.i(query.explain());
          }
      }
      // end query-explain

    void prepareIndex() throws CouchbaseLiteException {

        FullTextIndexConfiguration config = new FullTextIndexConfiguration("Overview").ignoreAccents(false)

        database.createIndex( config, "overviewFTSIndex")

    }

    void prepareIndex_Querybuilder() throws CouchbaseLiteException {
      database.createIndex(
          "overviewFTSIndex",
          IndexBuilder.fullTextIndex(FullTextIndexItem.property("overview")).ignoreAccents(false));
  }

    public void testFTS() throws CouchbaseLiteException {

        Query ftsQuery =
                database.createQuery(
                "SELECT _id, overview FROM _ WHERE MATCH(overviewFTSIndex, 'michigan') ORDER BY RANK(overviewFTSIndex)");

        for (result in ftsQuery.execute().allResults()) {
          Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}");
        }

    }
    public void testFTS_Querybuilder() throws CouchbaseLiteException {
        Expression whereClause = FullTextFunction.match("overviewFTSIndex", "'michigan'");
        Query ftsQuery =
                QueryBuilder.select(SelectResult.expression(Meta.id),
                                    SelectResult.expression(overview)
                                  )
            .from(DataSource.database(database))
            .where(whereClause);

            for (result in ftsQuery.execute().allResults()) {
              Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}");
            }

    }

    /</strong> The <code>tag::replication[]</code> example is inlined in java.adoc <strong>/

    public void testTroubleshooting() {
        Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE);
    }

    public void testReplicationBasicAuthentication() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new BasicAuthenticator("username", "password"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationSessionAuthentication() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationStatus() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        replicator.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == Replicator.ActivityLevel.STOPPED) {
                Log.i(TAG, "Replication stopped");
            }
          });
        }

    //  BEGIN PendingDocuments BM -- 19/Feb/21 --
    import android.support.annotation.NonNull;
    import android.util.Log;

    import java.net.URI;
    import java.net.URISyntaxException;
    import java.util.Iterator;
    import java.util.Set;

    import com.couchbase.lite.CouchbaseLiteException;
    import com.couchbase.lite.Database;
    import com.couchbase.lite.Endpoint;
    import com.couchbase.lite.Replicator;
    import com.couchbase.lite.ReplicatorConfiguration;
    import com.couchbase.lite.URLEndpoint;

    class PendingDocsExample {
        private static final String TAG = "SCRATCH";

        private Database database;
        private Replicator replicator;

        //  BEGIN PendingDocuments IB -- 11/Feb/21 --
        public void testReplicationPendingDocs() throws URISyntaxException, CouchbaseLiteException {
            // nottag::replication-pendingdocuments[]
            // ... include other code as required
            //
            final Endpoint endpoint =
              new URLEndpoint(new URI("ws://localhost:4984/db"));

            final ReplicatorConfiguration config =
              new ReplicatorConfiguration(database, endpoint)
            .setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

            replicator = new Replicator(config);
            final Set&lt;String&gt; pendingDocs =
              replicator.getPendingDocumentIds(); <i class="conum" data-value="22"></i><b>(22)</b>


            replicator.addChangeListener(change -&gt; {
              onStatusChanged(pendingDocs, change.getStatus()); });

            replicator.start();

            // ... include other code as required
            // notend::replication-pendingdocuments[]
          }
        //
        //
        private void onStatusChanged(
          @NonNull final Set&lt;String&gt; pendingDocs,
          @NonNull final Replicator.Status status) {
          // ... sample onStatusChanged function
          //
          Log.i(TAG,
            "Replicator activity level is " + status.getActivityLevel().toString());

          // iterate and report-on previously
          // retrieved pending docids 'list'
          for (Iterator&lt;String&gt; itr = pendingDocs.iterator(); itr.hasNext(); ) {
            final String docId = itr.next();
            try {
              if (!replicator.isDocumentPending(docId)) { continue; } <i class="conum" data-value="23"></i><b>(23)</b>

              itr.remove();
              Log.i(TAG, "Doc ID " + docId + " has been pushed");
            }
            catch (CouchbaseLiteException e) {
              Log.w(TAG, "isDocumentPending failed", e); }
          }
        }
        //  END PendingDocuments BM -- 19/Feb/21 --
    }


    public void testHandlingNetworkErrors() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        replicator.addChangeListener(change -&gt; {
            CouchbaseLiteException error = change.getStatus().getError();
            if (error != null) { Log.w(TAG, "Error code:: %d", error); }
        });
        replicator.start();

        replicator.stop();
    }

    public void testReplicatorDocumentEvent() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        ListenerToken token = replicator.addDocumentReplicationListener(replication -&gt; {

            Log.i(TAG, "Replication type: " + replication.isPush( ? "Push" : "Pull"));
            for (ReplicatedDocument document : replication.getDocuments()) {
                Log.i(TAG, "Doc ID: " + document.getID());

                CouchbaseLiteException err = document.getError();
                if (err != null) {
                    // There was an error
                    Log.e(TAG, "Error replicating document: ", err);
                    return;
                }

                if (document.flags().contains(DocumentFlag.DocumentFlagsDeleted)) {
                    Log.i(TAG, "Successfully replicated a deleted document");
                }
            }
        });

        replicator.start();

        replicator.removeChangeListener(token);
    }

    public void testReplicationCustomHeader() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();
        headers.put("CustomHeaderName", "Value");
        config.setHeaders(headers);
    }

    // <mark># Certificate Pinning

    public void testCertificatePinning() throws URISyntaxException, IOException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);

        InputStream is = getAsset("cert.cer");
        byte[] cert = IOUtils.toByteArray(is);
        if (is != null) {
            try { is.close(); }
            catch (IOException ignore) {}
        }

        config.setPinnedServerCertificate(cert);
    }

    // </mark># Reset replicator checkpoint
    public void testReplicationResetCheckpoint() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        if (resetCheckpointRequired_Example) {
          replicator.start(true); <i class="conum" data-value="24"></i><b>(24)</b>
        else
          replicator.start(false);
        }

        // ... at some later time

        replicator.stop();
    }

    public void testReplicationPushFilter() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPushFilterdocument, flags) -&gt; flags.contains(DocumentFlag.DocumentFlagsDeleted; <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationPullFilter() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPullFilterdocument, flags) -&gt; "draft".equals(document.getString("type"); <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testCustomRetryConfig() throws URISyntaxException {
    URLEndpoint target =
    new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

    ReplicatorConfiguration config =
    new ReplicatorConfiguration(database, target);

    //  other config as required . . .
    config.setHeartbeat(150L); <i class="conum" data-value="25"></i><b>(25)</b>
    config.setMaxattempts(20L); <i class="conum" data-value="26"></i><b>(26)</b>
    config.setMaxAttemptWaitTime(600L); <i class="conum" data-value="27"></i><b>(27)</b>

    Replicator repl = new Replicator(config);

    }


    public void docsSetAutoPurge() throws CouchbaseliteException {

      DatabaseConfiguration config = new DatabaseConfiguration();
      Database database1 = new Database("mydb", config);

      ReplicatorConfiguration repcfg =
      new ReplicatorConfiguration(database, target);

      repcfg.setAutoPurgeEnabled(true); <i class="conum" data-value="28"></i><b>(28)</b>

    }


    public void testDatabaseReplica() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database1 = new Database("mydb", config);

        config = new DatabaseConfiguration();
        Database database2 = new Database("db2", config);

        /</strong> EE feature: code below might throw a compilation error
           if it's compiled against CBL Android Community. <strong>/
        DatabaseEndpoint targetDatabase = new DatabaseEndpoint(database2);
        ReplicatorConfiguration replicatorConfig = new ReplicatorConfiguration(database1, targetDatabase);
        replicatorConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(replicatorConfig);
        replicator.start();
    }

    public void testPredictiveModel() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Database.prediction.registerModel("ImageClassifier", new ImageClassifierModel());

        ValueIndex index = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")));
        database.createIndex("value-index-image-classifier", index);

        Database.prediction.unregisterModel("ImageClassifier");
    }

    public void testPredictiveIndex() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Map&lt;String, Object&gt; inputMap = new HashMap&lt;&gt;();
        inputMap.put("numbers", Expression.property("photo"));
        Expression input = Expression.map(inputMap);

        PredictiveIndex index = IndexBuilder.predictiveIndex("ImageClassifier", input, null);
        database.createIndex("predictive-index-image-classifier", index);
    }

    public void testPredictiveQuery() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Map&lt;String, Object&gt; inputProperties = new HashMap&lt;&gt;();
        inputProperties.put("photo", Expression.property("photo"));
        Expression input = Expression.map(inputProperties);
        PredictionFunction prediction = PredictiveModel.predict("ImageClassifier", input); <i class="conum" data-value="1"></i><b>(1)</b>

        Query query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("label").equalTo(Expression.string("car"))
                .and(Expression.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))));

        // Run the query.
        ResultSet result = query.execute();
        Log.d(TAG, "Number of rows: " + result.allResults().size());
    }

    public void testReplicationWithCustomConflictResolver() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setConflictResolver(new LocalWinConflictResolver());

        Replicator replication = new Replicator(config);
        replication.start();
    }

    public void testSaveWithCustomConflictResolver() throws CouchbaseLiteException {
        Document doc = database.getDocument("xyz");
        if (doc == null) { return; }
        MutableDocument mutableDocument = doc.toMutable();
        mutableDocument.setString("name", "apples");

        database.save(
            mutableDocument,
            (newDoc, curDoc) -&gt; { <i class="conum" data-value="29"></i><b>(29)</b>
                if (curDoc == null) { return false; } <i class="conum" data-value="30"></i><b>(30)</b>
                Map&lt;String, Object&gt; dataMap = curDoc.toMap();
                dataMap.putAll(newDoc.toMap()); <i class="conum" data-value="31"></i><b>(31)</b>
                newDoc.setData(dataMap);
                return true; <i class="conum" data-value="32"></i><b>(32)</b>
            }); <i class="conum" data-value="33"></i><b>(33)</b>
      }
    }


&lt;.&gt; The conflict handler code is provided as a lambda.

&lt;.&gt; If the handler cannot resolve a conflict, it can return false.
In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.

&lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.

&lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).

&lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method

// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
class LocalWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getLocalDocument();
    }
}

// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
class RemoteWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getRemoteDocument();
    }
}

// Using replConfig.setConflictResolver(new MergeConflictResolver());
class MergeConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        Map&lt;String, Object&gt; merge = conflict.getLocalDocument().toMap();
        merge.putAll(conflict.getRemoteDocument().toMap());
        return new MutableDocument(conflict.getDocumentId(), merge);
    }
}


/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

class BrowserSessionManager implements MessageEndpointDelegate {
    private final Context context;
    private Replicator replicator;

    private BrowserSessionManager(Context context) { this.context = context; }

    public void initCouchbase() throws CouchbaseLiteException {
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration(context);
        Database database = new Database("mydb", databaseConfiguration);

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        MessageEndpoint messageEndpointTarget = new MessageEndpoint(
            "UID:123",
            "active",
            ProtocolType.MESSAGE_STREAM,
            this);

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, messageEndpointTarget);

        // Create the replicator object.
        replicator = new Replicator(config);
        // Start the replication.
        replicator.start();
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    @NonNull
    @Override
    public MessageEndpointConnection createConnection(@NonNull MessageEndpoint endpoint) {
        return new ActivePeerConnection(); /</strong> implements MessageEndpointConnection <strong>/
    }
}

class ActivePeerConnection implements MessageEndpointConnection {

    private ReplicatorConnection replicatorConnection;

    public void disconnect() {
        replicatorConnection.close(null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }

    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete();
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null);
    }

    public void receive(Message message) {
        replicatorConnection.receive(message);
    }

}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

class PassivePeerConnection implements MessageEndpointConnection {
    private final Context context;

    private MessageEndpointListener messageEndpointListener;
    private ReplicatorConnection replicatorConnection;

    private PassivePeerConnection(Context context) { this.context = context; }

    public void startListener() throws CouchbaseLiteException {
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration();
        Database database = new Database("mydb", databaseConfiguration);
        MessageEndpointListenerConfiguration listenerConfiguration = new MessageEndpointListenerConfiguration(
            database,
            ProtocolType.MESSAGE_STREAM);
        this.messageEndpointListener = new MessageEndpointListener(listenerConfiguration);
    }

    public void stopListener() {
        messageEndpointListener.closeAll();
    }

    public void accept() {
        PassivePeerConnection connection = new PassivePeerConnection(context); /</strong> implements
        MessageEndpointConnection <strong>/
        messageEndpointListener.accept(connection);
    }

    public void disconnect() {
        replicatorConnection.close(null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete();
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null);
    }

    public void receive(Message message) {
        replicatorConnection.receive(message);
    }
}

// tensorFlowModel is a fake implementation
// this would be the implementation of the ml model you have chosen
class ImageClassifierModel implements PredictiveModel {
    @Override
    public Dictionary predict(@NonNull Dictionary input) {
        Blob blob = input.getBlob("photo");
        if (blob == null) { return null; }

        // tensorFlowModel is a fake implementation
        // this would be the implementation of the ml model you have chosen
        return new MutableDictionary(TensorFlowModel.predictImage(blob.getContent())); <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

class TensorFlowModel {
    public static Map&lt;String, Object&gt; predictImage(byte[] data) {
        return null;
    }
}

class LogTestLogger implements Logger {
    @NonNull
    private final LogLevel level;

    public LogTestLogger(@NonNull LogLevel level) { this.level = level; }

    @NonNull
    @Override
    public LogLevel getLevel() { return level; }

    @Override
    public void log(@NonNull LogLevel level, @NonNull LogDomain domain, @NonNull String message) {
    }
}





//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);                 Log.e(TAG, "Success!!");                 deleteIdentity("server");                 Log.e(TAG, "Alias deleted: server");                 deleteIdentity("client");                 Log.e(TAG, "Alias deleted: client");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void startClient(         @NonNull URI uri,         @NonNull Certificate cert,         @NonNull TLSIdentity clientIdentity,         @NonNull Database db) throws CertificateEncodingException, InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    /</strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(false);
      config.setTlsIdentity(serverId);
      config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

      final URLEndpointListener listener = new URLEndpointListener(config);
      listener.start();

      final List&lt;URI&gt; urls = listener.getUrls();
      if (urls.isEmpty()) { return null; }
      return urls.get(0);
    }

    /<strong>
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
    throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

      final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
      keyStore.load(null);

      keyStore.deleteEntry(alias); <i class="conum" data-value="34"></i><b>(34)</b>
    }

    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /</strong> Configure Client (active) side certificates
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     <strong>/
    private void configureClientCerts(
      ReplicatorConfiguration config,
      @NonNull Certificate cert,
      @NonNull TLSIdentity clientIdentity)
      throws CertificateEncodingException {

        // Create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
      }
      // notend::p2p-tlsid-tlsidentity-with-label[]

    /</strong>
     * Copy a cert from a resource bundle
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte buf[] = new byte[1024];
        int n;
        while n = in.read(buf &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}



//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);                 Log.e(TAG, "Success!!");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void runClient(         @NonNull URI uri,         @NonNull String username,         @NonNull char[] password,         @NonNull Database db) throws InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    /</strong>*
     *
     * Start a listener for db that accepts connections using exactly the passed username and password

     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password) <i class="conum" data-value="35"></i><b>(35)</b>
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(true);
      config.setAuthenticator(new ListenerPasswordAuthenticator(
        (validUser, pwd) -&gt; username.equals(validUser) &amp;&amp; Arrays.equals(validPassword, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
      }
    }






// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.support.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;

public class docOnly_ReplicationExamples {
  private static final String TAG = "EXAMPLE ACTIVE PEER";
  private static final String thisDBNAME = "local-database";
  private final Context context;
  // private Database database;
  // private Replicator replicator;

  public docOnly_ReplicationExamples(Context context) { this.context = context; }

  String user = "syncuser";
  String password = "sync9455";
  SecCertificate cert=null;
  String passivePeerEndpoint = "10.1.1.12:8920";
  String passivePeerPort = "8920";
  String passiveDbName = "userdb";
  Database thisDB;
  Replicator thisReplicator;
  ListenerToken replicatorListener;




// PASSIVE PEER STUFF
// Stuff I adapted
//
// BEGIN new stuff 90420temp cache
  private URLEndpointListener createListener() {
  final URLEndpointListenerConfiguration listenerConfig = new URLEndpointListenerConfiguration(db);

  listenerConfig.setDisableTls(false);

  listenerConfig.setEnableDeltaSync(true);

  listenerConfig.setTlsIdentity(null); // Use with anonymous self signed cert

  listenerConfig.setAuthenticator(new ListenerPasswordAuthenticator(this::isWhitelistedUser));

  return new URLEndpointListener(listenerConfig);
}

public void startListener(@NotNull URLEndpointListener listener) {
  executor.submit) -&gt; {       CouchbaseLiteException err = null;       try { listener.start(); }       catch (CouchbaseLiteException e) { err = e; }       onStart(err);   }); }  private void stopListener(@NotNull URLEndpointListener listener) {   listener.stop(); } // END new stuff 90420temp cache   private void ibListenerSimple() {   final URLEndpointListenerConfiguration thisConfig =     new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="36"></i><b>(36)</b>    thisConfig.setAuthenticator(     new ListenerPasswordAuthenticator(       (username, password) -&gt;         username.equals("valid.User") &amp;&amp;         Arrays.equals(password, valid.password.string)       )     ); <i class="conum" data-value="37"></i><b>(37)</b>    final URLEndpointListener thisListener =     new URLEndpointListener(thisConfig); <i class="conum" data-value="38"></i><b>(38)</b>    thisListener.start(); <i class="conum" data-value="39"></i><b>(39)</b>  }  private void ibReplicatorSimple() {   URI uri = null;   try {       uri = new URI("wss://10.0.2.2:4984/db");   } catch (URISyntaxException e) {       e.printStackTrace();   }   Endpoint theListenerEndpoint = new URLEndpoint(uri); <i class="conum" data-value="40"></i><b>(40)</b>    ReplicatorConfiguration thisConfig =     new ReplicatorConfiguration(database, theListenerEndpoint); <i class="conum" data-value="41"></i><b>(41)</b>    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="42"></i><b>(42)</b>    final BasicAuthenticator thisAuth   = new BasicAuthenticator(       "valid.user",       "valid.password.string");   thisConfig.setAuthenticator(thisAuth) <i class="conum" data-value="43"></i><b>(43)</b>    this.replicator = new Replicator(config); <i class="conum" data-value="44"></i><b>(44)</b>   this.replicator.start(); <i class="conum" data-value="45"></i><b>(45)</b>  }   private void ibPassListener() { // EXAMPLE 1     // Initialize the listener config     final URLEndpointListenerConfiguration thisConfig        = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="46"></i><b>(46)</b>      thisConfig.setPort(55990); <i class="conum" data-value="47"></i><b>(47)</b>      thisConfig.setNetworkInterface("10.1.1.10"); <i class="conum" data-value="48"></i><b>(48)</b>      thisConfig.setEnableDeltaSync(false); <i class="conum" data-value="49"></i><b>(49)</b>      // Configure server security     thisConfig.setDisableTls(false); <i class="conum" data-value="50"></i><b>(50)</b>      // Use an Anonymous Self-Signed Cert     thisConfig.setTlsIdentity(null); <i class="conum" data-value="51"></i><b>(51)</b>       // Configure Client Security using an Authenticator     // For example, Basic Authentication <i class="conum" data-value="52"></i><b>(52)</b>     thisConfig.setAuthenticator(new ListenerPasswordAuthenticator(       (validUser, validPassword) -&gt;         username.equals(validUser) &amp;&amp;         Arrays.equals(password, validPassword);

    // Initialize the listener
    final URLEndpointListener thisListener
      = new URLEndpointListener(thisConfig); <i class="conum" data-value="53"></i><b>(53)</b>

    // Start the listener
    thisListener.start(); <i class="conum" data-value="54"></i><b>(54)</b>

}

private void ibListenerGetNetworkInterfaces() {
  final URLEndpointListenerConfiguration thisConfig =
    URLEndpointListenerConfiguration(database: self.oDB)
  final URLEndpointListener thisListener
    = new URLEndpointListener(thisConfig);
  thisListener.start()
  Log.i(TAG, "URLS are " + thisListener.getUrls());

}

private void ibListenerLocalDb() {
// . . . preceding application logic . . .
CouchbaseLite.init(context); <i class="conum" data-value="55"></i><b>(55)</b>
Database thisDB = new Database("passivepeerdb");

}

private void ibListenerConfigTlsDisable() {
thisConfig.setDisableTls(true); <i class="conum" data-value="56"></i><b>(56)</b>

}

private void ibListenerConfigTlsIdFull() {
  // Use CA Cert
  // Import a key pair into secure storage
  // Create a TLSIdentity from the imported key-pair
  InputStream thisKeyPair = new FileInputStream();

  thisKeyPair.getClass().getResourceAsStream("serverkeypair.p12"); <i class="conum" data-value="57"></i><b>(57)</b>

  TLSIdentity thisIdentity = new TLSIdentity.importIdentity(
    EXTERNAL_KEY_STORE_TYPE,  // KeyStore type, eg: "PKCS12"
    thisKeyPair,              // An InputStream from the keystore
    password,                 // The keystore password
    EXTERNAL_KEY_ALIAS,       // The alias to be used (in external keystore)
    null,                     // The key password
    "test-alias"              // The alias for the imported key
    );


  // Use a self-signed certificate
  // Create a TLSIdentity for the server using convenience API.
  // System generates self-signed cert
  // Work-in-progress. Code snippet coming soon.
  private static final Map&lt;String, String&gt; CERT_ATTRIBUTES; <i class="conum" data-value="58"></i><b>(58)</b>
  static {
    final Map&lt;String, String&gt; thisMap = new HashMap&lt;&gt;();
    m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "Couchbase Demo");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
    m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>");
    CERT_ATTRIBUTES = Collections.unmodifiableMap(thisMap);
  }

  // Store the TLS identity in secure storage
  // under the label 'couchbase-docs-cert'
  TLSIdentity thisIdentity =
    new TLSIdentity.createIdentity(
      true,
      CERT_ATTRIBUTES,
      null,
      "couchbase-docs-cert"); <i class="conum" data-value="59"></i><b>(59)</b>


  // Set the TLS Identity
  thisConfig.setTlsIdentity(thisIdentity); <i class="conum" data-value="60"></i><b>(60)</b>

}

private void ibListenerConfigClientAuthRoot() {
  // Configure the client authenticator
  // to validate using ROOT CA
  // thisClientID.certs is a list containing a client cert to accept
  // and any other certs needed to complete a chain between the client cert
  // and a CA
  final TLSIdentity validId =
    TLSIdentity.getIdentity("Our Corporate Id");  // get the identity <i class="conum" data-value="61"></i><b>(61)</b>

  if (validId == null) { throw new IllegalStateException("Cannot find corporate id"); }

  thisConfig.setTlsIdentity(validId);

  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(validId.getCerts())); <i class="conum" data-value="62"></i><b>(62)</b> <i class="conum" data-value="63"></i><b>(63)</b>
    // accept only clients signed by the corp cert

  final URLEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

}

private void ibListenerConfigClientAuthLambda() {
// Configure authentication using application logic
  final TLSIdentity thisCorpId = TLSIdentity.getIdentity("OurCorp"); <i class="conum" data-value="64"></i><b>(64)</b>
  if (thisCorpId == null) {
    throw new IllegalStateException("Cannot find corporate id"); }
  thisConfig.setTlsIdentity(thisCorpId);
  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(
      (thisCorpId.getCerts()) -&gt; {
      // use supplied logic that resolves to boolean
      // true=valid, false=invalid
      }
    )); <i class="conum" data-value="65"></i><b>(65)</b> <i class="conum" data-value="66"></i><b>(66)</b>
  final ULEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

}


private void ibListenerConfigTlsDisable() {

  thisConfig.disableTLS(true);

}


private void ibListenerStatusCheck() {
  int connectionCount =
    thisListener.getStatus().getConnectionCount(); <i class="conum" data-value="67"></i><b>(67)</b>

  int activeConnectionCount =
    thisListener.getStatus().getActiveConnectionCount();  <i class="conum" data-value="68"></i><b>(68)</b>

}

private void ibListenerStop() {

  thisListener.stop();

}

// Listener Callouts
/</strong>

    &lt;.&gt; Initialize the listener instance using the configuration settings.
    &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.



  &lt;.&gt; <code>connectionCount</code> -- the total number of connections served by the listener
  &lt;.&gt; <code>activeConnectionCount</code> -- the number of active (BUSY) connections currently being served by the listener
  //

<strong>/
/</strong> END CALLOUTS TEXT <strong>/


private void ibP2PUrlEndpointListener() {

  public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
  }
}



// ACTIVE PEER STUFF
// Replication code
//

  //@Test
  public void testActPeerSync() throws CouchbaseLiteException, URISyntaxException {
    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://listener.com:8954"))); <i class="conum" data-value="69"></i><b>(69)</b> <i class="conum" data-value="70"></i><b>(70)</b>

    // Set replicator type
    thisConfig.setReplicatorType(
      ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Configure Sync Mode
    thisConfig.setContinuous(false); // default value

    // set auto-purge behavior (here we override default)
    thisConfig.setAutoPurgeEnabled(false); <i class="conum" data-value="71"></i><b>(71)</b>

    // Configure Server Authentication --
    // only accept self-signed certs
    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="72"></i><b>(72)</b>

    // Configure the credentials the
    // client will provide if prompted
    final BasicAuthenticator thisAuth
      = new BasicAuthenticator(
          "Our Username",
          "Our PasswordValue")); <i class="conum" data-value="73"></i><b>(73)</b>

    thisConfig.setAuthenticator(thisAuth)

    /</strong> Optionally set custom conflict resolver call back <strong>/
    thisConfig.setConflictResolver( /</strong> define resolver function <strong>/); <i class="conum" data-value="74"></i><b>(74)</b>

    // Create replicator
    // Consider holding a reference somewhere
    // to prevent the Replicator from being GCed
    final Replicator thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="75"></i><b>(75)</b>

    // Optionally add a change listener <i class="conum" data-value="76"></i><b>(76)</b>
    ListenerToken thisListener =
      new thisReplicator.addChangeListener(change -&gt; {
        final CouchbaseLiteException err =
         change.getStatus().getError();
         if (err != null) {
           Log.i(TAG, "Error code ::  " + err.getCode(), e);
         }
      }); <i class="conum" data-value="77"></i><b>(77)</b>

    // Start replicator
    thisReplicator.start(false); <i class="conum" data-value="78"></i><b>(78)</b>


  public void ibReplicatorConfig() {
  // BEGIN additional snippets
      // Configure Server Security
      // -- only accept CA attested certs
      thisConfig.setAcceptOnlySelfSignedServerCertificate(false); <i class="conum" data-value="79"></i><b>(79)</b>


    // Return the remote pinned cert (the listener's cert)
    byte returnedCert
     = new byte(thisConfig.getPinnedCertificate()); // Get listener cert if pinned

    // ... your other replicator configuration

    // Provide a client certificate to the server for authentication
    final TLSIdentity thisClientId = TLSIdentity.getIdentity("clientId"); <i class="conum" data-value="80"></i><b>(80)</b>

    if (thisClientId == null) { throw new IllegalStateException("Cannot find client id"); }

    thisConfig.setAuthenticator(new ClientCertificateAuthenticator(thisClientId)); <i class="conum" data-value="81"></i><b>(81)</b>

    // ... your other replicator configuration
    final thisReplicator= new Replicator(thisConfig);


    // Use the pinned certificate from the byte array (cert)
    thisConfig.setPinnedServerCertificate(cert.getEncoded()); <i class="conum" data-value="82"></i><b>(82)</b>
}
// END additional snippets








    Log.i(TAG, "The Replicator is currently " +
      thisReplicator.getStatus().getActivityLevel());

    Log.i(TAG, "The Replicator has processed " + t);

    if (thisReplicator.getStatus().getActivityLevel() ==
      Replicator.ActivityLevel.BUSY) {
        Log.i(TAG, "Replication Processing");
        Log.i(TAG, "It has completed " +
          thisReplicator.getStatus().getProgess().getTotal() +
          " changes");
      }

      // Stop replication.
      thisReplicator.stop(); <i class="conum" data-value="83"></i><b>(83)</b>


  CouchbaseLite.init(context);
  Database thisDB = new Database("passivepeerdb");  <i class="conum" data-value="84"></i><b>(84)</b>
  // Initialize the listener config
  final URLEndpointListenerConfiguration thisConfig = new URLEndpointListenerConfiguration(database);
  thisConfig.setPort(55990)           // &lt;.&gt; Optional; defaults to auto
  thisConfig.setDisableTls(false)     // &lt;.&gt; Optional; defaults to false
  thisConfig.setEnableDeltaSync(true) // &lt;.&gt; Optional; Defaults to false

  // Configure the client authenticator (if using basic auth)
  ListenerPasswordAuthenticator auth = new ListenerPasswordAuthenticator { "username", "password"}; <i class="conum" data-value="85"></i><b>(85)</b>
  thisConfig.setAuthenticator(auth); <i class="conum" data-value="86"></i><b>(86)</b>

  // Initialize the listener
  final URLEndpointListener listener = new URLEndpointListener( thisConfig ); <i class="conum" data-value="87"></i><b>(87)</b>

  // Start the listener
  listener.start(); <i class="conum" data-value="88"></i><b>(88)</b>




  Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
        )

  TLSIdentity thisIdentity = new TLSIdentity.createIdentity(true, X509_ATTRIBUTES, null, "test-alias");




  String thisAlias = "alias-to-delete";
  final KeyStore thisKeyStore
    =  KeyStore.getInstance("AndroidKeyStore");
  thisKeyStore.load(null);
  thisKeyStore.deleteEntry(thisAlias);


  // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label

  TLSIdentity thisIdentity =
    new TLSIdentity.getIdentity("couchbase-docs-cert")


  public void ibRplicatorPull() {
    Database database;
    Replicator replicator; <i class="conum" data-value="89"></i><b>(89)</b>

    URI uri = null;
    try {
        uri = new URI("wss://10.0.2.2:4984/db"); <i class="conum" data-value="90"></i><b>(90)</b>
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
    Endpoint endpoint = new URLEndpoint(uri);
    ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
    config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
    this.replicator = new Replicator(config);
    this.replicator.start();
  }

    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))); <i class="conum" data-value="91"></i><b>(91)</b>



  /</strong> C A L L O U T S

  &lt;.&gt; Configure the pinned certificate using data from the byte array <code>cert</code>

  &lt;.&gt; Attempt to get the identity from secure storage
  &lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity


  &lt;.&gt; A replication is an asynchronous operation.
  To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
  &lt;.&gt; The URL scheme for remote database URLs uses <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections over wb sockets.
  In this example the hostname is <code>10.0.2.2</code> because the Android emulator runs in a VM that is generally accessible on <code>10.0.2.2</code> from the host machine (see <a href="https://developer.android.com/studio/run/emulator-networking">Android Emulator networking</a> documentation).
  +
  NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
  Although <code>wss:</code> protocol URLs are not affected, in order to use the <code>ws:</code> protocol, applications must target API 27 or lower, or must configure application network security as described <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted">here</a>.

  <strong>/

}
/</strong>

Snippets demonstrating use of resultsets

<strong>/
package com.example.docsnippet;
        import android.app.Application.</strong>;
        import android.content.Context;
        import android.content.Context.<strong>;
        import java.lang.Object;
        import java.security.Key;
        import java.util.</strong>;
        import com.couchbase.lite.<strong>;
        import com.couchbase.lite.Dictionary;

public class TestQueries {

    // For Documentation

    Datastore ds = new Datastore();

    Database this_Db = ds.getDB();

    String dbName = this_Db.getName();

    HashMap&lt;String, Object&gt; hotels = new HashMap&lt;&gt;();

    Dictionary thisDocsProps;
    String thisDocsId;
    String thisDocsName;
    String thisDocsType;
    String thisDocsCity;



    static {
        init();
    }

    private static void init() {
    }



    public void testQuerySyntaxAll() throws CouchbaseLiteException {

        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

      Query listQuery = QueryBuilder.select(SelectResult.all())
              .from(DataSource.database(this_Db));

        try {
            for (Result result : listQuery.execute().allResults()) {
                             // get the k-v pairs from the 'hotel' key's value into a dictionary
                thisDocsProps = result.getDictionary(0); <i class="conum" data-value="92"></i><b>(92)</b>
                thisDocsId = thisDocsProps.getString("id");
                thisDocsName = thisDocsProps.getString("Name");
                thisDocsType = thisDocsProps.getString("Type");
                thisDocsCity = thisDocsProps.getString("City");

                // Alternatively, access results value dictionary directly
                final Hotel hotel = new Hotel();
                hotel.Id = result.getDictionary(0).getString("id"); <i class="conum" data-value="93"></i><b>(93)</b>
                hotel.Type = result.getDictionary(0).getString("Type");
                hotel.Name = result.getDictionary(0).getString("Name");
                hotel.City = result.getDictionary(0).getString("City");
                hotel.Country= result.getDictionary(0).getString("Country");
                hotel.Description = result.getDictionary(0).getString("Description");
                hotels.put(hotel.Id, hotel);
            }

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }



    // Uses Jackson JSON processor

    ArrayList&lt;Hotel&gt; hotels = new ArrayList&lt;Hotel&gt;();
    HashMap&lt;String, Object&gt; dictFromJSONstring;
    for (Result result : listQuery.execute()) {

      // Get result as JSON string
      String thisJsonString = result.toJSON(); <i class="conum" data-value="94"></i><b>(94)</b>

      // Get Java  Hashmap from JSON string
      HashMap&lt;String, Object&gt; dictFromJSONstring =
              mapper.readValue(thisJsonString, HashMap.class); <i class="conum" data-value="95"></i><b>(95)</b>


      // Use created hashmap
      String hotelId = dictFromJSONstring.get("id").toString();
      String hotelType = dictFromJSONstring.get("type").toString();
      String hotelname = dictFromJSONstring.get("name").toString();


      // Get custom object from JSON string
      Hotel thisHotel =
              mapper.readValue(thisJsonString, Hotel.class); <i class="conum" data-value="96"></i><b>(96)</b>
      hotels.add(thisHotel);



            }
        }


    public void testQuerySyntaxProps() throws CouchbaseLiteException {
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        Query listQuery =
        QueryBuilder.select(SelectResult.expression(Meta.id),
        SelectResult.property("name"),
        SelectResult.property("Name"),
        SelectResult.property("Type"),
        SelectResult.property("City"))
        .from(DataSource.database(this_Db));



        try {
          for (Result result : listQuery.execute().allResults()) {

            // get data direct from result k-v pairs
            final Hotel hotel = new Hotel();
            hotel.Id = result.getString("id");
            hotel.Type = result.getString("Type");
            hotel.Name = result.getString("Name");
            hotel.City = result.getString("City");

            // Store created hotel object in a hashmap of hotels
            hotels.put(hotel.Id, hotel);

            // Get result k-v pairs into a 'dictionary' object
            Map &lt;String, Object&gt; thisDocsProps = result.toMap();
            thisDocsId =
            thisDocsProps.getOrDefault("id",null).toString();
            thisDocsName =
            thisDocsProps.getOrDefault("Name",null).toString();
            thisDocsType =
            thisDocsProps.getOrDefault("Type",null).toString();
            thisDocsCity =
            thisDocsProps.getOrDefault("City",null).toString();

          }
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

    }


    public void testQuerySyntaxCount() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery = QueryBuilder.select(
              SelectResult.expression(Function.count(Expression.string("</strong>"))).as("mycount")) <i class="conum" data-value="97"></i><b>(97)</b>
              .from(DataSource.database(this_Db));



        try {
            for (Result result : listQuery.execute()) {

                // Retrieve count using key 'mycount'
                Integer altDocId = result.getInt("mycount");

                // Alternatively, use the index
                Integer orDocId = result.getInt(0);
            }
            // Or even miss out the for-loop altogether
            Integer resultCount = listQuery.execute().next().getInt("mycount");

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }
    }


    public void testQuerySyntaxId() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id).as("metaID"))
                      .from(DataSource.database(this_Db));




        try {
            for (Result result : listQuery.execute().allResults()) {

                // get the ID form the result's k-v pair array
                thisDocsId = result.getString("metaID"); <i class="conum" data-value="98"></i><b>(98)</b>

                // Get document from DB using retrieved ID
                Document thisDoc = this_Db.getDocument(thisDocsId);

                // Process document as required
                thisDocsName = thisDoc.getString("Name");

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }


    }


    public void testQueryPagination() throws CouchbaseLiteException {


        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        int thisOffset = 0;
        int thisLimit = 20;

        Query listQuery =
                QueryBuilder
                        .select(SelectResult.all())
                        .from(DataSource.database(this_Db))
                        .limit(Expression.intValue(thisLimit),
                                  Expression.intValue(thisOffset)); <i class="conum" data-value="99"></i><b>(99)</b>


    }



    public List&lt;Result&gt; docsonly_QuerySyntaxN1QL (Database argDB)
    {
      // For Documentation -- N1QL Query using parameters
      //  Declared elsewhere: Database argDB

      Database thisDb = argDB;

      Query thisQuery =
      thisDb.createQuery(
        "SELECT META().id AS thisId FROM _ WHERE type = \"hotel\""); // &lt;.

        return thisQuery.execute().allResults();

      }


    public List&lt;Result&gt; docsonly_QuerySyntaxN1QLParams (Database argDB)
    {
      // For Documentation -- N1QL Query using parameters
      //  Declared elsewhere: Database argDB

      Database thisDb = argDB;

      Query thisQuery =
          thisDb.createQuery(
              "SELECT META().id AS thisId FROM _ WHERE type = $type"); // &lt;.

      thisQuery.parameters =
          Parameters.setString("type", "hotel"); <i class="conum" data-value="100"></i><b>(100)</b>

      return thisQuery.execute().allResults();

  }

} // class



public class supportingDatatypes
{
    private static final String TAG = "info";

    public void datatype_dictionary() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)
        Document document = database.getDocument("doc1");

        // Getting a dictionary from the document's properties
        Dictionary dict = document.getDictionary("address");

        // Access a value with a key from the dictionary
        String street = dict.getString("street");

        // Iterate dictionary
        for (String key : dict) {
            dict.getValue(key);
            Log.i("x", "Key %s, = %s", key, dict.getValue(key));
        }

        // Create a mutable copy
        MutableDictionary mutable_Dict = dict.toMutable();
    }

    public void datatype_mutable_dictionary() throws CouchbaseLiteException {

        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        MutableDictionary mutable_dict = new MutableDictionary();
        mutable_dict.setString("street", "1 Main st.");
        mutable_dict.setString("city", "San Francisco");

        // Add the dictionary to a document's properties and save the document
        MutableDocument mutable_doc = new MutableDocument("doc1");
        mutable_doc.setDictionary("address", mutable_dict);
        database.save(mutable_doc);

    }


    public void datatype_array() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        Document document = database.getDocument("doc1");

        // Getting a phones array from the document's properties
        Array array = document.getArray("phones");

        // Get element count
        int count = array.count();

        // Access an array element by index
        if (count &gt;= 0) { String phone = array.getString(1); }

        // Iterate dictionary
        for (int i = 0; i &lt; count; i)
        {
            Log.i("tag", "Item %d = %s", i, array.getString(i));
        }

        // Create a mutable copy
        MutableArray mutable_array = array.toMutable();


    }

    public void datatype_mutable_array() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        MutableArray mutable_array = new MutableArray();
        mutable_array.addString("650-000-0000");
        mutable_array.addString("650-000-0001");

        // Set the array to document's properties and save the document
        MutableDocument mutable_doc = new MutableDocument("doc1");
        mutable_doc.setArray("phones", mutable_array);
        database.save(mutable_doc);
    }

} // end  class supporting_datatypes



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/ZipUtils.java 
package com.couchbase.code_snippets;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class ZipUtils {
    public static void unzip(InputStream in, File destination) throws IOException {
        byte[] buffer = new byte[1024];
        ZipInputStream zis = new ZipInputStream(in);
        ZipEntry ze = zis.getNextEntry();
        while (ze != null) {
            String fileName = ze.getName();
            File newFile = new File(destination, fileName);
            if (ze.isDirectory()) {
                newFile.mkdirs();
            } else {
                new File(newFile.getParent()).mkdirs();
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) &gt; 0) {
                    fos.write(buffer, 0, len);
                }
                fos.close();
            }
            ze = zis.getNextEntry();
        }
        zis.closeEntry();
        zis.close();
        in.close();
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/ZipUtils.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/JSONExamples.java 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.util.Log;

import java.util.Map;

import org.json.JSONException;
import org.json.JSONObject;

import com.couchbase.lite.Array;
import com.couchbase.lite.Blob;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableArray;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.Result;
import com.couchbase.lite.SelectResult;


public class JSONExamples {
    private static final String TAG = "SNIPPETS";

    public static final String JSON
        = "[{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\","
        + "\"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},"
        + "{\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\","
        + "\"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},"
        + "{\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\","
        + "\"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\","
        + "\"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]";

    public void jsonArrayExample(Database db) throws CouchbaseLiteException {
        // github tag=tojson-array
        final MutableArray mArray = new MutableArray(JSON); // &lt;.&gt;

        for (int i = 0; i &lt; mArray.count(); i) { <i class="conum" data-value="101"></i><b>(101)</b>
          final Dictionary dict = mArray.getDictionary(i);
          Log.i(TAG, dict.getString("name"));
          db.save(new MutableDocument(dict.getString("id"), dict.toMap()));
        }

        final Array features = db.getDocument("1002").getArray("features"); <i class="conum" data-value="102"></i><b>(102)</b>
        for (Object feature: features.toList()) { Log.i(TAG, feature.toString()); }
        Log.i(TAG, features.toJSON()); <i class="conum" data-value="103"></i><b>(103)</b>
      }

      public void jsonBlobExample(Database db) {
        // github tag=tojson-blob
        final Map&lt;String, ?&gt; thisBlob = db.getDocument("thisdoc-id").toMap();
        if (!Blob.isBlob(thisBlob)) { return; }

        final String blobType = thisBlob.get("content_type").toString();
        final Number blobLength = (Number) thisBlob.get("length");
      }

      public void jsonDictionaryExample(Database db) {
        // github tag=tojson-dictionary
        final MutableDictionary mDict = new MutableDictionary(JSON); <i class="conum" data-value="104"></i><b>(104)</b>
        Log.i(TAG, mDict.toString());

        Log.i(TAG, "Details for: " + mDict.getString("name"));
        for (String key: mDict.getKeys()) {
          Log.i(TAG, key + " =&gt; " + mDict.getValue(key));
        }
    }

    public void jsonDocumentExample(Database srcDb, Database dstDb) throws CouchbaseLiteException {
        // github tag=tojson-document
        final Query listQuery = QueryBuilder
        .select(SelectResult.expression(Meta.id).as("metaId"))
        .from(DataSource.database(srcDb));

        for (Result row: listQuery.execute()) {
          final String thisId = row.getString("metaId");

          final String json = srcDb.getDocument(thisId).toJSON(); <i class="conum" data-value="105"></i><b>(105)</b>
          Log.i(TAG, "JSON String = " + json);

          final MutableDocument hotelFromJSON = new MutableDocument(thisId, json); <i class="conum" data-value="106"></i><b>(106)</b>

          dstDb.save(hotelFromJSON);

          for (Map.Entry entry: dstDb.getDocument(thisId).toMap().entrySet()) {
            Log.i(TAG, entry.getKey() + " =&gt; " + entry.getValue());
          } <i class="conum" data-value="107"></i><b>(107)</b>
        }
      }


    public void jsonQueryExample(Query query) throws CouchbaseLiteException, JSONException {
        for (Result row: query.execute()) {

            // get the result into a JSON String
            final String jsonString = row.toJSON();

            final JSONObject thisJsonObj = new JSONObject(jsonString);

            // Use Json Object to populate Native object
            // Use Codable class to unpack JSON data to native object
            final Hotel thisHotel = new Hotel(
                "this hotel",
                "Ghana, West Africa",
                thisJsonObj.getString("city"),
                thisJsonObj.getString("name"),
                thisJsonObj.getString("type"),
                thisJsonObj.getString("id"));
        }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/JSONExamples.java </code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create and populate a mutable array <code>phones</code></p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset4_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset4_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset4_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">

// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.*
import com.couchbase.lite.internal.utils.PlatformUtils
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.io.InputStream
import java.net.URI
import java.net.URISyntaxException


private const val TAG = "REPLICATION"

@Throws(IOException::class)
fun InputStream.toByteArray(): ByteArray {
    val buffer = ByteArray(1024)
    val output = ByteArrayOutputStream()

    var n: Int
    while (-1 &lt; this.read(buffer).also { n = it }) {
        output.write(buffer, 0, n)
    }

    return output.toByteArray()
}

//
//        &lt;.&gt; The conflict handler code is provided as a lambda.
//
//        &lt;.&gt; If the handler cannot resolve a conflict, it can return false.
//        In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.
//
//        &lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.
//
//        &lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).
//
//        &lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method


// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
@Suppress("unused")
object LocalWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.localDocument
}

// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
@Suppress("unused")
object RemoteWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.remoteDocument
}

// Using replConfig.setConflictResolver(new MergeConflictResolver());
@Suppress("unused")
object MergeConflictResolver : ConflictResolver {
    override fun resolve(conflict: Conflict): Document {
        val localDoc = conflict.localDocument?.toMap()
        val remoteDoc = conflict.remoteDocument?.toMap()

        val merge: MutableMap&lt;String, Any&gt;?
        if (localDoc == null) {
            merge = remoteDoc
        } else {
            merge = localDoc
            if (remoteDoc != null) {
                merge.putAll(remoteDoc)
            }
        }

        return if (merge == null) {
            MutableDocument(conflict.documentId)
        } else {
            MutableDocument(conflict.documentId, merge)
        }
    }

    @Suppress("unused")
    class ReplicationExamples(private val database: Database) {
        private var replicator: Replicator? = null

        @Throws(URISyntaxException::class)
        fun testReplicationBasicAuthentication() {

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = BasicAuthenticator("username", "password".toCharArray())
                )
            )
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationSessionAuthentication() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447")
                )
            )
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationStatus() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            repl.addChangeListener { change -&gt;
                if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                    Log.i(TAG, "Replication stopped")
                }
            }

            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testHandlingNetworkErrors() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            repl.addChangeListener { change -&gt;
                change.status.error?.let {
                    Log.w(TAG, "Error code: ${it.code}")
                }
            }
            repl.start()
            replicator = repl

            repl.stop()
        }

        @Throws(URISyntaxException::class)
        fun testReplicatorDocumentEvent() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            val token = repl.addDocumentReplicationListener { replication -&gt;
                Log.i(TAG, "Replication type: ${if (replication.isPush) "push" else "pull"}")

                for (document in replication.documents) {
                    document.let { doc -&gt;
                        Log.i(TAG, "Doc ID: ${document.id}")
                        doc.error?.let {
                            // There was an error
                            Log.e(TAG, "Error replicating document: ", it)
                            return@addDocumentReplicationListener
                        }
                        if (doc.flags.contains(DocumentFlag.DELETED)) {
                            Log.i(TAG, "Successfully replicated a deleted document")
                        }
                    }
                }
            }

            repl.start()
            replicator = repl

            repl.removeChangeListener(token)
        }

        @Throws(URISyntaxException::class)
        fun testReplicationCustomHeader() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value")
                )
            )
            replicator = repl
        }

        // <mark># Certificate Pinning
        @Throws(URISyntaxException::class, IOException::class)
        fun testCertificatePinning() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value"),
                    pinnedServerCertificate = PlatformUtils.getAsset("cert.cer")?.toByteArray()
                )
            )
            replicator = repl
        }

        // </mark># Reset replicator checkpoint
        @Throws(URISyntaxException::class)
        fun testReplicationResetCheckpoint() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            val resetCheckpointRequired_Example = false
            repl.start(resetCheckpointRequired_Example) <i class="conum" data-value="1"></i><b>(1)</b>

            // ... at some later time

            repl.stop()

        }

        @Throws(URISyntaxException::class)
        fun testReplicationPushFilter() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { _, flags -&gt; flags.contains(DocumentFlag.DELETED) } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationPullFilter() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { document, _ -&gt; "draft" == document.getString("type") } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testCustomRetryConfig() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    //  other config params as required . .
                    heartbeat = 150, <i class="conum" data-value="1"></i><b>(1)</b>
                    maxAttempts = 20,
                    maxAttemptWaitTime = 600
                )
            )

            repl.start()
            replicator = repl
        }

        @Throws(CouchbaseLiteException::class)
        fun testDatabaseReplica() {
            val config = DatabaseConfiguration()
            val database1 = Database("mydb", config)
            val database2 = Database("db2", config)

            /* EE feature: code below might throw a compilation error
               if it's compiled against CBL Android Community. <strong>/
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database1,
                    target = DatabaseEndpoint(database2),
                    type = ReplicatorType.PULL
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationWithCustomConflictResolver() {
            val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
            val config = ReplicatorConfiguration(database, target)
            config.conflictResolver = LocalWinsResolver
            val replication = Replicator(config)
            replication.start()
        }

        @Throws(CouchbaseLiteException::class)
        fun testSaveWithCustomConflictResolver() {
            val mutableDocument = database.getDocument("xyz")?.toMutable() ?: return
            mutableDocument.setString("name", "apples")
            database.save(mutableDocument) { newDoc, curDoc -&gt;  <i class="conum" data-value="2"></i><b>(2)</b>
                if (curDoc == null) {
                    return@save false
                } <i class="conum" data-value="3"></i><b>(3)</b>
                val dataMap: MutableMap&lt;String, Any&gt; = curDoc.toMap()
                dataMap.putAll(newDoc.toMap()) <i class="conum" data-value="4"></i><b>(4)</b>
                newDoc.setData(dataMap)
                true <i class="conum" data-value="5"></i><b>(5)</b>
            } <i class="conum" data-value="6"></i><b>(6)</b>
        }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import android.widget.Toast
import com.couchbase.lite.</strong>
import com.couchbase.lite.internal.utils.PlatformUtils
import org.junit.Test
import java.io.File
import java.io.IOException
import java.net.URI
import java.net.URISyntaxException
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.*


private const val TAG = "BASIC"

class LogTestLogger(private val level: LogLevel) : Logger {
    override fun getLevel() = level

    override fun log(level: LogLevel, domain: LogDomain, message: String) {
        // this method will never be called if param level &lt; this.level
        // handle the message, for example piping it to a third party framework
    }
}

@Suppress("unused")
class BasicExamples(private val context: Context) {
    private val database: Database

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        // Get the database (and create it if it doesnt exist).
        database = Database(
          "getting-started",
          DatabaseConfigurationFactory.create(context.filesDir.absolutePath)
          )
    }

    @Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {

        // !!! Note the code moved from here to the init { } above.
        // Create a new document (i.e. a record) in the database.
        var mutableDoc = MutableDocument().setFloat("version", 2.0f).setString("type", "SDK")

        // Save it to the database.
        database.save(mutableDoc)

        // Update a document.
        mutableDoc = database.getDocument(mutableDoc.id)!!.toMutable().setString("language", "Java")
        database.save(mutableDoc)

        val document = database.getDocument(mutableDoc.id)!!
        // Log the document ID (generated by the database) and properties
        Log.i(TAG, "Document ID :: ${document.id}")
        Log.i(TAG, "Learning ${document.getString("language")}")

        // Create a query to fetch documents of type SDK.
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))
            .execute()
        Log.i(TAG, "Number of rows :: ${rs.allResults().size}")

        // Create a replicator to push and pull changes to and from the cloud.
        // Be sure to hold a reference somewhere to prevent the Replicator from being GCed
        val replicator =
          Replicator(
            ReplicatorConfigurationFactory.create(
              database = database,
              target = URLEndpoint(URI("ws://localhost:4984/getting-started-db")),
              type = ReplicatorType.PUSH_AND_PULL,
              authenticator = BasicAuthenticator("sync-gateway", "password".toCharArray())
              )
          )


        // Listen to replicator change events.
        replicator.addChangeListener { change -&gt;
            val err = change.status.error
            if (err != null) Log.i(TAG, "Error code ::  ${err.code}")
        }

        // Start replication.
        replicator.start()

        database.delete()
    }

    @Throws(CouchbaseLiteException::class, IOException::class)
    fun test1xAttachments() {
        // if db exist, delete it
        deleteDB("android-sqlite", context.filesDir)
        ZipUtils.unzip(
            PlatformUtils.getAsset("replacedb/android140-sqlite.cblite2.zip"),
            context.filesDir
        )

        val db = Database("android-sqlite")
        try {
            // For Validation
            Arrays.equals(
                "attach1".toByteArray(),
                db.getDocument("doc1")?.getDictionary("_attachments")?.getBlob("attach1")?.content
            )
        } finally {
            // close db
            db.close()
            // if db exist, delete it
            deleteDB("android-sqlite", context.filesDir)
        }
        val document = MutableDocument()

        val content = document.getDictionary("_attachments")?.getBlob("avatar")?.content
    }

    // <mark># Initializer
    fun testInitializer() {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)
    }

    // </mark># New Database
    @Throws(CouchbaseLiteException::class)
    fun testNewDatabase() {
        val database = Database(
            "my-db",
            DatabaseConfigurationFactory.create(
                context.filesDir.absolutePath
            )
        ) <i class="conum" data-value="7"></i><b>(7)</b>
        database.close()


        database.delete()
    }

    // <mark># Database Encryption
    @Throws(CouchbaseLiteException::class)
    fun testDatabaseEncryption() {
        val db = Database(
            "my-db",
            DatabaseConfigurationFactory.create(
                encryptionKey = EncryptionKey("PASSWORD")
            )
        )

    }

    // </mark># Logging
    // !!! OBSOLETE in 3.0
    fun testLogging() {
    }

    fun testEnableCustomLogging() {
        // this custom logger will not log an event with a log level &lt; WARNING
        Database.log.custom = LogTestLogger(LogLevel.WARNING) <i class="conum" data-value="8"></i><b>(8)</b>
    }

    // <mark># Console logging
    @Throws(CouchbaseLiteException::class)
    fun testConsoleLogging() {
        Database.log.console.domains = LogDomain.ALL_DOMAINS <i class="conum" data-value="9"></i><b>(9)</b>
        Database.log.console.level = LogLevel.VERBOSE <i class="conum" data-value="10"></i><b>(10)</b>

        Database.log.console.domains = EnumSet.of(LogDomain.DATABASE) <i class="conum" data-value="11"></i><b>(11)</b>
    }

    // </mark># File logging
    @Throws(CouchbaseLiteException::class)
    fun testFileLogging() {
        Database.log.file.let {
          it.config = LogFileConfigurationFactory.create(
            context.cacheDir.absolutePath, <i class="conum" data-value="12"></i><b>(12)</b>
            maxSize = 10240, <i class="conum" data-value="13"></i><b>(13)</b>
            maxRotateCount = 5, <i class="conum" data-value="14"></i><b>(14)</b>
            usePlainText = false
            ) <i class="conum" data-value="15"></i><b>(15)</b>
            it.level = LogLevel.INFO <i class="conum" data-value="16"></i><b>(16)</b>

          }
    }

    fun writeConsoleLog() {
        Database.log.console.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    fun writeCustomLog() {
        Database.log.custom?.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    fun writeFileLog() {
        Database.log.file.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    /* The <code>tag::replication[]</code> example is inlined in java.adoc <strong>/
    fun testTroubleshooting() {
        Database.log.console.let {
            it.level = LogLevel.VERBOSE
            it.domains = LogDomain.ALL_DOMAINS
        }
    }

    // <mark># Loading a pre-built database
    @Throws(IOException::class)
    fun testPreBuiltDatabase() {
        // Note: Getting the path to a database is platform-specific.
        // For Android you need to extract the database from your assets
        // to a temporary directory and then copy it, using Database.copy()
        if (Database.exists("travel-sample", context.filesDir)) {
            return
        }
        ZipUtils.unzip(PlatformUtils.getAsset("travel-sample.cblite2.zip"), context.filesDir)
        Database.copy(
            File(context.filesDir, "travel-sample"),
            "travel-sample",
            DatabaseConfiguration()
        )
    }

    // helper methods
    // if db exist, delete it
    fun deleteDB(name: String, dir: File) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            Database.delete(name, dir)
        }

        // </mark># Initializers
        fun testInitializers() {
            val doc = MutableDocument()
            doc.let {
                it.setString("type", "task")
                it.setString("owner", "todo")
                it.setDate("createdAt", Date())
            }
            database.save(doc)
        }
    }

    // <mark># Mutability
    fun testMutability() {
        database.save(MutableDocument("xyz"))

        database.getDocument("xyz")?.toMutable()?.let {
            it.setString("name", "apples")
            database.save(it)
        }
    }

    // </mark># Typed Accessors
    fun testTypedAccessors() {
        val doc = MutableDocument()

        doc.setValue("createdAt", Date())
        val date = doc.getDate("createdAt")
    }

    // <mark># Batch operations
    fun testBatchOperations() {
        database.inBatch(UnitOfWork {
            for (i in 0..9) {
                val doc = MutableDocument()
                doc.let {
                    it.setValue("type", "user")
                    it.setValue("name", "user $i")
                    it.setBoolean("admin", false)
                }
                Log.i(TAG, "saved user document: ${doc.getString("name")}")
            }
        })
    }


    // toJSON
    fun testToJsonOperations(argDb: Database) {
        val db = argDb

    }


    // </mark># Document Expiration
    @Throws(CouchbaseLiteException::class)
    fun documentExpiration() {
        // Purge the document one day from now
        database.setDocumentExpiration(
            "doc123",
            Date(Instant.now().plus(1, ChronoUnit.DAYS).toEpochMilli())
        )

        // Reset expiration
        database.setDocumentExpiration("doc1", null)

        // Query documents that will be expired in less than five minutes
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.longValue(Instant.now().plus(5, ChronoUnit.MINUTES).toEpochMilli())
                )
            )
    }

    @Throws(CouchbaseLiteException::class)
    fun testDocumentChangeListener() {
        database.addDocumentChangeListener("user.john") { change -&gt;
            database.getDocument(change.documentID)?.let {
                Toast.makeText(
                    context,
                    "Status: ${it.getString("verified_account")}",
                    Toast.LENGTH_SHORT
                ).show()
            }
        }
    }

    // <mark># Blobs
    fun testBlobs() {
        val mDoc = MutableDocument()

        PlatformUtils.getAsset("avatar.jpg")?.use { <i class="conum" data-value="17"></i><b>(17)</b>
            mDoc.setBlob("avatar", Blob("image/jpeg", it)) <i class="conum" data-value="18"></i><b>(18)</b> <i class="conum" data-value="19"></i><b>(19)</b>
            database.save(mDoc)
        }

        val doc = database.getDocument(mDoc.id)
        val bytes = doc?.getBlob("avatar")?.content
    }
}


class supportingDatatypes
{

    private val database  = Database("mydb")

    fun datatype_dictionary() {

        // NOTE: No error handling, for brevity (see getting started)
        val document = database!!.getDocument("doc1")

        // Getting a dictionary from the document's properties
        val dict = document?.getDictionary("address")

        // Access a value with a key from the dictionary
        val street = dict?.getString("street")

        // Iterate dictionary
        for (key in dict!!.keys) {
            println("Key ${key} = ${dict.getValue(key)}")
        }

    // Create a mutable copy
    val mutable_Dict = dict.toMutable()
}

    fun datatype_mutable_dictionary() {

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        val mutable_dict = MutableDictionary()
        mutable_dict.setString("street", "1 Main st.")
        mutable_dict.setString("city", "San Francisco")

        // Add the dictionary to a document's properties and save the document
        val mutable_doc = MutableDocument("doc1")
        mutable_doc.setDictionary("address", mutable_dict)
        database!!.save(mutable_doc)

}


    fun datatype_array() {

        // NOTE: No error handling, for brevity (see getting started)

        val document = database?.getDocument("doc1")

        // Getting a phones array from the document's properties
        val array = document?.getArray("phones")

        // Get element count
        val count = array?.count()

        // Access an array element by index
        val phone = array?.getString(1)

        // Iterate array
        for ( (index, item) in array!!) {
            println("Row  ${index} = ${item}")
        }

        // Create a mutable copy
        val mutable_array = array.toMutable()
    }

    fun datatype_mutable_array() {

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        val mutable_array = MutableArray()
        mutable_array.addString("650-000-0000")
        mutable_array.addString("650-000-0001")

        // Set the array to document's properties and save the document
        val mutable_doc = MutableDocument("doc1")
        mutable_doc.setArray("phones", mutable_array)
        database?.save(mutable_doc)
    }

} // end  class supporting_datatypes



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.Dictionary
import com.couchbase.lite.Expression
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.MutableDictionary
import com.couchbase.lite.PredictionFunction
import com.couchbase.lite.PredictiveIndex
import com.couchbase.lite.PredictiveModel
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.SelectResult
import com.couchbase.lite.ValueIndex
import com.couchbase.lite.ValueIndexItem


private const val TAG = "PREDICT"
// tensorFlowModel is a fake implementation

object TensorFlowModel {
    fun predictImage(data: ByteArray?) = mapOf&lt;String, Any?&gt;()
}

object ImageClassifierModel : PredictiveModel {
    const val name = "ImageClassifier"

    override fun predict(input: Dictionary): Dictionary? {
        val blob: Blob = input.getBlob("photo") ?: return null

        // this would be the implementation of the ml model you have chosen
        return MutableDictionary(TensorFlowModel.predictImage(blob.content)) <i class="conum" data-value="1"></i><b>(1)</b>
    }
}


@Suppress("unused")
class PredictiveQueryExamples {
    @Throws(CouchbaseLiteException::class)
    fun testPredictiveModel() {
        val database = Database("mydb")

        Database.prediction.registerModel("ImageClassifier", ImageClassifierModel)

        val index: ValueIndex = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")))
        database.createIndex("value-index-image-classifier", index)

        Database.prediction.unregisterModel("ImageClassifier")
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveIndex() {
        val database = Database("mydb")

        val inputMap: MutableMap&lt;String, Any&gt; = mutableMapOf()
        inputMap["numbers"] = Expression.property("photo")
        val input: Expression = Expression.map(inputMap)
        val index: PredictiveIndex = IndexBuilder.predictiveIndex("ImageClassifier", input, null)
        database.createIndex("predictive-index-image-classifier", index)
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveQuery() {
        val database = Database("mydb")

        val prediction: PredictionFunction = Function.prediction(
            ImageClassifierModel.name,
            Expression.map(mutableMapOf("photo" to Expression.property("photo")) as Map&lt;String, Any&gt;?) <i class="conum" data-value="1"></i><b>(1)</b>
        )

        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                .and(prediction.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))
                    )
            )
            .execute()

        Log.d(TAG, "Number of rows: ${rs.allResults().size}")
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/FlowExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import androidx.lifecycle.LiveData
import androidx.lifecycle.asLiveData
import com.couchbase.lite.</strong>
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.map


class FlowExamples(argDb: Database,
                   argRepl: Replicator,
                   argQuery: Query,
                   argDocOwner: String) {

    val replState: LiveData&lt;ReplicatorActivityLevel&gt; = argRepl.replicatorChangesFlow()
        .map { it.status.activityLevel }
        .asLiveData()

    val dbChanges: LiveData&lt;MutableList&lt;String&gt;&gt; = argDb.databaseChangeFlow()
        .map { it.documentIDs }
        .asLiveData()

    val docChanges: LiveData&lt;DocumentChange?&gt; = argDb.documentChangeFlow("1001")
        .map {
            it.takeUnless {
                it.database.getDocument(it.documentID)?.getString("owner").equals(argDocOwner)
            }
        }
        .asLiveData()

    var liveQuery: LiveData&lt;List&lt;Any&gt;?&gt;? = null

    @ExperimentalCoroutinesApi
    fun watchQuery(query: Query): LiveData&lt;List&lt;Any&gt;?&gt; {
        val queryFlow = query.queryChangeFlow()
            .map {
                val err = it.error
                if (err != null) {
                    throw err
                }
                it.results?.allResults()?.flatMap { it.toList() }
            }
            .asLiveData()
        liveQuery = queryFlow
        return queryFlow
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/FlowExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorStatus


private const val TAG = "PENDING"

@Suppress("unused")
class PendingDocsExample(private var replicator: Replicator) {
    //
    //
    private fun onStatusChanged(pendingDocs: Set&lt;String&gt;, status: ReplicatorStatus) {
        // ... sample onStatusChanged function
        //
        Log.i(TAG, "Replicator activity level is ${status.activityLevel}")

        // iterate and report-on previously
        // retrieved pending docids 'list'
        val itr = pendingDocs.iterator()
        while (itr.hasNext()) {
            val docId = itr.next()

            if (!replicator.isDocumentPending(docId)) { <i class="conum" data-value="20"></i><b>(20)</b>
                continue
            }

            Log.i(TAG, "Doc ID $docId has been pushed")
        }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Endpoint
import com.couchbase.lite.KeyStoreUtils
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.net.URI
import java.net.URISyntaxException
import java.security.KeyStore
import java.security.cert.Certificate

private const val TAG = "P2P"


@Suppress("unused")
class IBExamples(private val context: Context, private val caCert: Certificate) {
    private val database: Database
    private var thisReplicator: Replicator? = null
    private var thisListener: URLEndpointListener? = null

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        database = Database("p2p_demo")

        /* do some stuff here <strong>/
    }

    // PASSIVE PEER STUFF
    fun ibListenerSimple() {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database,
                authenticator
                = ListenerPasswordAuthenticator { user, pwd -&gt; (user == "daniel") &amp;&amp; (String(pwd) == "123") })
        ) <i class="conum" data-value="21"></i><b>(21)</b>
        listener.start() <i class="conum" data-value="22"></i><b>(22)</b>
        thisListener = listener

    }

    fun ibReplicatorSimple() {
        val theListenerEndpoint: Endpoint = URLEndpoint(URI("wss://10.0.2.2:4984/db")) <i class="conum" data-value="23"></i><b>(23)</b>
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,
                target = theListenerEndpoint,
                authenticator = BasicAuthenticator("valid.user", "valid.password.string".toCharArray()), <i class="conum" data-value="24"></i><b>(24)</b>
                acceptOnlySelfSignedServerCertificate = true
            )
        )
        repl.start() <i class="conum" data-value="25"></i><b>(25)</b>
        thisReplicator = repl
    }

    fun ibPassListener(validUser: String, validPassword: CharArray) {
        // EXAMPLE 1
        // Initialize the listener
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database, <i class="conum" data-value="26"></i><b>(26)</b>
                port = 55990, <i class="conum" data-value="27"></i><b>(27)</b>
                networkInterface = "10.1.1.10", <i class="conum" data-value="28"></i><b>(28)</b>

                enableDeltaSync = false, <i class="conum" data-value="29"></i><b>(29)</b>

                // Configure server security
                disableTls = false, <i class="conum" data-value="30"></i><b>(30)</b>

                // Use an Anonymous Self-Signed Cert
                identity = null, <i class="conum" data-value="31"></i><b>(31)</b>

                // Configure Client Security using an Authenticator
                // For example, Basic Authentication <i class="conum" data-value="32"></i><b>(32)</b>
                authenticator = ListenerPasswordAuthenticator { username, paassword -&gt;
                    (username === validUser) &amp;&amp; (paassword === validPassword)
                }
            ))

        // Start the listener
        listener.start() <i class="conum" data-value="33"></i><b>(33)</b>
        thisListener = listener

    }

    fun ibListenerGetNetworkInterfaces() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        listener.start()
        Log.i(TAG, "URLS are ${listener.urls}")
        thisListener = listener
    }

    fun ibListenerLocalDb() {
        // . . . preceding application logic . . .
        CouchbaseLite.init(context) <i class="conum" data-value="34"></i><b>(34)</b>
        val thisDB = Database("passivepeerdb")
    }

    fun ibListenerConfigTlsDisable() {
        URLEndpointListenerConfigurationFactory.create(database, disableTls = false) <i class="conum" data-value="35"></i><b>(35)</b>
    }


    // !!! USERS SHOULD BE CAUTIONED THAT THIS IS INSECURE
    // Android has much better ways of importing keys
    fun ibListenerConfigTlsIdFull() {
        // Use CA Cert
        // Import a key pair into secure storage
        // Create a TLSIdentity from the imported key-pair

        this.javaClass.getResourceAsStream("serverkeypair.p12")?.use { <i class="conum" data-value="36"></i><b>(36)</b>
            KeyStoreUtils.importEntry(
                "teststore.p12",  // KeyStore type, eg: "PKCS12"
                it,  // An InputStream from the keystore
                "let me in".toCharArray(),  // The keystore password
                "topSekritKey",  // The alias to be used (in external keystore)
                null,  // The key password or null if the key has none
                "test-alias" // The alias for the imported key
            )
        }


        // Set the TLS Identity
        URLEndpointListenerConfigurationFactory.create(
            database,
            identity = TLSIdentity.getIdentity("test-alias")
        ) <i class="conum" data-value="37"></i><b>(37)</b>

    }

    fun ibListenerConfigClientAuthRoot() {
        // Configure the client authenticator
        // to validate using ROOT CA
        // thisClientID.certs is a list containing a client cert to accept
        // and any other certs needed to complete a chain between the client cert
        // and a CA
        val validId = TLSIdentity.getIdentity("Our Corporate Id")
            ?: throw IllegalStateException("Cannot find corporate id")
        // accept only clients signed by the corp cert
        thisListener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                // get the identity <i class="conum" data-value="38"></i><b>(38)</b>
                database = database,
                identity = validId,
                authenticator = ListenerCertificateAuthenticator(validId.certs)
            )
        ) <i class="conum" data-value="39"></i><b>(39)</b>

    }

    fun ibListenerConfigTlsDisable2() {

        URLEndpointListenerConfigurationFactory.create(database = database, disableTls = true)
    }

    fun ibListenerStatusCheck() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        val connectionCount = listener.status?.connectionCount <i class="conum" data-value="40"></i><b>(40)</b>
        val activeConnectionCount = listener.status?.activeConnectionCount <i class="conum" data-value="41"></i><b>(41)</b>
    }

    fun ibListenerStop() {

        thisListener?.stop()

    }

    // ACTIVE PEER STUFF
// Replication code
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testActPeerSync() {
        // Create replicator
        // Consider holding a reference somewhere
        // to prevent the Replicator from being GCed
        val repl = Replicator( <i class="conum" data-value="42"></i><b>(42)</b>

            // initialize the replicator configuration
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(URI("wss://listener.com:8954")), <i class="conum" data-value="43"></i><b>(43)</b>

                // Set replicator type
                type = ReplicatorType.PUSH_AND_PULL,

                // Configure Sync Mode
                continuous = false, // default value


                // set auto-purge behavior
                // (here we override default)
                enableAutoPurge = false, <i class="conum" data-value="44"></i><b>(44)</b>



                // Configure Server Authentication --
                // only accept self-signed certs
                acceptOnlySelfSignedServerCertificate = true, <i class="conum" data-value="45"></i><b>(45)</b>

                // Configure the credentials the
                // client will provide if prompted
                authenticator = BasicAuthenticator("Our Username", "Our PasswordValue".toCharArray()), <i class="conum" data-value="46"></i><b>(46)</b>


                /</strong> Optionally set custom conflict resolver call back <strong>/
                conflictResolver = null <i class="conum" data-value="47"></i><b>(47)</b>
            )
        )


        // Optionally add a change listener <i class="conum" data-value="48"></i><b>(48)</b>
        val thisListener = repl.addChangeListener { change -&gt;
            val err: CouchbaseLiteException? = change.status.error
            if (err != null) {
                Log.i(TAG, "Error code ::  ${err.code}", err)
            }
        }

        // Start replicator
        repl.start(false) <i class="conum" data-value="49"></i><b>(49)</b>
        thisReplicator = repl

    }

    fun ibReplicatorConfig() {
        // BEGIN additional snippets

        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,

                // Configure Server Security
                // -- only accept CA attested certs
                acceptOnlySelfSignedServerCertificate = false, <i class="conum" data-value="50"></i><b>(50)</b>




                // Use the pinned certificate from the byte array (cert)
                pinnedServerCertificate = caCert.encoded, <i class="conum" data-value="51"></i><b>(51)</b>


                // ... other replicator configuration
                // Provide a client certificate to the server for authentication
                authenticator = ClientCertificateAuthenticator(
                    TLSIdentity.getIdentity("clientId")
                        ?: throw IllegalStateException("Cannot find client id")
                ) <i class="conum" data-value="52"></i><b>(52)</b>

                // ... other replicator configuration

            )
        )

        thisReplicator = repl
    }

    fun ibP2pReplicatorStatus() {
        thisReplicator?.status?.let {
            Log.i(TAG, "The Replicator is currently ${it.activityLevel}")
            Log.i(TAG, "The Replicator has processed ${it.progress}")
            Log.i(
                TAG,
                if (it.activityLevel === ReplicatorActivityLevel.BUSY) {
                    "Replication Processing"
                } else {
                    "It has completed ${it.progress.total} changes"
                }
            )
        }
    }

    fun ibP2pReplicatorStop() {
        // Stop replication.
        thisReplicator?.stop() <i class="conum" data-value="53"></i><b>(53)</b>
    }

    fun ibP2pListener() {
        CouchbaseLite.init(context)
        val thisDB = Database("passivepeerdb") <i class="conum" data-value="54"></i><b>(54)</b>


        // Initialize the listener
        val listener = URLEndpointListener( <i class="conum" data-value="55"></i><b>(55)</b>

            // Initialize the listener config
            URLEndpointListenerConfigurationFactory.create(
                database = thisDB,
                port = 55990, /</strong> &lt;.&gt;  Optional; defaults to auto <strong>/
                disableTls = false, /</strong> &lt;.&gt;  Optional; defaults to false <strong>/
                enableDeltaSync = true,  /</strong> &lt;.&gt; Optional; defaults to false <strong>/

                // Configure the client authenticator (if using basic auth)
                authenticator = ListenerPasswordAuthenticator { username, password -&gt;
                    ("username" === username) &amp;&amp; (password === "password".toCharArray())  <i class="conum" data-value="56"></i><b>(56)</b>
                }
            )
        )

        // Start the listener
        listener.start() <i class="conum" data-value="57"></i><b>(57)</b>



//        Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
//                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
//                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
//        );
        val thisIdentity = TLSIdentity.createIdentity(
            true,
            mapOf(
                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
            ),
            null,
            "test-alias"
        )




        val thisAlias = "alias-to-delete"
        val thisKeyStore = KeyStore.getInstance("AndroidKeyStore")
        thisKeyStore.load(null)
        thisKeyStore.deleteEntry(thisAlias)


        // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label
        val thatIdentity = TLSIdentity.getIdentity("couchbase-docs-cert")
    }

    fun ibRplicatorPull() {
        val database = Database("ian")

        val uri = URI("wss://10.0.2.2:4984/db") <i class="conum" data-value="58"></i><b>(58)</b>

        val repl = Replicator( <i class="conum" data-value="59"></i><b>(59)</b>
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(uri),
                type = ReplicatorType.PULL
            )
        )

        repl.start()
        thisReplicator = repl
    }

// initialize the replicator configuration
    val thisConfig = ReplicatorConfigurationFactory.create(
        database = database,
        target = URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))

/</strong> C A L L O U T S

// Listener Callouts


&lt;.&gt; Initialize the listener instance using the configuration settings.
&lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.



&lt;.&gt; <code>connectionCount</code> -- the total number of connections served by the listener
&lt;.&gt; <code>activeConnectionCount</code> -- the number of active (BUSY) connections currently being served by the listener
//



&lt;.&gt; Configure the pinned certificate using data from the byte array <code>cert</code>

&lt;.&gt; Attempt to get the identity from secure storage
&lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity


&lt;.&gt; A replication is an asynchronous operation.
To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
&lt;.&gt; The URL scheme for remote database URLs uses <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections over wb sockets.
In this example the hostname is <code>10.0.2.2</code> because the Android emulator runs in a VM that is generally accessible on <code>10.0.2.2</code> from the host machine (see <a href="https://developer.android.com/studio/run/emulator-networking">Android Emulator networking</a> documentation).
+
NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
Although <code>wss:</code> protocol URLs are not affected, in order to use the <code>ws:</code> protocol, applications must target API 27 or lower, or must configure application network security as described <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted">here</a>.

<strong>/
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.net.URI
import java.security.KeyStore
import java.security.KeyStoreException
import java.security.NoSuchAlgorithmException
import java.security.cert.Certificate
import java.security.cert.CertificateEncodingException
import java.security.cert.CertificateException
import java.util.concurrent.CountDownLatch

private const val TAG = "LISTEN"

@Suppress("unused")
class KtCertAuthListener {
    companion object {
        private val CERT_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "CBL Test",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>",
        )
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)

        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        remoteDb.save(doc)

        val serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server")

        val clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client")
        val uri = startServer(remoteDb, serverIdentity, clientIdentity.certs)
            ?: throw IOException("Failed to start the server")

        Thread {
            startClient(localDb, uri, clientIdentity, serverIdentity.certs[0])
            Log.e(TAG, "Success!!")
            deleteIdentity("server")
            Log.e(TAG, "Alias deleted: server")
            deleteIdentity("client")
            Log.e(TAG, "Alias deleted: client")
        }.start()
    }

    // start a client replicator
    @Throws(CertificateEncodingException::class, InterruptedException::class)
    fun startClient(db: Database, uri: URI, clientIdentity: TLSIdentity, cert: Certificate) {
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = db,
                target = URLEndpoint(uri),
                type = ReplicatorType.PUSH_AND_PULL,
                continuous = false,
                authenticator = ClientCertificateAuthenticator(clientIdentity),
                pinnedServerCertificate = cert.encoded
            )
        )

        val completionLatch = CountDownLatch(1)

        repl.addChangeListener { change -&gt;
            if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    /<strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     *
     *
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Throws(CouchbaseLiteException::class)
    fun startServer(db: Database, serverId: TLSIdentity, certs: List&lt;Certificate?&gt;): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0, // this is the default
                disableTls = false,
                identity = serverId,
                authenticator = ListenerCertificateAuthenticator(certs)
            )
        )
        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
    /</strong>
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    @Throws(
        KeyStoreException::class,
        CertificateException::class,
        NoSuchAlgorithmException::class,
        IOException::class
    )
    fun deleteIdentity(alias: String?) {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        keyStore.deleteEntry(alias) <i class="conum" data-value="60"></i><b>(60)</b>
    }
    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /<strong>
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     *
     *
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    @Throws(CertificateEncodingException::class)
    private fun configureClientCerts(
        config: ReplicatorConfiguration,
        cert: Certificate,
        clientIdentity: TLSIdentity
    ) {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(ClientCertificateAuthenticator(clientIdentity))

        // Configure the pinned certificate passing a byte array.
        config.pinnedServerCertificate = cert.encoded
    }
    // notend::p2p-tlsid-tlsidentity-with-label[]
    /</strong>
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     *
     *
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    @Throws(IOException::class)
    private fun readCertMaterialFromBundle(
        context: Context,
        resId: Int
    ): ByteArray {
        val out = ByteArrayOutputStream()
        val <code>in</code> = context.resources.openRawResource(resId)
        val buf = ByteArray(1024)
        var n: Int
        while (<code>in</code>.read(buf).also { n = it } &gt;= 0) {
            out.write(buf, 0, n)
        }
        return out.toByteArray()
    }
}

@Suppress("unused")
class KtPasswordAuthListener {
    companion object {
        private const val VALID_USER = "Minnie"
        private val VALID_PASSWORD = "let me in!".toCharArray()
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray())
            ?: throw IOException("Failed to start the server")
        Thread {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb)
                Log.e(TAG, "Success!!")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }.start()
    }

    // start a client replicator
    @Throws(InterruptedException::class)
    fun runClient(
        uri: URI,
        username: String,
        password: CharArray,
        db: Database
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.type = ReplicatorType.PUSH_AND_PULL
        config.isContinuous = false
        config.setAuthenticator(BasicAuthenticator(username, password))
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)

        repl.addChangeListener { change -&gt;
            if (change.status
                    .activityLevel == ReplicatorActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    /</strong>*
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     *
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    fun startServer(db: Database, username: String, password: CharArray): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0,// this is the default
                disableTls = true,
                authenticator = ListenerPasswordAuthenticator { usr, pwd -&gt;
                    (usr == username) &amp;&amp; pwd.contentEquals(password)
                })
        )

        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
}





// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Message
import com.couchbase.lite.MessageEndpoint
import com.couchbase.lite.MessageEndpointConnection
import com.couchbase.lite.MessageEndpointDelegate
import com.couchbase.lite.MessageEndpointListener
import com.couchbase.lite.MessageEndpointListenerConfigurationFactory
import com.couchbase.lite.MessagingCloseCompletion
import com.couchbase.lite.MessagingCompletion
import com.couchbase.lite.ProtocolType
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorConnection
import com.couchbase.lite.create


@Suppress("unused")
class BrowserSessionManager : MessageEndpointDelegate {
    private var replicator: Replicator? = null

    @Throws(CouchbaseLiteException::class)
    fun initCouchbase() {
        val database = Database("mydb")

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        val messageEndpoint = MessageEndpoint("UID:123", "active", ProtocolType.MESSAGE_STREAM, this)

        // Create the replicator object.
        val repl = Replicator(ReplicatorConfigurationFactory.create(database = database, target = messageEndpoint))
        // Start the replication.
        repl.start()
        replicator = repl
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    override fun createConnection(endpoint: MessageEndpoint) = ActivePeerConnection()
}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

@Suppress("unused")
class ActivePeerConnection : MessageEndpointConnection {
    private var replicatorConnection: ReplicatorConnection? = null

    fun disconnect() {
        replicatorConnection?.close(null)
        replicatorConnection = null
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete()
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun send(message: Message, completion: MessagingCompletion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null)
    }

    fun receive(message: Message) {
        replicatorConnection?.receive(message)
    }
}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

@Suppress("unused")
class PassivePeerConnection private constructor() : MessageEndpointConnection {
    private var messageEndpointListener: MessageEndpointListener? = null
    private var replicatorConnection: ReplicatorConnection? = null

    @Throws(CouchbaseLiteException::class)
    fun startListener() {
        val database = Database("mydb")
        messageEndpointListener = MessageEndpointListener(
            MessageEndpointListenerConfigurationFactory.create(database, ProtocolType.MESSAGE_STREAM)
        )
    }

    fun stopListener() {
        messageEndpointListener?.closeAll()
    }

    fun accept() {
        val connection = PassivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        messageEndpointListener?.accept(connection)
    }

    fun disconnect() {
        replicatorConnection?.close(null)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete()
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun send(message: Message, completion: MessagingCompletion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null)
    }

    fun receive(message: Message) {
        replicatorConnection?.receive(message)
    }

}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.</strong>
import com.couchbase.lite.Function
import com.fasterxml.jackson.databind.ObjectMapper
import org.json.JSONException


private const val TAG = "QUERY"
private const val DATABASE_NAME = "database"

data class Hotel(
    var description: String? = null,
    var country: String? = null,
    var city: String? = null,
    var name: String? = null,
    var type: String? = null,
    var id: String? = null
)

@Suppress("unused")
class QueryExamples(private val database: Database) {

    // </mark># Indexing
    @Throws(CouchbaseLiteException::class)
    fun testIndexing() {
        database.createIndex( "TypeNameIndex",
              ValueIndexConfiguration( "type", "name")
    }

    fun testIndexing_Querybuilder() {
        database.createIndex(
            "TypeNameIndex",
            IndexBuilder.valueIndex(
                ValueIndexItem.property("type"),
                ValueIndexItem.property("name")
            )
        )
    }

    // <mark># SELECT statement
    fun testSelectStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("type")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.expression(Meta.id))
            .execute()

        for (result in rs) {
            Log.i(TAG, "hotel id -&gt;${result.getString("id")}")
            Log.i(TAG, "hotel name -&gt; ${result.getString("name")}")
        }
      }

      // META function
      @Throws(CouchbaseLiteException::class)
      fun testMetaFunction() {
        val rs = QueryBuilder
        .select(SelectResult.expression(Meta.id))
        .from(DataSource.database(database))
        .where(Expression.property("type").equalTo(Expression.string("airport")))
        .orderBy(Ordering.expression(Meta.id))
        .execute()

        for (result in rs) {
          Log.w(TAG, "airport id -&gt;${result.getString("id")}")
          Log.w(TAG, "airport id -&gt; ${result.getString(0)}")
        }
      }

      // </mark># all(<strong>)
    @Throws(CouchbaseLiteException::class)
    fun testSelectAll() {
        val queryAll = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))

        val query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="61"></i><b>(61)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        val token = query.addChangeListener { change -&gt;
            change.results?.let {
                for (result in it) {
                    Log.d(TAG, "results: ${result.keys}")
                    /</strong> Update UI <strong>/
                }
            } <i class="conum" data-value="62"></i><b>(62)</b>
        }


        query.removeChangeListener(token)

        for (result in query.execute()) {
            Log.i(TAG, "hotel -&gt; ${result.getDictionary(DATABASE_NAME)?.toMap()}")
        }
    }


    // <mark>#WHERE statement
    @Throws(CouchbaseLiteException::class)
    fun testWhereStatement() {
        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.intValue(10))
            .execute()
        for (result in rs) {
            result.getDictionary(DATABASE_NAME)?.let {
                Log.i(TAG, "name -&gt; ${it.getString("name")}")
                Log.i(TAG, "type -&gt; ${it.getString("type")}")
            }
        }
    }

    fun testQueryDeletedDocuments() {
        // Query documents that have been deleted
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted)
    }

    // </mark><mark>Collection Operators
    @Throws(CouchbaseLiteException::class)
    fun testCollectionStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(
                        ArrayFunction.contains(
                            Expression.property("public_likes"),
                            Expression.string("Armani Langworth")
                        )
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.getArray("public_likes")?.toList()}")
        }
    }

    // IN operator
    @Throws(CouchbaseLiteException::class)
    fun testInOperator() {
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.string("Armani").<code>in</code>(
                    Expression.property("first"),
                    Expression.property("last"),
                    Expression.property("username")
                )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.toMap()}")
        }
    }

    // Pattern Matching
    @Throws(CouchbaseLiteException::class)
    fun testPatternMatching() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // </mark># Wildcard Match
    @Throws(CouchbaseLiteException::class)
    fun testWildcardMatch() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // Wildcard Character Match
    @Throws(CouchbaseLiteException::class)
    fun testWildCharacterMatch() {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng____r"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // <mark># Regex Match
    @Throws(CouchbaseLiteException::class)
    fun testRegexMatch() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .regex(Expression.string("\\beng.*r\\b"))
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // JOIN statement
    @Throws(CouchbaseLiteException::class)
    fun testJoinStatement() {
        val rs = QueryBuilder.select(
            SelectResult.expression(Expression.property("name").from("airline")),
            SelectResult.expression(Expression.property("callsign").from("airline")),
            SelectResult.expression(Expression.property("destinationairport").from("route")),
            SelectResult.expression(Expression.property("stops").from("route")),
            SelectResult.expression(Expression.property("airline").from("route"))
        )
            .from(DataSource.database(database).<code>as</code>("airline"))
            .join(
                Join.join(DataSource.database(database).<code>as</code>("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(
                        Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline"))
                    )
                    .and(
                        Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.toMap()}")
        }
    }


    // </mark># GROUPBY statement
    @Throws(CouchbaseLiteException::class)
    fun testGroupByStatement() {
        val rs = QueryBuilder.select(
            SelectResult.expression(Function.count(Expression.string("</strong>"))),
            SelectResult.property("country"),
            SelectResult.property("tz")
        )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300)))
            )
            .groupBy(
                Expression.property("country"), Expression.property("tz")
            )
            .orderBy(Ordering.expression(Function.count(Expression.string("<strong>"))).descending())
            .execute()

        for (result in rs) {
            result.let {
                Log.i(
                    TAG,
                    "There are ${it.getInt("$1")} airports on the ${
                        it.getString("tz")
                    } timezone located in ${
                        it.getString("country")
                    } and above 300ft"
                )
            }
        }
    }

    // <mark># ORDER BY statement
    @Throws(CouchbaseLiteException::class)
    fun testOrderByStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("name").ascending())
            .limit(Expression.intValue(10))
            .execute()

        for (result in rs) {
            Log.i(TAG, "${result.toMap()}")
        }
    }


    // </mark># EXPLAIN statement
    @Throws(CouchbaseLiteException::class)
    fun testExplainStatement() {
        var query: Query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").descending()) <i class="conum" data-value="63"></i><b>(63)</b>
        Log.i(TAG, query.explain()) <i class="conum" data-value="64"></i><b>(64)</b>

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%"))) <i class="conum" data-value="65"></i><b>(65)</b>
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="66"></i><b>(66)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%")))
            )
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Function.lower(
                    Expression.property("type").equalTo(Expression.string("hotel"))
                )
            ) <i class="conum" data-value="67"></i><b>(67)</b>
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))) <i class="conum" data-value="68"></i><b>(68)</b>
        Log.i(TAG, query.explain())
    }

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex() {
        val config = FullTextIndexConfiguration("overview").ignoreAccents(false)

        database.createIndex( "overviewFTSIndex", config);
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS() {

        val ftsQuery =
              database.createQuery(
                "SELECT _id, overview FROM _ WHERE MATCH(overviewFTSIndex, 'michigan') ORDER BY RANK(overviewFTSIndex)")

        ftsQuery.execute().allResults().forEach {
          Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}")
        }

    }

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex_Querybuilder() {
        database.createIndex(
            "overviewFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("overview")).ignoreAccents(false)
        )
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS_Querybuilder() {

        val ftsQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id),
                                  SelectResult.expression(overview))
                          .from(DataSource.database(database))
                          .where(FullTextFunction.match("overviewFTSIndex", "michigan"))
                          .execute()

        ftsQuery.execute().allResults().forEach {
          Log.i(TAG, "${result.getString("Meta.id")}: ${result.getString("overview")}")
          }



    }


    fun testQuerySyntaxAll(currentUser: String) {
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(openOrCreateDatabaseForUser(currentUser)))

        val hotels: HashMap&lt;String, Hotel&gt; = HashMap()

        for (result in listQuery.execute().allResults()) {
            // get the k-v pairs from the 'hotel' key's value into a dictionary
            val thisDocsProps = result.getDictionary(0) <i class="conum" data-value="69"></i><b>(69)</b>
            val thisDocsId = thisDocsProps!!.getString("id")
            val thisDocsName = thisDocsProps.getString("name")
            val thisDocsType = thisDocsProps.getString("type")
            val thisDocsCity = thisDocsProps.getString("city")

            // Alternatively, access results value dictionary directly
            val id = result.getDictionary(0)?.getString("id").toString() <i class="conum" data-value="70"></i><b>(70)</b>
            hotels[id] = Hotel(
                id,
                result.getDictionary(0)?.getString("type"),
                result.getDictionary(0)?.getString("name"),
                result.getDictionary(0)?.getString("city"),
                result.getDictionary(0)?.getString("country"),
                result.getDictionary(0)?.getString("description")
            )
        }

    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun testQuerySyntaxJson(currentUser: String, argDb: Database) {
        val db = argDb
        // Example assumes Hotel class object defined elsewhere

        // Build the query
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(db))

        // Uses Jackson JSON processor
        val mapper = ObjectMapper()
        val hotels: ArrayList&lt;Hotel&gt; = ArrayList()

        for (result in listQuery.execute()) {

            // Get result as JSON string
            val json = result.toJSON() <i class="conum" data-value="71"></i><b>(71)</b>

            // Get Hashmap from JSON string
            val dictFromJSONstring = mapper.readValue(json, HashMap::class.java) <i class="conum" data-value="72"></i><b>(72)</b>

            // Use created hashmap
            val hotelId = dictFromJSONstring["id"].toString() //
            val hotelType = dictFromJSONstring["type"].toString()
            val hotelname = dictFromJSONstring["name"].toString()


            // Get custom object from JSON string
            val thisHotel = mapper.readValue(json, Hotel::class.java) <i class="conum" data-value="73"></i><b>(73)</b>
            hotels.add(thisHotel)
        }
    }
/</strong> end func testQuerySyntaxJson <strong>/



    fun testQuerySyntaxProps(currentUser: String) {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
            Log.i(TAG, "Hotel name -&gt; ${result.getString("name")}, in ${result.getString("country")}" )
        }
    }

    fun testQuerySyntaxCount(currentUser: String) {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.string("</strong>"))).as("mycount")) <i class="conum" data-value="74"></i><b>(74)</b>
            .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
            Log.i(TAG, "name -&gt; ${result.getInt("mycount").toString()}")
        }
    }


    fun testQuerySyntaxId(currentUser: String) {
        // tag::query-select-meta

        val rs = QueryBuilder
        .select(
          SelectResult.expression(Meta.id).as("hotelId"))
          .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
          Log.i(TAG, "hotel id -&gt;${result.getString("hotelId")}")
        }
        // end::query-select-meta
    }


    fun docsOnlyQuerySyntaxN1QL(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      val db = argDb
      val thisQuery = db.createQuery(
            "SELECT META().id AS id FROM _ WHERE type = \"hotel\"") <i class="conum" data-value="75"></i><b>(75)</b>

      return thisQuery.execute().allResults()

  }

  fun docsOnlyQuerySyntaxN1QLParams(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      val db = argDb
      val thisQuery = db.createQuery(
            "SELECT META().id AS id FROM _ WHERE type = \$type") <i class="conum" data-value="76"></i><b>(76)</b>

      thisQuery.parameters = Parameters().setString("type", "hotel") <i class="conum" data-value="77"></i><b>(77)</b>

      return thisQuery.execute().allResults()

  }

  fun testQuerySyntaxPagination(currentUser: String) {
    val limit = 20
    val offset = 0

    val rs = QueryBuilder
      .select(SelectResult.all())
      .from(DataSource.database(database))
      .where(Expression.property("type").equalTo(Expression.string("hotel")))
      .limit(Expression.intValue(limit), Expression.intValue(offset))

  }

    fun openOrCreateDatabaseForUser(argUser: String): Database = Database(argUser) {

    }



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/JSONExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.*
import org.json.JSONException
import org.json.JSONObject


const val JSON = """[{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\",
        \"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},
        {\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\",
        \"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},
        {\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",
        \"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\",
        \"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]"""


class KtJSONExamples {
    private val TAG = "SNIPPETS"

    fun jsonArrayExample(db: Database) {
        // github tag=tojson-array
        val mArray = MutableArray(JSON) <i class="conum" data-value="78"></i><b>(78)</b>
        for (i in 0 until mArray.count()) {
            mArray.getDictionary(i)?.apply {
                Log.i(TAG, getString("name") ?: "unknown")
                db.save(MutableDocument(getString("id"), toMap()))
            } <i class="conum" data-value="79"></i><b>(79)</b>
        }

        db.getDocument("1002")?.getArray("features")?.apply {
            for (feature in toList()) {
                Log.i(TAG, "$feature")
            } <i class="conum" data-value="80"></i><b>(80)</b>
            Log.i(TAG, toJSON())
        } <i class="conum" data-value="81"></i><b>(81)</b>
    }

    fun jsonBlobExample(db: Database) {
        // github tag=tojson-blob
        val thisBlob = db.getDocument("thisdoc-id")!!.toMap()
        if (!Blob.isBlob(thisBlob)) {
          return
        }
        val blobType = thisBlob["content_type"].toString()
        val blobLength = thisBlob["length"] as Number?
    }

    fun jsonDictionaryExample() {
        // github tag=tojson-dictionary
        val mDict = MutableDictionary(JSON) <i class="conum" data-value="82"></i><b>(82)</b>
        Log.i(TAG, "$mDict")
        Log.i(TAG, "Details for: ${mDict.getString("name")}")
        for (key in mDict.keys) {
          Log.i(TAG, key + " =&gt; " + mDict.getValue(key))
        }
      }

      @Throws(CouchbaseLiteException::class)
      fun jsonDocumentExample(srcDb: Database, dstDb: Database) {
        QueryBuilder
        .select(SelectResult.expression(Meta.id).as("metaId"))
        .from(DataSource.database(srcDb))
        .execute()
        .forEach {
          it.getString("metaId")?.let { thisId -&gt;
            srcDb.getDocument(thisId)?.toJSON()?.let { json -&gt; <i class="conum" data-value="83"></i><b>(83)</b>
              Log.i(TAG, "JSON String = $json")
              val hotelFromJSON = MutableDocument(thisId, json) <i class="conum" data-value="84"></i><b>(84)</b>
              dstDb.save(hotelFromJSON)
              dstDb.getDocument(thisId)?.toMap()?.forEach { e -&gt;
                Log.i(TAG, "$e.key =&gt; $e.value")
              } <i class="conum" data-value="85"></i><b>(85)</b>
            }
          }
        }
    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun jsonQueryExample(query: Query) {
        query.execute().forEach {

            // Use a Json Object to populate Native object
            JSONObject(it.toJSON()).apply {
                val (description, country, city, name, type, id) = Hotel(
                    id = getString("id"),
                    type = getString("type"),
                    name = getString("name"),
                    city = getString("city"),
                    country = "Ghana, West Africa",
                    description = "this hotel"
                )
            }
        }
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/JSONExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.Database
import com.couchbase.lite.MutableDictionary

class KtBlobExamples {

    // Example 2: Using Blobs
    fun example2(context: Context, db: Database) {
        val doc = db.getDocument("1000") ?: return

        // Create a blob from an asset
        val blob = Blob("image/png", context.assets.open("couchbaseimage.png"))

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON()

        // Save the blob as part of a document
        db.save(doc.toMutable().setBlob("avatar", blob))

        // Experts only!!!
        db.saveBlob(blob)

        // Retrieve saved blob and get as JSON again
        val blobAsJSONString = db.getDocument("1000")?.getBlob("avatar")?.toJSON() ?: return

        // reconstitute
        val blobAsMap = MutableDictionary().setJSON(blobAsJSONString).toMap()

        // show the contents of the reconstituted blob
        for key, value) in blobAsMap) {             Log.d("BLOB", "Data: $key -&gt; $value")         }          // verify that the reconstitued thing is still blob         if (Blob.isBlob(blobAsMap {
            Log.d("BLOB", blobAsJSONString)
        }
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt </code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset4_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">

// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/PasswordAuthListener.java 
//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorActivityLevel;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorType;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);                 Log.e(TAG, "Success!!");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void runClient(         @NonNull URI uri,         @NonNull String username,         @NonNull char[] password,         @NonNull Database db) throws InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setType(ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }

    /<strong>
     * Snippet 1: create a ListenerPasswordAuthenticator and configure the listener with it
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     * NOTE: This requires the following, in the manifest
     *     &lt;application
     *         ...
     *         android:usesCleartextTraffic="true"
     *         ...
     *     &gt;
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password)
        throws CouchbaseLiteException {
        final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

        config.setPort(0); // this is the default
        config.setDisableTls(true);
        config.setAuthenticator(new ListenerPasswordAuthenticator(
            (user, pwd) -&gt; username.equals(user) &amp;&amp; Arrays.equals(password, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/PasswordAuthListener.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/BlobExamples.java 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.util.Log;

import java.io.IOException;
import java.util.Map;

import com.couchbase.lite.Blob;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.Document;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;


class BlobExamples {

    // Example 2: Using Blobs
    public void example2(final Context context, final Database db) throws IOException, CouchbaseLiteException {
        final Document doc = db.getDocument("1000");
        if (doc == null) { return; }

        // Create a blob from an asset
        final Blob blob = new Blob("image/png", context.getAssets().open("couchbaseimage.png"));

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON();

        // Save the blob as part of a document
        final MutableDocument mDoc = doc.toMutable();
        mDoc.setBlob("avatar", blob);
        db.save(mDoc);

        // Experts only!!!
        db.saveBlob(blob);

        // Retrieve saved blob
        final Document sameDoc = db.getDocument("1000");
        if (sameDoc == null) { return; }

        final Blob sameBlob = sameDoc.getBlob("avatar");
        if (sameBlob == null) { return; }

        // Get as JSON again
        final String blobAsJSONString = sameBlob.toJSON();

        // reconstitute
        final Map&lt;String, Object&gt; blobAsMap = new MutableDictionary().setJSON(blobAsJSONString).toMap();

        // show the contents of the reconstituted blob
        for (Map.Entry&lt;String, Object&gt; entry: blobAsMap.entrySet()) {
            Log.d("BLOB", "Data: " + entry.getKey() + " -&gt; " + entry.getValue());
        }

        // verify that the reconstitued thing is still blob
        if (Blob.isBlob(blobAsMap)) { Log.d("BLOB", blobAsJSONString); }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/BlobExamples.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/MainActivity.java 
package com.couchbase.code_snippets;

import android.os.Bundle;

import androidx.appcompat.app.AppCompatActivity;


public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/MainActivity.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/CertAuthListener.java 

//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorActivityLevel;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorType;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);                 Log.e(TAG, "Success!!");                 deleteIdentity("server");                 Log.e(TAG, "Alias deleted: server");                 deleteIdentity("client");                 Log.e(TAG, "Alias deleted: client");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void startClient(         @NonNull URI uri,         @NonNull Certificate cert,         @NonNull TLSIdentity clientIdentity,         @NonNull Database db) throws CertificateEncodingException, InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setType(ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }

    /</strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
        throws CouchbaseLiteException {
        final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

        config.setPort(0); // this is the default
        config.setDisableTls(false);
        config.setTlsIdentity(serverId);
        config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
    }

    /<strong>
     * Snippet 3: delete an identity from the keystore
     * (NOTE: a keystore doesn't contain TLSIdentities: I'm guessing that this is what you intend)
     * &lt;p&gt;
     * Delete an identity from the key store.
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
        throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

        final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);

        keyStore.deleteEntry(alias);
    }

    /</strong>
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     * &lt;p&gt;
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    private void configureClientCerts(
        ReplicatorConfiguration config,
        @NonNull Certificate cert,
        @NonNull TLSIdentity clientIdentity)
        throws CertificateEncodingException {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
    }

    /<strong>
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     * &lt;p&gt;
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte[] buf = new byte[1024];
        int n;
        while n = in.read(buf &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/CertAuthListener.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java 
//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import androidx.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;
import com.example.docsnippet.Datastore;
import com.example.docsnippet.Hotel;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class docOnly_Examples {
  private static final String TAG = "EXAMPLE";

  private static final String DATABASE_NAME = "database";

  private final Context context;
  private Database database;
  private Replicator replicator;

  public docOnly_Examples(Context context) { this.context = context; }

  //@Test
  public void testGettingStarted() throws CouchbaseLiteException, URISyntaxException {

    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);

    // Get the database (and create it if it doesnt exist).
    DatabaseConfiguration config = new DatabaseConfiguration();

    config.setDirectory(context.getFilesDir().getAbsolutePath());

    Database database = new Database("getting-started", config);


    // Create a new document (i.e. a record) in the database.
    MutableDocument mutableDoc = new MutableDocument()
    .setFloat("version", 2.0F)
    .setString("type", "SDK");

    // Save it to the database.
    database.save(mutableDoc);

    // Update a document.
    mutableDoc = database.getDocument(mutableDoc.getId()).toMutable();
    mutableDoc.setString("language", "Java");
    database.save(mutableDoc);
    Document document = database.getDocument(mutableDoc.getId());
    // Log the document ID (generated by the database) and properties
    Log.i(TAG, "Document ID :: " + document.getId());
    Log.i(TAG, "Learning " + document.getString("language"));

    // Create a query to fetch documents of type SDK.
    Query query = QueryBuilder.select(SelectResult.all())
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("SDK")));
    ResultSet result = query.execute();
    Log.i(TAG, "Number of rows ::  " + result.allResults().size());

    // Create replicators to push and pull changes to and from the cloud.
    Endpoint targetEndpoint = new URLEndpoint(new URI("ws://localhost:4984/getting-started-db"));
    ReplicatorConfiguration replConfig = new ReplicatorConfiguration(database, targetEndpoint);
    replConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Add authentication.
    replConfig.setAuthenticator(new BasicAuthenticator("sync-gateway", "password"));

    // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
    Replicator replicator = new Replicator(replConfig);

    // Listen to replicator change events.
    replicator.addChangeListener(change -&gt; {
      if (change.getStatus().getError() != null) {
        Log.i(TAG, "Error code ::  " + change.getStatus().getError().getCode());
      }
    });

    // Start replication.
    replicator.start();


    database.delete();
  }

  public void test1xAttachments() throws CouchbaseLiteException, IOException {
    // if db exist, delete it
    deleteDB("android-sqlite", context.getFilesDir());

    ZipUtils.unzip(getAsset("replacedb/android140-sqlite.cblite2.zip"), context.getFilesDir());

    Database db = new Database("android-sqlite", new DatabaseConfiguration());
    try {

      Document doc = db.getDocument("doc1");

      // For Validation
      Dictionary attachments = doc.getDictionary("_attachments");
      Blob blob = attachments.getBlob("attach1");
      byte[] content = blob.getContent();
      // For Validation

      byte[] attach = String.format(Locale.ENGLISH, "attach1").getBytes();
      Arrays.equals(attach, content);

    } finally {
      // close db
      db.close();
      // if db exist, delete it
      deleteDB("android-sqlite", context.getFilesDir());
    }

    Document document = new MutableDocument();

    Dictionary attachments = document.getDictionary("_attachments");
    Blob blob = attachments != null ? attachments.getBlob("avatar") : null;
    byte[] content = blob != null ? blob.getContent() : null;
  }

  // <mark># Initializer
  public void testInitializer() {
    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);
  }

  // </mark># New Database
  public void testNewDatabase() throws CouchbaseLiteException {
    final DatabaseConfiguration config = new DatabaseConfiguration();
    config.setDirectory(context.getFilesDir().getAbsolutePath()); <i class="conum" data-value="1"></i><b>(1)</b>

    Database database = new Database("my-database", config);

    database.close();


    database.delete();
  }

  // <mark># Database Encryption
  public void testDatabaseEncryption() throws CouchbaseLiteException {
    DatabaseConfiguration config = new DatabaseConfiguration();
    config.setEncryptionKey(new EncryptionKey("PASSWORD"));
    Database database = new Database("mydb", config);
  }

  // </mark># Logging
  public void testLogging() {
    Database.setLogLevel(LogDomain.DATABASE, LogLevel.VERBOSE);
    Database.setLogLevel(LogDomain.QUERY, LogLevel.VERBOSE);
    }

    public void testEnableCustomLogging() {
        Database.log.setCustom(new LogTestLogger(LogLevel.WARNING)); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    // <mark># Console logging
    public void testConsoleLogging() throws CouchbaseLiteException {
          Database.log.getConsole().setDomain(LogDomain.ALL_DOMAINS);  <i class="conum" data-value="3"></i><b>(3)</b>
          Database.log.getConsole().setLevel(LogLevel.VERBOSE); <i class="conum" data-value="4"></i><b>(4)</b>
          Database.log.getConsole().setDomain(LogDomain.DATABASE);

    }

    // </mark># File logging
    public void testFileLogging() throws CouchbaseLiteException {
        final File path = context.getCacheDir();

        LogFileConfiguration LogCfg =
          new LogFileConfiguration(path.toString()); <i class="conum" data-value="5"></i><b>(5)</b>
        LogCfg.setMaxSize(10240); <i class="conum" data-value="6"></i><b>(6)</b>
        LogCfg.setMaxRotateCount(5); <i class="conum" data-value="7"></i><b>(7)</b>
        LogCfg.setUsePlainText(false); <i class="conum" data-value="8"></i><b>(8)</b>
        Database.log.getFile().setConfig(LogCfg);
        Database.log.getFile().setLevel(LogLevel.INFO); <i class="conum" data-value="9"></i><b>(9)</b>
    }

    public void writeConsoleLog()
    {
        Database.log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }
    public void writeCustomLog()
    {
        Database.log.Custom?.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }


    public void writeFileLog()
    {
        Database.log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }




    // <mark># Loading a pre-built database
    public void testPreBuiltDatabase() throws IOException {
      // Note: Getting the path to a database is platform-specific.
      // For Android you need to extract it from your
      // assets to a temporary directory and then pass that path to Database.copy()
      DatabaseConfiguration configuration = new DatabaseConfiguration();
      if (!Database.exists("travel-sample", context.getFilesDir())) {
            ZipUtils.unzip(getAsset("travel-sample.cblite2.zip"), context.getFilesDir());
            File path = new File(context.getFilesDir(), "travel-sample");
            try {
                Database.copy(path, "travel-sample", configuration);
            } catch (CouchbaseLiteException e) {
                e.printStackTrace();
            }
        }
    }

    // helper methods

    // if db exist, delete it
    private void deleteDB(String name, File dir) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            // sometimes, db is still in used, wait for a while. Maximum 3 sec
            for (int i = 0; i &lt; 10; i) {
                try {
                    Database.delete(name, dir);
                    break;
                } catch (CouchbaseLiteException ex) {
                    try { Thread.sleep(300); }
                    catch (InterruptedException ignore) { }
                }
            }
        }
    }

    // ### Initializers
    public void testInitializers() {
        MutableDocument newTask = new MutableDocument();
        newTask.setString("type", "task");
        newTask.setString("owner", "todo");
        newTask.setDate("createdAt", new Date());
        try {
            database.save(newTask);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // ### Mutability
    public void testMutability() {
        try { database.save(new MutableDocument("xyz")); }
        catch (CouchbaseLiteException ignore) { }

        Document document = database.getDocument("xyz");
        MutableDocument mutableDocument = document.toMutable();
        mutableDocument.setString("name", "apples");
        try {
            database.save(mutableDocument);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // ### Typed Accessors
    public void testTypedAccessors() {
        MutableDocument newTask = new MutableDocument();

        newTask.setValue("createdAt", new Date());
        Date date = newTask.getDate("createdAt");
    }

    // ### Batch operations
    public void testBatchOperations() {
        try {
            database.inBatch(() -&gt; {
                for (int i = 0; i &lt; 10; i) {
                    MutableDocument doc = new MutableDocument();
                    doc.setValue("type", "user");
                    doc.setValue("name", "user " + i);
                    doc.setBoolean("admin", false);
                    try {
                        database.save(doc);
                    } catch (CouchbaseLiteException e) {
                        Log.e(TAG, e.toString());
                    }
                    Log.i(TAG, String.format("saved user document %s", doc.getString("name")));
                }
            });
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // </mark># Document Expiration
    public void DocumentExpiration() throws CouchbaseLiteException {
        // Purge the document one day from now
        Instant ttl = Instant.now().plus(1, ChronoUnit.DAYS);
        database.setDocumentExpiration("doc123", new Date(ttl.toEpochMilli()));

        // Reset expiration
        database.setDocumentExpiration("doc1", null);

        // Query documents that will be expired in less than five minutes
        Instant fiveMinutesFromNow = Instant.now().plus(5, ChronoUnit.MINUTES);
        Query query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.expiration.lessThan(Expression.doubleValue(fiveMinutesFromNow.toEpochMilli())));
    }

    public void testDocumentChangeListener() throws CouchbaseLiteException {
        database.addDocumentChangeListener(
            "user.john",
            change -&gt; {
                Document doc = database.getDocument(change.getDocumentID());
                if (doc != null) {
                    Toast.makeText(context, "Status: " + doc.getString("verified_account"), Toast.LENGTH_SHORT).show();
                }
            });
    }

    // <mark># Blobs
    public void testBlobs() {
        MutableDocument newTask = new MutableDocument();

        InputStream is = getAsset("avatar.jpg"); <i class="conum" data-value="10"></i><b>(10)</b>
        if (is == null) { return; }
        try {
            Blob blob = new Blob("image/jpeg", is); <i class="conum" data-value="11"></i><b>(11)</b>
            newTask.setBlob("avatar", blob); <i class="conum" data-value="12"></i><b>(12)</b>
            database.save(newTask);

            Blob taskBlob = newTask.getBlob("avatar");
            byte[] bytes = taskBlob.getContent();
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        } finally {
            try { is.close(); }
            catch (IOException ignore) { }
        }
    }

    // </mark># Indexing
    public void testIndexing() throws CouchbaseLiteException {
        // For Documentation
        {

            database.createIndex(ValueIndexConfiguration(["type", "name"]), "TypeNameIndex");

        }
    }

    public void testIndexing_Querybuilder() throws CouchbaseLiteException {
        // For Documentation
        {
            database.createIndex(
                "TypeNameIndex",
                IndexBuilder.valueIndex(
                    ValueIndexItem.property("type"),
                    ValueIndexItem.property("name")));
        }
    }

    // <mark># SELECT statement
    public void testSelectStatement() {
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("type"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.expression(Meta.id));

            try {
                ResultSet rs = query.execute();
                for (Result result : rs) {
                    Log.i("Sample", String.format("hotel id -&gt; %s", result.getString("id")));
                    Log.i("Sample", String.format("hotel name -&gt; %s", result.getString("name")));
                }
            } catch (CouchbaseLiteException e) {
                Log.e("Sample", e.getLocalizedMessage());
            }
          }
        }

        // META function
        public void testMetaFunction() throws CouchbaseLiteException {
          // For Documentation
          {
          Query query = QueryBuilder
          .select(SelectResult.expression(Meta.id))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("airport")))
          .orderBy(Ordering.expression(Meta.id));
          ResultSet rs = query.execute();
          for (Result result : rs) {
            Log.w("Sample", String.format("airport id -&gt; %s", result.getString("id")));
            Log.w("Sample", String.format("airport id -&gt; %s", result.getString(0)));
          }
        }
    }

    // </mark># all(</strong>)
    public void testSelectAll() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")));

            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database)); <i class="conum" data-value="13"></i><b>(13)</b>

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            ListenerToken token = query.addChangeListener(change -&gt; { <i class="conum" data-value="14"></i><b>(14)</b>
                for (Result result : change.getResults()) {
                    Log.d(TAG, "results: " + result.getKeys());
                    /* Update UI <strong>/
                }
            });


            query.removeChangeListener(token); <i class="conum" data-value="15"></i><b>(15)</b>


            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("hotel -&gt; %s", result.getDictionary(DATABASE_NAME).toMap()));
            }
        }
    }

    // <mark>#WHERE statement
    public void testWhereStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .limit(Expression.intValue(10));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Dictionary all = result.getDictionary(DATABASE_NAME);
                Log.i("Sample", String.format("name -&gt; %s", all.getString("name")));
                Log.i("Sample", String.format("type -&gt; %s", all.getString("type")));
            }
        }
    }

    public void testQueryDeletedDocuments() {
        // Query documents that have been deleted
        Where query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted);
    }


    // </mark><mark>Collection Operators
    public void testCollectionStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("public_likes"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction
                        .contains(Expression.property("public_likes"), Expression.string("Armani Langworth"))));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("public_likes -&gt; %s", result.getArray("public_likes").toList()));
            }
        }
    }

    // IN operator
    public void testInOperator() throws CouchbaseLiteException {
        // For Documentation
        {
            Expression[] values = new Expression[] {
                Expression.property("first"),
                Expression.property("last"),
                Expression.property("username")
            };

            Query query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.string("Armani").in(values));

            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // Pattern Matching
    public void testPatternMatching() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Function.Expression.string("royal engineers museum")))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // </mark># Wildcard Match
    public void testWildcardMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng%e%"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // Wildcard Character Match
    public void testWildCharacterMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng____r"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // <mark># Regex Match
    public void testRegexMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).regex(Expression.string("\\beng.*r\\b"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // JOIN statement
    public void testJoinStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder.select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route")))
                .from(DataSource.database(database).as("airline"))
                .join(Join.join(DataSource.database(database).as("route"))
                    .on(Meta.id.from("airline").equalTo(Expression.property("airlineid").from("route"))))
                .where(Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline").equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route").equalTo(Expression.string("RIX"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // </mark># GROUPBY statement
    public void testGroupByStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder.select(
                SelectResult.expression(Function.count(Expression.string("</strong>"))),
                SelectResult.property("country"),
                SelectResult.property("tz"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300))))
                .groupBy(
                    Expression.property("country"),
                    Expression.property("tz"))
                .orderBy(Ordering.expression(Function.count(Expression.string("<strong>"))).descending());
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format(
                        "There are %d airports on the %s timezone located in %s and above 300ft",
                        result.getInt("$1"),
                        result.getString("tz"),
                        result.getString("country")));
            }
        }
    }

    // <mark># ORDER BY statement
    public void testOrderByStatement() throws CouchbaseLiteException {
      // For Documentation
      {
        Query query = QueryBuilder
        .select(
          SelectResult.expression(Meta.id),
          SelectResult.property("name"))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("hotel")))
          .orderBy(Ordering.property("name").ascending())
          .limit(Expression.intValue(10));
          ResultSet rs = query.execute();
          for (Result result : rs) { Log.i("Sample", String.format("%s", result.toMap())); }
        }
      }
      // </mark># EXPLAIN statement
      public void testExplainStatement() throws CouchbaseLiteException {
          // For Documentation
          {
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("university")))
                .groupBy(Expression.property("country"))
                .orderBy(Ordering.property("name").descending()); <i class="conum" data-value="16"></i><b>(16)</b>
              Log.i(query.explain()); <i class="conum" data-value="17"></i><b>(17)</b>
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("%hotel%"))); <i class="conum" data-value="18"></i><b>(18)</b>
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="19"></i><b>(19)</b>
                  .and(Expression.property("name").like(Expression.string("%royal%"))));
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))); <i class="conum" data-value="20"></i><b>(20)</b>
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="21"></i><b>(21)</b>
              Log.i(query.explain());
          }
      }
      // end query-explain

    void prepareIndex() throws CouchbaseLiteException {

        FullTextIndexConfiguration config = new FullTextIndexConfiguration("Overview").ignoreAccents(false)

        database.createIndex( config, "overviewFTSIndex")

    }

    void prepareIndex_Querybuilder() throws CouchbaseLiteException {
      database.createIndex(
          "overviewFTSIndex",
          IndexBuilder.fullTextIndex(FullTextIndexItem.property("overview")).ignoreAccents(false));
  }

    public void testFTS() throws CouchbaseLiteException {

        Query ftsQuery =
                database.createQuery(
                "SELECT _id, overview FROM _ WHERE MATCH(overviewFTSIndex, 'michigan') ORDER BY RANK(overviewFTSIndex)");

        for (result in ftsQuery.execute().allResults()) {
          Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}");
        }

    }
    public void testFTS_Querybuilder() throws CouchbaseLiteException {
        Expression whereClause = FullTextFunction.match("overviewFTSIndex", "'michigan'");
        Query ftsQuery =
                QueryBuilder.select(SelectResult.expression(Meta.id),
                                    SelectResult.expression(overview)
                                  )
            .from(DataSource.database(database))
            .where(whereClause);

            for (result in ftsQuery.execute().allResults()) {
              Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}");
            }

    }

    /</strong> The <code>tag::replication[]</code> example is inlined in java.adoc <strong>/

    public void testTroubleshooting() {
        Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE);
    }

    public void testReplicationBasicAuthentication() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new BasicAuthenticator("username", "password"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationSessionAuthentication() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationStatus() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        replicator.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == Replicator.ActivityLevel.STOPPED) {
                Log.i(TAG, "Replication stopped");
            }
          });
        }

    //  BEGIN PendingDocuments BM -- 19/Feb/21 --
    import android.support.annotation.NonNull;
    import android.util.Log;

    import java.net.URI;
    import java.net.URISyntaxException;
    import java.util.Iterator;
    import java.util.Set;

    import com.couchbase.lite.CouchbaseLiteException;
    import com.couchbase.lite.Database;
    import com.couchbase.lite.Endpoint;
    import com.couchbase.lite.Replicator;
    import com.couchbase.lite.ReplicatorConfiguration;
    import com.couchbase.lite.URLEndpoint;

    class PendingDocsExample {
        private static final String TAG = "SCRATCH";

        private Database database;
        private Replicator replicator;

        //  BEGIN PendingDocuments IB -- 11/Feb/21 --
        public void testReplicationPendingDocs() throws URISyntaxException, CouchbaseLiteException {
            // nottag::replication-pendingdocuments[]
            // ... include other code as required
            //
            final Endpoint endpoint =
              new URLEndpoint(new URI("ws://localhost:4984/db"));

            final ReplicatorConfiguration config =
              new ReplicatorConfiguration(database, endpoint)
            .setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

            replicator = new Replicator(config);
            final Set&lt;String&gt; pendingDocs =
              replicator.getPendingDocumentIds(); <i class="conum" data-value="22"></i><b>(22)</b>


            replicator.addChangeListener(change -&gt; {
              onStatusChanged(pendingDocs, change.getStatus()); });

            replicator.start();

            // ... include other code as required
            // notend::replication-pendingdocuments[]
          }
        //
        //
        private void onStatusChanged(
          @NonNull final Set&lt;String&gt; pendingDocs,
          @NonNull final Replicator.Status status) {
          // ... sample onStatusChanged function
          //
          Log.i(TAG,
            "Replicator activity level is " + status.getActivityLevel().toString());

          // iterate and report-on previously
          // retrieved pending docids 'list'
          for (Iterator&lt;String&gt; itr = pendingDocs.iterator(); itr.hasNext(); ) {
            final String docId = itr.next();
            try {
              if (!replicator.isDocumentPending(docId)) { continue; } <i class="conum" data-value="23"></i><b>(23)</b>

              itr.remove();
              Log.i(TAG, "Doc ID " + docId + " has been pushed");
            }
            catch (CouchbaseLiteException e) {
              Log.w(TAG, "isDocumentPending failed", e); }
          }
        }
        //  END PendingDocuments BM -- 19/Feb/21 --
    }


    public void testHandlingNetworkErrors() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        replicator.addChangeListener(change -&gt; {
            CouchbaseLiteException error = change.getStatus().getError();
            if (error != null) { Log.w(TAG, "Error code:: %d", error); }
        });
        replicator.start();

        replicator.stop();
    }

    public void testReplicatorDocumentEvent() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        ListenerToken token = replicator.addDocumentReplicationListener(replication -&gt; {

            Log.i(TAG, "Replication type: " + replication.isPush( ? "Push" : "Pull"));
            for (ReplicatedDocument document : replication.getDocuments()) {
                Log.i(TAG, "Doc ID: " + document.getID());

                CouchbaseLiteException err = document.getError();
                if (err != null) {
                    // There was an error
                    Log.e(TAG, "Error replicating document: ", err);
                    return;
                }

                if (document.flags().contains(DocumentFlag.DocumentFlagsDeleted)) {
                    Log.i(TAG, "Successfully replicated a deleted document");
                }
            }
        });

        replicator.start();

        replicator.removeChangeListener(token);
    }

    public void testReplicationCustomHeader() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();
        headers.put("CustomHeaderName", "Value");
        config.setHeaders(headers);
    }

    // <mark># Certificate Pinning

    public void testCertificatePinning() throws URISyntaxException, IOException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);

        InputStream is = getAsset("cert.cer");
        byte[] cert = IOUtils.toByteArray(is);
        if (is != null) {
            try { is.close(); }
            catch (IOException ignore) {}
        }

        config.setPinnedServerCertificate(cert);
    }

    // </mark># Reset replicator checkpoint
    public void testReplicationResetCheckpoint() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        if (resetCheckpointRequired_Example) {
          replicator.start(true); <i class="conum" data-value="24"></i><b>(24)</b>
        else
          replicator.start(false);
        }

        // ... at some later time

        replicator.stop();
    }

    public void testReplicationPushFilter() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPushFilterdocument, flags) -&gt; flags.contains(DocumentFlag.DocumentFlagsDeleted; <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationPullFilter() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPullFilterdocument, flags) -&gt; "draft".equals(document.getString("type"); <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testCustomRetryConfig() throws URISyntaxException {
    URLEndpoint target =
    new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

    ReplicatorConfiguration config =
    new ReplicatorConfiguration(database, target);

    //  other config as required . . .
    config.setHeartbeat(150L); <i class="conum" data-value="25"></i><b>(25)</b>
    config.setMaxattempts(20L); <i class="conum" data-value="26"></i><b>(26)</b>
    config.setMaxAttemptWaitTime(600L); <i class="conum" data-value="27"></i><b>(27)</b>

    Replicator repl = new Replicator(config);

    }


    public void docsSetAutoPurge() throws CouchbaseliteException {

      DatabaseConfiguration config = new DatabaseConfiguration();
      Database database1 = new Database("mydb", config);

      ReplicatorConfiguration repcfg =
      new ReplicatorConfiguration(database, target);

      repcfg.setAutoPurgeEnabled(true); <i class="conum" data-value="28"></i><b>(28)</b>

    }


    public void testDatabaseReplica() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database1 = new Database("mydb", config);

        config = new DatabaseConfiguration();
        Database database2 = new Database("db2", config);

        /</strong> EE feature: code below might throw a compilation error
           if it's compiled against CBL Android Community. <strong>/
        DatabaseEndpoint targetDatabase = new DatabaseEndpoint(database2);
        ReplicatorConfiguration replicatorConfig = new ReplicatorConfiguration(database1, targetDatabase);
        replicatorConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(replicatorConfig);
        replicator.start();
    }

    public void testPredictiveModel() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Database.prediction.registerModel("ImageClassifier", new ImageClassifierModel());

        ValueIndex index = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")));
        database.createIndex("value-index-image-classifier", index);

        Database.prediction.unregisterModel("ImageClassifier");
    }

    public void testPredictiveIndex() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Map&lt;String, Object&gt; inputMap = new HashMap&lt;&gt;();
        inputMap.put("numbers", Expression.property("photo"));
        Expression input = Expression.map(inputMap);

        PredictiveIndex index = IndexBuilder.predictiveIndex("ImageClassifier", input, null);
        database.createIndex("predictive-index-image-classifier", index);
    }

    public void testPredictiveQuery() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Map&lt;String, Object&gt; inputProperties = new HashMap&lt;&gt;();
        inputProperties.put("photo", Expression.property("photo"));
        Expression input = Expression.map(inputProperties);
        PredictionFunction prediction = PredictiveModel.predict("ImageClassifier", input); <i class="conum" data-value="1"></i><b>(1)</b>

        Query query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("label").equalTo(Expression.string("car"))
                .and(Expression.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))));

        // Run the query.
        ResultSet result = query.execute();
        Log.d(TAG, "Number of rows: " + result.allResults().size());
    }

    public void testReplicationWithCustomConflictResolver() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setConflictResolver(new LocalWinConflictResolver());

        Replicator replication = new Replicator(config);
        replication.start();
    }

    public void testSaveWithCustomConflictResolver() throws CouchbaseLiteException {
        Document doc = database.getDocument("xyz");
        if (doc == null) { return; }
        MutableDocument mutableDocument = doc.toMutable();
        mutableDocument.setString("name", "apples");

        database.save(
            mutableDocument,
            (newDoc, curDoc) -&gt; { <i class="conum" data-value="29"></i><b>(29)</b>
                if (curDoc == null) { return false; } <i class="conum" data-value="30"></i><b>(30)</b>
                Map&lt;String, Object&gt; dataMap = curDoc.toMap();
                dataMap.putAll(newDoc.toMap()); <i class="conum" data-value="31"></i><b>(31)</b>
                newDoc.setData(dataMap);
                return true; <i class="conum" data-value="32"></i><b>(32)</b>
            }); <i class="conum" data-value="33"></i><b>(33)</b>
      }
    }


&lt;.&gt; The conflict handler code is provided as a lambda.

&lt;.&gt; If the handler cannot resolve a conflict, it can return false.
In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.

&lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.

&lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).

&lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method

// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
class LocalWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getLocalDocument();
    }
}

// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
class RemoteWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getRemoteDocument();
    }
}

// Using replConfig.setConflictResolver(new MergeConflictResolver());
class MergeConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        Map&lt;String, Object&gt; merge = conflict.getLocalDocument().toMap();
        merge.putAll(conflict.getRemoteDocument().toMap());
        return new MutableDocument(conflict.getDocumentId(), merge);
    }
}


/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

class BrowserSessionManager implements MessageEndpointDelegate {
    private final Context context;
    private Replicator replicator;

    private BrowserSessionManager(Context context) { this.context = context; }

    public void initCouchbase() throws CouchbaseLiteException {
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration(context);
        Database database = new Database("mydb", databaseConfiguration);

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        MessageEndpoint messageEndpointTarget = new MessageEndpoint(
            "UID:123",
            "active",
            ProtocolType.MESSAGE_STREAM,
            this);

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, messageEndpointTarget);

        // Create the replicator object.
        replicator = new Replicator(config);
        // Start the replication.
        replicator.start();
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    @NonNull
    @Override
    public MessageEndpointConnection createConnection(@NonNull MessageEndpoint endpoint) {
        return new ActivePeerConnection(); /</strong> implements MessageEndpointConnection <strong>/
    }
}

class ActivePeerConnection implements MessageEndpointConnection {

    private ReplicatorConnection replicatorConnection;

    public void disconnect() {
        replicatorConnection.close(null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }

    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete();
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null);
    }

    public void receive(Message message) {
        replicatorConnection.receive(message);
    }

}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

class PassivePeerConnection implements MessageEndpointConnection {
    private final Context context;

    private MessageEndpointListener messageEndpointListener;
    private ReplicatorConnection replicatorConnection;

    private PassivePeerConnection(Context context) { this.context = context; }

    public void startListener() throws CouchbaseLiteException {
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration();
        Database database = new Database("mydb", databaseConfiguration);
        MessageEndpointListenerConfiguration listenerConfiguration = new MessageEndpointListenerConfiguration(
            database,
            ProtocolType.MESSAGE_STREAM);
        this.messageEndpointListener = new MessageEndpointListener(listenerConfiguration);
    }

    public void stopListener() {
        messageEndpointListener.closeAll();
    }

    public void accept() {
        PassivePeerConnection connection = new PassivePeerConnection(context); /</strong> implements
        MessageEndpointConnection <strong>/
        messageEndpointListener.accept(connection);
    }

    public void disconnect() {
        replicatorConnection.close(null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete();
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null);
    }

    public void receive(Message message) {
        replicatorConnection.receive(message);
    }
}

// tensorFlowModel is a fake implementation
// this would be the implementation of the ml model you have chosen
class ImageClassifierModel implements PredictiveModel {
    @Override
    public Dictionary predict(@NonNull Dictionary input) {
        Blob blob = input.getBlob("photo");
        if (blob == null) { return null; }

        // tensorFlowModel is a fake implementation
        // this would be the implementation of the ml model you have chosen
        return new MutableDictionary(TensorFlowModel.predictImage(blob.getContent())); <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

class TensorFlowModel {
    public static Map&lt;String, Object&gt; predictImage(byte[] data) {
        return null;
    }
}

class LogTestLogger implements Logger {
    @NonNull
    private final LogLevel level;

    public LogTestLogger(@NonNull LogLevel level) { this.level = level; }

    @NonNull
    @Override
    public LogLevel getLevel() { return level; }

    @Override
    public void log(@NonNull LogLevel level, @NonNull LogDomain domain, @NonNull String message) {
    }
}





//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);                 Log.e(TAG, "Success!!");                 deleteIdentity("server");                 Log.e(TAG, "Alias deleted: server");                 deleteIdentity("client");                 Log.e(TAG, "Alias deleted: client");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void startClient(         @NonNull URI uri,         @NonNull Certificate cert,         @NonNull TLSIdentity clientIdentity,         @NonNull Database db) throws CertificateEncodingException, InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    /</strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(false);
      config.setTlsIdentity(serverId);
      config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

      final URLEndpointListener listener = new URLEndpointListener(config);
      listener.start();

      final List&lt;URI&gt; urls = listener.getUrls();
      if (urls.isEmpty()) { return null; }
      return urls.get(0);
    }

    /<strong>
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
    throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

      final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
      keyStore.load(null);

      keyStore.deleteEntry(alias); <i class="conum" data-value="34"></i><b>(34)</b>
    }

    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /</strong> Configure Client (active) side certificates
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     <strong>/
    private void configureClientCerts(
      ReplicatorConfiguration config,
      @NonNull Certificate cert,
      @NonNull TLSIdentity clientIdentity)
      throws CertificateEncodingException {

        // Create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
      }
      // notend::p2p-tlsid-tlsidentity-with-label[]

    /</strong>
     * Copy a cert from a resource bundle
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte buf[] = new byte[1024];
        int n;
        while n = in.read(buf &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}



//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);                 Log.e(TAG, "Success!!");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void runClient(         @NonNull URI uri,         @NonNull String username,         @NonNull char[] password,         @NonNull Database db) throws InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    /</strong>*
     *
     * Start a listener for db that accepts connections using exactly the passed username and password

     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password) <i class="conum" data-value="35"></i><b>(35)</b>
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(true);
      config.setAuthenticator(new ListenerPasswordAuthenticator(
        (validUser, pwd) -&gt; username.equals(validUser) &amp;&amp; Arrays.equals(validPassword, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
      }
    }






// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.support.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;

public class docOnly_ReplicationExamples {
  private static final String TAG = "EXAMPLE ACTIVE PEER";
  private static final String thisDBNAME = "local-database";
  private final Context context;
  // private Database database;
  // private Replicator replicator;

  public docOnly_ReplicationExamples(Context context) { this.context = context; }

  String user = "syncuser";
  String password = "sync9455";
  SecCertificate cert=null;
  String passivePeerEndpoint = "10.1.1.12:8920";
  String passivePeerPort = "8920";
  String passiveDbName = "userdb";
  Database thisDB;
  Replicator thisReplicator;
  ListenerToken replicatorListener;




// PASSIVE PEER STUFF
// Stuff I adapted
//
// BEGIN new stuff 90420temp cache
  private URLEndpointListener createListener() {
  final URLEndpointListenerConfiguration listenerConfig = new URLEndpointListenerConfiguration(db);

  listenerConfig.setDisableTls(false);

  listenerConfig.setEnableDeltaSync(true);

  listenerConfig.setTlsIdentity(null); // Use with anonymous self signed cert

  listenerConfig.setAuthenticator(new ListenerPasswordAuthenticator(this::isWhitelistedUser));

  return new URLEndpointListener(listenerConfig);
}

public void startListener(@NotNull URLEndpointListener listener) {
  executor.submit) -&gt; {       CouchbaseLiteException err = null;       try { listener.start(); }       catch (CouchbaseLiteException e) { err = e; }       onStart(err);   }); }  private void stopListener(@NotNull URLEndpointListener listener) {   listener.stop(); } // END new stuff 90420temp cache   private void ibListenerSimple() {   final URLEndpointListenerConfiguration thisConfig =     new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="36"></i><b>(36)</b>    thisConfig.setAuthenticator(     new ListenerPasswordAuthenticator(       (username, password) -&gt;         username.equals("valid.User") &amp;&amp;         Arrays.equals(password, valid.password.string)       )     ); <i class="conum" data-value="37"></i><b>(37)</b>    final URLEndpointListener thisListener =     new URLEndpointListener(thisConfig); <i class="conum" data-value="38"></i><b>(38)</b>    thisListener.start(); <i class="conum" data-value="39"></i><b>(39)</b>  }  private void ibReplicatorSimple() {   URI uri = null;   try {       uri = new URI("wss://10.0.2.2:4984/db");   } catch (URISyntaxException e) {       e.printStackTrace();   }   Endpoint theListenerEndpoint = new URLEndpoint(uri); <i class="conum" data-value="40"></i><b>(40)</b>    ReplicatorConfiguration thisConfig =     new ReplicatorConfiguration(database, theListenerEndpoint); <i class="conum" data-value="41"></i><b>(41)</b>    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="42"></i><b>(42)</b>    final BasicAuthenticator thisAuth   = new BasicAuthenticator(       "valid.user",       "valid.password.string");   thisConfig.setAuthenticator(thisAuth) <i class="conum" data-value="43"></i><b>(43)</b>    this.replicator = new Replicator(config); <i class="conum" data-value="44"></i><b>(44)</b>   this.replicator.start(); <i class="conum" data-value="45"></i><b>(45)</b>  }   private void ibPassListener() { // EXAMPLE 1     // Initialize the listener config     final URLEndpointListenerConfiguration thisConfig        = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="46"></i><b>(46)</b>      thisConfig.setPort(55990); <i class="conum" data-value="47"></i><b>(47)</b>      thisConfig.setNetworkInterface("10.1.1.10"); <i class="conum" data-value="48"></i><b>(48)</b>      thisConfig.setEnableDeltaSync(false); <i class="conum" data-value="49"></i><b>(49)</b>      // Configure server security     thisConfig.setDisableTls(false); <i class="conum" data-value="50"></i><b>(50)</b>      // Use an Anonymous Self-Signed Cert     thisConfig.setTlsIdentity(null); <i class="conum" data-value="51"></i><b>(51)</b>       // Configure Client Security using an Authenticator     // For example, Basic Authentication <i class="conum" data-value="52"></i><b>(52)</b>     thisConfig.setAuthenticator(new ListenerPasswordAuthenticator(       (validUser, validPassword) -&gt;         username.equals(validUser) &amp;&amp;         Arrays.equals(password, validPassword);

    // Initialize the listener
    final URLEndpointListener thisListener
      = new URLEndpointListener(thisConfig); <i class="conum" data-value="53"></i><b>(53)</b>

    // Start the listener
    thisListener.start(); <i class="conum" data-value="54"></i><b>(54)</b>

}

private void ibListenerGetNetworkInterfaces() {
  final URLEndpointListenerConfiguration thisConfig =
    URLEndpointListenerConfiguration(database: self.oDB)
  final URLEndpointListener thisListener
    = new URLEndpointListener(thisConfig);
  thisListener.start()
  Log.i(TAG, "URLS are " + thisListener.getUrls());

}

private void ibListenerLocalDb() {
// . . . preceding application logic . . .
CouchbaseLite.init(context); <i class="conum" data-value="55"></i><b>(55)</b>
Database thisDB = new Database("passivepeerdb");

}

private void ibListenerConfigTlsDisable() {
thisConfig.setDisableTls(true); <i class="conum" data-value="56"></i><b>(56)</b>

}

private void ibListenerConfigTlsIdFull() {
  // Use CA Cert
  // Import a key pair into secure storage
  // Create a TLSIdentity from the imported key-pair
  InputStream thisKeyPair = new FileInputStream();

  thisKeyPair.getClass().getResourceAsStream("serverkeypair.p12"); <i class="conum" data-value="57"></i><b>(57)</b>

  TLSIdentity thisIdentity = new TLSIdentity.importIdentity(
    EXTERNAL_KEY_STORE_TYPE,  // KeyStore type, eg: "PKCS12"
    thisKeyPair,              // An InputStream from the keystore
    password,                 // The keystore password
    EXTERNAL_KEY_ALIAS,       // The alias to be used (in external keystore)
    null,                     // The key password
    "test-alias"              // The alias for the imported key
    );


  // Use a self-signed certificate
  // Create a TLSIdentity for the server using convenience API.
  // System generates self-signed cert
  // Work-in-progress. Code snippet coming soon.
  private static final Map&lt;String, String&gt; CERT_ATTRIBUTES; <i class="conum" data-value="58"></i><b>(58)</b>
  static {
    final Map&lt;String, String&gt; thisMap = new HashMap&lt;&gt;();
    m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "Couchbase Demo");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
    m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>");
    CERT_ATTRIBUTES = Collections.unmodifiableMap(thisMap);
  }

  // Store the TLS identity in secure storage
  // under the label 'couchbase-docs-cert'
  TLSIdentity thisIdentity =
    new TLSIdentity.createIdentity(
      true,
      CERT_ATTRIBUTES,
      null,
      "couchbase-docs-cert"); <i class="conum" data-value="59"></i><b>(59)</b>


  // Set the TLS Identity
  thisConfig.setTlsIdentity(thisIdentity); <i class="conum" data-value="60"></i><b>(60)</b>

}

private void ibListenerConfigClientAuthRoot() {
  // Configure the client authenticator
  // to validate using ROOT CA
  // thisClientID.certs is a list containing a client cert to accept
  // and any other certs needed to complete a chain between the client cert
  // and a CA
  final TLSIdentity validId =
    TLSIdentity.getIdentity("Our Corporate Id");  // get the identity <i class="conum" data-value="61"></i><b>(61)</b>

  if (validId == null) { throw new IllegalStateException("Cannot find corporate id"); }

  thisConfig.setTlsIdentity(validId);

  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(validId.getCerts())); <i class="conum" data-value="62"></i><b>(62)</b> <i class="conum" data-value="63"></i><b>(63)</b>
    // accept only clients signed by the corp cert

  final URLEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

}

private void ibListenerConfigClientAuthLambda() {
// Configure authentication using application logic
  final TLSIdentity thisCorpId = TLSIdentity.getIdentity("OurCorp"); <i class="conum" data-value="64"></i><b>(64)</b>
  if (thisCorpId == null) {
    throw new IllegalStateException("Cannot find corporate id"); }
  thisConfig.setTlsIdentity(thisCorpId);
  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(
      (thisCorpId.getCerts()) -&gt; {
      // use supplied logic that resolves to boolean
      // true=valid, false=invalid
      }
    )); <i class="conum" data-value="65"></i><b>(65)</b> <i class="conum" data-value="66"></i><b>(66)</b>
  final ULEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

}


private void ibListenerConfigTlsDisable() {

  thisConfig.disableTLS(true);

}


private void ibListenerStatusCheck() {
  int connectionCount =
    thisListener.getStatus().getConnectionCount(); <i class="conum" data-value="67"></i><b>(67)</b>

  int activeConnectionCount =
    thisListener.getStatus().getActiveConnectionCount();  <i class="conum" data-value="68"></i><b>(68)</b>

}

private void ibListenerStop() {

  thisListener.stop();

}

// Listener Callouts
/</strong>

    &lt;.&gt; Initialize the listener instance using the configuration settings.
    &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.



  &lt;.&gt; <code>connectionCount</code> -- the total number of connections served by the listener
  &lt;.&gt; <code>activeConnectionCount</code> -- the number of active (BUSY) connections currently being served by the listener
  //

<strong>/
/</strong> END CALLOUTS TEXT <strong>/


private void ibP2PUrlEndpointListener() {

  public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
  }
}



// ACTIVE PEER STUFF
// Replication code
//

  //@Test
  public void testActPeerSync() throws CouchbaseLiteException, URISyntaxException {
    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://listener.com:8954"))); <i class="conum" data-value="69"></i><b>(69)</b> <i class="conum" data-value="70"></i><b>(70)</b>

    // Set replicator type
    thisConfig.setReplicatorType(
      ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Configure Sync Mode
    thisConfig.setContinuous(false); // default value

    // set auto-purge behavior (here we override default)
    thisConfig.setAutoPurgeEnabled(false); <i class="conum" data-value="71"></i><b>(71)</b>

    // Configure Server Authentication --
    // only accept self-signed certs
    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="72"></i><b>(72)</b>

    // Configure the credentials the
    // client will provide if prompted
    final BasicAuthenticator thisAuth
      = new BasicAuthenticator(
          "Our Username",
          "Our PasswordValue")); <i class="conum" data-value="73"></i><b>(73)</b>

    thisConfig.setAuthenticator(thisAuth)

    /</strong> Optionally set custom conflict resolver call back <strong>/
    thisConfig.setConflictResolver( /</strong> define resolver function <strong>/); <i class="conum" data-value="74"></i><b>(74)</b>

    // Create replicator
    // Consider holding a reference somewhere
    // to prevent the Replicator from being GCed
    final Replicator thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="75"></i><b>(75)</b>

    // Optionally add a change listener <i class="conum" data-value="76"></i><b>(76)</b>
    ListenerToken thisListener =
      new thisReplicator.addChangeListener(change -&gt; {
        final CouchbaseLiteException err =
         change.getStatus().getError();
         if (err != null) {
           Log.i(TAG, "Error code ::  " + err.getCode(), e);
         }
      }); <i class="conum" data-value="77"></i><b>(77)</b>

    // Start replicator
    thisReplicator.start(false); <i class="conum" data-value="78"></i><b>(78)</b>


  public void ibReplicatorConfig() {
  // BEGIN additional snippets
      // Configure Server Security
      // -- only accept CA attested certs
      thisConfig.setAcceptOnlySelfSignedServerCertificate(false); <i class="conum" data-value="79"></i><b>(79)</b>


    // Return the remote pinned cert (the listener's cert)
    byte returnedCert
     = new byte(thisConfig.getPinnedCertificate()); // Get listener cert if pinned

    // ... your other replicator configuration

    // Provide a client certificate to the server for authentication
    final TLSIdentity thisClientId = TLSIdentity.getIdentity("clientId"); <i class="conum" data-value="80"></i><b>(80)</b>

    if (thisClientId == null) { throw new IllegalStateException("Cannot find client id"); }

    thisConfig.setAuthenticator(new ClientCertificateAuthenticator(thisClientId)); <i class="conum" data-value="81"></i><b>(81)</b>

    // ... your other replicator configuration
    final thisReplicator= new Replicator(thisConfig);


    // Use the pinned certificate from the byte array (cert)
    thisConfig.setPinnedServerCertificate(cert.getEncoded()); <i class="conum" data-value="82"></i><b>(82)</b>
}
// END additional snippets








    Log.i(TAG, "The Replicator is currently " +
      thisReplicator.getStatus().getActivityLevel());

    Log.i(TAG, "The Replicator has processed " + t);

    if (thisReplicator.getStatus().getActivityLevel() ==
      Replicator.ActivityLevel.BUSY) {
        Log.i(TAG, "Replication Processing");
        Log.i(TAG, "It has completed " +
          thisReplicator.getStatus().getProgess().getTotal() +
          " changes");
      }

      // Stop replication.
      thisReplicator.stop(); <i class="conum" data-value="83"></i><b>(83)</b>


  CouchbaseLite.init(context);
  Database thisDB = new Database("passivepeerdb");  <i class="conum" data-value="84"></i><b>(84)</b>
  // Initialize the listener config
  final URLEndpointListenerConfiguration thisConfig = new URLEndpointListenerConfiguration(database);
  thisConfig.setPort(55990)           // &lt;.&gt; Optional; defaults to auto
  thisConfig.setDisableTls(false)     // &lt;.&gt; Optional; defaults to false
  thisConfig.setEnableDeltaSync(true) // &lt;.&gt; Optional; Defaults to false

  // Configure the client authenticator (if using basic auth)
  ListenerPasswordAuthenticator auth = new ListenerPasswordAuthenticator { "username", "password"}; <i class="conum" data-value="85"></i><b>(85)</b>
  thisConfig.setAuthenticator(auth); <i class="conum" data-value="86"></i><b>(86)</b>

  // Initialize the listener
  final URLEndpointListener listener = new URLEndpointListener( thisConfig ); <i class="conum" data-value="87"></i><b>(87)</b>

  // Start the listener
  listener.start(); <i class="conum" data-value="88"></i><b>(88)</b>




  Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
        )

  TLSIdentity thisIdentity = new TLSIdentity.createIdentity(true, X509_ATTRIBUTES, null, "test-alias");




  String thisAlias = "alias-to-delete";
  final KeyStore thisKeyStore
    =  KeyStore.getInstance("AndroidKeyStore");
  thisKeyStore.load(null);
  thisKeyStore.deleteEntry(thisAlias);


  // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label

  TLSIdentity thisIdentity =
    new TLSIdentity.getIdentity("couchbase-docs-cert")


  public void ibRplicatorPull() {
    Database database;
    Replicator replicator; <i class="conum" data-value="89"></i><b>(89)</b>

    URI uri = null;
    try {
        uri = new URI("wss://10.0.2.2:4984/db"); <i class="conum" data-value="90"></i><b>(90)</b>
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
    Endpoint endpoint = new URLEndpoint(uri);
    ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
    config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
    this.replicator = new Replicator(config);
    this.replicator.start();
  }

    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))); <i class="conum" data-value="91"></i><b>(91)</b>



  /</strong> C A L L O U T S

  &lt;.&gt; Configure the pinned certificate using data from the byte array <code>cert</code>

  &lt;.&gt; Attempt to get the identity from secure storage
  &lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity


  &lt;.&gt; A replication is an asynchronous operation.
  To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
  &lt;.&gt; The URL scheme for remote database URLs uses <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections over wb sockets.
  In this example the hostname is <code>10.0.2.2</code> because the Android emulator runs in a VM that is generally accessible on <code>10.0.2.2</code> from the host machine (see <a href="https://developer.android.com/studio/run/emulator-networking">Android Emulator networking</a> documentation).
  +
  NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
  Although <code>wss:</code> protocol URLs are not affected, in order to use the <code>ws:</code> protocol, applications must target API 27 or lower, or must configure application network security as described <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted">here</a>.

  <strong>/

}
/</strong>

Snippets demonstrating use of resultsets

<strong>/
package com.example.docsnippet;
        import android.app.Application.</strong>;
        import android.content.Context;
        import android.content.Context.<strong>;
        import java.lang.Object;
        import java.security.Key;
        import java.util.</strong>;
        import com.couchbase.lite.<strong>;
        import com.couchbase.lite.Dictionary;

public class TestQueries {

    // For Documentation

    Datastore ds = new Datastore();

    Database this_Db = ds.getDB();

    String dbName = this_Db.getName();

    HashMap&lt;String, Object&gt; hotels = new HashMap&lt;&gt;();

    Dictionary thisDocsProps;
    String thisDocsId;
    String thisDocsName;
    String thisDocsType;
    String thisDocsCity;



    static {
        init();
    }

    private static void init() {
    }



    public void testQuerySyntaxAll() throws CouchbaseLiteException {

        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

      Query listQuery = QueryBuilder.select(SelectResult.all())
              .from(DataSource.database(this_Db));

        try {
            for (Result result : listQuery.execute().allResults()) {
                             // get the k-v pairs from the 'hotel' key's value into a dictionary
                thisDocsProps = result.getDictionary(0); <i class="conum" data-value="92"></i><b>(92)</b>
                thisDocsId = thisDocsProps.getString("id");
                thisDocsName = thisDocsProps.getString("Name");
                thisDocsType = thisDocsProps.getString("Type");
                thisDocsCity = thisDocsProps.getString("City");

                // Alternatively, access results value dictionary directly
                final Hotel hotel = new Hotel();
                hotel.Id = result.getDictionary(0).getString("id"); <i class="conum" data-value="93"></i><b>(93)</b>
                hotel.Type = result.getDictionary(0).getString("Type");
                hotel.Name = result.getDictionary(0).getString("Name");
                hotel.City = result.getDictionary(0).getString("City");
                hotel.Country= result.getDictionary(0).getString("Country");
                hotel.Description = result.getDictionary(0).getString("Description");
                hotels.put(hotel.Id, hotel);
            }

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }



    // Uses Jackson JSON processor

    ArrayList&lt;Hotel&gt; hotels = new ArrayList&lt;Hotel&gt;();
    HashMap&lt;String, Object&gt; dictFromJSONstring;
    for (Result result : listQuery.execute()) {

      // Get result as JSON string
      String thisJsonString = result.toJSON(); <i class="conum" data-value="94"></i><b>(94)</b>

      // Get Java  Hashmap from JSON string
      HashMap&lt;String, Object&gt; dictFromJSONstring =
              mapper.readValue(thisJsonString, HashMap.class); <i class="conum" data-value="95"></i><b>(95)</b>


      // Use created hashmap
      String hotelId = dictFromJSONstring.get("id").toString();
      String hotelType = dictFromJSONstring.get("type").toString();
      String hotelname = dictFromJSONstring.get("name").toString();


      // Get custom object from JSON string
      Hotel thisHotel =
              mapper.readValue(thisJsonString, Hotel.class); <i class="conum" data-value="96"></i><b>(96)</b>
      hotels.add(thisHotel);



            }
        }


    public void testQuerySyntaxProps() throws CouchbaseLiteException {
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        Query listQuery =
        QueryBuilder.select(SelectResult.expression(Meta.id),
        SelectResult.property("name"),
        SelectResult.property("Name"),
        SelectResult.property("Type"),
        SelectResult.property("City"))
        .from(DataSource.database(this_Db));



        try {
          for (Result result : listQuery.execute().allResults()) {

            // get data direct from result k-v pairs
            final Hotel hotel = new Hotel();
            hotel.Id = result.getString("id");
            hotel.Type = result.getString("Type");
            hotel.Name = result.getString("Name");
            hotel.City = result.getString("City");

            // Store created hotel object in a hashmap of hotels
            hotels.put(hotel.Id, hotel);

            // Get result k-v pairs into a 'dictionary' object
            Map &lt;String, Object&gt; thisDocsProps = result.toMap();
            thisDocsId =
            thisDocsProps.getOrDefault("id",null).toString();
            thisDocsName =
            thisDocsProps.getOrDefault("Name",null).toString();
            thisDocsType =
            thisDocsProps.getOrDefault("Type",null).toString();
            thisDocsCity =
            thisDocsProps.getOrDefault("City",null).toString();

          }
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

    }


    public void testQuerySyntaxCount() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery = QueryBuilder.select(
              SelectResult.expression(Function.count(Expression.string("</strong>"))).as("mycount")) <i class="conum" data-value="97"></i><b>(97)</b>
              .from(DataSource.database(this_Db));



        try {
            for (Result result : listQuery.execute()) {

                // Retrieve count using key 'mycount'
                Integer altDocId = result.getInt("mycount");

                // Alternatively, use the index
                Integer orDocId = result.getInt(0);
            }
            // Or even miss out the for-loop altogether
            Integer resultCount = listQuery.execute().next().getInt("mycount");

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }
    }


    public void testQuerySyntaxId() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id).as("metaID"))
                      .from(DataSource.database(this_Db));




        try {
            for (Result result : listQuery.execute().allResults()) {

                // get the ID form the result's k-v pair array
                thisDocsId = result.getString("metaID"); <i class="conum" data-value="98"></i><b>(98)</b>

                // Get document from DB using retrieved ID
                Document thisDoc = this_Db.getDocument(thisDocsId);

                // Process document as required
                thisDocsName = thisDoc.getString("Name");

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }


    }


    public void testQueryPagination() throws CouchbaseLiteException {


        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        int thisOffset = 0;
        int thisLimit = 20;

        Query listQuery =
                QueryBuilder
                        .select(SelectResult.all())
                        .from(DataSource.database(this_Db))
                        .limit(Expression.intValue(thisLimit),
                                  Expression.intValue(thisOffset)); <i class="conum" data-value="99"></i><b>(99)</b>


    }



    public List&lt;Result&gt; docsonly_QuerySyntaxN1QL (Database argDB)
    {
      // For Documentation -- N1QL Query using parameters
      //  Declared elsewhere: Database argDB

      Database thisDb = argDB;

      Query thisQuery =
      thisDb.createQuery(
        "SELECT META().id AS thisId FROM _ WHERE type = \"hotel\""); // &lt;.

        return thisQuery.execute().allResults();

      }


    public List&lt;Result&gt; docsonly_QuerySyntaxN1QLParams (Database argDB)
    {
      // For Documentation -- N1QL Query using parameters
      //  Declared elsewhere: Database argDB

      Database thisDb = argDB;

      Query thisQuery =
          thisDb.createQuery(
              "SELECT META().id AS thisId FROM _ WHERE type = $type"); // &lt;.

      thisQuery.parameters =
          Parameters.setString("type", "hotel"); <i class="conum" data-value="100"></i><b>(100)</b>

      return thisQuery.execute().allResults();

  }

} // class



public class supportingDatatypes
{
    private static final String TAG = "info";

    public void datatype_dictionary() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)
        Document document = database.getDocument("doc1");

        // Getting a dictionary from the document's properties
        Dictionary dict = document.getDictionary("address");

        // Access a value with a key from the dictionary
        String street = dict.getString("street");

        // Iterate dictionary
        for (String key : dict) {
            dict.getValue(key);
            Log.i("x", "Key %s, = %s", key, dict.getValue(key));
        }

        // Create a mutable copy
        MutableDictionary mutable_Dict = dict.toMutable();
    }

    public void datatype_mutable_dictionary() throws CouchbaseLiteException {

        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        MutableDictionary mutable_dict = new MutableDictionary();
        mutable_dict.setString("street", "1 Main st.");
        mutable_dict.setString("city", "San Francisco");

        // Add the dictionary to a document's properties and save the document
        MutableDocument mutable_doc = new MutableDocument("doc1");
        mutable_doc.setDictionary("address", mutable_dict);
        database.save(mutable_doc);

    }


    public void datatype_array() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        Document document = database.getDocument("doc1");

        // Getting a phones array from the document's properties
        Array array = document.getArray("phones");

        // Get element count
        int count = array.count();

        // Access an array element by index
        if (count &gt;= 0) { String phone = array.getString(1); }

        // Iterate dictionary
        for (int i = 0; i &lt; count; i)
        {
            Log.i("tag", "Item %d = %s", i, array.getString(i));
        }

        // Create a mutable copy
        MutableArray mutable_array = array.toMutable();


    }

    public void datatype_mutable_array() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        MutableArray mutable_array = new MutableArray();
        mutable_array.addString("650-000-0000");
        mutable_array.addString("650-000-0001");

        // Set the array to document's properties and save the document
        MutableDocument mutable_doc = new MutableDocument("doc1");
        mutable_doc.setArray("phones", mutable_array);
        database.save(mutable_doc);
    }

} // end  class supporting_datatypes



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/ZipUtils.java 
package com.couchbase.code_snippets;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class ZipUtils {
    public static void unzip(InputStream in, File destination) throws IOException {
        byte[] buffer = new byte[1024];
        ZipInputStream zis = new ZipInputStream(in);
        ZipEntry ze = zis.getNextEntry();
        while (ze != null) {
            String fileName = ze.getName();
            File newFile = new File(destination, fileName);
            if (ze.isDirectory()) {
                newFile.mkdirs();
            } else {
                new File(newFile.getParent()).mkdirs();
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) &gt; 0) {
                    fos.write(buffer, 0, len);
                }
                fos.close();
            }
            ze = zis.getNextEntry();
        }
        zis.closeEntry();
        zis.close();
        in.close();
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/ZipUtils.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/JSONExamples.java 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.util.Log;

import java.util.Map;

import org.json.JSONException;
import org.json.JSONObject;

import com.couchbase.lite.Array;
import com.couchbase.lite.Blob;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableArray;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.Result;
import com.couchbase.lite.SelectResult;


public class JSONExamples {
    private static final String TAG = "SNIPPETS";

    public static final String JSON
        = "[{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\","
        + "\"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},"
        + "{\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\","
        + "\"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},"
        + "{\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\","
        + "\"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\","
        + "\"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]";

    public void jsonArrayExample(Database db) throws CouchbaseLiteException {
        // github tag=tojson-array
        final MutableArray mArray = new MutableArray(JSON); // &lt;.&gt;

        for (int i = 0; i &lt; mArray.count(); i) { <i class="conum" data-value="101"></i><b>(101)</b>
          final Dictionary dict = mArray.getDictionary(i);
          Log.i(TAG, dict.getString("name"));
          db.save(new MutableDocument(dict.getString("id"), dict.toMap()));
        }

        final Array features = db.getDocument("1002").getArray("features"); <i class="conum" data-value="102"></i><b>(102)</b>
        for (Object feature: features.toList()) { Log.i(TAG, feature.toString()); }
        Log.i(TAG, features.toJSON()); <i class="conum" data-value="103"></i><b>(103)</b>
      }

      public void jsonBlobExample(Database db) {
        // github tag=tojson-blob
        final Map&lt;String, ?&gt; thisBlob = db.getDocument("thisdoc-id").toMap();
        if (!Blob.isBlob(thisBlob)) { return; }

        final String blobType = thisBlob.get("content_type").toString();
        final Number blobLength = (Number) thisBlob.get("length");
      }

      public void jsonDictionaryExample(Database db) {
        // github tag=tojson-dictionary
        final MutableDictionary mDict = new MutableDictionary(JSON); <i class="conum" data-value="104"></i><b>(104)</b>
        Log.i(TAG, mDict.toString());

        Log.i(TAG, "Details for: " + mDict.getString("name"));
        for (String key: mDict.getKeys()) {
          Log.i(TAG, key + " =&gt; " + mDict.getValue(key));
        }
    }

    public void jsonDocumentExample(Database srcDb, Database dstDb) throws CouchbaseLiteException {
        // github tag=tojson-document
        final Query listQuery = QueryBuilder
        .select(SelectResult.expression(Meta.id).as("metaId"))
        .from(DataSource.database(srcDb));

        for (Result row: listQuery.execute()) {
          final String thisId = row.getString("metaId");

          final String json = srcDb.getDocument(thisId).toJSON(); <i class="conum" data-value="105"></i><b>(105)</b>
          Log.i(TAG, "JSON String = " + json);

          final MutableDocument hotelFromJSON = new MutableDocument(thisId, json); <i class="conum" data-value="106"></i><b>(106)</b>

          dstDb.save(hotelFromJSON);

          for (Map.Entry entry: dstDb.getDocument(thisId).toMap().entrySet()) {
            Log.i(TAG, entry.getKey() + " =&gt; " + entry.getValue());
          } <i class="conum" data-value="107"></i><b>(107)</b>
        }
      }


    public void jsonQueryExample(Query query) throws CouchbaseLiteException, JSONException {
        for (Result row: query.execute()) {

            // get the result into a JSON String
            final String jsonString = row.toJSON();

            final JSONObject thisJsonObj = new JSONObject(jsonString);

            // Use Json Object to populate Native object
            // Use Codable class to unpack JSON data to native object
            final Hotel thisHotel = new Hotel(
                "this hotel",
                "Ghana, West Africa",
                thisJsonObj.getString("city"),
                thisJsonObj.getString("name"),
                thisJsonObj.getString("type"),
                thisJsonObj.getString("id"));
        }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/JSONExamples.java </code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Populate your hotel document</p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset5_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset5_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset5_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">

// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.*
import com.couchbase.lite.internal.utils.PlatformUtils
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.io.InputStream
import java.net.URI
import java.net.URISyntaxException


private const val TAG = "REPLICATION"

@Throws(IOException::class)
fun InputStream.toByteArray(): ByteArray {
    val buffer = ByteArray(1024)
    val output = ByteArrayOutputStream()

    var n: Int
    while (-1 &lt; this.read(buffer).also { n = it }) {
        output.write(buffer, 0, n)
    }

    return output.toByteArray()
}

//
//        &lt;.&gt; The conflict handler code is provided as a lambda.
//
//        &lt;.&gt; If the handler cannot resolve a conflict, it can return false.
//        In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.
//
//        &lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.
//
//        &lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).
//
//        &lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method


// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
@Suppress("unused")
object LocalWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.localDocument
}

// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
@Suppress("unused")
object RemoteWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.remoteDocument
}

// Using replConfig.setConflictResolver(new MergeConflictResolver());
@Suppress("unused")
object MergeConflictResolver : ConflictResolver {
    override fun resolve(conflict: Conflict): Document {
        val localDoc = conflict.localDocument?.toMap()
        val remoteDoc = conflict.remoteDocument?.toMap()

        val merge: MutableMap&lt;String, Any&gt;?
        if (localDoc == null) {
            merge = remoteDoc
        } else {
            merge = localDoc
            if (remoteDoc != null) {
                merge.putAll(remoteDoc)
            }
        }

        return if (merge == null) {
            MutableDocument(conflict.documentId)
        } else {
            MutableDocument(conflict.documentId, merge)
        }
    }

    @Suppress("unused")
    class ReplicationExamples(private val database: Database) {
        private var replicator: Replicator? = null

        @Throws(URISyntaxException::class)
        fun testReplicationBasicAuthentication() {

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = BasicAuthenticator("username", "password".toCharArray())
                )
            )
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationSessionAuthentication() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447")
                )
            )
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationStatus() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            repl.addChangeListener { change -&gt;
                if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                    Log.i(TAG, "Replication stopped")
                }
            }

            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testHandlingNetworkErrors() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            repl.addChangeListener { change -&gt;
                change.status.error?.let {
                    Log.w(TAG, "Error code: ${it.code}")
                }
            }
            repl.start()
            replicator = repl

            repl.stop()
        }

        @Throws(URISyntaxException::class)
        fun testReplicatorDocumentEvent() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            val token = repl.addDocumentReplicationListener { replication -&gt;
                Log.i(TAG, "Replication type: ${if (replication.isPush) "push" else "pull"}")

                for (document in replication.documents) {
                    document.let { doc -&gt;
                        Log.i(TAG, "Doc ID: ${document.id}")
                        doc.error?.let {
                            // There was an error
                            Log.e(TAG, "Error replicating document: ", it)
                            return@addDocumentReplicationListener
                        }
                        if (doc.flags.contains(DocumentFlag.DELETED)) {
                            Log.i(TAG, "Successfully replicated a deleted document")
                        }
                    }
                }
            }

            repl.start()
            replicator = repl

            repl.removeChangeListener(token)
        }

        @Throws(URISyntaxException::class)
        fun testReplicationCustomHeader() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value")
                )
            )
            replicator = repl
        }

        // <mark># Certificate Pinning
        @Throws(URISyntaxException::class, IOException::class)
        fun testCertificatePinning() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value"),
                    pinnedServerCertificate = PlatformUtils.getAsset("cert.cer")?.toByteArray()
                )
            )
            replicator = repl
        }

        // </mark># Reset replicator checkpoint
        @Throws(URISyntaxException::class)
        fun testReplicationResetCheckpoint() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            val resetCheckpointRequired_Example = false
            repl.start(resetCheckpointRequired_Example) <i class="conum" data-value="1"></i><b>(1)</b>

            // ... at some later time

            repl.stop()

        }

        @Throws(URISyntaxException::class)
        fun testReplicationPushFilter() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { _, flags -&gt; flags.contains(DocumentFlag.DELETED) } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationPullFilter() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { document, _ -&gt; "draft" == document.getString("type") } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testCustomRetryConfig() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    //  other config params as required . .
                    heartbeat = 150, <i class="conum" data-value="1"></i><b>(1)</b>
                    maxAttempts = 20,
                    maxAttemptWaitTime = 600
                )
            )

            repl.start()
            replicator = repl
        }

        @Throws(CouchbaseLiteException::class)
        fun testDatabaseReplica() {
            val config = DatabaseConfiguration()
            val database1 = Database("mydb", config)
            val database2 = Database("db2", config)

            /* EE feature: code below might throw a compilation error
               if it's compiled against CBL Android Community. <strong>/
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database1,
                    target = DatabaseEndpoint(database2),
                    type = ReplicatorType.PULL
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationWithCustomConflictResolver() {
            val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
            val config = ReplicatorConfiguration(database, target)
            config.conflictResolver = LocalWinsResolver
            val replication = Replicator(config)
            replication.start()
        }

        @Throws(CouchbaseLiteException::class)
        fun testSaveWithCustomConflictResolver() {
            val mutableDocument = database.getDocument("xyz")?.toMutable() ?: return
            mutableDocument.setString("name", "apples")
            database.save(mutableDocument) { newDoc, curDoc -&gt;  <i class="conum" data-value="2"></i><b>(2)</b>
                if (curDoc == null) {
                    return@save false
                } <i class="conum" data-value="3"></i><b>(3)</b>
                val dataMap: MutableMap&lt;String, Any&gt; = curDoc.toMap()
                dataMap.putAll(newDoc.toMap()) <i class="conum" data-value="4"></i><b>(4)</b>
                newDoc.setData(dataMap)
                true <i class="conum" data-value="5"></i><b>(5)</b>
            } <i class="conum" data-value="6"></i><b>(6)</b>
        }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import android.widget.Toast
import com.couchbase.lite.</strong>
import com.couchbase.lite.internal.utils.PlatformUtils
import org.junit.Test
import java.io.File
import java.io.IOException
import java.net.URI
import java.net.URISyntaxException
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.*


private const val TAG = "BASIC"

class LogTestLogger(private val level: LogLevel) : Logger {
    override fun getLevel() = level

    override fun log(level: LogLevel, domain: LogDomain, message: String) {
        // this method will never be called if param level &lt; this.level
        // handle the message, for example piping it to a third party framework
    }
}

@Suppress("unused")
class BasicExamples(private val context: Context) {
    private val database: Database

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        // Get the database (and create it if it doesnt exist).
        database = Database(
          "getting-started",
          DatabaseConfigurationFactory.create(context.filesDir.absolutePath)
          )
    }

    @Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {

        // !!! Note the code moved from here to the init { } above.
        // Create a new document (i.e. a record) in the database.
        var mutableDoc = MutableDocument().setFloat("version", 2.0f).setString("type", "SDK")

        // Save it to the database.
        database.save(mutableDoc)

        // Update a document.
        mutableDoc = database.getDocument(mutableDoc.id)!!.toMutable().setString("language", "Java")
        database.save(mutableDoc)

        val document = database.getDocument(mutableDoc.id)!!
        // Log the document ID (generated by the database) and properties
        Log.i(TAG, "Document ID :: ${document.id}")
        Log.i(TAG, "Learning ${document.getString("language")}")

        // Create a query to fetch documents of type SDK.
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))
            .execute()
        Log.i(TAG, "Number of rows :: ${rs.allResults().size}")

        // Create a replicator to push and pull changes to and from the cloud.
        // Be sure to hold a reference somewhere to prevent the Replicator from being GCed
        val replicator =
          Replicator(
            ReplicatorConfigurationFactory.create(
              database = database,
              target = URLEndpoint(URI("ws://localhost:4984/getting-started-db")),
              type = ReplicatorType.PUSH_AND_PULL,
              authenticator = BasicAuthenticator("sync-gateway", "password".toCharArray())
              )
          )


        // Listen to replicator change events.
        replicator.addChangeListener { change -&gt;
            val err = change.status.error
            if (err != null) Log.i(TAG, "Error code ::  ${err.code}")
        }

        // Start replication.
        replicator.start()

        database.delete()
    }

    @Throws(CouchbaseLiteException::class, IOException::class)
    fun test1xAttachments() {
        // if db exist, delete it
        deleteDB("android-sqlite", context.filesDir)
        ZipUtils.unzip(
            PlatformUtils.getAsset("replacedb/android140-sqlite.cblite2.zip"),
            context.filesDir
        )

        val db = Database("android-sqlite")
        try {
            // For Validation
            Arrays.equals(
                "attach1".toByteArray(),
                db.getDocument("doc1")?.getDictionary("_attachments")?.getBlob("attach1")?.content
            )
        } finally {
            // close db
            db.close()
            // if db exist, delete it
            deleteDB("android-sqlite", context.filesDir)
        }
        val document = MutableDocument()

        val content = document.getDictionary("_attachments")?.getBlob("avatar")?.content
    }

    // <mark># Initializer
    fun testInitializer() {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)
    }

    // </mark># New Database
    @Throws(CouchbaseLiteException::class)
    fun testNewDatabase() {
        val database = Database(
            "my-db",
            DatabaseConfigurationFactory.create(
                context.filesDir.absolutePath
            )
        ) <i class="conum" data-value="7"></i><b>(7)</b>
        database.close()


        database.delete()
    }

    // <mark># Database Encryption
    @Throws(CouchbaseLiteException::class)
    fun testDatabaseEncryption() {
        val db = Database(
            "my-db",
            DatabaseConfigurationFactory.create(
                encryptionKey = EncryptionKey("PASSWORD")
            )
        )

    }

    // </mark># Logging
    // !!! OBSOLETE in 3.0
    fun testLogging() {
    }

    fun testEnableCustomLogging() {
        // this custom logger will not log an event with a log level &lt; WARNING
        Database.log.custom = LogTestLogger(LogLevel.WARNING) <i class="conum" data-value="8"></i><b>(8)</b>
    }

    // <mark># Console logging
    @Throws(CouchbaseLiteException::class)
    fun testConsoleLogging() {
        Database.log.console.domains = LogDomain.ALL_DOMAINS <i class="conum" data-value="9"></i><b>(9)</b>
        Database.log.console.level = LogLevel.VERBOSE <i class="conum" data-value="10"></i><b>(10)</b>

        Database.log.console.domains = EnumSet.of(LogDomain.DATABASE) <i class="conum" data-value="11"></i><b>(11)</b>
    }

    // </mark># File logging
    @Throws(CouchbaseLiteException::class)
    fun testFileLogging() {
        Database.log.file.let {
          it.config = LogFileConfigurationFactory.create(
            context.cacheDir.absolutePath, <i class="conum" data-value="12"></i><b>(12)</b>
            maxSize = 10240, <i class="conum" data-value="13"></i><b>(13)</b>
            maxRotateCount = 5, <i class="conum" data-value="14"></i><b>(14)</b>
            usePlainText = false
            ) <i class="conum" data-value="15"></i><b>(15)</b>
            it.level = LogLevel.INFO <i class="conum" data-value="16"></i><b>(16)</b>

          }
    }

    fun writeConsoleLog() {
        Database.log.console.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    fun writeCustomLog() {
        Database.log.custom?.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    fun writeFileLog() {
        Database.log.file.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    /* The <code>tag::replication[]</code> example is inlined in java.adoc <strong>/
    fun testTroubleshooting() {
        Database.log.console.let {
            it.level = LogLevel.VERBOSE
            it.domains = LogDomain.ALL_DOMAINS
        }
    }

    // <mark># Loading a pre-built database
    @Throws(IOException::class)
    fun testPreBuiltDatabase() {
        // Note: Getting the path to a database is platform-specific.
        // For Android you need to extract the database from your assets
        // to a temporary directory and then copy it, using Database.copy()
        if (Database.exists("travel-sample", context.filesDir)) {
            return
        }
        ZipUtils.unzip(PlatformUtils.getAsset("travel-sample.cblite2.zip"), context.filesDir)
        Database.copy(
            File(context.filesDir, "travel-sample"),
            "travel-sample",
            DatabaseConfiguration()
        )
    }

    // helper methods
    // if db exist, delete it
    fun deleteDB(name: String, dir: File) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            Database.delete(name, dir)
        }

        // </mark># Initializers
        fun testInitializers() {
            val doc = MutableDocument()
            doc.let {
                it.setString("type", "task")
                it.setString("owner", "todo")
                it.setDate("createdAt", Date())
            }
            database.save(doc)
        }
    }

    // <mark># Mutability
    fun testMutability() {
        database.save(MutableDocument("xyz"))

        database.getDocument("xyz")?.toMutable()?.let {
            it.setString("name", "apples")
            database.save(it)
        }
    }

    // </mark># Typed Accessors
    fun testTypedAccessors() {
        val doc = MutableDocument()

        doc.setValue("createdAt", Date())
        val date = doc.getDate("createdAt")
    }

    // <mark># Batch operations
    fun testBatchOperations() {
        database.inBatch(UnitOfWork {
            for (i in 0..9) {
                val doc = MutableDocument()
                doc.let {
                    it.setValue("type", "user")
                    it.setValue("name", "user $i")
                    it.setBoolean("admin", false)
                }
                Log.i(TAG, "saved user document: ${doc.getString("name")}")
            }
        })
    }


    // toJSON
    fun testToJsonOperations(argDb: Database) {
        val db = argDb

    }


    // </mark># Document Expiration
    @Throws(CouchbaseLiteException::class)
    fun documentExpiration() {
        // Purge the document one day from now
        database.setDocumentExpiration(
            "doc123",
            Date(Instant.now().plus(1, ChronoUnit.DAYS).toEpochMilli())
        )

        // Reset expiration
        database.setDocumentExpiration("doc1", null)

        // Query documents that will be expired in less than five minutes
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.longValue(Instant.now().plus(5, ChronoUnit.MINUTES).toEpochMilli())
                )
            )
    }

    @Throws(CouchbaseLiteException::class)
    fun testDocumentChangeListener() {
        database.addDocumentChangeListener("user.john") { change -&gt;
            database.getDocument(change.documentID)?.let {
                Toast.makeText(
                    context,
                    "Status: ${it.getString("verified_account")}",
                    Toast.LENGTH_SHORT
                ).show()
            }
        }
    }

    // <mark># Blobs
    fun testBlobs() {
        val mDoc = MutableDocument()

        PlatformUtils.getAsset("avatar.jpg")?.use { <i class="conum" data-value="17"></i><b>(17)</b>
            mDoc.setBlob("avatar", Blob("image/jpeg", it)) <i class="conum" data-value="18"></i><b>(18)</b> <i class="conum" data-value="19"></i><b>(19)</b>
            database.save(mDoc)
        }

        val doc = database.getDocument(mDoc.id)
        val bytes = doc?.getBlob("avatar")?.content
    }
}


class supportingDatatypes
{

    private val database  = Database("mydb")

    fun datatype_dictionary() {

        // NOTE: No error handling, for brevity (see getting started)
        val document = database!!.getDocument("doc1")

        // Getting a dictionary from the document's properties
        val dict = document?.getDictionary("address")

        // Access a value with a key from the dictionary
        val street = dict?.getString("street")

        // Iterate dictionary
        for (key in dict!!.keys) {
            println("Key ${key} = ${dict.getValue(key)}")
        }

    // Create a mutable copy
    val mutable_Dict = dict.toMutable()
}

    fun datatype_mutable_dictionary() {

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        val mutable_dict = MutableDictionary()
        mutable_dict.setString("street", "1 Main st.")
        mutable_dict.setString("city", "San Francisco")

        // Add the dictionary to a document's properties and save the document
        val mutable_doc = MutableDocument("doc1")
        mutable_doc.setDictionary("address", mutable_dict)
        database!!.save(mutable_doc)

}


    fun datatype_array() {

        // NOTE: No error handling, for brevity (see getting started)

        val document = database?.getDocument("doc1")

        // Getting a phones array from the document's properties
        val array = document?.getArray("phones")

        // Get element count
        val count = array?.count()

        // Access an array element by index
        val phone = array?.getString(1)

        // Iterate array
        for ( (index, item) in array!!) {
            println("Row  ${index} = ${item}")
        }

        // Create a mutable copy
        val mutable_array = array.toMutable()
    }

    fun datatype_mutable_array() {

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        val mutable_array = MutableArray()
        mutable_array.addString("650-000-0000")
        mutable_array.addString("650-000-0001")

        // Set the array to document's properties and save the document
        val mutable_doc = MutableDocument("doc1")
        mutable_doc.setArray("phones", mutable_array)
        database?.save(mutable_doc)
    }

} // end  class supporting_datatypes



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.Dictionary
import com.couchbase.lite.Expression
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.MutableDictionary
import com.couchbase.lite.PredictionFunction
import com.couchbase.lite.PredictiveIndex
import com.couchbase.lite.PredictiveModel
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.SelectResult
import com.couchbase.lite.ValueIndex
import com.couchbase.lite.ValueIndexItem


private const val TAG = "PREDICT"
// tensorFlowModel is a fake implementation

object TensorFlowModel {
    fun predictImage(data: ByteArray?) = mapOf&lt;String, Any?&gt;()
}

object ImageClassifierModel : PredictiveModel {
    const val name = "ImageClassifier"

    override fun predict(input: Dictionary): Dictionary? {
        val blob: Blob = input.getBlob("photo") ?: return null

        // this would be the implementation of the ml model you have chosen
        return MutableDictionary(TensorFlowModel.predictImage(blob.content)) <i class="conum" data-value="1"></i><b>(1)</b>
    }
}


@Suppress("unused")
class PredictiveQueryExamples {
    @Throws(CouchbaseLiteException::class)
    fun testPredictiveModel() {
        val database = Database("mydb")

        Database.prediction.registerModel("ImageClassifier", ImageClassifierModel)

        val index: ValueIndex = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")))
        database.createIndex("value-index-image-classifier", index)

        Database.prediction.unregisterModel("ImageClassifier")
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveIndex() {
        val database = Database("mydb")

        val inputMap: MutableMap&lt;String, Any&gt; = mutableMapOf()
        inputMap["numbers"] = Expression.property("photo")
        val input: Expression = Expression.map(inputMap)
        val index: PredictiveIndex = IndexBuilder.predictiveIndex("ImageClassifier", input, null)
        database.createIndex("predictive-index-image-classifier", index)
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveQuery() {
        val database = Database("mydb")

        val prediction: PredictionFunction = Function.prediction(
            ImageClassifierModel.name,
            Expression.map(mutableMapOf("photo" to Expression.property("photo")) as Map&lt;String, Any&gt;?) <i class="conum" data-value="1"></i><b>(1)</b>
        )

        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                .and(prediction.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))
                    )
            )
            .execute()

        Log.d(TAG, "Number of rows: ${rs.allResults().size}")
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/FlowExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import androidx.lifecycle.LiveData
import androidx.lifecycle.asLiveData
import com.couchbase.lite.</strong>
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.map


class FlowExamples(argDb: Database,
                   argRepl: Replicator,
                   argQuery: Query,
                   argDocOwner: String) {

    val replState: LiveData&lt;ReplicatorActivityLevel&gt; = argRepl.replicatorChangesFlow()
        .map { it.status.activityLevel }
        .asLiveData()

    val dbChanges: LiveData&lt;MutableList&lt;String&gt;&gt; = argDb.databaseChangeFlow()
        .map { it.documentIDs }
        .asLiveData()

    val docChanges: LiveData&lt;DocumentChange?&gt; = argDb.documentChangeFlow("1001")
        .map {
            it.takeUnless {
                it.database.getDocument(it.documentID)?.getString("owner").equals(argDocOwner)
            }
        }
        .asLiveData()

    var liveQuery: LiveData&lt;List&lt;Any&gt;?&gt;? = null

    @ExperimentalCoroutinesApi
    fun watchQuery(query: Query): LiveData&lt;List&lt;Any&gt;?&gt; {
        val queryFlow = query.queryChangeFlow()
            .map {
                val err = it.error
                if (err != null) {
                    throw err
                }
                it.results?.allResults()?.flatMap { it.toList() }
            }
            .asLiveData()
        liveQuery = queryFlow
        return queryFlow
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/FlowExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorStatus


private const val TAG = "PENDING"

@Suppress("unused")
class PendingDocsExample(private var replicator: Replicator) {
    //
    //
    private fun onStatusChanged(pendingDocs: Set&lt;String&gt;, status: ReplicatorStatus) {
        // ... sample onStatusChanged function
        //
        Log.i(TAG, "Replicator activity level is ${status.activityLevel}")

        // iterate and report-on previously
        // retrieved pending docids 'list'
        val itr = pendingDocs.iterator()
        while (itr.hasNext()) {
            val docId = itr.next()

            if (!replicator.isDocumentPending(docId)) { <i class="conum" data-value="20"></i><b>(20)</b>
                continue
            }

            Log.i(TAG, "Doc ID $docId has been pushed")
        }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Endpoint
import com.couchbase.lite.KeyStoreUtils
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.net.URI
import java.net.URISyntaxException
import java.security.KeyStore
import java.security.cert.Certificate

private const val TAG = "P2P"


@Suppress("unused")
class IBExamples(private val context: Context, private val caCert: Certificate) {
    private val database: Database
    private var thisReplicator: Replicator? = null
    private var thisListener: URLEndpointListener? = null

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        database = Database("p2p_demo")

        /* do some stuff here <strong>/
    }

    // PASSIVE PEER STUFF
    fun ibListenerSimple() {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database,
                authenticator
                = ListenerPasswordAuthenticator { user, pwd -&gt; (user == "daniel") &amp;&amp; (String(pwd) == "123") })
        ) <i class="conum" data-value="21"></i><b>(21)</b>
        listener.start() <i class="conum" data-value="22"></i><b>(22)</b>
        thisListener = listener

    }

    fun ibReplicatorSimple() {
        val theListenerEndpoint: Endpoint = URLEndpoint(URI("wss://10.0.2.2:4984/db")) <i class="conum" data-value="23"></i><b>(23)</b>
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,
                target = theListenerEndpoint,
                authenticator = BasicAuthenticator("valid.user", "valid.password.string".toCharArray()), <i class="conum" data-value="24"></i><b>(24)</b>
                acceptOnlySelfSignedServerCertificate = true
            )
        )
        repl.start() <i class="conum" data-value="25"></i><b>(25)</b>
        thisReplicator = repl
    }

    fun ibPassListener(validUser: String, validPassword: CharArray) {
        // EXAMPLE 1
        // Initialize the listener
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database, <i class="conum" data-value="26"></i><b>(26)</b>
                port = 55990, <i class="conum" data-value="27"></i><b>(27)</b>
                networkInterface = "10.1.1.10", <i class="conum" data-value="28"></i><b>(28)</b>

                enableDeltaSync = false, <i class="conum" data-value="29"></i><b>(29)</b>

                // Configure server security
                disableTls = false, <i class="conum" data-value="30"></i><b>(30)</b>

                // Use an Anonymous Self-Signed Cert
                identity = null, <i class="conum" data-value="31"></i><b>(31)</b>

                // Configure Client Security using an Authenticator
                // For example, Basic Authentication <i class="conum" data-value="32"></i><b>(32)</b>
                authenticator = ListenerPasswordAuthenticator { username, paassword -&gt;
                    (username === validUser) &amp;&amp; (paassword === validPassword)
                }
            ))

        // Start the listener
        listener.start() <i class="conum" data-value="33"></i><b>(33)</b>
        thisListener = listener

    }

    fun ibListenerGetNetworkInterfaces() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        listener.start()
        Log.i(TAG, "URLS are ${listener.urls}")
        thisListener = listener
    }

    fun ibListenerLocalDb() {
        // . . . preceding application logic . . .
        CouchbaseLite.init(context) <i class="conum" data-value="34"></i><b>(34)</b>
        val thisDB = Database("passivepeerdb")
    }

    fun ibListenerConfigTlsDisable() {
        URLEndpointListenerConfigurationFactory.create(database, disableTls = false) <i class="conum" data-value="35"></i><b>(35)</b>
    }


    // !!! USERS SHOULD BE CAUTIONED THAT THIS IS INSECURE
    // Android has much better ways of importing keys
    fun ibListenerConfigTlsIdFull() {
        // Use CA Cert
        // Import a key pair into secure storage
        // Create a TLSIdentity from the imported key-pair

        this.javaClass.getResourceAsStream("serverkeypair.p12")?.use { <i class="conum" data-value="36"></i><b>(36)</b>
            KeyStoreUtils.importEntry(
                "teststore.p12",  // KeyStore type, eg: "PKCS12"
                it,  // An InputStream from the keystore
                "let me in".toCharArray(),  // The keystore password
                "topSekritKey",  // The alias to be used (in external keystore)
                null,  // The key password or null if the key has none
                "test-alias" // The alias for the imported key
            )
        }


        // Set the TLS Identity
        URLEndpointListenerConfigurationFactory.create(
            database,
            identity = TLSIdentity.getIdentity("test-alias")
        ) <i class="conum" data-value="37"></i><b>(37)</b>

    }

    fun ibListenerConfigClientAuthRoot() {
        // Configure the client authenticator
        // to validate using ROOT CA
        // thisClientID.certs is a list containing a client cert to accept
        // and any other certs needed to complete a chain between the client cert
        // and a CA
        val validId = TLSIdentity.getIdentity("Our Corporate Id")
            ?: throw IllegalStateException("Cannot find corporate id")
        // accept only clients signed by the corp cert
        thisListener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                // get the identity <i class="conum" data-value="38"></i><b>(38)</b>
                database = database,
                identity = validId,
                authenticator = ListenerCertificateAuthenticator(validId.certs)
            )
        ) <i class="conum" data-value="39"></i><b>(39)</b>

    }

    fun ibListenerConfigTlsDisable2() {

        URLEndpointListenerConfigurationFactory.create(database = database, disableTls = true)
    }

    fun ibListenerStatusCheck() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        val connectionCount = listener.status?.connectionCount <i class="conum" data-value="40"></i><b>(40)</b>
        val activeConnectionCount = listener.status?.activeConnectionCount <i class="conum" data-value="41"></i><b>(41)</b>
    }

    fun ibListenerStop() {

        thisListener?.stop()

    }

    // ACTIVE PEER STUFF
// Replication code
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testActPeerSync() {
        // Create replicator
        // Consider holding a reference somewhere
        // to prevent the Replicator from being GCed
        val repl = Replicator( <i class="conum" data-value="42"></i><b>(42)</b>

            // initialize the replicator configuration
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(URI("wss://listener.com:8954")), <i class="conum" data-value="43"></i><b>(43)</b>

                // Set replicator type
                type = ReplicatorType.PUSH_AND_PULL,

                // Configure Sync Mode
                continuous = false, // default value


                // set auto-purge behavior
                // (here we override default)
                enableAutoPurge = false, <i class="conum" data-value="44"></i><b>(44)</b>



                // Configure Server Authentication --
                // only accept self-signed certs
                acceptOnlySelfSignedServerCertificate = true, <i class="conum" data-value="45"></i><b>(45)</b>

                // Configure the credentials the
                // client will provide if prompted
                authenticator = BasicAuthenticator("Our Username", "Our PasswordValue".toCharArray()), <i class="conum" data-value="46"></i><b>(46)</b>


                /</strong> Optionally set custom conflict resolver call back <strong>/
                conflictResolver = null <i class="conum" data-value="47"></i><b>(47)</b>
            )
        )


        // Optionally add a change listener <i class="conum" data-value="48"></i><b>(48)</b>
        val thisListener = repl.addChangeListener { change -&gt;
            val err: CouchbaseLiteException? = change.status.error
            if (err != null) {
                Log.i(TAG, "Error code ::  ${err.code}", err)
            }
        }

        // Start replicator
        repl.start(false) <i class="conum" data-value="49"></i><b>(49)</b>
        thisReplicator = repl

    }

    fun ibReplicatorConfig() {
        // BEGIN additional snippets

        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,

                // Configure Server Security
                // -- only accept CA attested certs
                acceptOnlySelfSignedServerCertificate = false, <i class="conum" data-value="50"></i><b>(50)</b>




                // Use the pinned certificate from the byte array (cert)
                pinnedServerCertificate = caCert.encoded, <i class="conum" data-value="51"></i><b>(51)</b>


                // ... other replicator configuration
                // Provide a client certificate to the server for authentication
                authenticator = ClientCertificateAuthenticator(
                    TLSIdentity.getIdentity("clientId")
                        ?: throw IllegalStateException("Cannot find client id")
                ) <i class="conum" data-value="52"></i><b>(52)</b>

                // ... other replicator configuration

            )
        )

        thisReplicator = repl
    }

    fun ibP2pReplicatorStatus() {
        thisReplicator?.status?.let {
            Log.i(TAG, "The Replicator is currently ${it.activityLevel}")
            Log.i(TAG, "The Replicator has processed ${it.progress}")
            Log.i(
                TAG,
                if (it.activityLevel === ReplicatorActivityLevel.BUSY) {
                    "Replication Processing"
                } else {
                    "It has completed ${it.progress.total} changes"
                }
            )
        }
    }

    fun ibP2pReplicatorStop() {
        // Stop replication.
        thisReplicator?.stop() <i class="conum" data-value="53"></i><b>(53)</b>
    }

    fun ibP2pListener() {
        CouchbaseLite.init(context)
        val thisDB = Database("passivepeerdb") <i class="conum" data-value="54"></i><b>(54)</b>


        // Initialize the listener
        val listener = URLEndpointListener( <i class="conum" data-value="55"></i><b>(55)</b>

            // Initialize the listener config
            URLEndpointListenerConfigurationFactory.create(
                database = thisDB,
                port = 55990, /</strong> &lt;.&gt;  Optional; defaults to auto <strong>/
                disableTls = false, /</strong> &lt;.&gt;  Optional; defaults to false <strong>/
                enableDeltaSync = true,  /</strong> &lt;.&gt; Optional; defaults to false <strong>/

                // Configure the client authenticator (if using basic auth)
                authenticator = ListenerPasswordAuthenticator { username, password -&gt;
                    ("username" === username) &amp;&amp; (password === "password".toCharArray())  <i class="conum" data-value="56"></i><b>(56)</b>
                }
            )
        )

        // Start the listener
        listener.start() <i class="conum" data-value="57"></i><b>(57)</b>



//        Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
//                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
//                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
//        );
        val thisIdentity = TLSIdentity.createIdentity(
            true,
            mapOf(
                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
            ),
            null,
            "test-alias"
        )




        val thisAlias = "alias-to-delete"
        val thisKeyStore = KeyStore.getInstance("AndroidKeyStore")
        thisKeyStore.load(null)
        thisKeyStore.deleteEntry(thisAlias)


        // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label
        val thatIdentity = TLSIdentity.getIdentity("couchbase-docs-cert")
    }

    fun ibRplicatorPull() {
        val database = Database("ian")

        val uri = URI("wss://10.0.2.2:4984/db") <i class="conum" data-value="58"></i><b>(58)</b>

        val repl = Replicator( <i class="conum" data-value="59"></i><b>(59)</b>
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(uri),
                type = ReplicatorType.PULL
            )
        )

        repl.start()
        thisReplicator = repl
    }

// initialize the replicator configuration
    val thisConfig = ReplicatorConfigurationFactory.create(
        database = database,
        target = URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))

/</strong> C A L L O U T S

// Listener Callouts


&lt;.&gt; Initialize the listener instance using the configuration settings.
&lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.



&lt;.&gt; <code>connectionCount</code> -- the total number of connections served by the listener
&lt;.&gt; <code>activeConnectionCount</code> -- the number of active (BUSY) connections currently being served by the listener
//



&lt;.&gt; Configure the pinned certificate using data from the byte array <code>cert</code>

&lt;.&gt; Attempt to get the identity from secure storage
&lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity


&lt;.&gt; A replication is an asynchronous operation.
To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
&lt;.&gt; The URL scheme for remote database URLs uses <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections over wb sockets.
In this example the hostname is <code>10.0.2.2</code> because the Android emulator runs in a VM that is generally accessible on <code>10.0.2.2</code> from the host machine (see <a href="https://developer.android.com/studio/run/emulator-networking">Android Emulator networking</a> documentation).
+
NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
Although <code>wss:</code> protocol URLs are not affected, in order to use the <code>ws:</code> protocol, applications must target API 27 or lower, or must configure application network security as described <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted">here</a>.

<strong>/
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.net.URI
import java.security.KeyStore
import java.security.KeyStoreException
import java.security.NoSuchAlgorithmException
import java.security.cert.Certificate
import java.security.cert.CertificateEncodingException
import java.security.cert.CertificateException
import java.util.concurrent.CountDownLatch

private const val TAG = "LISTEN"

@Suppress("unused")
class KtCertAuthListener {
    companion object {
        private val CERT_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "CBL Test",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>",
        )
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)

        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        remoteDb.save(doc)

        val serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server")

        val clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client")
        val uri = startServer(remoteDb, serverIdentity, clientIdentity.certs)
            ?: throw IOException("Failed to start the server")

        Thread {
            startClient(localDb, uri, clientIdentity, serverIdentity.certs[0])
            Log.e(TAG, "Success!!")
            deleteIdentity("server")
            Log.e(TAG, "Alias deleted: server")
            deleteIdentity("client")
            Log.e(TAG, "Alias deleted: client")
        }.start()
    }

    // start a client replicator
    @Throws(CertificateEncodingException::class, InterruptedException::class)
    fun startClient(db: Database, uri: URI, clientIdentity: TLSIdentity, cert: Certificate) {
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = db,
                target = URLEndpoint(uri),
                type = ReplicatorType.PUSH_AND_PULL,
                continuous = false,
                authenticator = ClientCertificateAuthenticator(clientIdentity),
                pinnedServerCertificate = cert.encoded
            )
        )

        val completionLatch = CountDownLatch(1)

        repl.addChangeListener { change -&gt;
            if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    /<strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     *
     *
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Throws(CouchbaseLiteException::class)
    fun startServer(db: Database, serverId: TLSIdentity, certs: List&lt;Certificate?&gt;): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0, // this is the default
                disableTls = false,
                identity = serverId,
                authenticator = ListenerCertificateAuthenticator(certs)
            )
        )
        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
    /</strong>
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    @Throws(
        KeyStoreException::class,
        CertificateException::class,
        NoSuchAlgorithmException::class,
        IOException::class
    )
    fun deleteIdentity(alias: String?) {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        keyStore.deleteEntry(alias) <i class="conum" data-value="60"></i><b>(60)</b>
    }
    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /<strong>
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     *
     *
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    @Throws(CertificateEncodingException::class)
    private fun configureClientCerts(
        config: ReplicatorConfiguration,
        cert: Certificate,
        clientIdentity: TLSIdentity
    ) {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(ClientCertificateAuthenticator(clientIdentity))

        // Configure the pinned certificate passing a byte array.
        config.pinnedServerCertificate = cert.encoded
    }
    // notend::p2p-tlsid-tlsidentity-with-label[]
    /</strong>
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     *
     *
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    @Throws(IOException::class)
    private fun readCertMaterialFromBundle(
        context: Context,
        resId: Int
    ): ByteArray {
        val out = ByteArrayOutputStream()
        val <code>in</code> = context.resources.openRawResource(resId)
        val buf = ByteArray(1024)
        var n: Int
        while (<code>in</code>.read(buf).also { n = it } &gt;= 0) {
            out.write(buf, 0, n)
        }
        return out.toByteArray()
    }
}

@Suppress("unused")
class KtPasswordAuthListener {
    companion object {
        private const val VALID_USER = "Minnie"
        private val VALID_PASSWORD = "let me in!".toCharArray()
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray())
            ?: throw IOException("Failed to start the server")
        Thread {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb)
                Log.e(TAG, "Success!!")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }.start()
    }

    // start a client replicator
    @Throws(InterruptedException::class)
    fun runClient(
        uri: URI,
        username: String,
        password: CharArray,
        db: Database
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.type = ReplicatorType.PUSH_AND_PULL
        config.isContinuous = false
        config.setAuthenticator(BasicAuthenticator(username, password))
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)

        repl.addChangeListener { change -&gt;
            if (change.status
                    .activityLevel == ReplicatorActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    /</strong>*
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     *
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    fun startServer(db: Database, username: String, password: CharArray): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0,// this is the default
                disableTls = true,
                authenticator = ListenerPasswordAuthenticator { usr, pwd -&gt;
                    (usr == username) &amp;&amp; pwd.contentEquals(password)
                })
        )

        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
}





// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Message
import com.couchbase.lite.MessageEndpoint
import com.couchbase.lite.MessageEndpointConnection
import com.couchbase.lite.MessageEndpointDelegate
import com.couchbase.lite.MessageEndpointListener
import com.couchbase.lite.MessageEndpointListenerConfigurationFactory
import com.couchbase.lite.MessagingCloseCompletion
import com.couchbase.lite.MessagingCompletion
import com.couchbase.lite.ProtocolType
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorConnection
import com.couchbase.lite.create


@Suppress("unused")
class BrowserSessionManager : MessageEndpointDelegate {
    private var replicator: Replicator? = null

    @Throws(CouchbaseLiteException::class)
    fun initCouchbase() {
        val database = Database("mydb")

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        val messageEndpoint = MessageEndpoint("UID:123", "active", ProtocolType.MESSAGE_STREAM, this)

        // Create the replicator object.
        val repl = Replicator(ReplicatorConfigurationFactory.create(database = database, target = messageEndpoint))
        // Start the replication.
        repl.start()
        replicator = repl
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    override fun createConnection(endpoint: MessageEndpoint) = ActivePeerConnection()
}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

@Suppress("unused")
class ActivePeerConnection : MessageEndpointConnection {
    private var replicatorConnection: ReplicatorConnection? = null

    fun disconnect() {
        replicatorConnection?.close(null)
        replicatorConnection = null
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete()
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun send(message: Message, completion: MessagingCompletion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null)
    }

    fun receive(message: Message) {
        replicatorConnection?.receive(message)
    }
}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

@Suppress("unused")
class PassivePeerConnection private constructor() : MessageEndpointConnection {
    private var messageEndpointListener: MessageEndpointListener? = null
    private var replicatorConnection: ReplicatorConnection? = null

    @Throws(CouchbaseLiteException::class)
    fun startListener() {
        val database = Database("mydb")
        messageEndpointListener = MessageEndpointListener(
            MessageEndpointListenerConfigurationFactory.create(database, ProtocolType.MESSAGE_STREAM)
        )
    }

    fun stopListener() {
        messageEndpointListener?.closeAll()
    }

    fun accept() {
        val connection = PassivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        messageEndpointListener?.accept(connection)
    }

    fun disconnect() {
        replicatorConnection?.close(null)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete()
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun send(message: Message, completion: MessagingCompletion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null)
    }

    fun receive(message: Message) {
        replicatorConnection?.receive(message)
    }

}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.</strong>
import com.couchbase.lite.Function
import com.fasterxml.jackson.databind.ObjectMapper
import org.json.JSONException


private const val TAG = "QUERY"
private const val DATABASE_NAME = "database"

data class Hotel(
    var description: String? = null,
    var country: String? = null,
    var city: String? = null,
    var name: String? = null,
    var type: String? = null,
    var id: String? = null
)

@Suppress("unused")
class QueryExamples(private val database: Database) {

    // </mark># Indexing
    @Throws(CouchbaseLiteException::class)
    fun testIndexing() {
        database.createIndex( "TypeNameIndex",
              ValueIndexConfiguration( "type", "name")
    }

    fun testIndexing_Querybuilder() {
        database.createIndex(
            "TypeNameIndex",
            IndexBuilder.valueIndex(
                ValueIndexItem.property("type"),
                ValueIndexItem.property("name")
            )
        )
    }

    // <mark># SELECT statement
    fun testSelectStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("type")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.expression(Meta.id))
            .execute()

        for (result in rs) {
            Log.i(TAG, "hotel id -&gt;${result.getString("id")}")
            Log.i(TAG, "hotel name -&gt; ${result.getString("name")}")
        }
      }

      // META function
      @Throws(CouchbaseLiteException::class)
      fun testMetaFunction() {
        val rs = QueryBuilder
        .select(SelectResult.expression(Meta.id))
        .from(DataSource.database(database))
        .where(Expression.property("type").equalTo(Expression.string("airport")))
        .orderBy(Ordering.expression(Meta.id))
        .execute()

        for (result in rs) {
          Log.w(TAG, "airport id -&gt;${result.getString("id")}")
          Log.w(TAG, "airport id -&gt; ${result.getString(0)}")
        }
      }

      // </mark># all(<strong>)
    @Throws(CouchbaseLiteException::class)
    fun testSelectAll() {
        val queryAll = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))

        val query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="61"></i><b>(61)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        val token = query.addChangeListener { change -&gt;
            change.results?.let {
                for (result in it) {
                    Log.d(TAG, "results: ${result.keys}")
                    /</strong> Update UI <strong>/
                }
            } <i class="conum" data-value="62"></i><b>(62)</b>
        }


        query.removeChangeListener(token)

        for (result in query.execute()) {
            Log.i(TAG, "hotel -&gt; ${result.getDictionary(DATABASE_NAME)?.toMap()}")
        }
    }


    // <mark>#WHERE statement
    @Throws(CouchbaseLiteException::class)
    fun testWhereStatement() {
        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.intValue(10))
            .execute()
        for (result in rs) {
            result.getDictionary(DATABASE_NAME)?.let {
                Log.i(TAG, "name -&gt; ${it.getString("name")}")
                Log.i(TAG, "type -&gt; ${it.getString("type")}")
            }
        }
    }

    fun testQueryDeletedDocuments() {
        // Query documents that have been deleted
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted)
    }

    // </mark><mark>Collection Operators
    @Throws(CouchbaseLiteException::class)
    fun testCollectionStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(
                        ArrayFunction.contains(
                            Expression.property("public_likes"),
                            Expression.string("Armani Langworth")
                        )
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.getArray("public_likes")?.toList()}")
        }
    }

    // IN operator
    @Throws(CouchbaseLiteException::class)
    fun testInOperator() {
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.string("Armani").<code>in</code>(
                    Expression.property("first"),
                    Expression.property("last"),
                    Expression.property("username")
                )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.toMap()}")
        }
    }

    // Pattern Matching
    @Throws(CouchbaseLiteException::class)
    fun testPatternMatching() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // </mark># Wildcard Match
    @Throws(CouchbaseLiteException::class)
    fun testWildcardMatch() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // Wildcard Character Match
    @Throws(CouchbaseLiteException::class)
    fun testWildCharacterMatch() {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng____r"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // <mark># Regex Match
    @Throws(CouchbaseLiteException::class)
    fun testRegexMatch() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .regex(Expression.string("\\beng.*r\\b"))
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // JOIN statement
    @Throws(CouchbaseLiteException::class)
    fun testJoinStatement() {
        val rs = QueryBuilder.select(
            SelectResult.expression(Expression.property("name").from("airline")),
            SelectResult.expression(Expression.property("callsign").from("airline")),
            SelectResult.expression(Expression.property("destinationairport").from("route")),
            SelectResult.expression(Expression.property("stops").from("route")),
            SelectResult.expression(Expression.property("airline").from("route"))
        )
            .from(DataSource.database(database).<code>as</code>("airline"))
            .join(
                Join.join(DataSource.database(database).<code>as</code>("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(
                        Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline"))
                    )
                    .and(
                        Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.toMap()}")
        }
    }


    // </mark># GROUPBY statement
    @Throws(CouchbaseLiteException::class)
    fun testGroupByStatement() {
        val rs = QueryBuilder.select(
            SelectResult.expression(Function.count(Expression.string("</strong>"))),
            SelectResult.property("country"),
            SelectResult.property("tz")
        )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300)))
            )
            .groupBy(
                Expression.property("country"), Expression.property("tz")
            )
            .orderBy(Ordering.expression(Function.count(Expression.string("<strong>"))).descending())
            .execute()

        for (result in rs) {
            result.let {
                Log.i(
                    TAG,
                    "There are ${it.getInt("$1")} airports on the ${
                        it.getString("tz")
                    } timezone located in ${
                        it.getString("country")
                    } and above 300ft"
                )
            }
        }
    }

    // <mark># ORDER BY statement
    @Throws(CouchbaseLiteException::class)
    fun testOrderByStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("name").ascending())
            .limit(Expression.intValue(10))
            .execute()

        for (result in rs) {
            Log.i(TAG, "${result.toMap()}")
        }
    }


    // </mark># EXPLAIN statement
    @Throws(CouchbaseLiteException::class)
    fun testExplainStatement() {
        var query: Query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").descending()) <i class="conum" data-value="63"></i><b>(63)</b>
        Log.i(TAG, query.explain()) <i class="conum" data-value="64"></i><b>(64)</b>

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%"))) <i class="conum" data-value="65"></i><b>(65)</b>
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="66"></i><b>(66)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%")))
            )
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Function.lower(
                    Expression.property("type").equalTo(Expression.string("hotel"))
                )
            ) <i class="conum" data-value="67"></i><b>(67)</b>
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))) <i class="conum" data-value="68"></i><b>(68)</b>
        Log.i(TAG, query.explain())
    }

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex() {
        val config = FullTextIndexConfiguration("overview").ignoreAccents(false)

        database.createIndex( "overviewFTSIndex", config);
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS() {

        val ftsQuery =
              database.createQuery(
                "SELECT _id, overview FROM _ WHERE MATCH(overviewFTSIndex, 'michigan') ORDER BY RANK(overviewFTSIndex)")

        ftsQuery.execute().allResults().forEach {
          Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}")
        }

    }

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex_Querybuilder() {
        database.createIndex(
            "overviewFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("overview")).ignoreAccents(false)
        )
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS_Querybuilder() {

        val ftsQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id),
                                  SelectResult.expression(overview))
                          .from(DataSource.database(database))
                          .where(FullTextFunction.match("overviewFTSIndex", "michigan"))
                          .execute()

        ftsQuery.execute().allResults().forEach {
          Log.i(TAG, "${result.getString("Meta.id")}: ${result.getString("overview")}")
          }



    }


    fun testQuerySyntaxAll(currentUser: String) {
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(openOrCreateDatabaseForUser(currentUser)))

        val hotels: HashMap&lt;String, Hotel&gt; = HashMap()

        for (result in listQuery.execute().allResults()) {
            // get the k-v pairs from the 'hotel' key's value into a dictionary
            val thisDocsProps = result.getDictionary(0) <i class="conum" data-value="69"></i><b>(69)</b>
            val thisDocsId = thisDocsProps!!.getString("id")
            val thisDocsName = thisDocsProps.getString("name")
            val thisDocsType = thisDocsProps.getString("type")
            val thisDocsCity = thisDocsProps.getString("city")

            // Alternatively, access results value dictionary directly
            val id = result.getDictionary(0)?.getString("id").toString() <i class="conum" data-value="70"></i><b>(70)</b>
            hotels[id] = Hotel(
                id,
                result.getDictionary(0)?.getString("type"),
                result.getDictionary(0)?.getString("name"),
                result.getDictionary(0)?.getString("city"),
                result.getDictionary(0)?.getString("country"),
                result.getDictionary(0)?.getString("description")
            )
        }

    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun testQuerySyntaxJson(currentUser: String, argDb: Database) {
        val db = argDb
        // Example assumes Hotel class object defined elsewhere

        // Build the query
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(db))

        // Uses Jackson JSON processor
        val mapper = ObjectMapper()
        val hotels: ArrayList&lt;Hotel&gt; = ArrayList()

        for (result in listQuery.execute()) {

            // Get result as JSON string
            val json = result.toJSON() <i class="conum" data-value="71"></i><b>(71)</b>

            // Get Hashmap from JSON string
            val dictFromJSONstring = mapper.readValue(json, HashMap::class.java) <i class="conum" data-value="72"></i><b>(72)</b>

            // Use created hashmap
            val hotelId = dictFromJSONstring["id"].toString() //
            val hotelType = dictFromJSONstring["type"].toString()
            val hotelname = dictFromJSONstring["name"].toString()


            // Get custom object from JSON string
            val thisHotel = mapper.readValue(json, Hotel::class.java) <i class="conum" data-value="73"></i><b>(73)</b>
            hotels.add(thisHotel)
        }
    }
/</strong> end func testQuerySyntaxJson <strong>/



    fun testQuerySyntaxProps(currentUser: String) {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
            Log.i(TAG, "Hotel name -&gt; ${result.getString("name")}, in ${result.getString("country")}" )
        }
    }

    fun testQuerySyntaxCount(currentUser: String) {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.string("</strong>"))).as("mycount")) <i class="conum" data-value="74"></i><b>(74)</b>
            .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
            Log.i(TAG, "name -&gt; ${result.getInt("mycount").toString()}")
        }
    }


    fun testQuerySyntaxId(currentUser: String) {
        // tag::query-select-meta

        val rs = QueryBuilder
        .select(
          SelectResult.expression(Meta.id).as("hotelId"))
          .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
          Log.i(TAG, "hotel id -&gt;${result.getString("hotelId")}")
        }
        // end::query-select-meta
    }


    fun docsOnlyQuerySyntaxN1QL(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      val db = argDb
      val thisQuery = db.createQuery(
            "SELECT META().id AS id FROM _ WHERE type = \"hotel\"") <i class="conum" data-value="75"></i><b>(75)</b>

      return thisQuery.execute().allResults()

  }

  fun docsOnlyQuerySyntaxN1QLParams(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      val db = argDb
      val thisQuery = db.createQuery(
            "SELECT META().id AS id FROM _ WHERE type = \$type") <i class="conum" data-value="76"></i><b>(76)</b>

      thisQuery.parameters = Parameters().setString("type", "hotel") <i class="conum" data-value="77"></i><b>(77)</b>

      return thisQuery.execute().allResults()

  }

  fun testQuerySyntaxPagination(currentUser: String) {
    val limit = 20
    val offset = 0

    val rs = QueryBuilder
      .select(SelectResult.all())
      .from(DataSource.database(database))
      .where(Expression.property("type").equalTo(Expression.string("hotel")))
      .limit(Expression.intValue(limit), Expression.intValue(offset))

  }

    fun openOrCreateDatabaseForUser(argUser: String): Database = Database(argUser) {

    }



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/JSONExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.*
import org.json.JSONException
import org.json.JSONObject


const val JSON = """[{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\",
        \"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},
        {\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\",
        \"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},
        {\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",
        \"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\",
        \"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]"""


class KtJSONExamples {
    private val TAG = "SNIPPETS"

    fun jsonArrayExample(db: Database) {
        // github tag=tojson-array
        val mArray = MutableArray(JSON) <i class="conum" data-value="78"></i><b>(78)</b>
        for (i in 0 until mArray.count()) {
            mArray.getDictionary(i)?.apply {
                Log.i(TAG, getString("name") ?: "unknown")
                db.save(MutableDocument(getString("id"), toMap()))
            } <i class="conum" data-value="79"></i><b>(79)</b>
        }

        db.getDocument("1002")?.getArray("features")?.apply {
            for (feature in toList()) {
                Log.i(TAG, "$feature")
            } <i class="conum" data-value="80"></i><b>(80)</b>
            Log.i(TAG, toJSON())
        } <i class="conum" data-value="81"></i><b>(81)</b>
    }

    fun jsonBlobExample(db: Database) {
        // github tag=tojson-blob
        val thisBlob = db.getDocument("thisdoc-id")!!.toMap()
        if (!Blob.isBlob(thisBlob)) {
          return
        }
        val blobType = thisBlob["content_type"].toString()
        val blobLength = thisBlob["length"] as Number?
    }

    fun jsonDictionaryExample() {
        // github tag=tojson-dictionary
        val mDict = MutableDictionary(JSON) <i class="conum" data-value="82"></i><b>(82)</b>
        Log.i(TAG, "$mDict")
        Log.i(TAG, "Details for: ${mDict.getString("name")}")
        for (key in mDict.keys) {
          Log.i(TAG, key + " =&gt; " + mDict.getValue(key))
        }
      }

      @Throws(CouchbaseLiteException::class)
      fun jsonDocumentExample(srcDb: Database, dstDb: Database) {
        QueryBuilder
        .select(SelectResult.expression(Meta.id).as("metaId"))
        .from(DataSource.database(srcDb))
        .execute()
        .forEach {
          it.getString("metaId")?.let { thisId -&gt;
            srcDb.getDocument(thisId)?.toJSON()?.let { json -&gt; <i class="conum" data-value="83"></i><b>(83)</b>
              Log.i(TAG, "JSON String = $json")
              val hotelFromJSON = MutableDocument(thisId, json) <i class="conum" data-value="84"></i><b>(84)</b>
              dstDb.save(hotelFromJSON)
              dstDb.getDocument(thisId)?.toMap()?.forEach { e -&gt;
                Log.i(TAG, "$e.key =&gt; $e.value")
              } <i class="conum" data-value="85"></i><b>(85)</b>
            }
          }
        }
    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun jsonQueryExample(query: Query) {
        query.execute().forEach {

            // Use a Json Object to populate Native object
            JSONObject(it.toJSON()).apply {
                val (description, country, city, name, type, id) = Hotel(
                    id = getString("id"),
                    type = getString("type"),
                    name = getString("name"),
                    city = getString("city"),
                    country = "Ghana, West Africa",
                    description = "this hotel"
                )
            }
        }
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/JSONExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.Database
import com.couchbase.lite.MutableDictionary

class KtBlobExamples {

    // Example 2: Using Blobs
    fun example2(context: Context, db: Database) {
        val doc = db.getDocument("1000") ?: return

        // Create a blob from an asset
        val blob = Blob("image/png", context.assets.open("couchbaseimage.png"))

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON()

        // Save the blob as part of a document
        db.save(doc.toMutable().setBlob("avatar", blob))

        // Experts only!!!
        db.saveBlob(blob)

        // Retrieve saved blob and get as JSON again
        val blobAsJSONString = db.getDocument("1000")?.getBlob("avatar")?.toJSON() ?: return

        // reconstitute
        val blobAsMap = MutableDictionary().setJSON(blobAsJSONString).toMap()

        // show the contents of the reconstituted blob
        for key, value) in blobAsMap) {             Log.d("BLOB", "Data: $key -&gt; $value")         }          // verify that the reconstitued thing is still blob         if (Blob.isBlob(blobAsMap {
            Log.d("BLOB", blobAsJSONString)
        }
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt </code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset5_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">

// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/PasswordAuthListener.java 
//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorActivityLevel;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorType;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);                 Log.e(TAG, "Success!!");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void runClient(         @NonNull URI uri,         @NonNull String username,         @NonNull char[] password,         @NonNull Database db) throws InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setType(ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }

    /<strong>
     * Snippet 1: create a ListenerPasswordAuthenticator and configure the listener with it
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     * NOTE: This requires the following, in the manifest
     *     &lt;application
     *         ...
     *         android:usesCleartextTraffic="true"
     *         ...
     *     &gt;
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password)
        throws CouchbaseLiteException {
        final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

        config.setPort(0); // this is the default
        config.setDisableTls(true);
        config.setAuthenticator(new ListenerPasswordAuthenticator(
            (user, pwd) -&gt; username.equals(user) &amp;&amp; Arrays.equals(password, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/PasswordAuthListener.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/BlobExamples.java 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.util.Log;

import java.io.IOException;
import java.util.Map;

import com.couchbase.lite.Blob;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.Document;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;


class BlobExamples {

    // Example 2: Using Blobs
    public void example2(final Context context, final Database db) throws IOException, CouchbaseLiteException {
        final Document doc = db.getDocument("1000");
        if (doc == null) { return; }

        // Create a blob from an asset
        final Blob blob = new Blob("image/png", context.getAssets().open("couchbaseimage.png"));

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON();

        // Save the blob as part of a document
        final MutableDocument mDoc = doc.toMutable();
        mDoc.setBlob("avatar", blob);
        db.save(mDoc);

        // Experts only!!!
        db.saveBlob(blob);

        // Retrieve saved blob
        final Document sameDoc = db.getDocument("1000");
        if (sameDoc == null) { return; }

        final Blob sameBlob = sameDoc.getBlob("avatar");
        if (sameBlob == null) { return; }

        // Get as JSON again
        final String blobAsJSONString = sameBlob.toJSON();

        // reconstitute
        final Map&lt;String, Object&gt; blobAsMap = new MutableDictionary().setJSON(blobAsJSONString).toMap();

        // show the contents of the reconstituted blob
        for (Map.Entry&lt;String, Object&gt; entry: blobAsMap.entrySet()) {
            Log.d("BLOB", "Data: " + entry.getKey() + " -&gt; " + entry.getValue());
        }

        // verify that the reconstitued thing is still blob
        if (Blob.isBlob(blobAsMap)) { Log.d("BLOB", blobAsJSONString); }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/BlobExamples.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/MainActivity.java 
package com.couchbase.code_snippets;

import android.os.Bundle;

import androidx.appcompat.app.AppCompatActivity;


public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/MainActivity.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/CertAuthListener.java 

//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorActivityLevel;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorType;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);                 Log.e(TAG, "Success!!");                 deleteIdentity("server");                 Log.e(TAG, "Alias deleted: server");                 deleteIdentity("client");                 Log.e(TAG, "Alias deleted: client");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void startClient(         @NonNull URI uri,         @NonNull Certificate cert,         @NonNull TLSIdentity clientIdentity,         @NonNull Database db) throws CertificateEncodingException, InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setType(ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }

    /</strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
        throws CouchbaseLiteException {
        final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

        config.setPort(0); // this is the default
        config.setDisableTls(false);
        config.setTlsIdentity(serverId);
        config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
    }

    /<strong>
     * Snippet 3: delete an identity from the keystore
     * (NOTE: a keystore doesn't contain TLSIdentities: I'm guessing that this is what you intend)
     * &lt;p&gt;
     * Delete an identity from the key store.
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
        throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

        final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);

        keyStore.deleteEntry(alias);
    }

    /</strong>
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     * &lt;p&gt;
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    private void configureClientCerts(
        ReplicatorConfiguration config,
        @NonNull Certificate cert,
        @NonNull TLSIdentity clientIdentity)
        throws CertificateEncodingException {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
    }

    /<strong>
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     * &lt;p&gt;
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte[] buf = new byte[1024];
        int n;
        while n = in.read(buf &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/CertAuthListener.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java 
//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import androidx.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;
import com.example.docsnippet.Datastore;
import com.example.docsnippet.Hotel;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class docOnly_Examples {
  private static final String TAG = "EXAMPLE";

  private static final String DATABASE_NAME = "database";

  private final Context context;
  private Database database;
  private Replicator replicator;

  public docOnly_Examples(Context context) { this.context = context; }

  //@Test
  public void testGettingStarted() throws CouchbaseLiteException, URISyntaxException {

    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);

    // Get the database (and create it if it doesnt exist).
    DatabaseConfiguration config = new DatabaseConfiguration();

    config.setDirectory(context.getFilesDir().getAbsolutePath());

    Database database = new Database("getting-started", config);


    // Create a new document (i.e. a record) in the database.
    MutableDocument mutableDoc = new MutableDocument()
    .setFloat("version", 2.0F)
    .setString("type", "SDK");

    // Save it to the database.
    database.save(mutableDoc);

    // Update a document.
    mutableDoc = database.getDocument(mutableDoc.getId()).toMutable();
    mutableDoc.setString("language", "Java");
    database.save(mutableDoc);
    Document document = database.getDocument(mutableDoc.getId());
    // Log the document ID (generated by the database) and properties
    Log.i(TAG, "Document ID :: " + document.getId());
    Log.i(TAG, "Learning " + document.getString("language"));

    // Create a query to fetch documents of type SDK.
    Query query = QueryBuilder.select(SelectResult.all())
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("SDK")));
    ResultSet result = query.execute();
    Log.i(TAG, "Number of rows ::  " + result.allResults().size());

    // Create replicators to push and pull changes to and from the cloud.
    Endpoint targetEndpoint = new URLEndpoint(new URI("ws://localhost:4984/getting-started-db"));
    ReplicatorConfiguration replConfig = new ReplicatorConfiguration(database, targetEndpoint);
    replConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Add authentication.
    replConfig.setAuthenticator(new BasicAuthenticator("sync-gateway", "password"));

    // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
    Replicator replicator = new Replicator(replConfig);

    // Listen to replicator change events.
    replicator.addChangeListener(change -&gt; {
      if (change.getStatus().getError() != null) {
        Log.i(TAG, "Error code ::  " + change.getStatus().getError().getCode());
      }
    });

    // Start replication.
    replicator.start();


    database.delete();
  }

  public void test1xAttachments() throws CouchbaseLiteException, IOException {
    // if db exist, delete it
    deleteDB("android-sqlite", context.getFilesDir());

    ZipUtils.unzip(getAsset("replacedb/android140-sqlite.cblite2.zip"), context.getFilesDir());

    Database db = new Database("android-sqlite", new DatabaseConfiguration());
    try {

      Document doc = db.getDocument("doc1");

      // For Validation
      Dictionary attachments = doc.getDictionary("_attachments");
      Blob blob = attachments.getBlob("attach1");
      byte[] content = blob.getContent();
      // For Validation

      byte[] attach = String.format(Locale.ENGLISH, "attach1").getBytes();
      Arrays.equals(attach, content);

    } finally {
      // close db
      db.close();
      // if db exist, delete it
      deleteDB("android-sqlite", context.getFilesDir());
    }

    Document document = new MutableDocument();

    Dictionary attachments = document.getDictionary("_attachments");
    Blob blob = attachments != null ? attachments.getBlob("avatar") : null;
    byte[] content = blob != null ? blob.getContent() : null;
  }

  // <mark># Initializer
  public void testInitializer() {
    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);
  }

  // </mark># New Database
  public void testNewDatabase() throws CouchbaseLiteException {
    final DatabaseConfiguration config = new DatabaseConfiguration();
    config.setDirectory(context.getFilesDir().getAbsolutePath()); <i class="conum" data-value="1"></i><b>(1)</b>

    Database database = new Database("my-database", config);

    database.close();


    database.delete();
  }

  // <mark># Database Encryption
  public void testDatabaseEncryption() throws CouchbaseLiteException {
    DatabaseConfiguration config = new DatabaseConfiguration();
    config.setEncryptionKey(new EncryptionKey("PASSWORD"));
    Database database = new Database("mydb", config);
  }

  // </mark># Logging
  public void testLogging() {
    Database.setLogLevel(LogDomain.DATABASE, LogLevel.VERBOSE);
    Database.setLogLevel(LogDomain.QUERY, LogLevel.VERBOSE);
    }

    public void testEnableCustomLogging() {
        Database.log.setCustom(new LogTestLogger(LogLevel.WARNING)); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    // <mark># Console logging
    public void testConsoleLogging() throws CouchbaseLiteException {
          Database.log.getConsole().setDomain(LogDomain.ALL_DOMAINS);  <i class="conum" data-value="3"></i><b>(3)</b>
          Database.log.getConsole().setLevel(LogLevel.VERBOSE); <i class="conum" data-value="4"></i><b>(4)</b>
          Database.log.getConsole().setDomain(LogDomain.DATABASE);

    }

    // </mark># File logging
    public void testFileLogging() throws CouchbaseLiteException {
        final File path = context.getCacheDir();

        LogFileConfiguration LogCfg =
          new LogFileConfiguration(path.toString()); <i class="conum" data-value="5"></i><b>(5)</b>
        LogCfg.setMaxSize(10240); <i class="conum" data-value="6"></i><b>(6)</b>
        LogCfg.setMaxRotateCount(5); <i class="conum" data-value="7"></i><b>(7)</b>
        LogCfg.setUsePlainText(false); <i class="conum" data-value="8"></i><b>(8)</b>
        Database.log.getFile().setConfig(LogCfg);
        Database.log.getFile().setLevel(LogLevel.INFO); <i class="conum" data-value="9"></i><b>(9)</b>
    }

    public void writeConsoleLog()
    {
        Database.log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }
    public void writeCustomLog()
    {
        Database.log.Custom?.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }


    public void writeFileLog()
    {
        Database.log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }




    // <mark># Loading a pre-built database
    public void testPreBuiltDatabase() throws IOException {
      // Note: Getting the path to a database is platform-specific.
      // For Android you need to extract it from your
      // assets to a temporary directory and then pass that path to Database.copy()
      DatabaseConfiguration configuration = new DatabaseConfiguration();
      if (!Database.exists("travel-sample", context.getFilesDir())) {
            ZipUtils.unzip(getAsset("travel-sample.cblite2.zip"), context.getFilesDir());
            File path = new File(context.getFilesDir(), "travel-sample");
            try {
                Database.copy(path, "travel-sample", configuration);
            } catch (CouchbaseLiteException e) {
                e.printStackTrace();
            }
        }
    }

    // helper methods

    // if db exist, delete it
    private void deleteDB(String name, File dir) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            // sometimes, db is still in used, wait for a while. Maximum 3 sec
            for (int i = 0; i &lt; 10; i) {
                try {
                    Database.delete(name, dir);
                    break;
                } catch (CouchbaseLiteException ex) {
                    try { Thread.sleep(300); }
                    catch (InterruptedException ignore) { }
                }
            }
        }
    }

    // ### Initializers
    public void testInitializers() {
        MutableDocument newTask = new MutableDocument();
        newTask.setString("type", "task");
        newTask.setString("owner", "todo");
        newTask.setDate("createdAt", new Date());
        try {
            database.save(newTask);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // ### Mutability
    public void testMutability() {
        try { database.save(new MutableDocument("xyz")); }
        catch (CouchbaseLiteException ignore) { }

        Document document = database.getDocument("xyz");
        MutableDocument mutableDocument = document.toMutable();
        mutableDocument.setString("name", "apples");
        try {
            database.save(mutableDocument);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // ### Typed Accessors
    public void testTypedAccessors() {
        MutableDocument newTask = new MutableDocument();

        newTask.setValue("createdAt", new Date());
        Date date = newTask.getDate("createdAt");
    }

    // ### Batch operations
    public void testBatchOperations() {
        try {
            database.inBatch(() -&gt; {
                for (int i = 0; i &lt; 10; i) {
                    MutableDocument doc = new MutableDocument();
                    doc.setValue("type", "user");
                    doc.setValue("name", "user " + i);
                    doc.setBoolean("admin", false);
                    try {
                        database.save(doc);
                    } catch (CouchbaseLiteException e) {
                        Log.e(TAG, e.toString());
                    }
                    Log.i(TAG, String.format("saved user document %s", doc.getString("name")));
                }
            });
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // </mark># Document Expiration
    public void DocumentExpiration() throws CouchbaseLiteException {
        // Purge the document one day from now
        Instant ttl = Instant.now().plus(1, ChronoUnit.DAYS);
        database.setDocumentExpiration("doc123", new Date(ttl.toEpochMilli()));

        // Reset expiration
        database.setDocumentExpiration("doc1", null);

        // Query documents that will be expired in less than five minutes
        Instant fiveMinutesFromNow = Instant.now().plus(5, ChronoUnit.MINUTES);
        Query query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.expiration.lessThan(Expression.doubleValue(fiveMinutesFromNow.toEpochMilli())));
    }

    public void testDocumentChangeListener() throws CouchbaseLiteException {
        database.addDocumentChangeListener(
            "user.john",
            change -&gt; {
                Document doc = database.getDocument(change.getDocumentID());
                if (doc != null) {
                    Toast.makeText(context, "Status: " + doc.getString("verified_account"), Toast.LENGTH_SHORT).show();
                }
            });
    }

    // <mark># Blobs
    public void testBlobs() {
        MutableDocument newTask = new MutableDocument();

        InputStream is = getAsset("avatar.jpg"); <i class="conum" data-value="10"></i><b>(10)</b>
        if (is == null) { return; }
        try {
            Blob blob = new Blob("image/jpeg", is); <i class="conum" data-value="11"></i><b>(11)</b>
            newTask.setBlob("avatar", blob); <i class="conum" data-value="12"></i><b>(12)</b>
            database.save(newTask);

            Blob taskBlob = newTask.getBlob("avatar");
            byte[] bytes = taskBlob.getContent();
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        } finally {
            try { is.close(); }
            catch (IOException ignore) { }
        }
    }

    // </mark># Indexing
    public void testIndexing() throws CouchbaseLiteException {
        // For Documentation
        {

            database.createIndex(ValueIndexConfiguration(["type", "name"]), "TypeNameIndex");

        }
    }

    public void testIndexing_Querybuilder() throws CouchbaseLiteException {
        // For Documentation
        {
            database.createIndex(
                "TypeNameIndex",
                IndexBuilder.valueIndex(
                    ValueIndexItem.property("type"),
                    ValueIndexItem.property("name")));
        }
    }

    // <mark># SELECT statement
    public void testSelectStatement() {
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("type"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.expression(Meta.id));

            try {
                ResultSet rs = query.execute();
                for (Result result : rs) {
                    Log.i("Sample", String.format("hotel id -&gt; %s", result.getString("id")));
                    Log.i("Sample", String.format("hotel name -&gt; %s", result.getString("name")));
                }
            } catch (CouchbaseLiteException e) {
                Log.e("Sample", e.getLocalizedMessage());
            }
          }
        }

        // META function
        public void testMetaFunction() throws CouchbaseLiteException {
          // For Documentation
          {
          Query query = QueryBuilder
          .select(SelectResult.expression(Meta.id))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("airport")))
          .orderBy(Ordering.expression(Meta.id));
          ResultSet rs = query.execute();
          for (Result result : rs) {
            Log.w("Sample", String.format("airport id -&gt; %s", result.getString("id")));
            Log.w("Sample", String.format("airport id -&gt; %s", result.getString(0)));
          }
        }
    }

    // </mark># all(</strong>)
    public void testSelectAll() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")));

            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database)); <i class="conum" data-value="13"></i><b>(13)</b>

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            ListenerToken token = query.addChangeListener(change -&gt; { <i class="conum" data-value="14"></i><b>(14)</b>
                for (Result result : change.getResults()) {
                    Log.d(TAG, "results: " + result.getKeys());
                    /* Update UI <strong>/
                }
            });


            query.removeChangeListener(token); <i class="conum" data-value="15"></i><b>(15)</b>


            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("hotel -&gt; %s", result.getDictionary(DATABASE_NAME).toMap()));
            }
        }
    }

    // <mark>#WHERE statement
    public void testWhereStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .limit(Expression.intValue(10));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Dictionary all = result.getDictionary(DATABASE_NAME);
                Log.i("Sample", String.format("name -&gt; %s", all.getString("name")));
                Log.i("Sample", String.format("type -&gt; %s", all.getString("type")));
            }
        }
    }

    public void testQueryDeletedDocuments() {
        // Query documents that have been deleted
        Where query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted);
    }


    // </mark><mark>Collection Operators
    public void testCollectionStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("public_likes"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction
                        .contains(Expression.property("public_likes"), Expression.string("Armani Langworth"))));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("public_likes -&gt; %s", result.getArray("public_likes").toList()));
            }
        }
    }

    // IN operator
    public void testInOperator() throws CouchbaseLiteException {
        // For Documentation
        {
            Expression[] values = new Expression[] {
                Expression.property("first"),
                Expression.property("last"),
                Expression.property("username")
            };

            Query query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.string("Armani").in(values));

            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // Pattern Matching
    public void testPatternMatching() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Function.Expression.string("royal engineers museum")))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // </mark># Wildcard Match
    public void testWildcardMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng%e%"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // Wildcard Character Match
    public void testWildCharacterMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng____r"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // <mark># Regex Match
    public void testRegexMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).regex(Expression.string("\\beng.*r\\b"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // JOIN statement
    public void testJoinStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder.select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route")))
                .from(DataSource.database(database).as("airline"))
                .join(Join.join(DataSource.database(database).as("route"))
                    .on(Meta.id.from("airline").equalTo(Expression.property("airlineid").from("route"))))
                .where(Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline").equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route").equalTo(Expression.string("RIX"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // </mark># GROUPBY statement
    public void testGroupByStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder.select(
                SelectResult.expression(Function.count(Expression.string("</strong>"))),
                SelectResult.property("country"),
                SelectResult.property("tz"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300))))
                .groupBy(
                    Expression.property("country"),
                    Expression.property("tz"))
                .orderBy(Ordering.expression(Function.count(Expression.string("<strong>"))).descending());
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format(
                        "There are %d airports on the %s timezone located in %s and above 300ft",
                        result.getInt("$1"),
                        result.getString("tz"),
                        result.getString("country")));
            }
        }
    }

    // <mark># ORDER BY statement
    public void testOrderByStatement() throws CouchbaseLiteException {
      // For Documentation
      {
        Query query = QueryBuilder
        .select(
          SelectResult.expression(Meta.id),
          SelectResult.property("name"))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("hotel")))
          .orderBy(Ordering.property("name").ascending())
          .limit(Expression.intValue(10));
          ResultSet rs = query.execute();
          for (Result result : rs) { Log.i("Sample", String.format("%s", result.toMap())); }
        }
      }
      // </mark># EXPLAIN statement
      public void testExplainStatement() throws CouchbaseLiteException {
          // For Documentation
          {
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("university")))
                .groupBy(Expression.property("country"))
                .orderBy(Ordering.property("name").descending()); <i class="conum" data-value="16"></i><b>(16)</b>
              Log.i(query.explain()); <i class="conum" data-value="17"></i><b>(17)</b>
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("%hotel%"))); <i class="conum" data-value="18"></i><b>(18)</b>
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="19"></i><b>(19)</b>
                  .and(Expression.property("name").like(Expression.string("%royal%"))));
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))); <i class="conum" data-value="20"></i><b>(20)</b>
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="21"></i><b>(21)</b>
              Log.i(query.explain());
          }
      }
      // end query-explain

    void prepareIndex() throws CouchbaseLiteException {

        FullTextIndexConfiguration config = new FullTextIndexConfiguration("Overview").ignoreAccents(false)

        database.createIndex( config, "overviewFTSIndex")

    }

    void prepareIndex_Querybuilder() throws CouchbaseLiteException {
      database.createIndex(
          "overviewFTSIndex",
          IndexBuilder.fullTextIndex(FullTextIndexItem.property("overview")).ignoreAccents(false));
  }

    public void testFTS() throws CouchbaseLiteException {

        Query ftsQuery =
                database.createQuery(
                "SELECT _id, overview FROM _ WHERE MATCH(overviewFTSIndex, 'michigan') ORDER BY RANK(overviewFTSIndex)");

        for (result in ftsQuery.execute().allResults()) {
          Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}");
        }

    }
    public void testFTS_Querybuilder() throws CouchbaseLiteException {
        Expression whereClause = FullTextFunction.match("overviewFTSIndex", "'michigan'");
        Query ftsQuery =
                QueryBuilder.select(SelectResult.expression(Meta.id),
                                    SelectResult.expression(overview)
                                  )
            .from(DataSource.database(database))
            .where(whereClause);

            for (result in ftsQuery.execute().allResults()) {
              Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}");
            }

    }

    /</strong> The <code>tag::replication[]</code> example is inlined in java.adoc <strong>/

    public void testTroubleshooting() {
        Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE);
    }

    public void testReplicationBasicAuthentication() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new BasicAuthenticator("username", "password"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationSessionAuthentication() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationStatus() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        replicator.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == Replicator.ActivityLevel.STOPPED) {
                Log.i(TAG, "Replication stopped");
            }
          });
        }

    //  BEGIN PendingDocuments BM -- 19/Feb/21 --
    import android.support.annotation.NonNull;
    import android.util.Log;

    import java.net.URI;
    import java.net.URISyntaxException;
    import java.util.Iterator;
    import java.util.Set;

    import com.couchbase.lite.CouchbaseLiteException;
    import com.couchbase.lite.Database;
    import com.couchbase.lite.Endpoint;
    import com.couchbase.lite.Replicator;
    import com.couchbase.lite.ReplicatorConfiguration;
    import com.couchbase.lite.URLEndpoint;

    class PendingDocsExample {
        private static final String TAG = "SCRATCH";

        private Database database;
        private Replicator replicator;

        //  BEGIN PendingDocuments IB -- 11/Feb/21 --
        public void testReplicationPendingDocs() throws URISyntaxException, CouchbaseLiteException {
            // nottag::replication-pendingdocuments[]
            // ... include other code as required
            //
            final Endpoint endpoint =
              new URLEndpoint(new URI("ws://localhost:4984/db"));

            final ReplicatorConfiguration config =
              new ReplicatorConfiguration(database, endpoint)
            .setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

            replicator = new Replicator(config);
            final Set&lt;String&gt; pendingDocs =
              replicator.getPendingDocumentIds(); <i class="conum" data-value="22"></i><b>(22)</b>


            replicator.addChangeListener(change -&gt; {
              onStatusChanged(pendingDocs, change.getStatus()); });

            replicator.start();

            // ... include other code as required
            // notend::replication-pendingdocuments[]
          }
        //
        //
        private void onStatusChanged(
          @NonNull final Set&lt;String&gt; pendingDocs,
          @NonNull final Replicator.Status status) {
          // ... sample onStatusChanged function
          //
          Log.i(TAG,
            "Replicator activity level is " + status.getActivityLevel().toString());

          // iterate and report-on previously
          // retrieved pending docids 'list'
          for (Iterator&lt;String&gt; itr = pendingDocs.iterator(); itr.hasNext(); ) {
            final String docId = itr.next();
            try {
              if (!replicator.isDocumentPending(docId)) { continue; } <i class="conum" data-value="23"></i><b>(23)</b>

              itr.remove();
              Log.i(TAG, "Doc ID " + docId + " has been pushed");
            }
            catch (CouchbaseLiteException e) {
              Log.w(TAG, "isDocumentPending failed", e); }
          }
        }
        //  END PendingDocuments BM -- 19/Feb/21 --
    }


    public void testHandlingNetworkErrors() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        replicator.addChangeListener(change -&gt; {
            CouchbaseLiteException error = change.getStatus().getError();
            if (error != null) { Log.w(TAG, "Error code:: %d", error); }
        });
        replicator.start();

        replicator.stop();
    }

    public void testReplicatorDocumentEvent() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        ListenerToken token = replicator.addDocumentReplicationListener(replication -&gt; {

            Log.i(TAG, "Replication type: " + replication.isPush( ? "Push" : "Pull"));
            for (ReplicatedDocument document : replication.getDocuments()) {
                Log.i(TAG, "Doc ID: " + document.getID());

                CouchbaseLiteException err = document.getError();
                if (err != null) {
                    // There was an error
                    Log.e(TAG, "Error replicating document: ", err);
                    return;
                }

                if (document.flags().contains(DocumentFlag.DocumentFlagsDeleted)) {
                    Log.i(TAG, "Successfully replicated a deleted document");
                }
            }
        });

        replicator.start();

        replicator.removeChangeListener(token);
    }

    public void testReplicationCustomHeader() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();
        headers.put("CustomHeaderName", "Value");
        config.setHeaders(headers);
    }

    // <mark># Certificate Pinning

    public void testCertificatePinning() throws URISyntaxException, IOException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);

        InputStream is = getAsset("cert.cer");
        byte[] cert = IOUtils.toByteArray(is);
        if (is != null) {
            try { is.close(); }
            catch (IOException ignore) {}
        }

        config.setPinnedServerCertificate(cert);
    }

    // </mark># Reset replicator checkpoint
    public void testReplicationResetCheckpoint() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        if (resetCheckpointRequired_Example) {
          replicator.start(true); <i class="conum" data-value="24"></i><b>(24)</b>
        else
          replicator.start(false);
        }

        // ... at some later time

        replicator.stop();
    }

    public void testReplicationPushFilter() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPushFilterdocument, flags) -&gt; flags.contains(DocumentFlag.DocumentFlagsDeleted; <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationPullFilter() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPullFilterdocument, flags) -&gt; "draft".equals(document.getString("type"); <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testCustomRetryConfig() throws URISyntaxException {
    URLEndpoint target =
    new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

    ReplicatorConfiguration config =
    new ReplicatorConfiguration(database, target);

    //  other config as required . . .
    config.setHeartbeat(150L); <i class="conum" data-value="25"></i><b>(25)</b>
    config.setMaxattempts(20L); <i class="conum" data-value="26"></i><b>(26)</b>
    config.setMaxAttemptWaitTime(600L); <i class="conum" data-value="27"></i><b>(27)</b>

    Replicator repl = new Replicator(config);

    }


    public void docsSetAutoPurge() throws CouchbaseliteException {

      DatabaseConfiguration config = new DatabaseConfiguration();
      Database database1 = new Database("mydb", config);

      ReplicatorConfiguration repcfg =
      new ReplicatorConfiguration(database, target);

      repcfg.setAutoPurgeEnabled(true); <i class="conum" data-value="28"></i><b>(28)</b>

    }


    public void testDatabaseReplica() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database1 = new Database("mydb", config);

        config = new DatabaseConfiguration();
        Database database2 = new Database("db2", config);

        /</strong> EE feature: code below might throw a compilation error
           if it's compiled against CBL Android Community. <strong>/
        DatabaseEndpoint targetDatabase = new DatabaseEndpoint(database2);
        ReplicatorConfiguration replicatorConfig = new ReplicatorConfiguration(database1, targetDatabase);
        replicatorConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(replicatorConfig);
        replicator.start();
    }

    public void testPredictiveModel() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Database.prediction.registerModel("ImageClassifier", new ImageClassifierModel());

        ValueIndex index = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")));
        database.createIndex("value-index-image-classifier", index);

        Database.prediction.unregisterModel("ImageClassifier");
    }

    public void testPredictiveIndex() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Map&lt;String, Object&gt; inputMap = new HashMap&lt;&gt;();
        inputMap.put("numbers", Expression.property("photo"));
        Expression input = Expression.map(inputMap);

        PredictiveIndex index = IndexBuilder.predictiveIndex("ImageClassifier", input, null);
        database.createIndex("predictive-index-image-classifier", index);
    }

    public void testPredictiveQuery() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Map&lt;String, Object&gt; inputProperties = new HashMap&lt;&gt;();
        inputProperties.put("photo", Expression.property("photo"));
        Expression input = Expression.map(inputProperties);
        PredictionFunction prediction = PredictiveModel.predict("ImageClassifier", input); <i class="conum" data-value="1"></i><b>(1)</b>

        Query query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("label").equalTo(Expression.string("car"))
                .and(Expression.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))));

        // Run the query.
        ResultSet result = query.execute();
        Log.d(TAG, "Number of rows: " + result.allResults().size());
    }

    public void testReplicationWithCustomConflictResolver() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setConflictResolver(new LocalWinConflictResolver());

        Replicator replication = new Replicator(config);
        replication.start();
    }

    public void testSaveWithCustomConflictResolver() throws CouchbaseLiteException {
        Document doc = database.getDocument("xyz");
        if (doc == null) { return; }
        MutableDocument mutableDocument = doc.toMutable();
        mutableDocument.setString("name", "apples");

        database.save(
            mutableDocument,
            (newDoc, curDoc) -&gt; { <i class="conum" data-value="29"></i><b>(29)</b>
                if (curDoc == null) { return false; } <i class="conum" data-value="30"></i><b>(30)</b>
                Map&lt;String, Object&gt; dataMap = curDoc.toMap();
                dataMap.putAll(newDoc.toMap()); <i class="conum" data-value="31"></i><b>(31)</b>
                newDoc.setData(dataMap);
                return true; <i class="conum" data-value="32"></i><b>(32)</b>
            }); <i class="conum" data-value="33"></i><b>(33)</b>
      }
    }


&lt;.&gt; The conflict handler code is provided as a lambda.

&lt;.&gt; If the handler cannot resolve a conflict, it can return false.
In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.

&lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.

&lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).

&lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method

// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
class LocalWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getLocalDocument();
    }
}

// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
class RemoteWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getRemoteDocument();
    }
}

// Using replConfig.setConflictResolver(new MergeConflictResolver());
class MergeConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        Map&lt;String, Object&gt; merge = conflict.getLocalDocument().toMap();
        merge.putAll(conflict.getRemoteDocument().toMap());
        return new MutableDocument(conflict.getDocumentId(), merge);
    }
}


/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

class BrowserSessionManager implements MessageEndpointDelegate {
    private final Context context;
    private Replicator replicator;

    private BrowserSessionManager(Context context) { this.context = context; }

    public void initCouchbase() throws CouchbaseLiteException {
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration(context);
        Database database = new Database("mydb", databaseConfiguration);

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        MessageEndpoint messageEndpointTarget = new MessageEndpoint(
            "UID:123",
            "active",
            ProtocolType.MESSAGE_STREAM,
            this);

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, messageEndpointTarget);

        // Create the replicator object.
        replicator = new Replicator(config);
        // Start the replication.
        replicator.start();
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    @NonNull
    @Override
    public MessageEndpointConnection createConnection(@NonNull MessageEndpoint endpoint) {
        return new ActivePeerConnection(); /</strong> implements MessageEndpointConnection <strong>/
    }
}

class ActivePeerConnection implements MessageEndpointConnection {

    private ReplicatorConnection replicatorConnection;

    public void disconnect() {
        replicatorConnection.close(null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }

    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete();
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null);
    }

    public void receive(Message message) {
        replicatorConnection.receive(message);
    }

}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

class PassivePeerConnection implements MessageEndpointConnection {
    private final Context context;

    private MessageEndpointListener messageEndpointListener;
    private ReplicatorConnection replicatorConnection;

    private PassivePeerConnection(Context context) { this.context = context; }

    public void startListener() throws CouchbaseLiteException {
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration();
        Database database = new Database("mydb", databaseConfiguration);
        MessageEndpointListenerConfiguration listenerConfiguration = new MessageEndpointListenerConfiguration(
            database,
            ProtocolType.MESSAGE_STREAM);
        this.messageEndpointListener = new MessageEndpointListener(listenerConfiguration);
    }

    public void stopListener() {
        messageEndpointListener.closeAll();
    }

    public void accept() {
        PassivePeerConnection connection = new PassivePeerConnection(context); /</strong> implements
        MessageEndpointConnection <strong>/
        messageEndpointListener.accept(connection);
    }

    public void disconnect() {
        replicatorConnection.close(null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete();
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null);
    }

    public void receive(Message message) {
        replicatorConnection.receive(message);
    }
}

// tensorFlowModel is a fake implementation
// this would be the implementation of the ml model you have chosen
class ImageClassifierModel implements PredictiveModel {
    @Override
    public Dictionary predict(@NonNull Dictionary input) {
        Blob blob = input.getBlob("photo");
        if (blob == null) { return null; }

        // tensorFlowModel is a fake implementation
        // this would be the implementation of the ml model you have chosen
        return new MutableDictionary(TensorFlowModel.predictImage(blob.getContent())); <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

class TensorFlowModel {
    public static Map&lt;String, Object&gt; predictImage(byte[] data) {
        return null;
    }
}

class LogTestLogger implements Logger {
    @NonNull
    private final LogLevel level;

    public LogTestLogger(@NonNull LogLevel level) { this.level = level; }

    @NonNull
    @Override
    public LogLevel getLevel() { return level; }

    @Override
    public void log(@NonNull LogLevel level, @NonNull LogDomain domain, @NonNull String message) {
    }
}





//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);                 Log.e(TAG, "Success!!");                 deleteIdentity("server");                 Log.e(TAG, "Alias deleted: server");                 deleteIdentity("client");                 Log.e(TAG, "Alias deleted: client");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void startClient(         @NonNull URI uri,         @NonNull Certificate cert,         @NonNull TLSIdentity clientIdentity,         @NonNull Database db) throws CertificateEncodingException, InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    /</strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(false);
      config.setTlsIdentity(serverId);
      config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

      final URLEndpointListener listener = new URLEndpointListener(config);
      listener.start();

      final List&lt;URI&gt; urls = listener.getUrls();
      if (urls.isEmpty()) { return null; }
      return urls.get(0);
    }

    /<strong>
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
    throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

      final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
      keyStore.load(null);

      keyStore.deleteEntry(alias); <i class="conum" data-value="34"></i><b>(34)</b>
    }

    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /</strong> Configure Client (active) side certificates
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     <strong>/
    private void configureClientCerts(
      ReplicatorConfiguration config,
      @NonNull Certificate cert,
      @NonNull TLSIdentity clientIdentity)
      throws CertificateEncodingException {

        // Create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
      }
      // notend::p2p-tlsid-tlsidentity-with-label[]

    /</strong>
     * Copy a cert from a resource bundle
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte buf[] = new byte[1024];
        int n;
        while n = in.read(buf &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}



//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);                 Log.e(TAG, "Success!!");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void runClient(         @NonNull URI uri,         @NonNull String username,         @NonNull char[] password,         @NonNull Database db) throws InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    /</strong>*
     *
     * Start a listener for db that accepts connections using exactly the passed username and password

     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password) <i class="conum" data-value="35"></i><b>(35)</b>
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(true);
      config.setAuthenticator(new ListenerPasswordAuthenticator(
        (validUser, pwd) -&gt; username.equals(validUser) &amp;&amp; Arrays.equals(validPassword, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
      }
    }






// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.support.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;

public class docOnly_ReplicationExamples {
  private static final String TAG = "EXAMPLE ACTIVE PEER";
  private static final String thisDBNAME = "local-database";
  private final Context context;
  // private Database database;
  // private Replicator replicator;

  public docOnly_ReplicationExamples(Context context) { this.context = context; }

  String user = "syncuser";
  String password = "sync9455";
  SecCertificate cert=null;
  String passivePeerEndpoint = "10.1.1.12:8920";
  String passivePeerPort = "8920";
  String passiveDbName = "userdb";
  Database thisDB;
  Replicator thisReplicator;
  ListenerToken replicatorListener;




// PASSIVE PEER STUFF
// Stuff I adapted
//
// BEGIN new stuff 90420temp cache
  private URLEndpointListener createListener() {
  final URLEndpointListenerConfiguration listenerConfig = new URLEndpointListenerConfiguration(db);

  listenerConfig.setDisableTls(false);

  listenerConfig.setEnableDeltaSync(true);

  listenerConfig.setTlsIdentity(null); // Use with anonymous self signed cert

  listenerConfig.setAuthenticator(new ListenerPasswordAuthenticator(this::isWhitelistedUser));

  return new URLEndpointListener(listenerConfig);
}

public void startListener(@NotNull URLEndpointListener listener) {
  executor.submit) -&gt; {       CouchbaseLiteException err = null;       try { listener.start(); }       catch (CouchbaseLiteException e) { err = e; }       onStart(err);   }); }  private void stopListener(@NotNull URLEndpointListener listener) {   listener.stop(); } // END new stuff 90420temp cache   private void ibListenerSimple() {   final URLEndpointListenerConfiguration thisConfig =     new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="36"></i><b>(36)</b>    thisConfig.setAuthenticator(     new ListenerPasswordAuthenticator(       (username, password) -&gt;         username.equals("valid.User") &amp;&amp;         Arrays.equals(password, valid.password.string)       )     ); <i class="conum" data-value="37"></i><b>(37)</b>    final URLEndpointListener thisListener =     new URLEndpointListener(thisConfig); <i class="conum" data-value="38"></i><b>(38)</b>    thisListener.start(); <i class="conum" data-value="39"></i><b>(39)</b>  }  private void ibReplicatorSimple() {   URI uri = null;   try {       uri = new URI("wss://10.0.2.2:4984/db");   } catch (URISyntaxException e) {       e.printStackTrace();   }   Endpoint theListenerEndpoint = new URLEndpoint(uri); <i class="conum" data-value="40"></i><b>(40)</b>    ReplicatorConfiguration thisConfig =     new ReplicatorConfiguration(database, theListenerEndpoint); <i class="conum" data-value="41"></i><b>(41)</b>    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="42"></i><b>(42)</b>    final BasicAuthenticator thisAuth   = new BasicAuthenticator(       "valid.user",       "valid.password.string");   thisConfig.setAuthenticator(thisAuth) <i class="conum" data-value="43"></i><b>(43)</b>    this.replicator = new Replicator(config); <i class="conum" data-value="44"></i><b>(44)</b>   this.replicator.start(); <i class="conum" data-value="45"></i><b>(45)</b>  }   private void ibPassListener() { // EXAMPLE 1     // Initialize the listener config     final URLEndpointListenerConfiguration thisConfig        = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="46"></i><b>(46)</b>      thisConfig.setPort(55990); <i class="conum" data-value="47"></i><b>(47)</b>      thisConfig.setNetworkInterface("10.1.1.10"); <i class="conum" data-value="48"></i><b>(48)</b>      thisConfig.setEnableDeltaSync(false); <i class="conum" data-value="49"></i><b>(49)</b>      // Configure server security     thisConfig.setDisableTls(false); <i class="conum" data-value="50"></i><b>(50)</b>      // Use an Anonymous Self-Signed Cert     thisConfig.setTlsIdentity(null); <i class="conum" data-value="51"></i><b>(51)</b>       // Configure Client Security using an Authenticator     // For example, Basic Authentication <i class="conum" data-value="52"></i><b>(52)</b>     thisConfig.setAuthenticator(new ListenerPasswordAuthenticator(       (validUser, validPassword) -&gt;         username.equals(validUser) &amp;&amp;         Arrays.equals(password, validPassword);

    // Initialize the listener
    final URLEndpointListener thisListener
      = new URLEndpointListener(thisConfig); <i class="conum" data-value="53"></i><b>(53)</b>

    // Start the listener
    thisListener.start(); <i class="conum" data-value="54"></i><b>(54)</b>

}

private void ibListenerGetNetworkInterfaces() {
  final URLEndpointListenerConfiguration thisConfig =
    URLEndpointListenerConfiguration(database: self.oDB)
  final URLEndpointListener thisListener
    = new URLEndpointListener(thisConfig);
  thisListener.start()
  Log.i(TAG, "URLS are " + thisListener.getUrls());

}

private void ibListenerLocalDb() {
// . . . preceding application logic . . .
CouchbaseLite.init(context); <i class="conum" data-value="55"></i><b>(55)</b>
Database thisDB = new Database("passivepeerdb");

}

private void ibListenerConfigTlsDisable() {
thisConfig.setDisableTls(true); <i class="conum" data-value="56"></i><b>(56)</b>

}

private void ibListenerConfigTlsIdFull() {
  // Use CA Cert
  // Import a key pair into secure storage
  // Create a TLSIdentity from the imported key-pair
  InputStream thisKeyPair = new FileInputStream();

  thisKeyPair.getClass().getResourceAsStream("serverkeypair.p12"); <i class="conum" data-value="57"></i><b>(57)</b>

  TLSIdentity thisIdentity = new TLSIdentity.importIdentity(
    EXTERNAL_KEY_STORE_TYPE,  // KeyStore type, eg: "PKCS12"
    thisKeyPair,              // An InputStream from the keystore
    password,                 // The keystore password
    EXTERNAL_KEY_ALIAS,       // The alias to be used (in external keystore)
    null,                     // The key password
    "test-alias"              // The alias for the imported key
    );


  // Use a self-signed certificate
  // Create a TLSIdentity for the server using convenience API.
  // System generates self-signed cert
  // Work-in-progress. Code snippet coming soon.
  private static final Map&lt;String, String&gt; CERT_ATTRIBUTES; <i class="conum" data-value="58"></i><b>(58)</b>
  static {
    final Map&lt;String, String&gt; thisMap = new HashMap&lt;&gt;();
    m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "Couchbase Demo");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
    m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>");
    CERT_ATTRIBUTES = Collections.unmodifiableMap(thisMap);
  }

  // Store the TLS identity in secure storage
  // under the label 'couchbase-docs-cert'
  TLSIdentity thisIdentity =
    new TLSIdentity.createIdentity(
      true,
      CERT_ATTRIBUTES,
      null,
      "couchbase-docs-cert"); <i class="conum" data-value="59"></i><b>(59)</b>


  // Set the TLS Identity
  thisConfig.setTlsIdentity(thisIdentity); <i class="conum" data-value="60"></i><b>(60)</b>

}

private void ibListenerConfigClientAuthRoot() {
  // Configure the client authenticator
  // to validate using ROOT CA
  // thisClientID.certs is a list containing a client cert to accept
  // and any other certs needed to complete a chain between the client cert
  // and a CA
  final TLSIdentity validId =
    TLSIdentity.getIdentity("Our Corporate Id");  // get the identity <i class="conum" data-value="61"></i><b>(61)</b>

  if (validId == null) { throw new IllegalStateException("Cannot find corporate id"); }

  thisConfig.setTlsIdentity(validId);

  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(validId.getCerts())); <i class="conum" data-value="62"></i><b>(62)</b> <i class="conum" data-value="63"></i><b>(63)</b>
    // accept only clients signed by the corp cert

  final URLEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

}

private void ibListenerConfigClientAuthLambda() {
// Configure authentication using application logic
  final TLSIdentity thisCorpId = TLSIdentity.getIdentity("OurCorp"); <i class="conum" data-value="64"></i><b>(64)</b>
  if (thisCorpId == null) {
    throw new IllegalStateException("Cannot find corporate id"); }
  thisConfig.setTlsIdentity(thisCorpId);
  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(
      (thisCorpId.getCerts()) -&gt; {
      // use supplied logic that resolves to boolean
      // true=valid, false=invalid
      }
    )); <i class="conum" data-value="65"></i><b>(65)</b> <i class="conum" data-value="66"></i><b>(66)</b>
  final ULEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

}


private void ibListenerConfigTlsDisable() {

  thisConfig.disableTLS(true);

}


private void ibListenerStatusCheck() {
  int connectionCount =
    thisListener.getStatus().getConnectionCount(); <i class="conum" data-value="67"></i><b>(67)</b>

  int activeConnectionCount =
    thisListener.getStatus().getActiveConnectionCount();  <i class="conum" data-value="68"></i><b>(68)</b>

}

private void ibListenerStop() {

  thisListener.stop();

}

// Listener Callouts
/</strong>

    &lt;.&gt; Initialize the listener instance using the configuration settings.
    &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.



  &lt;.&gt; <code>connectionCount</code> -- the total number of connections served by the listener
  &lt;.&gt; <code>activeConnectionCount</code> -- the number of active (BUSY) connections currently being served by the listener
  //

<strong>/
/</strong> END CALLOUTS TEXT <strong>/


private void ibP2PUrlEndpointListener() {

  public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
  }
}



// ACTIVE PEER STUFF
// Replication code
//

  //@Test
  public void testActPeerSync() throws CouchbaseLiteException, URISyntaxException {
    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://listener.com:8954"))); <i class="conum" data-value="69"></i><b>(69)</b> <i class="conum" data-value="70"></i><b>(70)</b>

    // Set replicator type
    thisConfig.setReplicatorType(
      ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Configure Sync Mode
    thisConfig.setContinuous(false); // default value

    // set auto-purge behavior (here we override default)
    thisConfig.setAutoPurgeEnabled(false); <i class="conum" data-value="71"></i><b>(71)</b>

    // Configure Server Authentication --
    // only accept self-signed certs
    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="72"></i><b>(72)</b>

    // Configure the credentials the
    // client will provide if prompted
    final BasicAuthenticator thisAuth
      = new BasicAuthenticator(
          "Our Username",
          "Our PasswordValue")); <i class="conum" data-value="73"></i><b>(73)</b>

    thisConfig.setAuthenticator(thisAuth)

    /</strong> Optionally set custom conflict resolver call back <strong>/
    thisConfig.setConflictResolver( /</strong> define resolver function <strong>/); <i class="conum" data-value="74"></i><b>(74)</b>

    // Create replicator
    // Consider holding a reference somewhere
    // to prevent the Replicator from being GCed
    final Replicator thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="75"></i><b>(75)</b>

    // Optionally add a change listener <i class="conum" data-value="76"></i><b>(76)</b>
    ListenerToken thisListener =
      new thisReplicator.addChangeListener(change -&gt; {
        final CouchbaseLiteException err =
         change.getStatus().getError();
         if (err != null) {
           Log.i(TAG, "Error code ::  " + err.getCode(), e);
         }
      }); <i class="conum" data-value="77"></i><b>(77)</b>

    // Start replicator
    thisReplicator.start(false); <i class="conum" data-value="78"></i><b>(78)</b>


  public void ibReplicatorConfig() {
  // BEGIN additional snippets
      // Configure Server Security
      // -- only accept CA attested certs
      thisConfig.setAcceptOnlySelfSignedServerCertificate(false); <i class="conum" data-value="79"></i><b>(79)</b>


    // Return the remote pinned cert (the listener's cert)
    byte returnedCert
     = new byte(thisConfig.getPinnedCertificate()); // Get listener cert if pinned

    // ... your other replicator configuration

    // Provide a client certificate to the server for authentication
    final TLSIdentity thisClientId = TLSIdentity.getIdentity("clientId"); <i class="conum" data-value="80"></i><b>(80)</b>

    if (thisClientId == null) { throw new IllegalStateException("Cannot find client id"); }

    thisConfig.setAuthenticator(new ClientCertificateAuthenticator(thisClientId)); <i class="conum" data-value="81"></i><b>(81)</b>

    // ... your other replicator configuration
    final thisReplicator= new Replicator(thisConfig);


    // Use the pinned certificate from the byte array (cert)
    thisConfig.setPinnedServerCertificate(cert.getEncoded()); <i class="conum" data-value="82"></i><b>(82)</b>
}
// END additional snippets








    Log.i(TAG, "The Replicator is currently " +
      thisReplicator.getStatus().getActivityLevel());

    Log.i(TAG, "The Replicator has processed " + t);

    if (thisReplicator.getStatus().getActivityLevel() ==
      Replicator.ActivityLevel.BUSY) {
        Log.i(TAG, "Replication Processing");
        Log.i(TAG, "It has completed " +
          thisReplicator.getStatus().getProgess().getTotal() +
          " changes");
      }

      // Stop replication.
      thisReplicator.stop(); <i class="conum" data-value="83"></i><b>(83)</b>


  CouchbaseLite.init(context);
  Database thisDB = new Database("passivepeerdb");  <i class="conum" data-value="84"></i><b>(84)</b>
  // Initialize the listener config
  final URLEndpointListenerConfiguration thisConfig = new URLEndpointListenerConfiguration(database);
  thisConfig.setPort(55990)           // &lt;.&gt; Optional; defaults to auto
  thisConfig.setDisableTls(false)     // &lt;.&gt; Optional; defaults to false
  thisConfig.setEnableDeltaSync(true) // &lt;.&gt; Optional; Defaults to false

  // Configure the client authenticator (if using basic auth)
  ListenerPasswordAuthenticator auth = new ListenerPasswordAuthenticator { "username", "password"}; <i class="conum" data-value="85"></i><b>(85)</b>
  thisConfig.setAuthenticator(auth); <i class="conum" data-value="86"></i><b>(86)</b>

  // Initialize the listener
  final URLEndpointListener listener = new URLEndpointListener( thisConfig ); <i class="conum" data-value="87"></i><b>(87)</b>

  // Start the listener
  listener.start(); <i class="conum" data-value="88"></i><b>(88)</b>




  Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
        )

  TLSIdentity thisIdentity = new TLSIdentity.createIdentity(true, X509_ATTRIBUTES, null, "test-alias");




  String thisAlias = "alias-to-delete";
  final KeyStore thisKeyStore
    =  KeyStore.getInstance("AndroidKeyStore");
  thisKeyStore.load(null);
  thisKeyStore.deleteEntry(thisAlias);


  // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label

  TLSIdentity thisIdentity =
    new TLSIdentity.getIdentity("couchbase-docs-cert")


  public void ibRplicatorPull() {
    Database database;
    Replicator replicator; <i class="conum" data-value="89"></i><b>(89)</b>

    URI uri = null;
    try {
        uri = new URI("wss://10.0.2.2:4984/db"); <i class="conum" data-value="90"></i><b>(90)</b>
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
    Endpoint endpoint = new URLEndpoint(uri);
    ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
    config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
    this.replicator = new Replicator(config);
    this.replicator.start();
  }

    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))); <i class="conum" data-value="91"></i><b>(91)</b>



  /</strong> C A L L O U T S

  &lt;.&gt; Configure the pinned certificate using data from the byte array <code>cert</code>

  &lt;.&gt; Attempt to get the identity from secure storage
  &lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity


  &lt;.&gt; A replication is an asynchronous operation.
  To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
  &lt;.&gt; The URL scheme for remote database URLs uses <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections over wb sockets.
  In this example the hostname is <code>10.0.2.2</code> because the Android emulator runs in a VM that is generally accessible on <code>10.0.2.2</code> from the host machine (see <a href="https://developer.android.com/studio/run/emulator-networking">Android Emulator networking</a> documentation).
  +
  NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
  Although <code>wss:</code> protocol URLs are not affected, in order to use the <code>ws:</code> protocol, applications must target API 27 or lower, or must configure application network security as described <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted">here</a>.

  <strong>/

}
/</strong>

Snippets demonstrating use of resultsets

<strong>/
package com.example.docsnippet;
        import android.app.Application.</strong>;
        import android.content.Context;
        import android.content.Context.<strong>;
        import java.lang.Object;
        import java.security.Key;
        import java.util.</strong>;
        import com.couchbase.lite.<strong>;
        import com.couchbase.lite.Dictionary;

public class TestQueries {

    // For Documentation

    Datastore ds = new Datastore();

    Database this_Db = ds.getDB();

    String dbName = this_Db.getName();

    HashMap&lt;String, Object&gt; hotels = new HashMap&lt;&gt;();

    Dictionary thisDocsProps;
    String thisDocsId;
    String thisDocsName;
    String thisDocsType;
    String thisDocsCity;



    static {
        init();
    }

    private static void init() {
    }



    public void testQuerySyntaxAll() throws CouchbaseLiteException {

        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

      Query listQuery = QueryBuilder.select(SelectResult.all())
              .from(DataSource.database(this_Db));

        try {
            for (Result result : listQuery.execute().allResults()) {
                             // get the k-v pairs from the 'hotel' key's value into a dictionary
                thisDocsProps = result.getDictionary(0); <i class="conum" data-value="92"></i><b>(92)</b>
                thisDocsId = thisDocsProps.getString("id");
                thisDocsName = thisDocsProps.getString("Name");
                thisDocsType = thisDocsProps.getString("Type");
                thisDocsCity = thisDocsProps.getString("City");

                // Alternatively, access results value dictionary directly
                final Hotel hotel = new Hotel();
                hotel.Id = result.getDictionary(0).getString("id"); <i class="conum" data-value="93"></i><b>(93)</b>
                hotel.Type = result.getDictionary(0).getString("Type");
                hotel.Name = result.getDictionary(0).getString("Name");
                hotel.City = result.getDictionary(0).getString("City");
                hotel.Country= result.getDictionary(0).getString("Country");
                hotel.Description = result.getDictionary(0).getString("Description");
                hotels.put(hotel.Id, hotel);
            }

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }



    // Uses Jackson JSON processor

    ArrayList&lt;Hotel&gt; hotels = new ArrayList&lt;Hotel&gt;();
    HashMap&lt;String, Object&gt; dictFromJSONstring;
    for (Result result : listQuery.execute()) {

      // Get result as JSON string
      String thisJsonString = result.toJSON(); <i class="conum" data-value="94"></i><b>(94)</b>

      // Get Java  Hashmap from JSON string
      HashMap&lt;String, Object&gt; dictFromJSONstring =
              mapper.readValue(thisJsonString, HashMap.class); <i class="conum" data-value="95"></i><b>(95)</b>


      // Use created hashmap
      String hotelId = dictFromJSONstring.get("id").toString();
      String hotelType = dictFromJSONstring.get("type").toString();
      String hotelname = dictFromJSONstring.get("name").toString();


      // Get custom object from JSON string
      Hotel thisHotel =
              mapper.readValue(thisJsonString, Hotel.class); <i class="conum" data-value="96"></i><b>(96)</b>
      hotels.add(thisHotel);



            }
        }


    public void testQuerySyntaxProps() throws CouchbaseLiteException {
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        Query listQuery =
        QueryBuilder.select(SelectResult.expression(Meta.id),
        SelectResult.property("name"),
        SelectResult.property("Name"),
        SelectResult.property("Type"),
        SelectResult.property("City"))
        .from(DataSource.database(this_Db));



        try {
          for (Result result : listQuery.execute().allResults()) {

            // get data direct from result k-v pairs
            final Hotel hotel = new Hotel();
            hotel.Id = result.getString("id");
            hotel.Type = result.getString("Type");
            hotel.Name = result.getString("Name");
            hotel.City = result.getString("City");

            // Store created hotel object in a hashmap of hotels
            hotels.put(hotel.Id, hotel);

            // Get result k-v pairs into a 'dictionary' object
            Map &lt;String, Object&gt; thisDocsProps = result.toMap();
            thisDocsId =
            thisDocsProps.getOrDefault("id",null).toString();
            thisDocsName =
            thisDocsProps.getOrDefault("Name",null).toString();
            thisDocsType =
            thisDocsProps.getOrDefault("Type",null).toString();
            thisDocsCity =
            thisDocsProps.getOrDefault("City",null).toString();

          }
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

    }


    public void testQuerySyntaxCount() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery = QueryBuilder.select(
              SelectResult.expression(Function.count(Expression.string("</strong>"))).as("mycount")) <i class="conum" data-value="97"></i><b>(97)</b>
              .from(DataSource.database(this_Db));



        try {
            for (Result result : listQuery.execute()) {

                // Retrieve count using key 'mycount'
                Integer altDocId = result.getInt("mycount");

                // Alternatively, use the index
                Integer orDocId = result.getInt(0);
            }
            // Or even miss out the for-loop altogether
            Integer resultCount = listQuery.execute().next().getInt("mycount");

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }
    }


    public void testQuerySyntaxId() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id).as("metaID"))
                      .from(DataSource.database(this_Db));




        try {
            for (Result result : listQuery.execute().allResults()) {

                // get the ID form the result's k-v pair array
                thisDocsId = result.getString("metaID"); <i class="conum" data-value="98"></i><b>(98)</b>

                // Get document from DB using retrieved ID
                Document thisDoc = this_Db.getDocument(thisDocsId);

                // Process document as required
                thisDocsName = thisDoc.getString("Name");

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }


    }


    public void testQueryPagination() throws CouchbaseLiteException {


        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        int thisOffset = 0;
        int thisLimit = 20;

        Query listQuery =
                QueryBuilder
                        .select(SelectResult.all())
                        .from(DataSource.database(this_Db))
                        .limit(Expression.intValue(thisLimit),
                                  Expression.intValue(thisOffset)); <i class="conum" data-value="99"></i><b>(99)</b>


    }



    public List&lt;Result&gt; docsonly_QuerySyntaxN1QL (Database argDB)
    {
      // For Documentation -- N1QL Query using parameters
      //  Declared elsewhere: Database argDB

      Database thisDb = argDB;

      Query thisQuery =
      thisDb.createQuery(
        "SELECT META().id AS thisId FROM _ WHERE type = \"hotel\""); // &lt;.

        return thisQuery.execute().allResults();

      }


    public List&lt;Result&gt; docsonly_QuerySyntaxN1QLParams (Database argDB)
    {
      // For Documentation -- N1QL Query using parameters
      //  Declared elsewhere: Database argDB

      Database thisDb = argDB;

      Query thisQuery =
          thisDb.createQuery(
              "SELECT META().id AS thisId FROM _ WHERE type = $type"); // &lt;.

      thisQuery.parameters =
          Parameters.setString("type", "hotel"); <i class="conum" data-value="100"></i><b>(100)</b>

      return thisQuery.execute().allResults();

  }

} // class



public class supportingDatatypes
{
    private static final String TAG = "info";

    public void datatype_dictionary() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)
        Document document = database.getDocument("doc1");

        // Getting a dictionary from the document's properties
        Dictionary dict = document.getDictionary("address");

        // Access a value with a key from the dictionary
        String street = dict.getString("street");

        // Iterate dictionary
        for (String key : dict) {
            dict.getValue(key);
            Log.i("x", "Key %s, = %s", key, dict.getValue(key));
        }

        // Create a mutable copy
        MutableDictionary mutable_Dict = dict.toMutable();
    }

    public void datatype_mutable_dictionary() throws CouchbaseLiteException {

        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        MutableDictionary mutable_dict = new MutableDictionary();
        mutable_dict.setString("street", "1 Main st.");
        mutable_dict.setString("city", "San Francisco");

        // Add the dictionary to a document's properties and save the document
        MutableDocument mutable_doc = new MutableDocument("doc1");
        mutable_doc.setDictionary("address", mutable_dict);
        database.save(mutable_doc);

    }


    public void datatype_array() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        Document document = database.getDocument("doc1");

        // Getting a phones array from the document's properties
        Array array = document.getArray("phones");

        // Get element count
        int count = array.count();

        // Access an array element by index
        if (count &gt;= 0) { String phone = array.getString(1); }

        // Iterate dictionary
        for (int i = 0; i &lt; count; i)
        {
            Log.i("tag", "Item %d = %s", i, array.getString(i));
        }

        // Create a mutable copy
        MutableArray mutable_array = array.toMutable();


    }

    public void datatype_mutable_array() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        MutableArray mutable_array = new MutableArray();
        mutable_array.addString("650-000-0000");
        mutable_array.addString("650-000-0001");

        // Set the array to document's properties and save the document
        MutableDocument mutable_doc = new MutableDocument("doc1");
        mutable_doc.setArray("phones", mutable_array);
        database.save(mutable_doc);
    }

} // end  class supporting_datatypes



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/ZipUtils.java 
package com.couchbase.code_snippets;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class ZipUtils {
    public static void unzip(InputStream in, File destination) throws IOException {
        byte[] buffer = new byte[1024];
        ZipInputStream zis = new ZipInputStream(in);
        ZipEntry ze = zis.getNextEntry();
        while (ze != null) {
            String fileName = ze.getName();
            File newFile = new File(destination, fileName);
            if (ze.isDirectory()) {
                newFile.mkdirs();
            } else {
                new File(newFile.getParent()).mkdirs();
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) &gt; 0) {
                    fos.write(buffer, 0, len);
                }
                fos.close();
            }
            ze = zis.getNextEntry();
        }
        zis.closeEntry();
        zis.close();
        in.close();
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/ZipUtils.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/JSONExamples.java 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.util.Log;

import java.util.Map;

import org.json.JSONException;
import org.json.JSONObject;

import com.couchbase.lite.Array;
import com.couchbase.lite.Blob;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableArray;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.Result;
import com.couchbase.lite.SelectResult;


public class JSONExamples {
    private static final String TAG = "SNIPPETS";

    public static final String JSON
        = "[{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\","
        + "\"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},"
        + "{\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\","
        + "\"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},"
        + "{\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\","
        + "\"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\","
        + "\"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]";

    public void jsonArrayExample(Database db) throws CouchbaseLiteException {
        // github tag=tojson-array
        final MutableArray mArray = new MutableArray(JSON); // &lt;.&gt;

        for (int i = 0; i &lt; mArray.count(); i) { <i class="conum" data-value="101"></i><b>(101)</b>
          final Dictionary dict = mArray.getDictionary(i);
          Log.i(TAG, dict.getString("name"));
          db.save(new MutableDocument(dict.getString("id"), dict.toMap()));
        }

        final Array features = db.getDocument("1002").getArray("features"); <i class="conum" data-value="102"></i><b>(102)</b>
        for (Object feature: features.toList()) { Log.i(TAG, feature.toString()); }
        Log.i(TAG, features.toJSON()); <i class="conum" data-value="103"></i><b>(103)</b>
      }

      public void jsonBlobExample(Database db) {
        // github tag=tojson-blob
        final Map&lt;String, ?&gt; thisBlob = db.getDocument("thisdoc-id").toMap();
        if (!Blob.isBlob(thisBlob)) { return; }

        final String blobType = thisBlob.get("content_type").toString();
        final Number blobLength = (Number) thisBlob.get("length");
      }

      public void jsonDictionaryExample(Database db) {
        // github tag=tojson-dictionary
        final MutableDictionary mDict = new MutableDictionary(JSON); <i class="conum" data-value="104"></i><b>(104)</b>
        Log.i(TAG, mDict.toString());

        Log.i(TAG, "Details for: " + mDict.getString("name"));
        for (String key: mDict.getKeys()) {
          Log.i(TAG, key + " =&gt; " + mDict.getValue(key));
        }
    }

    public void jsonDocumentExample(Database srcDb, Database dstDb) throws CouchbaseLiteException {
        // github tag=tojson-document
        final Query listQuery = QueryBuilder
        .select(SelectResult.expression(Meta.id).as("metaId"))
        .from(DataSource.database(srcDb));

        for (Result row: listQuery.execute()) {
          final String thisId = row.getString("metaId");

          final String json = srcDb.getDocument(thisId).toJSON(); <i class="conum" data-value="105"></i><b>(105)</b>
          Log.i(TAG, "JSON String = " + json);

          final MutableDocument hotelFromJSON = new MutableDocument(thisId, json); <i class="conum" data-value="106"></i><b>(106)</b>

          dstDb.save(hotelFromJSON);

          for (Map.Entry entry: dstDb.getDocument(thisId).toMap().entrySet()) {
            Log.i(TAG, entry.getKey() + " =&gt; " + entry.getValue());
          } <i class="conum" data-value="107"></i><b>(107)</b>
        }
      }


    public void jsonQueryExample(Query query) throws CouchbaseLiteException, JSONException {
        for (Result row: query.execute()) {

            // get the result into a JSON String
            final String jsonString = row.toJSON();

            final JSONObject thisJsonObj = new JSONObject(jsonString);

            // Use Json Object to populate Native object
            // Use Codable class to unpack JSON data to native object
            final Hotel thisHotel = new Hotel(
                "this hotel",
                "Ghana, West Africa",
                thisJsonObj.getString("city"),
                thisJsonObj.getString("name"),
                thisJsonObj.getString("type"),
                thisJsonObj.getString("id"));
        }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/JSONExamples.java </code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="openblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Add hotel name (string)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Add average room rate (float)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Add document type (string)<br>
Couchbase recommend using a <code>type</code> attribute to define each logical document type.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Add address (dictionary)</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Add phone numbers (array)</td>
</tr>
</table>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Save the new document to database</p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset6_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset6_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset6_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">

// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.*
import com.couchbase.lite.internal.utils.PlatformUtils
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.io.InputStream
import java.net.URI
import java.net.URISyntaxException


private const val TAG = "REPLICATION"

@Throws(IOException::class)
fun InputStream.toByteArray(): ByteArray {
    val buffer = ByteArray(1024)
    val output = ByteArrayOutputStream()

    var n: Int
    while (-1 &lt; this.read(buffer).also { n = it }) {
        output.write(buffer, 0, n)
    }

    return output.toByteArray()
}

//
//        &lt;.&gt; The conflict handler code is provided as a lambda.
//
//        &lt;.&gt; If the handler cannot resolve a conflict, it can return false.
//        In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.
//
//        &lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.
//
//        &lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).
//
//        &lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method


// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
@Suppress("unused")
object LocalWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.localDocument
}

// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
@Suppress("unused")
object RemoteWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.remoteDocument
}

// Using replConfig.setConflictResolver(new MergeConflictResolver());
@Suppress("unused")
object MergeConflictResolver : ConflictResolver {
    override fun resolve(conflict: Conflict): Document {
        val localDoc = conflict.localDocument?.toMap()
        val remoteDoc = conflict.remoteDocument?.toMap()

        val merge: MutableMap&lt;String, Any&gt;?
        if (localDoc == null) {
            merge = remoteDoc
        } else {
            merge = localDoc
            if (remoteDoc != null) {
                merge.putAll(remoteDoc)
            }
        }

        return if (merge == null) {
            MutableDocument(conflict.documentId)
        } else {
            MutableDocument(conflict.documentId, merge)
        }
    }

    @Suppress("unused")
    class ReplicationExamples(private val database: Database) {
        private var replicator: Replicator? = null

        @Throws(URISyntaxException::class)
        fun testReplicationBasicAuthentication() {

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = BasicAuthenticator("username", "password".toCharArray())
                )
            )
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationSessionAuthentication() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447")
                )
            )
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationStatus() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            repl.addChangeListener { change -&gt;
                if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                    Log.i(TAG, "Replication stopped")
                }
            }

            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testHandlingNetworkErrors() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            repl.addChangeListener { change -&gt;
                change.status.error?.let {
                    Log.w(TAG, "Error code: ${it.code}")
                }
            }
            repl.start()
            replicator = repl

            repl.stop()
        }

        @Throws(URISyntaxException::class)
        fun testReplicatorDocumentEvent() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            val token = repl.addDocumentReplicationListener { replication -&gt;
                Log.i(TAG, "Replication type: ${if (replication.isPush) "push" else "pull"}")

                for (document in replication.documents) {
                    document.let { doc -&gt;
                        Log.i(TAG, "Doc ID: ${document.id}")
                        doc.error?.let {
                            // There was an error
                            Log.e(TAG, "Error replicating document: ", it)
                            return@addDocumentReplicationListener
                        }
                        if (doc.flags.contains(DocumentFlag.DELETED)) {
                            Log.i(TAG, "Successfully replicated a deleted document")
                        }
                    }
                }
            }

            repl.start()
            replicator = repl

            repl.removeChangeListener(token)
        }

        @Throws(URISyntaxException::class)
        fun testReplicationCustomHeader() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value")
                )
            )
            replicator = repl
        }

        // <mark># Certificate Pinning
        @Throws(URISyntaxException::class, IOException::class)
        fun testCertificatePinning() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value"),
                    pinnedServerCertificate = PlatformUtils.getAsset("cert.cer")?.toByteArray()
                )
            )
            replicator = repl
        }

        // </mark># Reset replicator checkpoint
        @Throws(URISyntaxException::class)
        fun testReplicationResetCheckpoint() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            val resetCheckpointRequired_Example = false
            repl.start(resetCheckpointRequired_Example) <i class="conum" data-value="1"></i><b>(1)</b>

            // ... at some later time

            repl.stop()

        }

        @Throws(URISyntaxException::class)
        fun testReplicationPushFilter() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { _, flags -&gt; flags.contains(DocumentFlag.DELETED) } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationPullFilter() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { document, _ -&gt; "draft" == document.getString("type") } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testCustomRetryConfig() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    //  other config params as required . .
                    heartbeat = 150, <i class="conum" data-value="1"></i><b>(1)</b>
                    maxAttempts = 20,
                    maxAttemptWaitTime = 600
                )
            )

            repl.start()
            replicator = repl
        }

        @Throws(CouchbaseLiteException::class)
        fun testDatabaseReplica() {
            val config = DatabaseConfiguration()
            val database1 = Database("mydb", config)
            val database2 = Database("db2", config)

            /* EE feature: code below might throw a compilation error
               if it's compiled against CBL Android Community. <strong>/
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database1,
                    target = DatabaseEndpoint(database2),
                    type = ReplicatorType.PULL
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
        }

        @Throws(URISyntaxException::class)
        fun testReplicationWithCustomConflictResolver() {
            val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
            val config = ReplicatorConfiguration(database, target)
            config.conflictResolver = LocalWinsResolver
            val replication = Replicator(config)
            replication.start()
        }

        @Throws(CouchbaseLiteException::class)
        fun testSaveWithCustomConflictResolver() {
            val mutableDocument = database.getDocument("xyz")?.toMutable() ?: return
            mutableDocument.setString("name", "apples")
            database.save(mutableDocument) { newDoc, curDoc -&gt;  <i class="conum" data-value="2"></i><b>(2)</b>
                if (curDoc == null) {
                    return@save false
                } <i class="conum" data-value="3"></i><b>(3)</b>
                val dataMap: MutableMap&lt;String, Any&gt; = curDoc.toMap()
                dataMap.putAll(newDoc.toMap()) <i class="conum" data-value="4"></i><b>(4)</b>
                newDoc.setData(dataMap)
                true <i class="conum" data-value="5"></i><b>(5)</b>
            } <i class="conum" data-value="6"></i><b>(6)</b>
        }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import android.widget.Toast
import com.couchbase.lite.</strong>
import com.couchbase.lite.internal.utils.PlatformUtils
import org.junit.Test
import java.io.File
import java.io.IOException
import java.net.URI
import java.net.URISyntaxException
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.*


private const val TAG = "BASIC"

class LogTestLogger(private val level: LogLevel) : Logger {
    override fun getLevel() = level

    override fun log(level: LogLevel, domain: LogDomain, message: String) {
        // this method will never be called if param level &lt; this.level
        // handle the message, for example piping it to a third party framework
    }
}

@Suppress("unused")
class BasicExamples(private val context: Context) {
    private val database: Database

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        // Get the database (and create it if it doesnt exist).
        database = Database(
          "getting-started",
          DatabaseConfigurationFactory.create(context.filesDir.absolutePath)
          )
    }

    @Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {

        // !!! Note the code moved from here to the init { } above.
        // Create a new document (i.e. a record) in the database.
        var mutableDoc = MutableDocument().setFloat("version", 2.0f).setString("type", "SDK")

        // Save it to the database.
        database.save(mutableDoc)

        // Update a document.
        mutableDoc = database.getDocument(mutableDoc.id)!!.toMutable().setString("language", "Java")
        database.save(mutableDoc)

        val document = database.getDocument(mutableDoc.id)!!
        // Log the document ID (generated by the database) and properties
        Log.i(TAG, "Document ID :: ${document.id}")
        Log.i(TAG, "Learning ${document.getString("language")}")

        // Create a query to fetch documents of type SDK.
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))
            .execute()
        Log.i(TAG, "Number of rows :: ${rs.allResults().size}")

        // Create a replicator to push and pull changes to and from the cloud.
        // Be sure to hold a reference somewhere to prevent the Replicator from being GCed
        val replicator =
          Replicator(
            ReplicatorConfigurationFactory.create(
              database = database,
              target = URLEndpoint(URI("ws://localhost:4984/getting-started-db")),
              type = ReplicatorType.PUSH_AND_PULL,
              authenticator = BasicAuthenticator("sync-gateway", "password".toCharArray())
              )
          )


        // Listen to replicator change events.
        replicator.addChangeListener { change -&gt;
            val err = change.status.error
            if (err != null) Log.i(TAG, "Error code ::  ${err.code}")
        }

        // Start replication.
        replicator.start()

        database.delete()
    }

    @Throws(CouchbaseLiteException::class, IOException::class)
    fun test1xAttachments() {
        // if db exist, delete it
        deleteDB("android-sqlite", context.filesDir)
        ZipUtils.unzip(
            PlatformUtils.getAsset("replacedb/android140-sqlite.cblite2.zip"),
            context.filesDir
        )

        val db = Database("android-sqlite")
        try {
            // For Validation
            Arrays.equals(
                "attach1".toByteArray(),
                db.getDocument("doc1")?.getDictionary("_attachments")?.getBlob("attach1")?.content
            )
        } finally {
            // close db
            db.close()
            // if db exist, delete it
            deleteDB("android-sqlite", context.filesDir)
        }
        val document = MutableDocument()

        val content = document.getDictionary("_attachments")?.getBlob("avatar")?.content
    }

    // <mark># Initializer
    fun testInitializer() {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)
    }

    // </mark># New Database
    @Throws(CouchbaseLiteException::class)
    fun testNewDatabase() {
        val database = Database(
            "my-db",
            DatabaseConfigurationFactory.create(
                context.filesDir.absolutePath
            )
        ) <i class="conum" data-value="7"></i><b>(7)</b>
        database.close()


        database.delete()
    }

    // <mark># Database Encryption
    @Throws(CouchbaseLiteException::class)
    fun testDatabaseEncryption() {
        val db = Database(
            "my-db",
            DatabaseConfigurationFactory.create(
                encryptionKey = EncryptionKey("PASSWORD")
            )
        )

    }

    // </mark># Logging
    // !!! OBSOLETE in 3.0
    fun testLogging() {
    }

    fun testEnableCustomLogging() {
        // this custom logger will not log an event with a log level &lt; WARNING
        Database.log.custom = LogTestLogger(LogLevel.WARNING) <i class="conum" data-value="8"></i><b>(8)</b>
    }

    // <mark># Console logging
    @Throws(CouchbaseLiteException::class)
    fun testConsoleLogging() {
        Database.log.console.domains = LogDomain.ALL_DOMAINS <i class="conum" data-value="9"></i><b>(9)</b>
        Database.log.console.level = LogLevel.VERBOSE <i class="conum" data-value="10"></i><b>(10)</b>

        Database.log.console.domains = EnumSet.of(LogDomain.DATABASE) <i class="conum" data-value="11"></i><b>(11)</b>
    }

    // </mark># File logging
    @Throws(CouchbaseLiteException::class)
    fun testFileLogging() {
        Database.log.file.let {
          it.config = LogFileConfigurationFactory.create(
            context.cacheDir.absolutePath, <i class="conum" data-value="12"></i><b>(12)</b>
            maxSize = 10240, <i class="conum" data-value="13"></i><b>(13)</b>
            maxRotateCount = 5, <i class="conum" data-value="14"></i><b>(14)</b>
            usePlainText = false
            ) <i class="conum" data-value="15"></i><b>(15)</b>
            it.level = LogLevel.INFO <i class="conum" data-value="16"></i><b>(16)</b>

          }
    }

    fun writeConsoleLog() {
        Database.log.console.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    fun writeCustomLog() {
        Database.log.custom?.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    fun writeFileLog() {
        Database.log.file.log(
            LogLevel.WARNING,
            LogDomain.REPLICATOR, "Any old log message"
        )
    }

    /* The <code>tag::replication[]</code> example is inlined in java.adoc <strong>/
    fun testTroubleshooting() {
        Database.log.console.let {
            it.level = LogLevel.VERBOSE
            it.domains = LogDomain.ALL_DOMAINS
        }
    }

    // <mark># Loading a pre-built database
    @Throws(IOException::class)
    fun testPreBuiltDatabase() {
        // Note: Getting the path to a database is platform-specific.
        // For Android you need to extract the database from your assets
        // to a temporary directory and then copy it, using Database.copy()
        if (Database.exists("travel-sample", context.filesDir)) {
            return
        }
        ZipUtils.unzip(PlatformUtils.getAsset("travel-sample.cblite2.zip"), context.filesDir)
        Database.copy(
            File(context.filesDir, "travel-sample"),
            "travel-sample",
            DatabaseConfiguration()
        )
    }

    // helper methods
    // if db exist, delete it
    fun deleteDB(name: String, dir: File) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            Database.delete(name, dir)
        }

        // </mark># Initializers
        fun testInitializers() {
            val doc = MutableDocument()
            doc.let {
                it.setString("type", "task")
                it.setString("owner", "todo")
                it.setDate("createdAt", Date())
            }
            database.save(doc)
        }
    }

    // <mark># Mutability
    fun testMutability() {
        database.save(MutableDocument("xyz"))

        database.getDocument("xyz")?.toMutable()?.let {
            it.setString("name", "apples")
            database.save(it)
        }
    }

    // </mark># Typed Accessors
    fun testTypedAccessors() {
        val doc = MutableDocument()

        doc.setValue("createdAt", Date())
        val date = doc.getDate("createdAt")
    }

    // <mark># Batch operations
    fun testBatchOperations() {
        database.inBatch(UnitOfWork {
            for (i in 0..9) {
                val doc = MutableDocument()
                doc.let {
                    it.setValue("type", "user")
                    it.setValue("name", "user $i")
                    it.setBoolean("admin", false)
                }
                Log.i(TAG, "saved user document: ${doc.getString("name")}")
            }
        })
    }


    // toJSON
    fun testToJsonOperations(argDb: Database) {
        val db = argDb

    }


    // </mark># Document Expiration
    @Throws(CouchbaseLiteException::class)
    fun documentExpiration() {
        // Purge the document one day from now
        database.setDocumentExpiration(
            "doc123",
            Date(Instant.now().plus(1, ChronoUnit.DAYS).toEpochMilli())
        )

        // Reset expiration
        database.setDocumentExpiration("doc1", null)

        // Query documents that will be expired in less than five minutes
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.longValue(Instant.now().plus(5, ChronoUnit.MINUTES).toEpochMilli())
                )
            )
    }

    @Throws(CouchbaseLiteException::class)
    fun testDocumentChangeListener() {
        database.addDocumentChangeListener("user.john") { change -&gt;
            database.getDocument(change.documentID)?.let {
                Toast.makeText(
                    context,
                    "Status: ${it.getString("verified_account")}",
                    Toast.LENGTH_SHORT
                ).show()
            }
        }
    }

    // <mark># Blobs
    fun testBlobs() {
        val mDoc = MutableDocument()

        PlatformUtils.getAsset("avatar.jpg")?.use { <i class="conum" data-value="17"></i><b>(17)</b>
            mDoc.setBlob("avatar", Blob("image/jpeg", it)) <i class="conum" data-value="18"></i><b>(18)</b> <i class="conum" data-value="19"></i><b>(19)</b>
            database.save(mDoc)
        }

        val doc = database.getDocument(mDoc.id)
        val bytes = doc?.getBlob("avatar")?.content
    }
}


class supportingDatatypes
{

    private val database  = Database("mydb")

    fun datatype_dictionary() {

        // NOTE: No error handling, for brevity (see getting started)
        val document = database!!.getDocument("doc1")

        // Getting a dictionary from the document's properties
        val dict = document?.getDictionary("address")

        // Access a value with a key from the dictionary
        val street = dict?.getString("street")

        // Iterate dictionary
        for (key in dict!!.keys) {
            println("Key ${key} = ${dict.getValue(key)}")
        }

    // Create a mutable copy
    val mutable_Dict = dict.toMutable()
}

    fun datatype_mutable_dictionary() {

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        val mutable_dict = MutableDictionary()
        mutable_dict.setString("street", "1 Main st.")
        mutable_dict.setString("city", "San Francisco")

        // Add the dictionary to a document's properties and save the document
        val mutable_doc = MutableDocument("doc1")
        mutable_doc.setDictionary("address", mutable_dict)
        database!!.save(mutable_doc)

}


    fun datatype_array() {

        // NOTE: No error handling, for brevity (see getting started)

        val document = database?.getDocument("doc1")

        // Getting a phones array from the document's properties
        val array = document?.getArray("phones")

        // Get element count
        val count = array?.count()

        // Access an array element by index
        val phone = array?.getString(1)

        // Iterate array
        for ( (index, item) in array!!) {
            println("Row  ${index} = ${item}")
        }

        // Create a mutable copy
        val mutable_array = array.toMutable()
    }

    fun datatype_mutable_array() {

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        val mutable_array = MutableArray()
        mutable_array.addString("650-000-0000")
        mutable_array.addString("650-000-0001")

        // Set the array to document's properties and save the document
        val mutable_doc = MutableDocument("doc1")
        mutable_doc.setArray("phones", mutable_array)
        database?.save(mutable_doc)
    }

} // end  class supporting_datatypes



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.Dictionary
import com.couchbase.lite.Expression
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.MutableDictionary
import com.couchbase.lite.PredictionFunction
import com.couchbase.lite.PredictiveIndex
import com.couchbase.lite.PredictiveModel
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.SelectResult
import com.couchbase.lite.ValueIndex
import com.couchbase.lite.ValueIndexItem


private const val TAG = "PREDICT"
// tensorFlowModel is a fake implementation

object TensorFlowModel {
    fun predictImage(data: ByteArray?) = mapOf&lt;String, Any?&gt;()
}

object ImageClassifierModel : PredictiveModel {
    const val name = "ImageClassifier"

    override fun predict(input: Dictionary): Dictionary? {
        val blob: Blob = input.getBlob("photo") ?: return null

        // this would be the implementation of the ml model you have chosen
        return MutableDictionary(TensorFlowModel.predictImage(blob.content)) <i class="conum" data-value="1"></i><b>(1)</b>
    }
}


@Suppress("unused")
class PredictiveQueryExamples {
    @Throws(CouchbaseLiteException::class)
    fun testPredictiveModel() {
        val database = Database("mydb")

        Database.prediction.registerModel("ImageClassifier", ImageClassifierModel)

        val index: ValueIndex = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")))
        database.createIndex("value-index-image-classifier", index)

        Database.prediction.unregisterModel("ImageClassifier")
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveIndex() {
        val database = Database("mydb")

        val inputMap: MutableMap&lt;String, Any&gt; = mutableMapOf()
        inputMap["numbers"] = Expression.property("photo")
        val input: Expression = Expression.map(inputMap)
        val index: PredictiveIndex = IndexBuilder.predictiveIndex("ImageClassifier", input, null)
        database.createIndex("predictive-index-image-classifier", index)
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveQuery() {
        val database = Database("mydb")

        val prediction: PredictionFunction = Function.prediction(
            ImageClassifierModel.name,
            Expression.map(mutableMapOf("photo" to Expression.property("photo")) as Map&lt;String, Any&gt;?) <i class="conum" data-value="1"></i><b>(1)</b>
        )

        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                prediction.property("label").equalTo(Expression.string("car"))
                .and(prediction.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))
                    )
            )
            .execute()

        Log.d(TAG, "Number of rows: ${rs.allResults().size}")
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/FlowExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import androidx.lifecycle.LiveData
import androidx.lifecycle.asLiveData
import com.couchbase.lite.</strong>
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.map


class FlowExamples(argDb: Database,
                   argRepl: Replicator,
                   argQuery: Query,
                   argDocOwner: String) {

    val replState: LiveData&lt;ReplicatorActivityLevel&gt; = argRepl.replicatorChangesFlow()
        .map { it.status.activityLevel }
        .asLiveData()

    val dbChanges: LiveData&lt;MutableList&lt;String&gt;&gt; = argDb.databaseChangeFlow()
        .map { it.documentIDs }
        .asLiveData()

    val docChanges: LiveData&lt;DocumentChange?&gt; = argDb.documentChangeFlow("1001")
        .map {
            it.takeUnless {
                it.database.getDocument(it.documentID)?.getString("owner").equals(argDocOwner)
            }
        }
        .asLiveData()

    var liveQuery: LiveData&lt;List&lt;Any&gt;?&gt;? = null

    @ExperimentalCoroutinesApi
    fun watchQuery(query: Query): LiveData&lt;List&lt;Any&gt;?&gt; {
        val queryFlow = query.queryChangeFlow()
            .map {
                val err = it.error
                if (err != null) {
                    throw err
                }
                it.results?.allResults()?.flatMap { it.toList() }
            }
            .asLiveData()
        liveQuery = queryFlow
        return queryFlow
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/FlowExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorStatus


private const val TAG = "PENDING"

@Suppress("unused")
class PendingDocsExample(private var replicator: Replicator) {
    //
    //
    private fun onStatusChanged(pendingDocs: Set&lt;String&gt;, status: ReplicatorStatus) {
        // ... sample onStatusChanged function
        //
        Log.i(TAG, "Replicator activity level is ${status.activityLevel}")

        // iterate and report-on previously
        // retrieved pending docids 'list'
        val itr = pendingDocs.iterator()
        while (itr.hasNext()) {
            val docId = itr.next()

            if (!replicator.isDocumentPending(docId)) { <i class="conum" data-value="20"></i><b>(20)</b>
                continue
            }

            Log.i(TAG, "Doc ID $docId has been pushed")
        }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Endpoint
import com.couchbase.lite.KeyStoreUtils
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.net.URI
import java.net.URISyntaxException
import java.security.KeyStore
import java.security.cert.Certificate

private const val TAG = "P2P"


@Suppress("unused")
class IBExamples(private val context: Context, private val caCert: Certificate) {
    private val database: Database
    private var thisReplicator: Replicator? = null
    private var thisListener: URLEndpointListener? = null

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        database = Database("p2p_demo")

        /* do some stuff here <strong>/
    }

    // PASSIVE PEER STUFF
    fun ibListenerSimple() {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database,
                authenticator
                = ListenerPasswordAuthenticator { user, pwd -&gt; (user == "daniel") &amp;&amp; (String(pwd) == "123") })
        ) <i class="conum" data-value="21"></i><b>(21)</b>
        listener.start() <i class="conum" data-value="22"></i><b>(22)</b>
        thisListener = listener

    }

    fun ibReplicatorSimple() {
        val theListenerEndpoint: Endpoint = URLEndpoint(URI("wss://10.0.2.2:4984/db")) <i class="conum" data-value="23"></i><b>(23)</b>
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,
                target = theListenerEndpoint,
                authenticator = BasicAuthenticator("valid.user", "valid.password.string".toCharArray()), <i class="conum" data-value="24"></i><b>(24)</b>
                acceptOnlySelfSignedServerCertificate = true
            )
        )
        repl.start() <i class="conum" data-value="25"></i><b>(25)</b>
        thisReplicator = repl
    }

    fun ibPassListener(validUser: String, validPassword: CharArray) {
        // EXAMPLE 1
        // Initialize the listener
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database, <i class="conum" data-value="26"></i><b>(26)</b>
                port = 55990, <i class="conum" data-value="27"></i><b>(27)</b>
                networkInterface = "10.1.1.10", <i class="conum" data-value="28"></i><b>(28)</b>

                enableDeltaSync = false, <i class="conum" data-value="29"></i><b>(29)</b>

                // Configure server security
                disableTls = false, <i class="conum" data-value="30"></i><b>(30)</b>

                // Use an Anonymous Self-Signed Cert
                identity = null, <i class="conum" data-value="31"></i><b>(31)</b>

                // Configure Client Security using an Authenticator
                // For example, Basic Authentication <i class="conum" data-value="32"></i><b>(32)</b>
                authenticator = ListenerPasswordAuthenticator { username, paassword -&gt;
                    (username === validUser) &amp;&amp; (paassword === validPassword)
                }
            ))

        // Start the listener
        listener.start() <i class="conum" data-value="33"></i><b>(33)</b>
        thisListener = listener

    }

    fun ibListenerGetNetworkInterfaces() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        listener.start()
        Log.i(TAG, "URLS are ${listener.urls}")
        thisListener = listener
    }

    fun ibListenerLocalDb() {
        // . . . preceding application logic . . .
        CouchbaseLite.init(context) <i class="conum" data-value="34"></i><b>(34)</b>
        val thisDB = Database("passivepeerdb")
    }

    fun ibListenerConfigTlsDisable() {
        URLEndpointListenerConfigurationFactory.create(database, disableTls = false) <i class="conum" data-value="35"></i><b>(35)</b>
    }


    // !!! USERS SHOULD BE CAUTIONED THAT THIS IS INSECURE
    // Android has much better ways of importing keys
    fun ibListenerConfigTlsIdFull() {
        // Use CA Cert
        // Import a key pair into secure storage
        // Create a TLSIdentity from the imported key-pair

        this.javaClass.getResourceAsStream("serverkeypair.p12")?.use { <i class="conum" data-value="36"></i><b>(36)</b>
            KeyStoreUtils.importEntry(
                "teststore.p12",  // KeyStore type, eg: "PKCS12"
                it,  // An InputStream from the keystore
                "let me in".toCharArray(),  // The keystore password
                "topSekritKey",  // The alias to be used (in external keystore)
                null,  // The key password or null if the key has none
                "test-alias" // The alias for the imported key
            )
        }


        // Set the TLS Identity
        URLEndpointListenerConfigurationFactory.create(
            database,
            identity = TLSIdentity.getIdentity("test-alias")
        ) <i class="conum" data-value="37"></i><b>(37)</b>

    }

    fun ibListenerConfigClientAuthRoot() {
        // Configure the client authenticator
        // to validate using ROOT CA
        // thisClientID.certs is a list containing a client cert to accept
        // and any other certs needed to complete a chain between the client cert
        // and a CA
        val validId = TLSIdentity.getIdentity("Our Corporate Id")
            ?: throw IllegalStateException("Cannot find corporate id")
        // accept only clients signed by the corp cert
        thisListener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                // get the identity <i class="conum" data-value="38"></i><b>(38)</b>
                database = database,
                identity = validId,
                authenticator = ListenerCertificateAuthenticator(validId.certs)
            )
        ) <i class="conum" data-value="39"></i><b>(39)</b>

    }

    fun ibListenerConfigTlsDisable2() {

        URLEndpointListenerConfigurationFactory.create(database = database, disableTls = true)
    }

    fun ibListenerStatusCheck() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        val connectionCount = listener.status?.connectionCount <i class="conum" data-value="40"></i><b>(40)</b>
        val activeConnectionCount = listener.status?.activeConnectionCount <i class="conum" data-value="41"></i><b>(41)</b>
    }

    fun ibListenerStop() {

        thisListener?.stop()

    }

    // ACTIVE PEER STUFF
// Replication code
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testActPeerSync() {
        // Create replicator
        // Consider holding a reference somewhere
        // to prevent the Replicator from being GCed
        val repl = Replicator( <i class="conum" data-value="42"></i><b>(42)</b>

            // initialize the replicator configuration
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(URI("wss://listener.com:8954")), <i class="conum" data-value="43"></i><b>(43)</b>

                // Set replicator type
                type = ReplicatorType.PUSH_AND_PULL,

                // Configure Sync Mode
                continuous = false, // default value


                // set auto-purge behavior
                // (here we override default)
                enableAutoPurge = false, <i class="conum" data-value="44"></i><b>(44)</b>



                // Configure Server Authentication --
                // only accept self-signed certs
                acceptOnlySelfSignedServerCertificate = true, <i class="conum" data-value="45"></i><b>(45)</b>

                // Configure the credentials the
                // client will provide if prompted
                authenticator = BasicAuthenticator("Our Username", "Our PasswordValue".toCharArray()), <i class="conum" data-value="46"></i><b>(46)</b>


                /</strong> Optionally set custom conflict resolver call back <strong>/
                conflictResolver = null <i class="conum" data-value="47"></i><b>(47)</b>
            )
        )


        // Optionally add a change listener <i class="conum" data-value="48"></i><b>(48)</b>
        val thisListener = repl.addChangeListener { change -&gt;
            val err: CouchbaseLiteException? = change.status.error
            if (err != null) {
                Log.i(TAG, "Error code ::  ${err.code}", err)
            }
        }

        // Start replicator
        repl.start(false) <i class="conum" data-value="49"></i><b>(49)</b>
        thisReplicator = repl

    }

    fun ibReplicatorConfig() {
        // BEGIN additional snippets

        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,

                // Configure Server Security
                // -- only accept CA attested certs
                acceptOnlySelfSignedServerCertificate = false, <i class="conum" data-value="50"></i><b>(50)</b>




                // Use the pinned certificate from the byte array (cert)
                pinnedServerCertificate = caCert.encoded, <i class="conum" data-value="51"></i><b>(51)</b>


                // ... other replicator configuration
                // Provide a client certificate to the server for authentication
                authenticator = ClientCertificateAuthenticator(
                    TLSIdentity.getIdentity("clientId")
                        ?: throw IllegalStateException("Cannot find client id")
                ) <i class="conum" data-value="52"></i><b>(52)</b>

                // ... other replicator configuration

            )
        )

        thisReplicator = repl
    }

    fun ibP2pReplicatorStatus() {
        thisReplicator?.status?.let {
            Log.i(TAG, "The Replicator is currently ${it.activityLevel}")
            Log.i(TAG, "The Replicator has processed ${it.progress}")
            Log.i(
                TAG,
                if (it.activityLevel === ReplicatorActivityLevel.BUSY) {
                    "Replication Processing"
                } else {
                    "It has completed ${it.progress.total} changes"
                }
            )
        }
    }

    fun ibP2pReplicatorStop() {
        // Stop replication.
        thisReplicator?.stop() <i class="conum" data-value="53"></i><b>(53)</b>
    }

    fun ibP2pListener() {
        CouchbaseLite.init(context)
        val thisDB = Database("passivepeerdb") <i class="conum" data-value="54"></i><b>(54)</b>


        // Initialize the listener
        val listener = URLEndpointListener( <i class="conum" data-value="55"></i><b>(55)</b>

            // Initialize the listener config
            URLEndpointListenerConfigurationFactory.create(
                database = thisDB,
                port = 55990, /</strong> &lt;.&gt;  Optional; defaults to auto <strong>/
                disableTls = false, /</strong> &lt;.&gt;  Optional; defaults to false <strong>/
                enableDeltaSync = true,  /</strong> &lt;.&gt; Optional; defaults to false <strong>/

                // Configure the client authenticator (if using basic auth)
                authenticator = ListenerPasswordAuthenticator { username, password -&gt;
                    ("username" === username) &amp;&amp; (password === "password".toCharArray())  <i class="conum" data-value="56"></i><b>(56)</b>
                }
            )
        )

        // Start the listener
        listener.start() <i class="conum" data-value="57"></i><b>(57)</b>



//        Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
//                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
//                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
//        );
        val thisIdentity = TLSIdentity.createIdentity(
            true,
            mapOf(
                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
            ),
            null,
            "test-alias"
        )




        val thisAlias = "alias-to-delete"
        val thisKeyStore = KeyStore.getInstance("AndroidKeyStore")
        thisKeyStore.load(null)
        thisKeyStore.deleteEntry(thisAlias)


        // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label
        val thatIdentity = TLSIdentity.getIdentity("couchbase-docs-cert")
    }

    fun ibRplicatorPull() {
        val database = Database("ian")

        val uri = URI("wss://10.0.2.2:4984/db") <i class="conum" data-value="58"></i><b>(58)</b>

        val repl = Replicator( <i class="conum" data-value="59"></i><b>(59)</b>
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(uri),
                type = ReplicatorType.PULL
            )
        )

        repl.start()
        thisReplicator = repl
    }

// initialize the replicator configuration
    val thisConfig = ReplicatorConfigurationFactory.create(
        database = database,
        target = URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))

/</strong> C A L L O U T S

// Listener Callouts


&lt;.&gt; Initialize the listener instance using the configuration settings.
&lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.



&lt;.&gt; <code>connectionCount</code> -- the total number of connections served by the listener
&lt;.&gt; <code>activeConnectionCount</code> -- the number of active (BUSY) connections currently being served by the listener
//



&lt;.&gt; Configure the pinned certificate using data from the byte array <code>cert</code>

&lt;.&gt; Attempt to get the identity from secure storage
&lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity


&lt;.&gt; A replication is an asynchronous operation.
To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
&lt;.&gt; The URL scheme for remote database URLs uses <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections over wb sockets.
In this example the hostname is <code>10.0.2.2</code> because the Android emulator runs in a VM that is generally accessible on <code>10.0.2.2</code> from the host machine (see <a href="https://developer.android.com/studio/run/emulator-networking">Android Emulator networking</a> documentation).
+
NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
Although <code>wss:</code> protocol URLs are not affected, in order to use the <code>ws:</code> protocol, applications must target API 27 or lower, or must configure application network security as described <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted">here</a>.

<strong>/
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.net.URI
import java.security.KeyStore
import java.security.KeyStoreException
import java.security.NoSuchAlgorithmException
import java.security.cert.Certificate
import java.security.cert.CertificateEncodingException
import java.security.cert.CertificateException
import java.util.concurrent.CountDownLatch

private const val TAG = "LISTEN"

@Suppress("unused")
class KtCertAuthListener {
    companion object {
        private val CERT_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "CBL Test",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>",
        )
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)

        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        remoteDb.save(doc)

        val serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server")

        val clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client")
        val uri = startServer(remoteDb, serverIdentity, clientIdentity.certs)
            ?: throw IOException("Failed to start the server")

        Thread {
            startClient(localDb, uri, clientIdentity, serverIdentity.certs[0])
            Log.e(TAG, "Success!!")
            deleteIdentity("server")
            Log.e(TAG, "Alias deleted: server")
            deleteIdentity("client")
            Log.e(TAG, "Alias deleted: client")
        }.start()
    }

    // start a client replicator
    @Throws(CertificateEncodingException::class, InterruptedException::class)
    fun startClient(db: Database, uri: URI, clientIdentity: TLSIdentity, cert: Certificate) {
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = db,
                target = URLEndpoint(uri),
                type = ReplicatorType.PUSH_AND_PULL,
                continuous = false,
                authenticator = ClientCertificateAuthenticator(clientIdentity),
                pinnedServerCertificate = cert.encoded
            )
        )

        val completionLatch = CountDownLatch(1)

        repl.addChangeListener { change -&gt;
            if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    /<strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     *
     *
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Throws(CouchbaseLiteException::class)
    fun startServer(db: Database, serverId: TLSIdentity, certs: List&lt;Certificate?&gt;): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0, // this is the default
                disableTls = false,
                identity = serverId,
                authenticator = ListenerCertificateAuthenticator(certs)
            )
        )
        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
    /</strong>
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    @Throws(
        KeyStoreException::class,
        CertificateException::class,
        NoSuchAlgorithmException::class,
        IOException::class
    )
    fun deleteIdentity(alias: String?) {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        keyStore.deleteEntry(alias) <i class="conum" data-value="60"></i><b>(60)</b>
    }
    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /<strong>
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     *
     *
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    @Throws(CertificateEncodingException::class)
    private fun configureClientCerts(
        config: ReplicatorConfiguration,
        cert: Certificate,
        clientIdentity: TLSIdentity
    ) {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(ClientCertificateAuthenticator(clientIdentity))

        // Configure the pinned certificate passing a byte array.
        config.pinnedServerCertificate = cert.encoded
    }
    // notend::p2p-tlsid-tlsidentity-with-label[]
    /</strong>
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     *
     *
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    @Throws(IOException::class)
    private fun readCertMaterialFromBundle(
        context: Context,
        resId: Int
    ): ByteArray {
        val out = ByteArrayOutputStream()
        val <code>in</code> = context.resources.openRawResource(resId)
        val buf = ByteArray(1024)
        var n: Int
        while (<code>in</code>.read(buf).also { n = it } &gt;= 0) {
            out.write(buf, 0, n)
        }
        return out.toByteArray()
    }
}

@Suppress("unused")
class KtPasswordAuthListener {
    companion object {
        private const val VALID_USER = "Minnie"
        private val VALID_PASSWORD = "let me in!".toCharArray()
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray())
            ?: throw IOException("Failed to start the server")
        Thread {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb)
                Log.e(TAG, "Success!!")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }.start()
    }

    // start a client replicator
    @Throws(InterruptedException::class)
    fun runClient(
        uri: URI,
        username: String,
        password: CharArray,
        db: Database
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.type = ReplicatorType.PUSH_AND_PULL
        config.isContinuous = false
        config.setAuthenticator(BasicAuthenticator(username, password))
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)

        repl.addChangeListener { change -&gt;
            if (change.status
                    .activityLevel == ReplicatorActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    /</strong>*
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     *
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    fun startServer(db: Database, username: String, password: CharArray): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0,// this is the default
                disableTls = true,
                authenticator = ListenerPasswordAuthenticator { usr, pwd -&gt;
                    (usr == username) &amp;&amp; pwd.contentEquals(password)
                })
        )

        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
}





// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Message
import com.couchbase.lite.MessageEndpoint
import com.couchbase.lite.MessageEndpointConnection
import com.couchbase.lite.MessageEndpointDelegate
import com.couchbase.lite.MessageEndpointListener
import com.couchbase.lite.MessageEndpointListenerConfigurationFactory
import com.couchbase.lite.MessagingCloseCompletion
import com.couchbase.lite.MessagingCompletion
import com.couchbase.lite.ProtocolType
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorConnection
import com.couchbase.lite.create


@Suppress("unused")
class BrowserSessionManager : MessageEndpointDelegate {
    private var replicator: Replicator? = null

    @Throws(CouchbaseLiteException::class)
    fun initCouchbase() {
        val database = Database("mydb")

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        val messageEndpoint = MessageEndpoint("UID:123", "active", ProtocolType.MESSAGE_STREAM, this)

        // Create the replicator object.
        val repl = Replicator(ReplicatorConfigurationFactory.create(database = database, target = messageEndpoint))
        // Start the replication.
        repl.start()
        replicator = repl
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    override fun createConnection(endpoint: MessageEndpoint) = ActivePeerConnection()
}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

@Suppress("unused")
class ActivePeerConnection : MessageEndpointConnection {
    private var replicatorConnection: ReplicatorConnection? = null

    fun disconnect() {
        replicatorConnection?.close(null)
        replicatorConnection = null
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete()
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun send(message: Message, completion: MessagingCompletion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null)
    }

    fun receive(message: Message) {
        replicatorConnection?.receive(message)
    }
}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

@Suppress("unused")
class PassivePeerConnection private constructor() : MessageEndpointConnection {
    private var messageEndpointListener: MessageEndpointListener? = null
    private var replicatorConnection: ReplicatorConnection? = null

    @Throws(CouchbaseLiteException::class)
    fun startListener() {
        val database = Database("mydb")
        messageEndpointListener = MessageEndpointListener(
            MessageEndpointListenerConfigurationFactory.create(database, ProtocolType.MESSAGE_STREAM)
        )
    }

    fun stopListener() {
        messageEndpointListener?.closeAll()
    }

    fun accept() {
        val connection = PassivePeerConnection() /</strong> implements MessageEndpointConnection <strong>/
        messageEndpointListener?.accept(connection)
    }

    fun disconnect() {
        replicatorConnection?.close(null)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete()
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    override fun send(message: Message, completion: MessagingCompletion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null)
    }

    fun receive(message: Message) {
        replicatorConnection?.receive(message)
    }

}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.</strong>
import com.couchbase.lite.Function
import com.fasterxml.jackson.databind.ObjectMapper
import org.json.JSONException


private const val TAG = "QUERY"
private const val DATABASE_NAME = "database"

data class Hotel(
    var description: String? = null,
    var country: String? = null,
    var city: String? = null,
    var name: String? = null,
    var type: String? = null,
    var id: String? = null
)

@Suppress("unused")
class QueryExamples(private val database: Database) {

    // </mark># Indexing
    @Throws(CouchbaseLiteException::class)
    fun testIndexing() {
        database.createIndex( "TypeNameIndex",
              ValueIndexConfiguration( "type", "name")
    }

    fun testIndexing_Querybuilder() {
        database.createIndex(
            "TypeNameIndex",
            IndexBuilder.valueIndex(
                ValueIndexItem.property("type"),
                ValueIndexItem.property("name")
            )
        )
    }

    // <mark># SELECT statement
    fun testSelectStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("type")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.expression(Meta.id))
            .execute()

        for (result in rs) {
            Log.i(TAG, "hotel id -&gt;${result.getString("id")}")
            Log.i(TAG, "hotel name -&gt; ${result.getString("name")}")
        }
      }

      // META function
      @Throws(CouchbaseLiteException::class)
      fun testMetaFunction() {
        val rs = QueryBuilder
        .select(SelectResult.expression(Meta.id))
        .from(DataSource.database(database))
        .where(Expression.property("type").equalTo(Expression.string("airport")))
        .orderBy(Ordering.expression(Meta.id))
        .execute()

        for (result in rs) {
          Log.w(TAG, "airport id -&gt;${result.getString("id")}")
          Log.w(TAG, "airport id -&gt; ${result.getString(0)}")
        }
      }

      // </mark># all(<strong>)
    @Throws(CouchbaseLiteException::class)
    fun testSelectAll() {
        val queryAll = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))

        val query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="61"></i><b>(61)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        val token = query.addChangeListener { change -&gt;
            change.results?.let {
                for (result in it) {
                    Log.d(TAG, "results: ${result.keys}")
                    /</strong> Update UI <strong>/
                }
            } <i class="conum" data-value="62"></i><b>(62)</b>
        }


        query.removeChangeListener(token)

        for (result in query.execute()) {
            Log.i(TAG, "hotel -&gt; ${result.getDictionary(DATABASE_NAME)?.toMap()}")
        }
    }


    // <mark>#WHERE statement
    @Throws(CouchbaseLiteException::class)
    fun testWhereStatement() {
        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.intValue(10))
            .execute()
        for (result in rs) {
            result.getDictionary(DATABASE_NAME)?.let {
                Log.i(TAG, "name -&gt; ${it.getString("name")}")
                Log.i(TAG, "type -&gt; ${it.getString("type")}")
            }
        }
    }

    fun testQueryDeletedDocuments() {
        // Query documents that have been deleted
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted)
    }

    // </mark><mark>Collection Operators
    @Throws(CouchbaseLiteException::class)
    fun testCollectionStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(
                        ArrayFunction.contains(
                            Expression.property("public_likes"),
                            Expression.string("Armani Langworth")
                        )
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.getArray("public_likes")?.toList()}")
        }
    }

    // IN operator
    @Throws(CouchbaseLiteException::class)
    fun testInOperator() {
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.string("Armani").<code>in</code>(
                    Expression.property("first"),
                    Expression.property("last"),
                    Expression.property("username")
                )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.toMap()}")
        }
    }

    // Pattern Matching
    @Throws(CouchbaseLiteException::class)
    fun testPatternMatching() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // </mark># Wildcard Match
    @Throws(CouchbaseLiteException::class)
    fun testWildcardMatch() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // Wildcard Character Match
    @Throws(CouchbaseLiteException::class)
    fun testWildCharacterMatch() {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng____r"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // <mark># Regex Match
    @Throws(CouchbaseLiteException::class)
    fun testRegexMatch() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .regex(Expression.string("\\beng.*r\\b"))
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
    }

    // JOIN statement
    @Throws(CouchbaseLiteException::class)
    fun testJoinStatement() {
        val rs = QueryBuilder.select(
            SelectResult.expression(Expression.property("name").from("airline")),
            SelectResult.expression(Expression.property("callsign").from("airline")),
            SelectResult.expression(Expression.property("destinationairport").from("route")),
            SelectResult.expression(Expression.property("stops").from("route")),
            SelectResult.expression(Expression.property("airline").from("route"))
        )
            .from(DataSource.database(database).<code>as</code>("airline"))
            .join(
                Join.join(DataSource.database(database).<code>as</code>("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(
                        Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline"))
                    )
                    .and(
                        Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.toMap()}")
        }
    }


    // </mark># GROUPBY statement
    @Throws(CouchbaseLiteException::class)
    fun testGroupByStatement() {
        val rs = QueryBuilder.select(
            SelectResult.expression(Function.count(Expression.string("</strong>"))),
            SelectResult.property("country"),
            SelectResult.property("tz")
        )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300)))
            )
            .groupBy(
                Expression.property("country"), Expression.property("tz")
            )
            .orderBy(Ordering.expression(Function.count(Expression.string("<strong>"))).descending())
            .execute()

        for (result in rs) {
            result.let {
                Log.i(
                    TAG,
                    "There are ${it.getInt("$1")} airports on the ${
                        it.getString("tz")
                    } timezone located in ${
                        it.getString("country")
                    } and above 300ft"
                )
            }
        }
    }

    // <mark># ORDER BY statement
    @Throws(CouchbaseLiteException::class)
    fun testOrderByStatement() {
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("name").ascending())
            .limit(Expression.intValue(10))
            .execute()

        for (result in rs) {
            Log.i(TAG, "${result.toMap()}")
        }
    }


    // </mark># EXPLAIN statement
    @Throws(CouchbaseLiteException::class)
    fun testExplainStatement() {
        var query: Query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").descending()) <i class="conum" data-value="63"></i><b>(63)</b>
        Log.i(TAG, query.explain()) <i class="conum" data-value="64"></i><b>(64)</b>

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%"))) <i class="conum" data-value="65"></i><b>(65)</b>
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="66"></i><b>(66)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%")))
            )
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Function.lower(
                    Expression.property("type").equalTo(Expression.string("hotel"))
                )
            ) <i class="conum" data-value="67"></i><b>(67)</b>
        Log.i(TAG, query.explain())

        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))) <i class="conum" data-value="68"></i><b>(68)</b>
        Log.i(TAG, query.explain())
    }

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex() {
        val config = FullTextIndexConfiguration("overview").ignoreAccents(false)

        database.createIndex( "overviewFTSIndex", config);
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS() {

        val ftsQuery =
              database.createQuery(
                "SELECT _id, overview FROM _ WHERE MATCH(overviewFTSIndex, 'michigan') ORDER BY RANK(overviewFTSIndex)")

        ftsQuery.execute().allResults().forEach {
          Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}")
        }

    }

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex_Querybuilder() {
        database.createIndex(
            "overviewFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("overview")).ignoreAccents(false)
        )
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS_Querybuilder() {

        val ftsQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id),
                                  SelectResult.expression(overview))
                          .from(DataSource.database(database))
                          .where(FullTextFunction.match("overviewFTSIndex", "michigan"))
                          .execute()

        ftsQuery.execute().allResults().forEach {
          Log.i(TAG, "${result.getString("Meta.id")}: ${result.getString("overview")}")
          }



    }


    fun testQuerySyntaxAll(currentUser: String) {
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(openOrCreateDatabaseForUser(currentUser)))

        val hotels: HashMap&lt;String, Hotel&gt; = HashMap()

        for (result in listQuery.execute().allResults()) {
            // get the k-v pairs from the 'hotel' key's value into a dictionary
            val thisDocsProps = result.getDictionary(0) <i class="conum" data-value="69"></i><b>(69)</b>
            val thisDocsId = thisDocsProps!!.getString("id")
            val thisDocsName = thisDocsProps.getString("name")
            val thisDocsType = thisDocsProps.getString("type")
            val thisDocsCity = thisDocsProps.getString("city")

            // Alternatively, access results value dictionary directly
            val id = result.getDictionary(0)?.getString("id").toString() <i class="conum" data-value="70"></i><b>(70)</b>
            hotels[id] = Hotel(
                id,
                result.getDictionary(0)?.getString("type"),
                result.getDictionary(0)?.getString("name"),
                result.getDictionary(0)?.getString("city"),
                result.getDictionary(0)?.getString("country"),
                result.getDictionary(0)?.getString("description")
            )
        }

    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun testQuerySyntaxJson(currentUser: String, argDb: Database) {
        val db = argDb
        // Example assumes Hotel class object defined elsewhere

        // Build the query
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(db))

        // Uses Jackson JSON processor
        val mapper = ObjectMapper()
        val hotels: ArrayList&lt;Hotel&gt; = ArrayList()

        for (result in listQuery.execute()) {

            // Get result as JSON string
            val json = result.toJSON() <i class="conum" data-value="71"></i><b>(71)</b>

            // Get Hashmap from JSON string
            val dictFromJSONstring = mapper.readValue(json, HashMap::class.java) <i class="conum" data-value="72"></i><b>(72)</b>

            // Use created hashmap
            val hotelId = dictFromJSONstring["id"].toString() //
            val hotelType = dictFromJSONstring["type"].toString()
            val hotelname = dictFromJSONstring["name"].toString()


            // Get custom object from JSON string
            val thisHotel = mapper.readValue(json, Hotel::class.java) <i class="conum" data-value="73"></i><b>(73)</b>
            hotels.add(thisHotel)
        }
    }
/</strong> end func testQuerySyntaxJson <strong>/



    fun testQuerySyntaxProps(currentUser: String) {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
            Log.i(TAG, "Hotel name -&gt; ${result.getString("name")}, in ${result.getString("country")}" )
        }
    }

    fun testQuerySyntaxCount(currentUser: String) {

        val rs = QueryBuilder
            .select(
                SelectResult.expression(Function.count(Expression.string("</strong>"))).as("mycount")) <i class="conum" data-value="74"></i><b>(74)</b>
            .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
            Log.i(TAG, "name -&gt; ${result.getInt("mycount").toString()}")
        }
    }


    fun testQuerySyntaxId(currentUser: String) {
        // tag::query-select-meta

        val rs = QueryBuilder
        .select(
          SelectResult.expression(Meta.id).as("hotelId"))
          .from(DataSource.database(database))


        for (result in rs.execute().allResults()) {
          Log.i(TAG, "hotel id -&gt;${result.getString("hotelId")}")
        }
        // end::query-select-meta
    }


    fun docsOnlyQuerySyntaxN1QL(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      val db = argDb
      val thisQuery = db.createQuery(
            "SELECT META().id AS id FROM _ WHERE type = \"hotel\"") <i class="conum" data-value="75"></i><b>(75)</b>

      return thisQuery.execute().allResults()

  }

  fun docsOnlyQuerySyntaxN1QLParams(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      val db = argDb
      val thisQuery = db.createQuery(
            "SELECT META().id AS id FROM _ WHERE type = \$type") <i class="conum" data-value="76"></i><b>(76)</b>

      thisQuery.parameters = Parameters().setString("type", "hotel") <i class="conum" data-value="77"></i><b>(77)</b>

      return thisQuery.execute().allResults()

  }

  fun testQuerySyntaxPagination(currentUser: String) {
    val limit = 20
    val offset = 0

    val rs = QueryBuilder
      .select(SelectResult.all())
      .from(DataSource.database(database))
      .where(Expression.property("type").equalTo(Expression.string("hotel")))
      .limit(Expression.intValue(limit), Expression.intValue(offset))

  }

    fun openOrCreateDatabaseForUser(argUser: String): Database = Database(argUser) {

    }



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/JSONExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.*
import org.json.JSONException
import org.json.JSONObject


const val JSON = """[{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\",
        \"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},
        {\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\",
        \"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},
        {\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",
        \"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\",
        \"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]"""


class KtJSONExamples {
    private val TAG = "SNIPPETS"

    fun jsonArrayExample(db: Database) {
        // github tag=tojson-array
        val mArray = MutableArray(JSON) <i class="conum" data-value="78"></i><b>(78)</b>
        for (i in 0 until mArray.count()) {
            mArray.getDictionary(i)?.apply {
                Log.i(TAG, getString("name") ?: "unknown")
                db.save(MutableDocument(getString("id"), toMap()))
            } <i class="conum" data-value="79"></i><b>(79)</b>
        }

        db.getDocument("1002")?.getArray("features")?.apply {
            for (feature in toList()) {
                Log.i(TAG, "$feature")
            } <i class="conum" data-value="80"></i><b>(80)</b>
            Log.i(TAG, toJSON())
        } <i class="conum" data-value="81"></i><b>(81)</b>
    }

    fun jsonBlobExample(db: Database) {
        // github tag=tojson-blob
        val thisBlob = db.getDocument("thisdoc-id")!!.toMap()
        if (!Blob.isBlob(thisBlob)) {
          return
        }
        val blobType = thisBlob["content_type"].toString()
        val blobLength = thisBlob["length"] as Number?
    }

    fun jsonDictionaryExample() {
        // github tag=tojson-dictionary
        val mDict = MutableDictionary(JSON) <i class="conum" data-value="82"></i><b>(82)</b>
        Log.i(TAG, "$mDict")
        Log.i(TAG, "Details for: ${mDict.getString("name")}")
        for (key in mDict.keys) {
          Log.i(TAG, key + " =&gt; " + mDict.getValue(key))
        }
      }

      @Throws(CouchbaseLiteException::class)
      fun jsonDocumentExample(srcDb: Database, dstDb: Database) {
        QueryBuilder
        .select(SelectResult.expression(Meta.id).as("metaId"))
        .from(DataSource.database(srcDb))
        .execute()
        .forEach {
          it.getString("metaId")?.let { thisId -&gt;
            srcDb.getDocument(thisId)?.toJSON()?.let { json -&gt; <i class="conum" data-value="83"></i><b>(83)</b>
              Log.i(TAG, "JSON String = $json")
              val hotelFromJSON = MutableDocument(thisId, json) <i class="conum" data-value="84"></i><b>(84)</b>
              dstDb.save(hotelFromJSON)
              dstDb.getDocument(thisId)?.toMap()?.forEach { e -&gt;
                Log.i(TAG, "$e.key =&gt; $e.value")
              } <i class="conum" data-value="85"></i><b>(85)</b>
            }
          }
        }
    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun jsonQueryExample(query: Query) {
        query.execute().forEach {

            // Use a Json Object to populate Native object
            JSONObject(it.toJSON()).apply {
                val (description, country, city, name, type, id) = Hotel(
                    id = getString("id"),
                    type = getString("type"),
                    name = getString("name"),
                    city = getString("city"),
                    country = "Ghana, West Africa",
                    description = "this hotel"
                )
            }
        }
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/JSONExamples.kt 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.Database
import com.couchbase.lite.MutableDictionary

class KtBlobExamples {

    // Example 2: Using Blobs
    fun example2(context: Context, db: Database) {
        val doc = db.getDocument("1000") ?: return

        // Create a blob from an asset
        val blob = Blob("image/png", context.assets.open("couchbaseimage.png"))

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON()

        // Save the blob as part of a document
        db.save(doc.toMutable().setBlob("avatar", blob))

        // Experts only!!!
        db.saveBlob(blob)

        // Retrieve saved blob and get as JSON again
        val blobAsJSONString = db.getDocument("1000")?.getBlob("avatar")?.toJSON() ?: return

        // reconstitute
        val blobAsMap = MutableDictionary().setJSON(blobAsJSONString).toMap()

        // show the contents of the reconstituted blob
        for key, value) in blobAsMap) {             Log.d("BLOB", "Data: $key -&gt; $value")         }          // verify that the reconstitued thing is still blob         if (Blob.isBlob(blobAsMap {
            Log.d("BLOB", blobAsJSONString)
        }
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt </code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset6_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">

// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/PasswordAuthListener.java 
//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorActivityLevel;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorType;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);                 Log.e(TAG, "Success!!");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void runClient(         @NonNull URI uri,         @NonNull String username,         @NonNull char[] password,         @NonNull Database db) throws InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setType(ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }

    /<strong>
     * Snippet 1: create a ListenerPasswordAuthenticator and configure the listener with it
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     * NOTE: This requires the following, in the manifest
     *     &lt;application
     *         ...
     *         android:usesCleartextTraffic="true"
     *         ...
     *     &gt;
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password)
        throws CouchbaseLiteException {
        final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

        config.setPort(0); // this is the default
        config.setDisableTls(true);
        config.setAuthenticator(new ListenerPasswordAuthenticator(
            (user, pwd) -&gt; username.equals(user) &amp;&amp; Arrays.equals(password, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/PasswordAuthListener.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/BlobExamples.java 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.util.Log;

import java.io.IOException;
import java.util.Map;

import com.couchbase.lite.Blob;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.Document;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;


class BlobExamples {

    // Example 2: Using Blobs
    public void example2(final Context context, final Database db) throws IOException, CouchbaseLiteException {
        final Document doc = db.getDocument("1000");
        if (doc == null) { return; }

        // Create a blob from an asset
        final Blob blob = new Blob("image/png", context.getAssets().open("couchbaseimage.png"));

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON();

        // Save the blob as part of a document
        final MutableDocument mDoc = doc.toMutable();
        mDoc.setBlob("avatar", blob);
        db.save(mDoc);

        // Experts only!!!
        db.saveBlob(blob);

        // Retrieve saved blob
        final Document sameDoc = db.getDocument("1000");
        if (sameDoc == null) { return; }

        final Blob sameBlob = sameDoc.getBlob("avatar");
        if (sameBlob == null) { return; }

        // Get as JSON again
        final String blobAsJSONString = sameBlob.toJSON();

        // reconstitute
        final Map&lt;String, Object&gt; blobAsMap = new MutableDictionary().setJSON(blobAsJSONString).toMap();

        // show the contents of the reconstituted blob
        for (Map.Entry&lt;String, Object&gt; entry: blobAsMap.entrySet()) {
            Log.d("BLOB", "Data: " + entry.getKey() + " -&gt; " + entry.getValue());
        }

        // verify that the reconstitued thing is still blob
        if (Blob.isBlob(blobAsMap)) { Log.d("BLOB", blobAsJSONString); }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/BlobExamples.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/MainActivity.java 
package com.couchbase.code_snippets;

import android.os.Bundle;

import androidx.appcompat.app.AppCompatActivity;


public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/MainActivity.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/CertAuthListener.java 

//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorActivityLevel;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorType;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);                 Log.e(TAG, "Success!!");                 deleteIdentity("server");                 Log.e(TAG, "Alias deleted: server");                 deleteIdentity("client");                 Log.e(TAG, "Alias deleted: client");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void startClient(         @NonNull URI uri,         @NonNull Certificate cert,         @NonNull TLSIdentity clientIdentity,         @NonNull Database db) throws CertificateEncodingException, InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setType(ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }

    /</strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
        throws CouchbaseLiteException {
        final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

        config.setPort(0); // this is the default
        config.setDisableTls(false);
        config.setTlsIdentity(serverId);
        config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
    }

    /<strong>
     * Snippet 3: delete an identity from the keystore
     * (NOTE: a keystore doesn't contain TLSIdentities: I'm guessing that this is what you intend)
     * &lt;p&gt;
     * Delete an identity from the key store.
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
        throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

        final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
        keyStore.load(null);

        keyStore.deleteEntry(alias);
    }

    /</strong>
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     * &lt;p&gt;
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    private void configureClientCerts(
        ReplicatorConfiguration config,
        @NonNull Certificate cert,
        @NonNull TLSIdentity clientIdentity)
        throws CertificateEncodingException {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
    }

    /<strong>
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     * &lt;p&gt;
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte[] buf = new byte[1024];
        int n;
        while n = in.read(buf &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/CertAuthListener.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java 
//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import androidx.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;
import com.example.docsnippet.Datastore;
import com.example.docsnippet.Hotel;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class docOnly_Examples {
  private static final String TAG = "EXAMPLE";

  private static final String DATABASE_NAME = "database";

  private final Context context;
  private Database database;
  private Replicator replicator;

  public docOnly_Examples(Context context) { this.context = context; }

  //@Test
  public void testGettingStarted() throws CouchbaseLiteException, URISyntaxException {

    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);

    // Get the database (and create it if it doesnt exist).
    DatabaseConfiguration config = new DatabaseConfiguration();

    config.setDirectory(context.getFilesDir().getAbsolutePath());

    Database database = new Database("getting-started", config);


    // Create a new document (i.e. a record) in the database.
    MutableDocument mutableDoc = new MutableDocument()
    .setFloat("version", 2.0F)
    .setString("type", "SDK");

    // Save it to the database.
    database.save(mutableDoc);

    // Update a document.
    mutableDoc = database.getDocument(mutableDoc.getId()).toMutable();
    mutableDoc.setString("language", "Java");
    database.save(mutableDoc);
    Document document = database.getDocument(mutableDoc.getId());
    // Log the document ID (generated by the database) and properties
    Log.i(TAG, "Document ID :: " + document.getId());
    Log.i(TAG, "Learning " + document.getString("language"));

    // Create a query to fetch documents of type SDK.
    Query query = QueryBuilder.select(SelectResult.all())
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("SDK")));
    ResultSet result = query.execute();
    Log.i(TAG, "Number of rows ::  " + result.allResults().size());

    // Create replicators to push and pull changes to and from the cloud.
    Endpoint targetEndpoint = new URLEndpoint(new URI("ws://localhost:4984/getting-started-db"));
    ReplicatorConfiguration replConfig = new ReplicatorConfiguration(database, targetEndpoint);
    replConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Add authentication.
    replConfig.setAuthenticator(new BasicAuthenticator("sync-gateway", "password"));

    // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
    Replicator replicator = new Replicator(replConfig);

    // Listen to replicator change events.
    replicator.addChangeListener(change -&gt; {
      if (change.getStatus().getError() != null) {
        Log.i(TAG, "Error code ::  " + change.getStatus().getError().getCode());
      }
    });

    // Start replication.
    replicator.start();


    database.delete();
  }

  public void test1xAttachments() throws CouchbaseLiteException, IOException {
    // if db exist, delete it
    deleteDB("android-sqlite", context.getFilesDir());

    ZipUtils.unzip(getAsset("replacedb/android140-sqlite.cblite2.zip"), context.getFilesDir());

    Database db = new Database("android-sqlite", new DatabaseConfiguration());
    try {

      Document doc = db.getDocument("doc1");

      // For Validation
      Dictionary attachments = doc.getDictionary("_attachments");
      Blob blob = attachments.getBlob("attach1");
      byte[] content = blob.getContent();
      // For Validation

      byte[] attach = String.format(Locale.ENGLISH, "attach1").getBytes();
      Arrays.equals(attach, content);

    } finally {
      // close db
      db.close();
      // if db exist, delete it
      deleteDB("android-sqlite", context.getFilesDir());
    }

    Document document = new MutableDocument();

    Dictionary attachments = document.getDictionary("_attachments");
    Blob blob = attachments != null ? attachments.getBlob("avatar") : null;
    byte[] content = blob != null ? blob.getContent() : null;
  }

  // <mark># Initializer
  public void testInitializer() {
    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);
  }

  // </mark># New Database
  public void testNewDatabase() throws CouchbaseLiteException {
    final DatabaseConfiguration config = new DatabaseConfiguration();
    config.setDirectory(context.getFilesDir().getAbsolutePath()); <i class="conum" data-value="1"></i><b>(1)</b>

    Database database = new Database("my-database", config);

    database.close();


    database.delete();
  }

  // <mark># Database Encryption
  public void testDatabaseEncryption() throws CouchbaseLiteException {
    DatabaseConfiguration config = new DatabaseConfiguration();
    config.setEncryptionKey(new EncryptionKey("PASSWORD"));
    Database database = new Database("mydb", config);
  }

  // </mark># Logging
  public void testLogging() {
    Database.setLogLevel(LogDomain.DATABASE, LogLevel.VERBOSE);
    Database.setLogLevel(LogDomain.QUERY, LogLevel.VERBOSE);
    }

    public void testEnableCustomLogging() {
        Database.log.setCustom(new LogTestLogger(LogLevel.WARNING)); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    // <mark># Console logging
    public void testConsoleLogging() throws CouchbaseLiteException {
          Database.log.getConsole().setDomain(LogDomain.ALL_DOMAINS);  <i class="conum" data-value="3"></i><b>(3)</b>
          Database.log.getConsole().setLevel(LogLevel.VERBOSE); <i class="conum" data-value="4"></i><b>(4)</b>
          Database.log.getConsole().setDomain(LogDomain.DATABASE);

    }

    // </mark># File logging
    public void testFileLogging() throws CouchbaseLiteException {
        final File path = context.getCacheDir();

        LogFileConfiguration LogCfg =
          new LogFileConfiguration(path.toString()); <i class="conum" data-value="5"></i><b>(5)</b>
        LogCfg.setMaxSize(10240); <i class="conum" data-value="6"></i><b>(6)</b>
        LogCfg.setMaxRotateCount(5); <i class="conum" data-value="7"></i><b>(7)</b>
        LogCfg.setUsePlainText(false); <i class="conum" data-value="8"></i><b>(8)</b>
        Database.log.getFile().setConfig(LogCfg);
        Database.log.getFile().setLevel(LogLevel.INFO); <i class="conum" data-value="9"></i><b>(9)</b>
    }

    public void writeConsoleLog()
    {
        Database.log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }
    public void writeCustomLog()
    {
        Database.log.Custom?.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }


    public void writeFileLog()
    {
        Database.log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
    }




    // <mark># Loading a pre-built database
    public void testPreBuiltDatabase() throws IOException {
      // Note: Getting the path to a database is platform-specific.
      // For Android you need to extract it from your
      // assets to a temporary directory and then pass that path to Database.copy()
      DatabaseConfiguration configuration = new DatabaseConfiguration();
      if (!Database.exists("travel-sample", context.getFilesDir())) {
            ZipUtils.unzip(getAsset("travel-sample.cblite2.zip"), context.getFilesDir());
            File path = new File(context.getFilesDir(), "travel-sample");
            try {
                Database.copy(path, "travel-sample", configuration);
            } catch (CouchbaseLiteException e) {
                e.printStackTrace();
            }
        }
    }

    // helper methods

    // if db exist, delete it
    private void deleteDB(String name, File dir) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            // sometimes, db is still in used, wait for a while. Maximum 3 sec
            for (int i = 0; i &lt; 10; i) {
                try {
                    Database.delete(name, dir);
                    break;
                } catch (CouchbaseLiteException ex) {
                    try { Thread.sleep(300); }
                    catch (InterruptedException ignore) { }
                }
            }
        }
    }

    // ### Initializers
    public void testInitializers() {
        MutableDocument newTask = new MutableDocument();
        newTask.setString("type", "task");
        newTask.setString("owner", "todo");
        newTask.setDate("createdAt", new Date());
        try {
            database.save(newTask);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // ### Mutability
    public void testMutability() {
        try { database.save(new MutableDocument("xyz")); }
        catch (CouchbaseLiteException ignore) { }

        Document document = database.getDocument("xyz");
        MutableDocument mutableDocument = document.toMutable();
        mutableDocument.setString("name", "apples");
        try {
            database.save(mutableDocument);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // ### Typed Accessors
    public void testTypedAccessors() {
        MutableDocument newTask = new MutableDocument();

        newTask.setValue("createdAt", new Date());
        Date date = newTask.getDate("createdAt");
    }

    // ### Batch operations
    public void testBatchOperations() {
        try {
            database.inBatch(() -&gt; {
                for (int i = 0; i &lt; 10; i) {
                    MutableDocument doc = new MutableDocument();
                    doc.setValue("type", "user");
                    doc.setValue("name", "user " + i);
                    doc.setBoolean("admin", false);
                    try {
                        database.save(doc);
                    } catch (CouchbaseLiteException e) {
                        Log.e(TAG, e.toString());
                    }
                    Log.i(TAG, String.format("saved user document %s", doc.getString("name")));
                }
            });
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
    }

    // </mark># Document Expiration
    public void DocumentExpiration() throws CouchbaseLiteException {
        // Purge the document one day from now
        Instant ttl = Instant.now().plus(1, ChronoUnit.DAYS);
        database.setDocumentExpiration("doc123", new Date(ttl.toEpochMilli()));

        // Reset expiration
        database.setDocumentExpiration("doc1", null);

        // Query documents that will be expired in less than five minutes
        Instant fiveMinutesFromNow = Instant.now().plus(5, ChronoUnit.MINUTES);
        Query query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.expiration.lessThan(Expression.doubleValue(fiveMinutesFromNow.toEpochMilli())));
    }

    public void testDocumentChangeListener() throws CouchbaseLiteException {
        database.addDocumentChangeListener(
            "user.john",
            change -&gt; {
                Document doc = database.getDocument(change.getDocumentID());
                if (doc != null) {
                    Toast.makeText(context, "Status: " + doc.getString("verified_account"), Toast.LENGTH_SHORT).show();
                }
            });
    }

    // <mark># Blobs
    public void testBlobs() {
        MutableDocument newTask = new MutableDocument();

        InputStream is = getAsset("avatar.jpg"); <i class="conum" data-value="10"></i><b>(10)</b>
        if (is == null) { return; }
        try {
            Blob blob = new Blob("image/jpeg", is); <i class="conum" data-value="11"></i><b>(11)</b>
            newTask.setBlob("avatar", blob); <i class="conum" data-value="12"></i><b>(12)</b>
            database.save(newTask);

            Blob taskBlob = newTask.getBlob("avatar");
            byte[] bytes = taskBlob.getContent();
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        } finally {
            try { is.close(); }
            catch (IOException ignore) { }
        }
    }

    // </mark># Indexing
    public void testIndexing() throws CouchbaseLiteException {
        // For Documentation
        {

            database.createIndex(ValueIndexConfiguration(["type", "name"]), "TypeNameIndex");

        }
    }

    public void testIndexing_Querybuilder() throws CouchbaseLiteException {
        // For Documentation
        {
            database.createIndex(
                "TypeNameIndex",
                IndexBuilder.valueIndex(
                    ValueIndexItem.property("type"),
                    ValueIndexItem.property("name")));
        }
    }

    // <mark># SELECT statement
    public void testSelectStatement() {
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("type"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.expression(Meta.id));

            try {
                ResultSet rs = query.execute();
                for (Result result : rs) {
                    Log.i("Sample", String.format("hotel id -&gt; %s", result.getString("id")));
                    Log.i("Sample", String.format("hotel name -&gt; %s", result.getString("name")));
                }
            } catch (CouchbaseLiteException e) {
                Log.e("Sample", e.getLocalizedMessage());
            }
          }
        }

        // META function
        public void testMetaFunction() throws CouchbaseLiteException {
          // For Documentation
          {
          Query query = QueryBuilder
          .select(SelectResult.expression(Meta.id))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("airport")))
          .orderBy(Ordering.expression(Meta.id));
          ResultSet rs = query.execute();
          for (Result result : rs) {
            Log.w("Sample", String.format("airport id -&gt; %s", result.getString("id")));
            Log.w("Sample", String.format("airport id -&gt; %s", result.getString(0)));
          }
        }
    }

    // </mark># all(</strong>)
    public void testSelectAll() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")));

            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database)); <i class="conum" data-value="13"></i><b>(13)</b>

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            ListenerToken token = query.addChangeListener(change -&gt; { <i class="conum" data-value="14"></i><b>(14)</b>
                for (Result result : change.getResults()) {
                    Log.d(TAG, "results: " + result.getKeys());
                    /* Update UI <strong>/
                }
            });


            query.removeChangeListener(token); <i class="conum" data-value="15"></i><b>(15)</b>


            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("hotel -&gt; %s", result.getDictionary(DATABASE_NAME).toMap()));
            }
        }
    }

    // <mark>#WHERE statement
    public void testWhereStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .limit(Expression.intValue(10));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Dictionary all = result.getDictionary(DATABASE_NAME);
                Log.i("Sample", String.format("name -&gt; %s", all.getString("name")));
                Log.i("Sample", String.format("type -&gt; %s", all.getString("type")));
            }
        }
    }

    public void testQueryDeletedDocuments() {
        // Query documents that have been deleted
        Where query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted);
    }


    // </mark><mark>Collection Operators
    public void testCollectionStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("public_likes"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction
                        .contains(Expression.property("public_likes"), Expression.string("Armani Langworth"))));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("public_likes -&gt; %s", result.getArray("public_likes").toList()));
            }
        }
    }

    // IN operator
    public void testInOperator() throws CouchbaseLiteException {
        // For Documentation
        {
            Expression[] values = new Expression[] {
                Expression.property("first"),
                Expression.property("last"),
                Expression.property("username")
            };

            Query query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.string("Armani").in(values));

            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // Pattern Matching
    public void testPatternMatching() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Function.Expression.string("royal engineers museum")))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // </mark># Wildcard Match
    public void testWildcardMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng%e%"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // Wildcard Character Match
    public void testWildCharacterMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng____r"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // <mark># Regex Match
    public void testRegexMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).regex(Expression.string("\\beng.*r\\b"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
        }
    }

    // JOIN statement
    public void testJoinStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder.select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route")))
                .from(DataSource.database(database).as("airline"))
                .join(Join.join(DataSource.database(database).as("route"))
                    .on(Meta.id.from("airline").equalTo(Expression.property("airlineid").from("route"))))
                .where(Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline").equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route").equalTo(Expression.string("RIX"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // </mark># GROUPBY statement
    public void testGroupByStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder.select(
                SelectResult.expression(Function.count(Expression.string("</strong>"))),
                SelectResult.property("country"),
                SelectResult.property("tz"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300))))
                .groupBy(
                    Expression.property("country"),
                    Expression.property("tz"))
                .orderBy(Ordering.expression(Function.count(Expression.string("<strong>"))).descending());
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format(
                        "There are %d airports on the %s timezone located in %s and above 300ft",
                        result.getInt("$1"),
                        result.getString("tz"),
                        result.getString("country")));
            }
        }
    }

    // <mark># ORDER BY statement
    public void testOrderByStatement() throws CouchbaseLiteException {
      // For Documentation
      {
        Query query = QueryBuilder
        .select(
          SelectResult.expression(Meta.id),
          SelectResult.property("name"))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("hotel")))
          .orderBy(Ordering.property("name").ascending())
          .limit(Expression.intValue(10));
          ResultSet rs = query.execute();
          for (Result result : rs) { Log.i("Sample", String.format("%s", result.toMap())); }
        }
      }
      // </mark># EXPLAIN statement
      public void testExplainStatement() throws CouchbaseLiteException {
          // For Documentation
          {
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("university")))
                .groupBy(Expression.property("country"))
                .orderBy(Ordering.property("name").descending()); <i class="conum" data-value="16"></i><b>(16)</b>
              Log.i(query.explain()); <i class="conum" data-value="17"></i><b>(17)</b>
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("%hotel%"))); <i class="conum" data-value="18"></i><b>(18)</b>
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="19"></i><b>(19)</b>
                  .and(Expression.property("name").like(Expression.string("%royal%"))));
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))); <i class="conum" data-value="20"></i><b>(20)</b>
              Log.i(query.explain());
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="21"></i><b>(21)</b>
              Log.i(query.explain());
          }
      }
      // end query-explain

    void prepareIndex() throws CouchbaseLiteException {

        FullTextIndexConfiguration config = new FullTextIndexConfiguration("Overview").ignoreAccents(false)

        database.createIndex( config, "overviewFTSIndex")

    }

    void prepareIndex_Querybuilder() throws CouchbaseLiteException {
      database.createIndex(
          "overviewFTSIndex",
          IndexBuilder.fullTextIndex(FullTextIndexItem.property("overview")).ignoreAccents(false));
  }

    public void testFTS() throws CouchbaseLiteException {

        Query ftsQuery =
                database.createQuery(
                "SELECT _id, overview FROM _ WHERE MATCH(overviewFTSIndex, 'michigan') ORDER BY RANK(overviewFTSIndex)");

        for (result in ftsQuery.execute().allResults()) {
          Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}");
        }

    }
    public void testFTS_Querybuilder() throws CouchbaseLiteException {
        Expression whereClause = FullTextFunction.match("overviewFTSIndex", "'michigan'");
        Query ftsQuery =
                QueryBuilder.select(SelectResult.expression(Meta.id),
                                    SelectResult.expression(overview)
                                  )
            .from(DataSource.database(database))
            .where(whereClause);

            for (result in ftsQuery.execute().allResults()) {
              Log.i(TAG, "${result.getString("id")}: ${result.getString("overview")}");
            }

    }

    /</strong> The <code>tag::replication[]</code> example is inlined in java.adoc <strong>/

    public void testTroubleshooting() {
        Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE);
    }

    public void testReplicationBasicAuthentication() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new BasicAuthenticator("username", "password"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationSessionAuthentication() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationStatus() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        replicator.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == Replicator.ActivityLevel.STOPPED) {
                Log.i(TAG, "Replication stopped");
            }
          });
        }

    //  BEGIN PendingDocuments BM -- 19/Feb/21 --
    import android.support.annotation.NonNull;
    import android.util.Log;

    import java.net.URI;
    import java.net.URISyntaxException;
    import java.util.Iterator;
    import java.util.Set;

    import com.couchbase.lite.CouchbaseLiteException;
    import com.couchbase.lite.Database;
    import com.couchbase.lite.Endpoint;
    import com.couchbase.lite.Replicator;
    import com.couchbase.lite.ReplicatorConfiguration;
    import com.couchbase.lite.URLEndpoint;

    class PendingDocsExample {
        private static final String TAG = "SCRATCH";

        private Database database;
        private Replicator replicator;

        //  BEGIN PendingDocuments IB -- 11/Feb/21 --
        public void testReplicationPendingDocs() throws URISyntaxException, CouchbaseLiteException {
            // nottag::replication-pendingdocuments[]
            // ... include other code as required
            //
            final Endpoint endpoint =
              new URLEndpoint(new URI("ws://localhost:4984/db"));

            final ReplicatorConfiguration config =
              new ReplicatorConfiguration(database, endpoint)
            .setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

            replicator = new Replicator(config);
            final Set&lt;String&gt; pendingDocs =
              replicator.getPendingDocumentIds(); <i class="conum" data-value="22"></i><b>(22)</b>


            replicator.addChangeListener(change -&gt; {
              onStatusChanged(pendingDocs, change.getStatus()); });

            replicator.start();

            // ... include other code as required
            // notend::replication-pendingdocuments[]
          }
        //
        //
        private void onStatusChanged(
          @NonNull final Set&lt;String&gt; pendingDocs,
          @NonNull final Replicator.Status status) {
          // ... sample onStatusChanged function
          //
          Log.i(TAG,
            "Replicator activity level is " + status.getActivityLevel().toString());

          // iterate and report-on previously
          // retrieved pending docids 'list'
          for (Iterator&lt;String&gt; itr = pendingDocs.iterator(); itr.hasNext(); ) {
            final String docId = itr.next();
            try {
              if (!replicator.isDocumentPending(docId)) { continue; } <i class="conum" data-value="23"></i><b>(23)</b>

              itr.remove();
              Log.i(TAG, "Doc ID " + docId + " has been pushed");
            }
            catch (CouchbaseLiteException e) {
              Log.w(TAG, "isDocumentPending failed", e); }
          }
        }
        //  END PendingDocuments BM -- 19/Feb/21 --
    }


    public void testHandlingNetworkErrors() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        replicator.addChangeListener(change -&gt; {
            CouchbaseLiteException error = change.getStatus().getError();
            if (error != null) { Log.w(TAG, "Error code:: %d", error); }
        });
        replicator.start();

        replicator.stop();
    }

    public void testReplicatorDocumentEvent() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        ListenerToken token = replicator.addDocumentReplicationListener(replication -&gt; {

            Log.i(TAG, "Replication type: " + replication.isPush( ? "Push" : "Pull"));
            for (ReplicatedDocument document : replication.getDocuments()) {
                Log.i(TAG, "Doc ID: " + document.getID());

                CouchbaseLiteException err = document.getError();
                if (err != null) {
                    // There was an error
                    Log.e(TAG, "Error replicating document: ", err);
                    return;
                }

                if (document.flags().contains(DocumentFlag.DocumentFlagsDeleted)) {
                    Log.i(TAG, "Successfully replicated a deleted document");
                }
            }
        });

        replicator.start();

        replicator.removeChangeListener(token);
    }

    public void testReplicationCustomHeader() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();
        headers.put("CustomHeaderName", "Value");
        config.setHeaders(headers);
    }

    // <mark># Certificate Pinning

    public void testCertificatePinning() throws URISyntaxException, IOException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);

        InputStream is = getAsset("cert.cer");
        byte[] cert = IOUtils.toByteArray(is);
        if (is != null) {
            try { is.close(); }
            catch (IOException ignore) {}
        }

        config.setPinnedServerCertificate(cert);
    }

    // </mark># Reset replicator checkpoint
    public void testReplicationResetCheckpoint() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        if (resetCheckpointRequired_Example) {
          replicator.start(true); <i class="conum" data-value="24"></i><b>(24)</b>
        else
          replicator.start(false);
        }

        // ... at some later time

        replicator.stop();
    }

    public void testReplicationPushFilter() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPushFilterdocument, flags) -&gt; flags.contains(DocumentFlag.DocumentFlagsDeleted; <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testReplicationPullFilter() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPullFilterdocument, flags) -&gt; "draft".equals(document.getString("type"); <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
    }

    public void testCustomRetryConfig() throws URISyntaxException {
    URLEndpoint target =
    new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

    ReplicatorConfiguration config =
    new ReplicatorConfiguration(database, target);

    //  other config as required . . .
    config.setHeartbeat(150L); <i class="conum" data-value="25"></i><b>(25)</b>
    config.setMaxattempts(20L); <i class="conum" data-value="26"></i><b>(26)</b>
    config.setMaxAttemptWaitTime(600L); <i class="conum" data-value="27"></i><b>(27)</b>

    Replicator repl = new Replicator(config);

    }


    public void docsSetAutoPurge() throws CouchbaseliteException {

      DatabaseConfiguration config = new DatabaseConfiguration();
      Database database1 = new Database("mydb", config);

      ReplicatorConfiguration repcfg =
      new ReplicatorConfiguration(database, target);

      repcfg.setAutoPurgeEnabled(true); <i class="conum" data-value="28"></i><b>(28)</b>

    }


    public void testDatabaseReplica() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database1 = new Database("mydb", config);

        config = new DatabaseConfiguration();
        Database database2 = new Database("db2", config);

        /</strong> EE feature: code below might throw a compilation error
           if it's compiled against CBL Android Community. <strong>/
        DatabaseEndpoint targetDatabase = new DatabaseEndpoint(database2);
        ReplicatorConfiguration replicatorConfig = new ReplicatorConfiguration(database1, targetDatabase);
        replicatorConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(replicatorConfig);
        replicator.start();
    }

    public void testPredictiveModel() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Database.prediction.registerModel("ImageClassifier", new ImageClassifierModel());

        ValueIndex index = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")));
        database.createIndex("value-index-image-classifier", index);

        Database.prediction.unregisterModel("ImageClassifier");
    }

    public void testPredictiveIndex() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Map&lt;String, Object&gt; inputMap = new HashMap&lt;&gt;();
        inputMap.put("numbers", Expression.property("photo"));
        Expression input = Expression.map(inputMap);

        PredictiveIndex index = IndexBuilder.predictiveIndex("ImageClassifier", input, null);
        database.createIndex("predictive-index-image-classifier", index);
    }

    public void testPredictiveQuery() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        Map&lt;String, Object&gt; inputProperties = new HashMap&lt;&gt;();
        inputProperties.put("photo", Expression.property("photo"));
        Expression input = Expression.map(inputProperties);
        PredictionFunction prediction = PredictiveModel.predict("ImageClassifier", input); <i class="conum" data-value="1"></i><b>(1)</b>

        Query query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("label").equalTo(Expression.string("car"))
                .and(Expression.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))));

        // Run the query.
        ResultSet result = query.execute();
        Log.d(TAG, "Number of rows: " + result.allResults().size());
    }

    public void testReplicationWithCustomConflictResolver() throws URISyntaxException {
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setConflictResolver(new LocalWinConflictResolver());

        Replicator replication = new Replicator(config);
        replication.start();
    }

    public void testSaveWithCustomConflictResolver() throws CouchbaseLiteException {
        Document doc = database.getDocument("xyz");
        if (doc == null) { return; }
        MutableDocument mutableDocument = doc.toMutable();
        mutableDocument.setString("name", "apples");

        database.save(
            mutableDocument,
            (newDoc, curDoc) -&gt; { <i class="conum" data-value="29"></i><b>(29)</b>
                if (curDoc == null) { return false; } <i class="conum" data-value="30"></i><b>(30)</b>
                Map&lt;String, Object&gt; dataMap = curDoc.toMap();
                dataMap.putAll(newDoc.toMap()); <i class="conum" data-value="31"></i><b>(31)</b>
                newDoc.setData(dataMap);
                return true; <i class="conum" data-value="32"></i><b>(32)</b>
            }); <i class="conum" data-value="33"></i><b>(33)</b>
      }
    }


&lt;.&gt; The conflict handler code is provided as a lambda.

&lt;.&gt; If the handler cannot resolve a conflict, it can return false.
In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.

&lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.

&lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).

&lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method

// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
class LocalWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getLocalDocument();
    }
}

// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
class RemoteWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getRemoteDocument();
    }
}

// Using replConfig.setConflictResolver(new MergeConflictResolver());
class MergeConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        Map&lt;String, Object&gt; merge = conflict.getLocalDocument().toMap();
        merge.putAll(conflict.getRemoteDocument().toMap());
        return new MutableDocument(conflict.getDocumentId(), merge);
    }
}


/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  ACTIVE SIDE  ----------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

class BrowserSessionManager implements MessageEndpointDelegate {
    private final Context context;
    private Replicator replicator;

    private BrowserSessionManager(Context context) { this.context = context; }

    public void initCouchbase() throws CouchbaseLiteException {
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration(context);
        Database database = new Database("mydb", databaseConfiguration);

        // The delegate must implement the <code>MessageEndpointDelegate</code> protocol.
        MessageEndpoint messageEndpointTarget = new MessageEndpoint(
            "UID:123",
            "active",
            ProtocolType.MESSAGE_STREAM,
            this);

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, messageEndpointTarget);

        // Create the replicator object.
        replicator = new Replicator(config);
        // Start the replication.
        replicator.start();
    }

    /</strong> implementation of MessageEndpointDelegate <strong>/
    @NonNull
    @Override
    public MessageEndpointConnection createConnection(@NonNull MessageEndpoint endpoint) {
        return new ActivePeerConnection(); /</strong> implements MessageEndpointConnection <strong>/
    }
}

class ActivePeerConnection implements MessageEndpointConnection {

    private ReplicatorConnection replicatorConnection;

    public void disconnect() {
        replicatorConnection.close(null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }

    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete();
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null);
    }

    public void receive(Message message) {
        replicatorConnection.receive(message);
    }

}

/</strong> ----------------------------------------------------------- <strong>/
/</strong> ---------------------  PASSIVE SIDE  ---------------------- <strong>/
/</strong> ----------------------------------------------------------- <strong>/

class PassivePeerConnection implements MessageEndpointConnection {
    private final Context context;

    private MessageEndpointListener messageEndpointListener;
    private ReplicatorConnection replicatorConnection;

    private PassivePeerConnection(Context context) { this.context = context; }

    public void startListener() throws CouchbaseLiteException {
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration();
        Database database = new Database("mydb", databaseConfiguration);
        MessageEndpointListenerConfiguration listenerConfiguration = new MessageEndpointListenerConfiguration(
            database,
            ProtocolType.MESSAGE_STREAM);
        this.messageEndpointListener = new MessageEndpointListener(listenerConfiguration);
    }

    public void stopListener() {
        messageEndpointListener.closeAll();
    }

    public void accept() {
        PassivePeerConnection connection = new PassivePeerConnection(context); /</strong> implements
        MessageEndpointConnection <strong>/
        messageEndpointListener.accept(connection);
    }

    public void disconnect() {
        replicatorConnection.close(null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /</strong> disconnect with communications framework <strong>/
        /</strong> ... <strong>/
        /</strong> call completion handler <strong>/
        completion.complete();
    }

    /</strong> implementation of MessageEndpointConnection <strong>/
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /</strong> send the data to the other peer <strong>/
        /</strong> ... <strong>/
        /</strong> call the completion handler once the message is sent <strong>/
        completion.complete(true, null);
    }

    public void receive(Message message) {
        replicatorConnection.receive(message);
    }
}

// tensorFlowModel is a fake implementation
// this would be the implementation of the ml model you have chosen
class ImageClassifierModel implements PredictiveModel {
    @Override
    public Dictionary predict(@NonNull Dictionary input) {
        Blob blob = input.getBlob("photo");
        if (blob == null) { return null; }

        // tensorFlowModel is a fake implementation
        // this would be the implementation of the ml model you have chosen
        return new MutableDictionary(TensorFlowModel.predictImage(blob.getContent())); <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

class TensorFlowModel {
    public static Map&lt;String, Object&gt; predictImage(byte[] data) {
        return null;
    }
}

class LogTestLogger implements Logger {
    @NonNull
    private final LogLevel level;

    public LogTestLogger(@NonNull LogLevel level) { this.level = level; }

    @NonNull
    @Override
    public LogLevel getLevel() { return level; }

    @Override
    public void log(@NonNull LogLevel level, @NonNull LogDomain domain, @NonNull String message) {
    }
}





//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:lite@couchbase.com">lite@couchbase.com</a>");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);                 Log.e(TAG, "Success!!");                 deleteIdentity("server");                 Log.e(TAG, "Alias deleted: server");                 deleteIdentity("client");                 Log.e(TAG, "Alias deleted: client");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void startClient(         @NonNull URI uri,         @NonNull Certificate cert,         @NonNull TLSIdentity clientIdentity,         @NonNull Database db) throws CertificateEncodingException, InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    /</strong>
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(false);
      config.setTlsIdentity(serverId);
      config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

      final URLEndpointListener listener = new URLEndpointListener(config);
      listener.start();

      final List&lt;URI&gt; urls = listener.getUrls();
      if (urls.isEmpty()) { return null; }
      return urls.get(0);
    }

    /<strong>
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
    throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

      final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
      keyStore.load(null);

      keyStore.deleteEntry(alias); <i class="conum" data-value="34"></i><b>(34)</b>
    }

    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /</strong> Configure Client (active) side certificates
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     <strong>/
    private void configureClientCerts(
      ReplicatorConfiguration config,
      @NonNull Certificate cert,
      @NonNull TLSIdentity clientIdentity)
      throws CertificateEncodingException {

        // Create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
      }
      // notend::p2p-tlsid-tlsidentity-with-label[]

    /</strong>
     * Copy a cert from a resource bundle
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte buf[] = new byte[1024];
        int n;
        while n = in.read(buf &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}



//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread) -&gt; {             try {                 runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);                 Log.e(TAG, "Success!!");             }             catch (Exception e) { Log.e(TAG, "Failed!!", e); }         }).start();     }      // start a client replicator     public void runClient(         @NonNull URI uri,         @NonNull String username,         @NonNull char[] password,         @NonNull Database db) throws InterruptedException {         final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri;
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    /</strong>*
     *
     * Start a listener for db that accepts connections using exactly the passed username and password

     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     <strong>/
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password) <i class="conum" data-value="35"></i><b>(35)</b>
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(true);
      config.setAuthenticator(new ListenerPasswordAuthenticator(
        (validUser, pwd) -&gt; username.equals(validUser) &amp;&amp; Arrays.equals(validPassword, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
      }
    }






// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// <a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a>
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.support.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;

public class docOnly_ReplicationExamples {
  private static final String TAG = "EXAMPLE ACTIVE PEER";
  private static final String thisDBNAME = "local-database";
  private final Context context;
  // private Database database;
  // private Replicator replicator;

  public docOnly_ReplicationExamples(Context context) { this.context = context; }

  String user = "syncuser";
  String password = "sync9455";
  SecCertificate cert=null;
  String passivePeerEndpoint = "10.1.1.12:8920";
  String passivePeerPort = "8920";
  String passiveDbName = "userdb";
  Database thisDB;
  Replicator thisReplicator;
  ListenerToken replicatorListener;




// PASSIVE PEER STUFF
// Stuff I adapted
//
// BEGIN new stuff 90420temp cache
  private URLEndpointListener createListener() {
  final URLEndpointListenerConfiguration listenerConfig = new URLEndpointListenerConfiguration(db);

  listenerConfig.setDisableTls(false);

  listenerConfig.setEnableDeltaSync(true);

  listenerConfig.setTlsIdentity(null); // Use with anonymous self signed cert

  listenerConfig.setAuthenticator(new ListenerPasswordAuthenticator(this::isWhitelistedUser));

  return new URLEndpointListener(listenerConfig);
}

public void startListener(@NotNull URLEndpointListener listener) {
  executor.submit) -&gt; {       CouchbaseLiteException err = null;       try { listener.start(); }       catch (CouchbaseLiteException e) { err = e; }       onStart(err);   }); }  private void stopListener(@NotNull URLEndpointListener listener) {   listener.stop(); } // END new stuff 90420temp cache   private void ibListenerSimple() {   final URLEndpointListenerConfiguration thisConfig =     new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="36"></i><b>(36)</b>    thisConfig.setAuthenticator(     new ListenerPasswordAuthenticator(       (username, password) -&gt;         username.equals("valid.User") &amp;&amp;         Arrays.equals(password, valid.password.string)       )     ); <i class="conum" data-value="37"></i><b>(37)</b>    final URLEndpointListener thisListener =     new URLEndpointListener(thisConfig); <i class="conum" data-value="38"></i><b>(38)</b>    thisListener.start(); <i class="conum" data-value="39"></i><b>(39)</b>  }  private void ibReplicatorSimple() {   URI uri = null;   try {       uri = new URI("wss://10.0.2.2:4984/db");   } catch (URISyntaxException e) {       e.printStackTrace();   }   Endpoint theListenerEndpoint = new URLEndpoint(uri); <i class="conum" data-value="40"></i><b>(40)</b>    ReplicatorConfiguration thisConfig =     new ReplicatorConfiguration(database, theListenerEndpoint); <i class="conum" data-value="41"></i><b>(41)</b>    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="42"></i><b>(42)</b>    final BasicAuthenticator thisAuth   = new BasicAuthenticator(       "valid.user",       "valid.password.string");   thisConfig.setAuthenticator(thisAuth) <i class="conum" data-value="43"></i><b>(43)</b>    this.replicator = new Replicator(config); <i class="conum" data-value="44"></i><b>(44)</b>   this.replicator.start(); <i class="conum" data-value="45"></i><b>(45)</b>  }   private void ibPassListener() { // EXAMPLE 1     // Initialize the listener config     final URLEndpointListenerConfiguration thisConfig        = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="46"></i><b>(46)</b>      thisConfig.setPort(55990); <i class="conum" data-value="47"></i><b>(47)</b>      thisConfig.setNetworkInterface("10.1.1.10"); <i class="conum" data-value="48"></i><b>(48)</b>      thisConfig.setEnableDeltaSync(false); <i class="conum" data-value="49"></i><b>(49)</b>      // Configure server security     thisConfig.setDisableTls(false); <i class="conum" data-value="50"></i><b>(50)</b>      // Use an Anonymous Self-Signed Cert     thisConfig.setTlsIdentity(null); <i class="conum" data-value="51"></i><b>(51)</b>       // Configure Client Security using an Authenticator     // For example, Basic Authentication <i class="conum" data-value="52"></i><b>(52)</b>     thisConfig.setAuthenticator(new ListenerPasswordAuthenticator(       (validUser, validPassword) -&gt;         username.equals(validUser) &amp;&amp;         Arrays.equals(password, validPassword);

    // Initialize the listener
    final URLEndpointListener thisListener
      = new URLEndpointListener(thisConfig); <i class="conum" data-value="53"></i><b>(53)</b>

    // Start the listener
    thisListener.start(); <i class="conum" data-value="54"></i><b>(54)</b>

}

private void ibListenerGetNetworkInterfaces() {
  final URLEndpointListenerConfiguration thisConfig =
    URLEndpointListenerConfiguration(database: self.oDB)
  final URLEndpointListener thisListener
    = new URLEndpointListener(thisConfig);
  thisListener.start()
  Log.i(TAG, "URLS are " + thisListener.getUrls());

}

private void ibListenerLocalDb() {
// . . . preceding application logic . . .
CouchbaseLite.init(context); <i class="conum" data-value="55"></i><b>(55)</b>
Database thisDB = new Database("passivepeerdb");

}

private void ibListenerConfigTlsDisable() {
thisConfig.setDisableTls(true); <i class="conum" data-value="56"></i><b>(56)</b>

}

private void ibListenerConfigTlsIdFull() {
  // Use CA Cert
  // Import a key pair into secure storage
  // Create a TLSIdentity from the imported key-pair
  InputStream thisKeyPair = new FileInputStream();

  thisKeyPair.getClass().getResourceAsStream("serverkeypair.p12"); <i class="conum" data-value="57"></i><b>(57)</b>

  TLSIdentity thisIdentity = new TLSIdentity.importIdentity(
    EXTERNAL_KEY_STORE_TYPE,  // KeyStore type, eg: "PKCS12"
    thisKeyPair,              // An InputStream from the keystore
    password,                 // The keystore password
    EXTERNAL_KEY_ALIAS,       // The alias to be used (in external keystore)
    null,                     // The key password
    "test-alias"              // The alias for the imported key
    );


  // Use a self-signed certificate
  // Create a TLSIdentity for the server using convenience API.
  // System generates self-signed cert
  // Work-in-progress. Code snippet coming soon.
  private static final Map&lt;String, String&gt; CERT_ATTRIBUTES; <i class="conum" data-value="58"></i><b>(58)</b>
  static {
    final Map&lt;String, String&gt; thisMap = new HashMap&lt;&gt;();
    m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "Couchbase Demo");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
    m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>");
    CERT_ATTRIBUTES = Collections.unmodifiableMap(thisMap);
  }

  // Store the TLS identity in secure storage
  // under the label 'couchbase-docs-cert'
  TLSIdentity thisIdentity =
    new TLSIdentity.createIdentity(
      true,
      CERT_ATTRIBUTES,
      null,
      "couchbase-docs-cert"); <i class="conum" data-value="59"></i><b>(59)</b>


  // Set the TLS Identity
  thisConfig.setTlsIdentity(thisIdentity); <i class="conum" data-value="60"></i><b>(60)</b>

}

private void ibListenerConfigClientAuthRoot() {
  // Configure the client authenticator
  // to validate using ROOT CA
  // thisClientID.certs is a list containing a client cert to accept
  // and any other certs needed to complete a chain between the client cert
  // and a CA
  final TLSIdentity validId =
    TLSIdentity.getIdentity("Our Corporate Id");  // get the identity <i class="conum" data-value="61"></i><b>(61)</b>

  if (validId == null) { throw new IllegalStateException("Cannot find corporate id"); }

  thisConfig.setTlsIdentity(validId);

  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(validId.getCerts())); <i class="conum" data-value="62"></i><b>(62)</b> <i class="conum" data-value="63"></i><b>(63)</b>
    // accept only clients signed by the corp cert

  final URLEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

}

private void ibListenerConfigClientAuthLambda() {
// Configure authentication using application logic
  final TLSIdentity thisCorpId = TLSIdentity.getIdentity("OurCorp"); <i class="conum" data-value="64"></i><b>(64)</b>
  if (thisCorpId == null) {
    throw new IllegalStateException("Cannot find corporate id"); }
  thisConfig.setTlsIdentity(thisCorpId);
  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(
      (thisCorpId.getCerts()) -&gt; {
      // use supplied logic that resolves to boolean
      // true=valid, false=invalid
      }
    )); <i class="conum" data-value="65"></i><b>(65)</b> <i class="conum" data-value="66"></i><b>(66)</b>
  final ULEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

}


private void ibListenerConfigTlsDisable() {

  thisConfig.disableTLS(true);

}


private void ibListenerStatusCheck() {
  int connectionCount =
    thisListener.getStatus().getConnectionCount(); <i class="conum" data-value="67"></i><b>(67)</b>

  int activeConnectionCount =
    thisListener.getStatus().getActiveConnectionCount();  <i class="conum" data-value="68"></i><b>(68)</b>

}

private void ibListenerStop() {

  thisListener.stop();

}

// Listener Callouts
/</strong>

    &lt;.&gt; Initialize the listener instance using the configuration settings.
    &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.



  &lt;.&gt; <code>connectionCount</code> -- the total number of connections served by the listener
  &lt;.&gt; <code>activeConnectionCount</code> -- the number of active (BUSY) connections currently being served by the listener
  //

<strong>/
/</strong> END CALLOUTS TEXT <strong>/


private void ibP2PUrlEndpointListener() {

  public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
  }
}



// ACTIVE PEER STUFF
// Replication code
//

  //@Test
  public void testActPeerSync() throws CouchbaseLiteException, URISyntaxException {
    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://listener.com:8954"))); <i class="conum" data-value="69"></i><b>(69)</b> <i class="conum" data-value="70"></i><b>(70)</b>

    // Set replicator type
    thisConfig.setReplicatorType(
      ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Configure Sync Mode
    thisConfig.setContinuous(false); // default value

    // set auto-purge behavior (here we override default)
    thisConfig.setAutoPurgeEnabled(false); <i class="conum" data-value="71"></i><b>(71)</b>

    // Configure Server Authentication --
    // only accept self-signed certs
    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="72"></i><b>(72)</b>

    // Configure the credentials the
    // client will provide if prompted
    final BasicAuthenticator thisAuth
      = new BasicAuthenticator(
          "Our Username",
          "Our PasswordValue")); <i class="conum" data-value="73"></i><b>(73)</b>

    thisConfig.setAuthenticator(thisAuth)

    /</strong> Optionally set custom conflict resolver call back <strong>/
    thisConfig.setConflictResolver( /</strong> define resolver function <strong>/); <i class="conum" data-value="74"></i><b>(74)</b>

    // Create replicator
    // Consider holding a reference somewhere
    // to prevent the Replicator from being GCed
    final Replicator thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="75"></i><b>(75)</b>

    // Optionally add a change listener <i class="conum" data-value="76"></i><b>(76)</b>
    ListenerToken thisListener =
      new thisReplicator.addChangeListener(change -&gt; {
        final CouchbaseLiteException err =
         change.getStatus().getError();
         if (err != null) {
           Log.i(TAG, "Error code ::  " + err.getCode(), e);
         }
      }); <i class="conum" data-value="77"></i><b>(77)</b>

    // Start replicator
    thisReplicator.start(false); <i class="conum" data-value="78"></i><b>(78)</b>


  public void ibReplicatorConfig() {
  // BEGIN additional snippets
      // Configure Server Security
      // -- only accept CA attested certs
      thisConfig.setAcceptOnlySelfSignedServerCertificate(false); <i class="conum" data-value="79"></i><b>(79)</b>


    // Return the remote pinned cert (the listener's cert)
    byte returnedCert
     = new byte(thisConfig.getPinnedCertificate()); // Get listener cert if pinned

    // ... your other replicator configuration

    // Provide a client certificate to the server for authentication
    final TLSIdentity thisClientId = TLSIdentity.getIdentity("clientId"); <i class="conum" data-value="80"></i><b>(80)</b>

    if (thisClientId == null) { throw new IllegalStateException("Cannot find client id"); }

    thisConfig.setAuthenticator(new ClientCertificateAuthenticator(thisClientId)); <i class="conum" data-value="81"></i><b>(81)</b>

    // ... your other replicator configuration
    final thisReplicator= new Replicator(thisConfig);


    // Use the pinned certificate from the byte array (cert)
    thisConfig.setPinnedServerCertificate(cert.getEncoded()); <i class="conum" data-value="82"></i><b>(82)</b>
}
// END additional snippets








    Log.i(TAG, "The Replicator is currently " +
      thisReplicator.getStatus().getActivityLevel());

    Log.i(TAG, "The Replicator has processed " + t);

    if (thisReplicator.getStatus().getActivityLevel() ==
      Replicator.ActivityLevel.BUSY) {
        Log.i(TAG, "Replication Processing");
        Log.i(TAG, "It has completed " +
          thisReplicator.getStatus().getProgess().getTotal() +
          " changes");
      }

      // Stop replication.
      thisReplicator.stop(); <i class="conum" data-value="83"></i><b>(83)</b>


  CouchbaseLite.init(context);
  Database thisDB = new Database("passivepeerdb");  <i class="conum" data-value="84"></i><b>(84)</b>
  // Initialize the listener config
  final URLEndpointListenerConfiguration thisConfig = new URLEndpointListenerConfiguration(database);
  thisConfig.setPort(55990)           // &lt;.&gt; Optional; defaults to auto
  thisConfig.setDisableTls(false)     // &lt;.&gt; Optional; defaults to false
  thisConfig.setEnableDeltaSync(true) // &lt;.&gt; Optional; Defaults to false

  // Configure the client authenticator (if using basic auth)
  ListenerPasswordAuthenticator auth = new ListenerPasswordAuthenticator { "username", "password"}; <i class="conum" data-value="85"></i><b>(85)</b>
  thisConfig.setAuthenticator(auth); <i class="conum" data-value="86"></i><b>(86)</b>

  // Initialize the listener
  final URLEndpointListener listener = new URLEndpointListener( thisConfig ); <i class="conum" data-value="87"></i><b>(87)</b>

  // Start the listener
  listener.start(); <i class="conum" data-value="88"></i><b>(88)</b>




  Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "<a href="mailto:noreply@couchbase.com">noreply@couchbase.com</a>"
        )

  TLSIdentity thisIdentity = new TLSIdentity.createIdentity(true, X509_ATTRIBUTES, null, "test-alias");




  String thisAlias = "alias-to-delete";
  final KeyStore thisKeyStore
    =  KeyStore.getInstance("AndroidKeyStore");
  thisKeyStore.load(null);
  thisKeyStore.deleteEntry(thisAlias);


  // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label

  TLSIdentity thisIdentity =
    new TLSIdentity.getIdentity("couchbase-docs-cert")


  public void ibRplicatorPull() {
    Database database;
    Replicator replicator; <i class="conum" data-value="89"></i><b>(89)</b>

    URI uri = null;
    try {
        uri = new URI("wss://10.0.2.2:4984/db"); <i class="conum" data-value="90"></i><b>(90)</b>
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
    Endpoint endpoint = new URLEndpoint(uri);
    ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
    config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
    this.replicator = new Replicator(config);
    this.replicator.start();
  }

    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))); <i class="conum" data-value="91"></i><b>(91)</b>



  /</strong> C A L L O U T S

  &lt;.&gt; Configure the pinned certificate using data from the byte array <code>cert</code>

  &lt;.&gt; Attempt to get the identity from secure storage
  &lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity


  &lt;.&gt; A replication is an asynchronous operation.
  To keep a reference to the <code>replicator</code> object, you can set it as an instance property.
  &lt;.&gt; The URL scheme for remote database URLs uses <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections over wb sockets.
  In this example the hostname is <code>10.0.2.2</code> because the Android emulator runs in a VM that is generally accessible on <code>10.0.2.2</code> from the host machine (see <a href="https://developer.android.com/studio/run/emulator-networking">Android Emulator networking</a> documentation).
  +
  NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
  Although <code>wss:</code> protocol URLs are not affected, in order to use the <code>ws:</code> protocol, applications must target API 27 or lower, or must configure application network security as described <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted">here</a>.

  <strong>/

}
/</strong>

Snippets demonstrating use of resultsets

<strong>/
package com.example.docsnippet;
        import android.app.Application.</strong>;
        import android.content.Context;
        import android.content.Context.<strong>;
        import java.lang.Object;
        import java.security.Key;
        import java.util.</strong>;
        import com.couchbase.lite.<strong>;
        import com.couchbase.lite.Dictionary;

public class TestQueries {

    // For Documentation

    Datastore ds = new Datastore();

    Database this_Db = ds.getDB();

    String dbName = this_Db.getName();

    HashMap&lt;String, Object&gt; hotels = new HashMap&lt;&gt;();

    Dictionary thisDocsProps;
    String thisDocsId;
    String thisDocsName;
    String thisDocsType;
    String thisDocsCity;



    static {
        init();
    }

    private static void init() {
    }



    public void testQuerySyntaxAll() throws CouchbaseLiteException {

        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

      Query listQuery = QueryBuilder.select(SelectResult.all())
              .from(DataSource.database(this_Db));

        try {
            for (Result result : listQuery.execute().allResults()) {
                             // get the k-v pairs from the 'hotel' key's value into a dictionary
                thisDocsProps = result.getDictionary(0); <i class="conum" data-value="92"></i><b>(92)</b>
                thisDocsId = thisDocsProps.getString("id");
                thisDocsName = thisDocsProps.getString("Name");
                thisDocsType = thisDocsProps.getString("Type");
                thisDocsCity = thisDocsProps.getString("City");

                // Alternatively, access results value dictionary directly
                final Hotel hotel = new Hotel();
                hotel.Id = result.getDictionary(0).getString("id"); <i class="conum" data-value="93"></i><b>(93)</b>
                hotel.Type = result.getDictionary(0).getString("Type");
                hotel.Name = result.getDictionary(0).getString("Name");
                hotel.City = result.getDictionary(0).getString("City");
                hotel.Country= result.getDictionary(0).getString("Country");
                hotel.Description = result.getDictionary(0).getString("Description");
                hotels.put(hotel.Id, hotel);
            }

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }



    // Uses Jackson JSON processor

    ArrayList&lt;Hotel&gt; hotels = new ArrayList&lt;Hotel&gt;();
    HashMap&lt;String, Object&gt; dictFromJSONstring;
    for (Result result : listQuery.execute()) {

      // Get result as JSON string
      String thisJsonString = result.toJSON(); <i class="conum" data-value="94"></i><b>(94)</b>

      // Get Java  Hashmap from JSON string
      HashMap&lt;String, Object&gt; dictFromJSONstring =
              mapper.readValue(thisJsonString, HashMap.class); <i class="conum" data-value="95"></i><b>(95)</b>


      // Use created hashmap
      String hotelId = dictFromJSONstring.get("id").toString();
      String hotelType = dictFromJSONstring.get("type").toString();
      String hotelname = dictFromJSONstring.get("name").toString();


      // Get custom object from JSON string
      Hotel thisHotel =
              mapper.readValue(thisJsonString, Hotel.class); <i class="conum" data-value="96"></i><b>(96)</b>
      hotels.add(thisHotel);



            }
        }


    public void testQuerySyntaxProps() throws CouchbaseLiteException {
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        Query listQuery =
        QueryBuilder.select(SelectResult.expression(Meta.id),
        SelectResult.property("name"),
        SelectResult.property("Name"),
        SelectResult.property("Type"),
        SelectResult.property("City"))
        .from(DataSource.database(this_Db));



        try {
          for (Result result : listQuery.execute().allResults()) {

            // get data direct from result k-v pairs
            final Hotel hotel = new Hotel();
            hotel.Id = result.getString("id");
            hotel.Type = result.getString("Type");
            hotel.Name = result.getString("Name");
            hotel.City = result.getString("City");

            // Store created hotel object in a hashmap of hotels
            hotels.put(hotel.Id, hotel);

            // Get result k-v pairs into a 'dictionary' object
            Map &lt;String, Object&gt; thisDocsProps = result.toMap();
            thisDocsId =
            thisDocsProps.getOrDefault("id",null).toString();
            thisDocsName =
            thisDocsProps.getOrDefault("Name",null).toString();
            thisDocsType =
            thisDocsProps.getOrDefault("Type",null).toString();
            thisDocsCity =
            thisDocsProps.getOrDefault("City",null).toString();

          }
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

    }


    public void testQuerySyntaxCount() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery = QueryBuilder.select(
              SelectResult.expression(Function.count(Expression.string("</strong>"))).as("mycount")) <i class="conum" data-value="97"></i><b>(97)</b>
              .from(DataSource.database(this_Db));



        try {
            for (Result result : listQuery.execute()) {

                // Retrieve count using key 'mycount'
                Integer altDocId = result.getInt("mycount");

                // Alternatively, use the index
                Integer orDocId = result.getInt(0);
            }
            // Or even miss out the for-loop altogether
            Integer resultCount = listQuery.execute().next().getInt("mycount");

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }
    }


    public void testQuerySyntaxId() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id).as("metaID"))
                      .from(DataSource.database(this_Db));




        try {
            for (Result result : listQuery.execute().allResults()) {

                // get the ID form the result's k-v pair array
                thisDocsId = result.getString("metaID"); <i class="conum" data-value="98"></i><b>(98)</b>

                // Get document from DB using retrieved ID
                Document thisDoc = this_Db.getDocument(thisDocsId);

                // Process document as required
                thisDocsName = thisDoc.getString("Name");

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }


    }


    public void testQueryPagination() throws CouchbaseLiteException {


        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        int thisOffset = 0;
        int thisLimit = 20;

        Query listQuery =
                QueryBuilder
                        .select(SelectResult.all())
                        .from(DataSource.database(this_Db))
                        .limit(Expression.intValue(thisLimit),
                                  Expression.intValue(thisOffset)); <i class="conum" data-value="99"></i><b>(99)</b>


    }



    public List&lt;Result&gt; docsonly_QuerySyntaxN1QL (Database argDB)
    {
      // For Documentation -- N1QL Query using parameters
      //  Declared elsewhere: Database argDB

      Database thisDb = argDB;

      Query thisQuery =
      thisDb.createQuery(
        "SELECT META().id AS thisId FROM _ WHERE type = \"hotel\""); // &lt;.

        return thisQuery.execute().allResults();

      }


    public List&lt;Result&gt; docsonly_QuerySyntaxN1QLParams (Database argDB)
    {
      // For Documentation -- N1QL Query using parameters
      //  Declared elsewhere: Database argDB

      Database thisDb = argDB;

      Query thisQuery =
          thisDb.createQuery(
              "SELECT META().id AS thisId FROM _ WHERE type = $type"); // &lt;.

      thisQuery.parameters =
          Parameters.setString("type", "hotel"); <i class="conum" data-value="100"></i><b>(100)</b>

      return thisQuery.execute().allResults();

  }

} // class



public class supportingDatatypes
{
    private static final String TAG = "info";

    public void datatype_dictionary() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)
        Document document = database.getDocument("doc1");

        // Getting a dictionary from the document's properties
        Dictionary dict = document.getDictionary("address");

        // Access a value with a key from the dictionary
        String street = dict.getString("street");

        // Iterate dictionary
        for (String key : dict) {
            dict.getValue(key);
            Log.i("x", "Key %s, = %s", key, dict.getValue(key));
        }

        // Create a mutable copy
        MutableDictionary mutable_Dict = dict.toMutable();
    }

    public void datatype_mutable_dictionary() throws CouchbaseLiteException {

        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable dictionary and populate some keys/values
        MutableDictionary mutable_dict = new MutableDictionary();
        mutable_dict.setString("street", "1 Main st.");
        mutable_dict.setString("city", "San Francisco");

        // Add the dictionary to a document's properties and save the document
        MutableDocument mutable_doc = new MutableDocument("doc1");
        mutable_doc.setDictionary("address", mutable_dict);
        database.save(mutable_doc);

    }


    public void datatype_array() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        Document document = database.getDocument("doc1");

        // Getting a phones array from the document's properties
        Array array = document.getArray("phones");

        // Get element count
        int count = array.count();

        // Access an array element by index
        if (count &gt;= 0) { String phone = array.getString(1); }

        // Iterate dictionary
        for (int i = 0; i &lt; count; i)
        {
            Log.i("tag", "Item %d = %s", i, array.getString(i));
        }

        // Create a mutable copy
        MutableArray mutable_array = array.toMutable();


    }

    public void datatype_mutable_array() throws CouchbaseLiteException {
        Database database = new Database("mydb");

        // NOTE: No error handling, for brevity (see getting started)

        // Create a new mutable array and populate data into the array
        MutableArray mutable_array = new MutableArray();
        mutable_array.addString("650-000-0000");
        mutable_array.addString("650-000-0001");

        // Set the array to document's properties and save the document
        MutableDocument mutable_doc = new MutableDocument("doc1");
        mutable_doc.setArray("phones", mutable_array);
        database.save(mutable_doc);
    }

} // end  class supporting_datatypes



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/ZipUtils.java 
package com.couchbase.code_snippets;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class ZipUtils {
    public static void unzip(InputStream in, File destination) throws IOException {
        byte[] buffer = new byte[1024];
        ZipInputStream zis = new ZipInputStream(in);
        ZipEntry ze = zis.getNextEntry();
        while (ze != null) {
            String fileName = ze.getName();
            File newFile = new File(destination, fileName);
            if (ze.isDirectory()) {
                newFile.mkdirs();
            } else {
                new File(newFile.getParent()).mkdirs();
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) &gt; 0) {
                    fos.write(buffer, 0, len);
                }
                fos.close();
            }
            ze = zis.getNextEntry();
        }
        zis.closeEntry();
        zis.close();
        in.close();
    }
}


// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/ZipUtils.java 



// MODULE_BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/JSONExamples.java 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.util.Log;

import java.util.Map;

import org.json.JSONException;
import org.json.JSONObject;

import com.couchbase.lite.Array;
import com.couchbase.lite.Blob;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableArray;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.Result;
import com.couchbase.lite.SelectResult;


public class JSONExamples {
    private static final String TAG = "SNIPPETS";

    public static final String JSON
        = "[{\"id\":\"1000\",\"type\":\"hotel\",\"name\":\"Hotel Ted\",\"city\":\"Paris\","
        + "\"country\":\"France\",\"description\":\"Undefined description for Hotel Ted\"},"
        + "{\"id\":\"1001\",\"type\":\"hotel\",\"name\":\"Hotel Fred\",\"city\":\"London\","
        + "\"country\":\"England\",\"description\":\"Undefined description for Hotel Fred\"},"
        + "{\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\","
        + "\"country\":\"Australia\",\"description\":\"Undefined description for Hotel Ned\","
        + "\"features\":[\"Cable TV\",\"Toaster\",\"Microwave\"]}]";

    public void jsonArrayExample(Database db) throws CouchbaseLiteException {
        // github tag=tojson-array
        final MutableArray mArray = new MutableArray(JSON); // &lt;.&gt;

        for (int i = 0; i &lt; mArray.count(); i) { <i class="conum" data-value="101"></i><b>(101)</b>
          final Dictionary dict = mArray.getDictionary(i);
          Log.i(TAG, dict.getString("name"));
          db.save(new MutableDocument(dict.getString("id"), dict.toMap()));
        }

        final Array features = db.getDocument("1002").getArray("features"); <i class="conum" data-value="102"></i><b>(102)</b>
        for (Object feature: features.toList()) { Log.i(TAG, feature.toString()); }
        Log.i(TAG, features.toJSON()); <i class="conum" data-value="103"></i><b>(103)</b>
      }

      public void jsonBlobExample(Database db) {
        // github tag=tojson-blob
        final Map&lt;String, ?&gt; thisBlob = db.getDocument("thisdoc-id").toMap();
        if (!Blob.isBlob(thisBlob)) { return; }

        final String blobType = thisBlob.get("content_type").toString();
        final Number blobLength = (Number) thisBlob.get("length");
      }

      public void jsonDictionaryExample(Database db) {
        // github tag=tojson-dictionary
        final MutableDictionary mDict = new MutableDictionary(JSON); <i class="conum" data-value="104"></i><b>(104)</b>
        Log.i(TAG, mDict.toString());

        Log.i(TAG, "Details for: " + mDict.getString("name"));
        for (String key: mDict.getKeys()) {
          Log.i(TAG, key + " =&gt; " + mDict.getValue(key));
        }
    }

    public void jsonDocumentExample(Database srcDb, Database dstDb) throws CouchbaseLiteException {
        // github tag=tojson-document
        final Query listQuery = QueryBuilder
        .select(SelectResult.expression(Meta.id).as("metaId"))
        .from(DataSource.database(srcDb));

        for (Result row: listQuery.execute()) {
          final String thisId = row.getString("metaId");

          final String json = srcDb.getDocument(thisId).toJSON(); <i class="conum" data-value="105"></i><b>(105)</b>
          Log.i(TAG, "JSON String = " + json);

          final MutableDocument hotelFromJSON = new MutableDocument(thisId, json); <i class="conum" data-value="106"></i><b>(106)</b>

          dstDb.save(hotelFromJSON);

          for (Map.Entry entry: dstDb.getDocument(thisId).toMap().entrySet()) {
            Log.i(TAG, entry.getKey() + " =&gt; " + entry.getValue());
          } <i class="conum" data-value="107"></i><b>(107)</b>
        }
      }


    public void jsonQueryExample(Query query) throws CouchbaseLiteException, JSONException {
        for (Result row: query.execute()) {

            // get the result into a JSON String
            final String jsonString = row.toJSON();

            final JSONObject thisJsonObj = new JSONObject(jsonString);

            // Use Json Object to populate Native object
            // Use Codable class to unpack JSON data to native object
            final Hotel thisHotel = new Hotel(
                "this hotel",
                "Ghana, West Africa",
                thisJsonObj.getString("city"),
                thisJsonObj.getString("name"),
                thisJsonObj.getString("type"),
                thisJsonObj.getString("id"));
        }
    }
}



// MODULE_END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/JSONExamples.java </code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="data-types"><a class="anchor" href="#data-types"></a>Data Types</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="scalars"><a class="anchor" href="#scalars"></a>Scalars</h3>
<div class="paragraph">
<p>The <code>Document</code> class offers a set of property accessors for various scalar types, including boolean, integers, floating-point and strings.
These accessors take care of converting to/from JSON encoding, and make sure you get the type you&#8217;re expecting.</p>
</div>
<div class="paragraph">
<p>So your document content may well comprise one or more supporting data types such as:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Double</p>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enumerator</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HashCode</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dictionary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Represents a read-only key-value pair collection</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MutableDictionary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Represents a writeable key-value pair collection</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Represents a readonly ordered collection of objects</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MutableArray</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Represents a writeable collection of objects</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Blob</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Represents an arbitrary piece of binary data</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Fleece data encoding</div>
<div class="paragraph">
<p>Care should be taken when storing and recovering data in a document or converting that document to JSON and back.<br>
Data encoding (Fleece) can result in <code>Long</code> values being converted to <code>Float</code> instead of <code>Double</code>.<br>
Interpreting data as boolean can also give inconsistent results.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="date-accessors"><a class="anchor" href="#date-accessors"></a>Date accessors</h3>
<div class="paragraph">
<p>As a convenience Couchbase Lite offers <em>Date</em> accessors.
Dates are a common data type, but JSON doesn&#8217;t natively support them, so the convention is to store them as strings in ISO-8601 format.</p>
</div>
<div id="ex-date-getter" class="exampleblock">
<div class="title">Example 1. Date Getter</div>
<div class="content">
<div class="paragraph">
<p>This example sets the date on the <code>createdAt</code> property and reads it back using the <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-android/com/couchbase/lite/Document.html#getDate-java.lang.String-">Document.getDate()</a> accessor method.</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset7_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset7_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset7_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">doc.setValue("createdAt", Date())
val date = doc.getDate("createdAt")</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset7_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">newTask.setValue("createdAt", new Date());
Date date = newTask.getDate("createdAt");</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-dictionaries"><a class="anchor" href="#using-dictionaries"></a>Using Dictionaries</h3>
<div class="ulist">
<div class="title">API References</div>
<ul>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-android/com/couchbase/lite/Dictionary.html">Dictionary</a></p>
</li>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-android/com/couchbase/lite/MutableDictionary.html">MutableDictionary</a></p>
</li>
</ul>
</div>
<div id="ex-dict" class="exampleblock">
<div class="title">Example 2. Read Only</div>
<div class="content">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset8_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset8_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset8_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">    // NOTE: No error handling, for brevity (see getting started)
    val document = database!!.getDocument("doc1")

    // Getting a dictionary from the document's properties
    val dict = document?.getDictionary("address")

    // Access a value with a key from the dictionary
    val street = dict?.getString("street")

    // Iterate dictionary
    for (key in dict!!.keys) {
        println("Key ${key} = ${dict.getValue(key)}")
    }

// Create a mutable copy
val mutable_Dict = dict.toMutable()</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset8_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">// NOTE: No error handling, for brevity (see getting started)
Document document = database.getDocument("doc1");

// Getting a dictionary from the document's properties
Dictionary dict = document.getDictionary("address");

// Access a value with a key from the dictionary
String street = dict.getString("street");

// Iterate dictionary
for (String key : dict) {
    dict.getValue(key);
    Log.i("x", "Key %s, = %s", key, dict.getValue(key));
}

// Create a mutable copy
MutableDictionary mutable_Dict = dict.toMutable();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="ex-mutdict" class="exampleblock">
<div class="title">Example 3. Mutable</div>
<div class="content">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset9_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset9_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset9_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">// NOTE: No error handling, for brevity (see getting started)

// Create a new mutable dictionary and populate some keys/values
val mutable_dict = MutableDictionary()
mutable_dict.setString("street", "1 Main st.")
mutable_dict.setString("city", "San Francisco")

// Add the dictionary to a document's properties and save the document
val mutable_doc = MutableDocument("doc1")
mutable_doc.setDictionary("address", mutable_dict)
database!!.save(mutable_doc)</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset9_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">// NOTE: No error handling, for brevity (see getting started)

// Create a new mutable dictionary and populate some keys/values
MutableDictionary mutable_dict = new MutableDictionary();
mutable_dict.setString("street", "1 Main st.");
mutable_dict.setString("city", "San Francisco");

// Add the dictionary to a document's properties and save the document
MutableDocument mutable_doc = new MutableDocument("doc1");
mutable_doc.setDictionary("address", mutable_dict);
database.save(mutable_doc);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-arrays"><a class="anchor" href="#using-arrays"></a>Using Arrays</h3>
<div class="ulist">
<div class="title">API References</div>
<ul>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-android/com/couchbase/lite/Array.html">Array</a></p>
</li>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-android/com/couchbase/lite/MutableArray.html">MutableArray</a></p>
</li>
</ul>
</div>
<div id="ex-array" class="exampleblock">
<div class="title">Example 4. Read Only</div>
<div class="content">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset10_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset10_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset10_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">// NOTE: No error handling, for brevity (see getting started)

val document = database?.getDocument("doc1")

// Getting a phones array from the document's properties
val array = document?.getArray("phones")

// Get element count
val count = array?.count()

// Access an array element by index
val phone = array?.getString(1)

// Iterate array
for ( (index, item) in array!!) {
    println("Row  ${index} = ${item}")
}

// Create a mutable copy
val mutable_array = array.toMutable()</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset10_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">// NOTE: No error handling, for brevity (see getting started)

Document document = database.getDocument("doc1");

// Getting a phones array from the document's properties
Array array = document.getArray("phones");

// Get element count
int count = array.count();

// Access an array element by index
if (count &gt;= 0) { String phone = array.getString(1); }

// Iterate dictionary
for (int i = 0; i &lt; count; i++)
{
    Log.i("tag", "Item %d = %s", i, array.getString(i));
}

// Create a mutable copy
MutableArray mutable_array = array.toMutable();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="ex-mutarray" class="exampleblock">
<div class="title">Example 5. Mutable</div>
<div class="content">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset11_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset11_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset11_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">// NOTE: No error handling, for brevity (see getting started)

// Create a new mutable array and populate data into the array
val mutable_array = MutableArray()
mutable_array.addString("650-000-0000")
mutable_array.addString("650-000-0001")

// Set the array to document's properties and save the document
val mutable_doc = MutableDocument("doc1")
mutable_doc.setArray("phones", mutable_array)
database?.save(mutable_doc)</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset11_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">// NOTE: No error handling, for brevity (see getting started)

// Create a new mutable array and populate data into the array
MutableArray mutable_array = new MutableArray();
mutable_array.addString("650-000-0000");
mutable_array.addString("650-000-0001");

// Set the array to document's properties and save the document
MutableDocument mutable_doc = new MutableDocument("doc1");
mutable_doc.setArray("phones", mutable_array);
database.save(mutable_doc);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-blobs"><a class="anchor" href="#using-blobs"></a>Using Blobs</h3>
<div class="paragraph">
<p>For more on working with blobs&#8201;&#8212;&#8201;see <a href="blob.html" class="page">Blobs</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="document-initializers"><a class="anchor" href="#document-initializers"></a>Document Initializers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following methods/initializers can be used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-android/com/couchbase/lite/MutableDocument.html#s:18CouchbaseLiteSwift15MutableDocumentMutableDocument--">MutableDocument()</a> initializer can be used to create a new document where the document ID is randomly generated by the database.</p>
</li>
<li>
<p>The <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-android/com/couchbase/lite/MutableDocument.html#s:18CouchbaseLiteSwift15MutableDocument}MutableDocument-java.lang.String-">MutableDocument(String id)</a> initializer can be used to create a new document with a specific ID.</p>
</li>
<li>
<p>The <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-android/com/couchbase/lite/Database.html#getDocument-java.lang.String-">Database.getDocument()</a> method can be used to get a document.
If it doesn&#8217;t exist in the database, it will return <code>null</code>.
This method can be used to check if a document with a given ID already exists in the database.</p>
</li>
</ul>
</div>
<div id="ex-persists-doc" class="exampleblock">
<div class="title">Example 6. Persist a document</div>
<div class="content">
<div class="paragraph">
<p>The following code example creates a document and persists it to the database.</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset12_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset12_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset12_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">val doc = MutableDocument()
doc.let {
    it.setString("type", "task")
    it.setString("owner", "todo")
    it.setDate("createdAt", Date())
}
database.save(doc)</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset12_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">MutableDocument newTask = new MutableDocument();
newTask.setString("type", "task");
newTask.setString("owner", "todo");
newTask.setDate("createdAt", new Date());
try {
    database.save(newTask);
} catch (CouchbaseLiteException e) {
    Log.e(TAG, e.toString());
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mutability"><a class="anchor" href="#mutability"></a>Mutability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, when a document is read from the database it is immutable.
The <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-android/com/couchbase/lite/Document.html#toMutable--">`Document.toMutable()</a> method should be used to create an instance of the document which can be updated.</p>
</div>
<div id="ex-update-doc" class="exampleblock">
<div class="title">Example 7. Make a mutable document</div>
<div class="content">
<div class="paragraph">
<p>Changes to the document are persisted to the database when the <code>save</code> method is called.</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset13_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset13_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset13_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">database.getDocument("xyz")?.toMutable()?.let {
    it.setString("name", "apples")
    database.save(it)
}</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset13_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">Document document = database.getDocument("xyz");
MutableDocument mutableDocument = document.toMutable();
mutableDocument.setString("name", "apples");
try {
    database.save(mutableDocument);
} catch (CouchbaseLiteException e) {
    Log.e(TAG, e.toString());
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Any user change to the value of reserved keys (<code>_id</code>, <code>_rev</code> or <code>_deleted</code>) will be detected when a document is saved and will result in an exception (Error Code 5&#8201;&#8212;&#8201;<code>CorruptRevisionData</code>)&#8201;&#8212;&#8201;see also <a href="#lbl-doc-constraints">Document Constraints</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="checking-a-document-for-properties"><a class="anchor" href="#checking-a-document-for-properties"></a>Checking a Document for properties</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To check whether a given pro
perty exists in the document, you should use the <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-android/com/couchbase/lite/Document.html#contains-java.lang.String-">`Document.Contains(String key)</a> method.</p>
</div>
<div class="paragraph">
<p>If the property doesn&#8217;t exist in the document it will return the default value for that getter method (0 for <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-android/com/couchbase/lite/Document.html#getInt-java.lang.String-">Document.getInt()</a> 0.0 for <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-android/com/couchbase/lite/Document.html#getFloat-java.lang.String-">Document.getFloat()</a> etc.).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="batch-operations"><a class="anchor" href="#batch-operations"></a>Batch operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you&#8217;re making multiple changes to a database at once, it&#8217;s faster to group them together.
The following example persists a few documents in batch.</p>
</div>
<div id="ex-batch-ops" class="exampleblock">
<div class="title">Example 8. Batch operations</div>
<div class="content">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset14_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset14_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset14_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">database.inBatch(UnitOfWork {
    for (i in 0..9) {
        val doc = MutableDocument()
        doc.let {
            it.setValue("type", "user")
            it.setValue("name", "user $i")
            it.setBoolean("admin", false)
        }
        Log.i(TAG, "saved user document: ${doc.getString("name")}")
    }
})</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset14_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">try {
    database.inBatch) -&gt; {         for (int i = 0; i &lt; 10; i++) {             MutableDocument doc = new MutableDocument();             doc.setValue("type", "user");             doc.setValue("name", "user " + i);             doc.setBoolean("admin", false);             try {                 database.save(doc);             } catch (CouchbaseLiteException e) {                 Log.e(TAG, e.toString(;
            }
            Log.i(TAG, String.format("saved user document %s", doc.getString("name")));
        }
    });
} catch (CouchbaseLiteException e) {
    Log.e(TAG, e.toString());
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>At the <strong>local</strong> level this operation is still transactional: no other <code>Database</code> instances, including ones managed by the replicator can make changes during the execution of the block, and other instances will not see partial changes.
But Couchbase Mobile is a distributed system, and due to the way replication works, there&#8217;s no guarantee that Sync Gateway or other devices will receive your changes all at once.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="document-change-events"><a class="anchor" href="#document-change-events"></a>Document change events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s also possible to register for document changes.
The following example registers for changes to the document with ID <code>user.john</code> and prints the <code>verified_account</code> property.</p>
</div>
<div id="ex-doc-events" class="exampleblock">
<div class="title">Example 9. Document change events</div>
<div class="content">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset15_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset15_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset15_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">database.addDocumentChangeListener("user.john") { change -&gt;
    database.getDocument(change.documentID)?.let {
        Toast.makeText(
            context,
            "Status: ${it.getString("verified_account")}",
            Toast.LENGTH_SHORT
        ).show()
    }
}</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset15_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">database.addDocumentChangeListener(
    "user.john",
    change -&gt; {
        Document doc = database.getDocument(change.getDocumentID());
        if (doc != null) {
            Toast.makeText(context, "Status: " + doc.getString("verified_account"), Toast.LENGTH_SHORT).show();
        }
    });</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-kotlin-flows-and-livedata"><a class="anchor" href="#using-kotlin-flows-and-livedata"></a>Using Kotlin Flows and LiveData</h3>
<div class="paragraph">
<p>Kotlin users can also take advantage of Flows and LiveData to monitor for changes.</p>
</div>
<div class="paragraph">
<p>The following methods show how to watch for document changes in a given database or for changes to a specific document.</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset16_database-changes"></a>Database Changes</p>
</li>
<li>
<p><a id="tabset16_document-changes"></a>Document Changes</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset16_database-changes">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/FlowExamples.kt#L37-L40">    val dbChanges: LiveData&lt;MutableList&lt;String&gt;&gt; = argDb.databaseChangeFlow()
        .map { it.documentIDs }
        .asLiveData()</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset16_document-changes">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/FlowExamples.kt#L43-L50">    val docChanges: LiveData&lt;DocumentChange?&gt; = argDb.documentChangeFlow("1001")
        .map {
            it.takeUnless {
                it.database.getDocument(it.documentID)?.getString("owner").equals(argDocOwner)
            }
        }
        .asLiveData()</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="document-expiration"><a class="anchor" href="#document-expiration"></a>Document Expiration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Document expiration allows users to set the expiration date to a document.
When the document is expired, the document will be purged from the database.
The purge will not be replicated to Sync Gateway.</p>
</div>
<div id="ex-set-doc-exp" class="exampleblock">
<div class="title">Example 10. Set document expiration</div>
<div class="content">
<div class="paragraph">
<p>This example sets the TTL for a document to 5 minutes from the current time.</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset17_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset17_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset17_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">// Purge the document one day from now
database.setDocumentExpiration(
    "doc123",
    Date(Instant.now().plus(1, ChronoUnit.DAYS).toEpochMilli())
)

// Reset expiration
database.setDocumentExpiration("doc1", null)

// Query documents that will be expired in less than five minutes
val query = QueryBuilder
    .select(SelectResult.expression(Meta.id))
    .from(DataSource.database(database))
    .where(
        Meta.expiration.lessThan(
            Expression.longValue(Instant.now().plus(5, ChronoUnit.MINUTES).toEpochMilli())
        )
    )</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset17_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">// Purge the document one day from now
Instant ttl = Instant.now().plus(1, ChronoUnit.DAYS);
database.setDocumentExpiration("doc123", new Date(ttl.toEpochMilli()));

// Reset expiration
database.setDocumentExpiration("doc1", null);

// Query documents that will be expired in less than five minutes
Instant fiveMinutesFromNow = Instant.now().plus(5, ChronoUnit.MINUTES);
Query query = QueryBuilder
    .select(SelectResult.expression(Meta.id))
    .from(DataSource.database(database))
    .where(Meta.expiration.lessThan(Expression.doubleValue(fiveMinutesFromNow.toEpochMilli())));</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lbl-doc-constraints"><a class="anchor" href="#lbl-doc-constraints"></a>Document Constraints</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Couchbase Lite APIs do not explicitly disallow the use of attributes with the underscore prefix at the top level of document.
This is to facilitate the creation of documents for use either in <em>local only</em> mode where documents are not synced, or when used exclusively in peer-to-peer sync.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
"_id", :"_rev" and "_sequence" are reserved keywords and must not be used as top-level attributes&#8201;&#8212;&#8201;see <a href="#res-keys">Example 11</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Users are cautioned that any attempt to sync such documents to Sync Gateway will result in an error.
To be future proof, you are advised to avoid creating such documents.
Use of these attributes for user-level data may result in undefined system behavior.</p>
</div>
<div class="paragraph">
<p>For more guidance&#8201;&#8212;&#8201;see: <a href="../../../sync-gateway/current/data-modeling.html" class="page">Sync Gateway - data modeling guidelines</a></p>
</div>
<div id="res-keys" class="exampleblock">
<div class="title">Example 11. Reserved Keys List</div>
<div class="content">
<div class="ulist">
<ul>
<li>
<p>_attachments</p>
</li>
<li>
<p>_deleted <sup class="footnote" id="_footnote_fn1">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</li>
<li>
<p>_id <sup class="footnoteref">[<a class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</li>
<li>
<p>_removed</p>
</li>
<li>
<p>_rev <sup class="footnoteref">[<a class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</li>
<li>
<p>_sequence</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lbl-json-data"><a class="anchor" href="#lbl-json-data"></a>Working with JSON Data</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">In this section</dt>
<dd>
<p><a href="#lbl-array">Arrays</a>
| <a href="#lbl-blob">Blobs</a>
| <a href="#lbl-dictionary">Dictionaries</a>
| <a href="#lbl-document">Documents</a>
| <a href="#lbl-result">Query Results as JSON</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>toJSON()</code> typed-accessor means you can easily work with JSON data, native and Couchbase Lite objects.</p>
</div>
<div class="sect2">
<h3 id="lbl-array"><a class="anchor" href="#lbl-array"></a>Arrays</h3>
<div class="paragraph">
<p>Convert an <code>ArrayObject</code> to and from JSON using the <code>toJSON()</code> and <code>toArray</code> methods&#8201;&#8212;&#8201;see: <a href="#ex-array">Example 4</a>.</p>
</div>
<div class="paragraph">
<p>Additionally you can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initialize a 'MutableArrayObject' using data supplied as a JSON string.
This is done using the <code>init(json)</code> constructor-- see: <a href="#ex-array">Example 4</a></p>
</li>
<li>
<p>Convert an <code>ArrayFragment</code> object to a JSON String</p>
</li>
<li>
<p>Set data with a JSON string using <code>setJSON()</code></p>
</li>
</ul>
</div>
<div id="ex-array" class="exampleblock">
<div class="title">Example 12. Arrays as JSON strings</div>
<div class="content">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset18_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset18_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset18_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">// github tag=tojson-array
val mArray = MutableArray(JSON) <i class="conum" data-value="1"></i><b>(1)</b>
for (i in 0 until mArray.count()) {
    mArray.getDictionary(i)?.apply {
        Log.i(TAG, getString("name") ?: "unknown")
        db.save(MutableDocument(getString("id"), toMap()))
    } <i class="conum" data-value="2"></i><b>(2)</b>
}

db.getDocument("1002")?.getArray("features")?.apply {
    for (feature in toList()) {
        Log.i(TAG, "$feature")
    } <i class="conum" data-value="3"></i><b>(3)</b>
    Log.i(TAG, toJSON())
} <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset18_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">// github tag=tojson-array
final MutableArray mArray = new MutableArray(JSON); <i class="conum" data-value="1"></i><b>(1)</b>

for (int i = 0; i &lt; mArray.count(); i++) { <i class="conum" data-value="2"></i><b>(2)</b>
  final Dictionary dict = mArray.getDictionary(i);
  Log.i(TAG, dict.getString("name"));
  db.save(new MutableDocument(dict.getString("id"), dict.toMap()));
}

final Array features = db.getDocument("1002").getArray("features"); <i class="conum" data-value="3"></i><b>(3)</b>
for (Object feature: features.toList()) { Log.i(TAG, feature.toString()); }
Log.i(TAG, features.toJSON()); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Initialize array with JSON string</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create and save new document using the array</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Get native array object from new doc and print its elements</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Get an array from the document as a JSON string</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="lbl-blob"><a class="anchor" href="#lbl-blob"></a>Blobs</h3>
<div class="paragraph">
<p>Convert a <code>Blob</code> to JSON using the <code>toJSON</code> method&#8201;&#8212;&#8201;see <a href="#ex-blob">Example 13</a>.</p>
</div>
<div class="paragraph">
<p>You can also check whether a given dictionary object is a blob, or not, using <code>isBlob()</code>&#8201;&#8212;&#8201;again, see <a href="#ex-blob">Example 13</a>.</p>
</div>
<div class="paragraph">
<p>Note that the blob object must first be saved to the database (generating required metadata) before you can use the <code>toJSON</code> method.</p>
</div>
<div id="ex-blob" class="exampleblock">
<div class="title">Example 13. Blobs as JSON strings</div>
<div class="content">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset19_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset19_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset19_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">// github tag=tojson-blob
val thisBlob = db.getDocument("thisdoc-id")!!.toMap()
if (!Blob.isBlob(thisBlob)) {
  return
}
val blobType = thisBlob["content_type"].toString()
val blobLength = thisBlob["length"] as Number?</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset19_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">// github tag=tojson-blob
final Map&lt;String, ?&gt; thisBlob = db.getDocument("thisdoc-id").toMap();
if (!Blob.isBlob(thisBlob)) { return; }

final String blobType = thisBlob.get("content_type").toString();
final Number blobLength = (Number) thisBlob.get("length");</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See also: <a href="blob.html" class="page">Blobs</a></p>
</div>
</div>
<div class="sect2">
<h3 id="lbl-dictionary"><a class="anchor" href="#lbl-dictionary"></a>Dictionaries</h3>
<div class="paragraph">
<p>Convert a <code>DictionaryObject</code> to and from JSON using the <code>toJSON</code> and <code>toDictionary</code> methods&#8201;&#8212;&#8201;see <a href="#ex-dictionary">Example 14</a>.</p>
</div>
<div class="paragraph">
<p>Additionally you can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initialize a 'MutableDictionaryObject' using data supplied as a JSON string.
This is done using the <code>init(json)</code> constructor-- see: <a href="#ex-dictionary">Example 14</a></p>
</li>
<li>
<p>Set data with a JSON string using <code>setJSON()</code></p>
</li>
</ul>
</div>
<div id="ex-dictionary" class="exampleblock">
<div class="title">Example 14. Dictionaries as JSON strings</div>
<div class="content">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset20_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset20_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset20_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">// github tag=tojson-dictionary
val mDict = MutableDictionary(JSON) <i class="conum" data-value="1"></i><b>(1)</b>
Log.i(TAG, "$mDict")
Log.i(TAG, "Details for: ${mDict.getString("name")}")
for (key in mDict.keys) {
  Log.i(TAG, key + " =&gt; " + mDict.getValue(key))
}</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset20_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">// github tag=tojson-dictionary
final MutableDictionary mDict = new MutableDictionary(JSON); <i class="conum" data-value="1"></i><b>(1)</b>
Log.i(TAG, mDict.toString());

Log.i(TAG, "Details for: " + mDict.getString("name"));
for (String key: mDict.getKeys()) {
  Log.i(TAG, key + " =&gt; " + mDict.getValue(key));
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set the dictionary using a JSON string</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="lbl-document"><a class="anchor" href="#lbl-document"></a>Documents</h3>
<div class="paragraph">
<p>Convert a <code>Document</code> to and from JSON strings using the <code>toJSON()</code> and <code>setJSON()</code> methods&#8201;&#8212;&#8201;see <a href="#ex-document">Example 15</a>.</p>
</div>
<div class="paragraph">
<p>Additionally you can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initialize a 'MutableDocument' using data supplied as a JSON string.
This is done using the <code>init(json)</code> and-or <code>init(id: json:)</code> constructor-- see: <a href="#ex-document">Example 15</a></p>
</li>
<li>
<p>Set data with a JSON string using <code>setJSON()</code></p>
</li>
</ul>
</div>
<div id="ex-document" class="exampleblock">
<div class="title">Example 15. Documents as JSON strings</div>
<div class="content">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset21_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset21_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset21_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">QueryBuilder
.select(SelectResult.expression(Meta.id).as("metaId"))
.from(DataSource.database(srcDb))
.execute()
.forEach {
  it.getString("metaId")?.let { thisId -&gt;
    srcDb.getDocument(thisId)?.toJSON()?.let { json -&gt; <i class="conum" data-value="1"></i><b>(1)</b>
      Log.i(TAG, "JSON String = $json")
      val hotelFromJSON = MutableDocument(thisId, json) <i class="conum" data-value="2"></i><b>(2)</b>
      dstDb.save(hotelFromJSON)
      dstDb.getDocument(thisId)?.toMap()?.forEach { e -&gt;
        Log.i(TAG, "$e.key =&gt; $e.value")
      } <i class="conum" data-value="3"></i><b>(3)</b>
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset21_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">// github tag=tojson-document
final Query listQuery = QueryBuilder
.select(SelectResult.expression(Meta.id).as("metaId"))
.from(DataSource.database(srcDb));

for (Result row: listQuery.execute()) {
  final String thisId = row.getString("metaId");

  final String json = srcDb.getDocument(thisId).toJSON(); <i class="conum" data-value="1"></i><b>(1)</b>
  Log.i(TAG, "JSON String = " + json);

  final MutableDocument hotelFromJSON = new MutableDocument(thisId, json); <i class="conum" data-value="2"></i><b>(2)</b>

  dstDb.save(hotelFromJSON);

  for (Map.Entry entry: dstDb.getDocument(thisId).toMap().entrySet()) {
    Log.i(TAG, entry.getKey() + " =&gt; " + entry.getValue());
  } <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get a document as a JSON string</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Initialize a MutableDocument using the JSON string and save to a separate database</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Retrieve the document created from JSON and print values</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="lbl-result"><a class="anchor" href="#lbl-result"></a>Query Results as JSON</h3>
<div class="paragraph">
<p>Convert a <code>Query Result</code> to JSON using its <code>toJSON()</code> accessor method.</p>
</div>
<div id="ex-json" class="exampleblock">
<div class="title">Example 16. Using JSON Results</div>
<div class="content">
<div class="paragraph">
<p>Use <a href="https://ibsoln.github.io/api/mobile/3.0.0/couchbase-lite-android/com/couchbase/lite/Result.html#toJSON--">Result.toJSON()</a> to transform your result string into a JSON string, which can easily be serialized or used as required in your application. See <<ex-json>> for a working example.</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset22_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset22_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset22_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.kt">// Uses Jackson JSON processor
val mapper = ObjectMapper()
val hotels: ArrayList&lt;Hotel&gt; = ArrayList()

for (result in listQuery.execute()) {

    // Get result as JSON string
    val json = result.toJSON() <i class="conum" data-value="1"></i><b>(1)</b>

    // Get Hashmap from JSON string
    val dictFromJSONstring = mapper.readValue(json, HashMap::class.java) <i class="conum" data-value="2"></i><b>(2)</b>

    // Use created hashmap
    val hotelId = dictFromJSONstring["id"].toString() //
    val hotelType = dictFromJSONstring["type"].toString()
    val hotelname = dictFromJSONstring["name"].toString()


    // Get custom object from JSON string
    val thisHotel = mapper.readValue(json, Hotel::class.java) <i class="conum" data-value="3"></i><b>(3)</b>
    hotels.add(thisHotel)
}</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset22_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/codesnippet_collection.java">// Uses Jackson JSON processor

ArrayList&lt;Hotel&gt; hotels = new ArrayList&lt;Hotel&gt;();
HashMap&lt;String, Object&gt; dictFromJSONstring;
for (Result result : listQuery.execute()) {

  // Get result as JSON string
  String thisJsonString = result.toJSON(); <i class="conum" data-value="1"></i><b>(1)</b>

  // Get Java  Hashmap from JSON string
  HashMap&lt;String, Object&gt; dictFromJSONstring =
          mapper.readValue(thisJsonString, HashMap.class); <i class="conum" data-value="2"></i><b>(2)</b>


  // Use created hashmap
  String hotelId = dictFromJSONstring.get("id").toString();
  String hotelType = dictFromJSONstring.get("type").toString();
  String hotelname = dictFromJSONstring.get("name").toString();


  // Get custom object from JSON string
  Hotel thisHotel =
          mapper.readValue(thisJsonString, Hotel.class); <i class="conum" data-value="3"></i><b>(3)</b>
  hotels.add(thisHotel);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the Query result as a JSON string&#8201;&#8212;&#8201;see <a href="#ex-json-format">JSON String Format</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Get a native object from the JSON string</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Populate your custom object from the dictionary created from JSON data</td>
</tr>
</table>
</div>
<div id="ex-json-format" class="paragraph">
<div class="title">JSON String Format</div>
<p>If your query selects ALL then the JSON format will be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-JSON hljs" data-lang="JSON">{
  database-name: {
    key1: "value1",
    keyx: "valuex"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If your query selects a sub-set of available properties then the JSON format will be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-JSON hljs" data-lang="JSON">{
  key1: "value1",
  keyx: "valuex"
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="related-content"><a class="anchor" href="#related-content"></a>Related Content</h2>
<div class="sectionbody">
<div class="card-row three-column-row">
<div class="sect5 column">
<h6 id=""><a class="anchor" href="#"></a></h6>
<div class="ulist">
<div class="title">How to . . .</div>
<ul>
<li>
<p><a href="gs-prereqs.html" class="page">Prerequisites</a></p>
</li>
<li>
<p><a href="gs-install.html" class="page">Install</a></p>
</li>
<li>
<p><a href="gs-build.html" class="page">Build and Run</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-2"><a class="anchor" href="#-2"></a></h6>
<div class="ulist">
<div class="title">Learn more . . .</div>
<ul>
<li>
<p><a href="database.html" class="page">Databases</a></p>
</li>
<li>
<p><a href="document.html" class="page">Documents</a></p>
</li>
<li>
<p><a href="blob.html" class="page">Blobs</a></p>
</li>
<li>
<p><a href="replication.html" class="page">Remote Sync Gateway</a></p>
</li>
<li>
<p><a href="conflict.html" class="page">Handling Data Conflicts</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-3"><a class="anchor" href="#-3"></a></h6>
<div class="paragraph">
<div class="title">Dive Deeper . . .</div>
<p><a href="https://forums.couchbase.com/c/mobile/14">Mobile Forum</a> |
<a href="https://blog.couchbase.com/category/couchbase-mobile/?ref=blog-menu">Blog</a> |
<a href="https://docs.couchbase.com/tutorials/">Tutorials</a></p>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Any change to this reserved key will be detected when it is saved and will result in a Couchbase exception (Error Code 5&#8201;&#8212;&#8201;`CorruptRevisionData`)
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase">
          </a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <svg  width="14" height="14" viewBox="0 0 32.1 26.1"> <path id="twitter" class="cls-1" d="M32,7.1a11.836,11.836,0,0,1-3.8,1,6.462,6.462,0,0,0,2.9-3.6,12.606,12.606,0,0,1-4.2,1.6A6.492,6.492,0,0,0,22.1,4a6.594,6.594,0,0,0-6.6,6.6,7.719,7.719,0,0,0,.2,1.5A18.458,18.458,0,0,1,2.2,5.2a6.294,6.294,0,0,0-.9,3.3A6.765,6.765,0,0,0,4.2,14a6.109,6.109,0,0,1-3-.8v.1a6.543,6.543,0,0,0,5.3,6.4,4.678,4.678,0,0,1-1.7.2,4.869,4.869,0,0,1-1.2-.1,6.679,6.679,0,0,0,6.1,4.6,12.917,12.917,0,0,1-8.2,2.8,9.151,9.151,0,0,1-1.6-.1,18.438,18.438,0,0,0,10.1,3c12.1,0,18.7-10,18.7-18.7v-.8A13.336,13.336,0,0,0,32,7.2Z" transform="translate(0.1 -4)"/></svg>
            <a href="https://twitter.com/couchbase" class="icon">
              Twitter
            </a>
          </li>
          <li>
          <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="linkedin" class="cls-1" d="M29,0H3A3.076,3.076,0,0,0,0,3V29a3.009,3.009,0,0,0,3,3H29a2.946,2.946,0,0,0,3-3V3A3.009,3.009,0,0,0,29,0ZM12,26H8V12h4ZM10,10a2,2,0,1,1,2-2A2.006,2.006,0,0,1,10,10ZM26,26H22V18a2,2,0,0,0-4,0v8H14V12h4v2.5c.8-1.1,2.1-2.5,3.5-2.5A4.736,4.736,0,0,1,26,17Z"/></svg>
              <a href="https://www.linkedin.com/company/couchbase" class="icon">
             Linkedin
            </a>
          </li>
          <li>
            <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="facebook" class="cls-1" d="M29,0H3A2.652,2.652,0,0,0,0,3V29a2.652,2.652,0,0,0,3,3H16V18H12V14h4V12a6.452,6.452,0,0,1,6-6h4v4H22a2.151,2.151,0,0,0-2,2v2h6l-1,4H20V32h9a2.652,2.652,0,0,0,3-3V3A2.652,2.652,0,0,0,29,0Z"/></svg>
            <a href="https://www.facebook.com/Couchbase" class="icon">
            Facebook
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <div class="footer-terms-copyright">
          <span> 2022 Couchbase, Inc. Couchbase, Couchbase Lite and the Couchbase logo are registered trademarks of Couchbase, Inc.</span>
      </div>
      <div class="footer-terms-links">
        <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
        <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
        <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
        <a href="https://www.couchbase.com/support-policy">Support Policy</a>
        <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
      </div>
    </div>
  </div>
</footer>
<template id="run-code-panel">
<div class="action-panel">
  <form class="action-panel-control" method="POST" action="https://couchbase.live/run" target="run-code-output">
    <input type="hidden" name="lang">
    <input type="hidden" name="code">
    <input type="hidden" name="from" value="docs">
    <div class="controls">
      <button class="control-button rerun" type="submit"><i class="fas fa-redo"></i></button>
      <span class="shell-name control-label">Output</span>
      <button class="control-button close"><i class="fas fa-times"></i> Close</button>
    </div>
  </form>
  <iframe class="run-code-output" name="run-code-output"></iframe>
</div>
</template>
<script id="site-script" src="../../../_/js/site.js"></script>
<script defer src="../../../_/js/vendor/fontawesome-icon-defs.js"></script>
<script defer src="../../../_/js/vendor/fontawesome.js" data-search-pseudo-elements="true"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
</body>
</html>
