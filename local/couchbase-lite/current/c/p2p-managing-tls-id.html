<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv=content-security-policy content="default-src 'none'; script-src 'self' 'unsafe-eval' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; font-src 'self' https://fonts.gstatic.com; frame-src 'self' https:; img-src 'self' data: https:; connect-src 'self' https:; worker-src blob:;">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Managing TLS Identities | Couchbase Docs</title>
<link rel="canonical" href="http://127.0.0.1:5000/couchbase-lite/current/c/p2p-managing-tls-id.html">
<link rel="stylesheet" href="../../../_/css/site.css">
<script src="../../../_/js/vendor/jquery.js"></script>
<meta name="description" content="Couchbase Lite - this content covers how to manage TLS identities using Couchbase Lite">
<link rel="schema.dcterms" href="https://purl.org/dc/terms/">


<meta name="dcterms.subject" content="couchbase-lite">
<meta name="dcterms.identifier" content="3.0">
<meta name="page-url" content="/couchbase-lite/current/c/p2p-managing-tls-id.html">
<meta name="generator" content="Antora 3.0.0-alpha.5">
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
</head>
<body class="article">
<header class="header fixed-top">
  <div class="header-top-row">
      <div class="container">
          <nav class="navbar navbar-expand-md flex-nowrap justify-content-between navbar-new-top">
              <ul class="navbar-brand-list">
                <li class="brand-logo">
                  <a class="navbar-brand" href="https://www.couchbase.com">
                    <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase" />
                  </a>
                </li>
                <li>
                  <a class="navbar-brand cb-documentation" href="http://127.0.0.1:5000/home/index.html">
                    <img src="../../../_/img/cb-documentation.svg" alt="Couchbase Documentation" class="cb-docs" />
                    <img src="../../../_/img/cb-docs-hover.svg" alt="Couchbase Documentation" class="hide cb-hover-docs" />
                  </a>
                </li>
              </ul>
              <button class="navbar-burger" data-target="topbar-menu">
                <span></span>
                <span></span>
                <span></span>
              </button>

          </nav>
      </div>
  </div>
  <div class="header-bottom-row" id="topbar-menu">
    <div class="container">
        <nav  class="navbar navbar-new-bottom">

              <div class="navbar-collapse collapse" id="navbar2">
                <ul class="navbar-nav w-100 justify-content-start">
                  <li class="nav-item">
                    <a href="http://127.0.0.1:5000/home/index.html" class="nav-link">
                      <i class="fas fa-home"></i>
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/server.html">
                      Server
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/mobile.html">
                      Mobile Local
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/cloud.html">
                      Cloud
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/sdk.html">
                      SDKs
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../tutorials/index.html">
                      Tutorials
                      <span class="arrow">
                        <i class="fas fa-arrow-right"></i>
                      </span>
                    </a>
                  </li>
                </ul>
              </div>
              <div class="primary-action">
                <a class="btn btn-primary btn-grey-reverse" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Download'});" href="https://www.couchbase.com/downloads">
                  Downloads
                  <i class="far fa-arrow-to-bottom fa-fw"></i>
                </a>
                <a href="https://cloud.couchbase.com/sign-up" class="btn btn-primary" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Free Trial'});" >
                  Start Free Trial
                  <i class="far fa-cloud fa-fw"></i>
                </a>

              </div>

        </nav>
    </div>
   </div>
</header>
<div class="body container">
<aside class="nav left-sidebar">
  <div class="nav-container">
    <a href="#" class="menu-expand-toggle"><span>Navigation</span><i class="fas fa-times-circle"></i><i class="fas fa-chevron-circle-left"></i></a>
<div class="components">
  <div class="components_group-title">
    <a href="../../../home/mobile.html">Mobile Local</a>
  </div>
  <ul class="components_list">
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Couchbase Lite</span>
        <select class="version_list" data-component="couchbase-lite">
          <option value="3.0" data-url="../index.html" selected>3.0</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0">
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../index.html">Introduction</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../cbl-whatsnew.html">New in 3.0</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../android/quickstart.html">Android</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/kotlin.html">Kotlin</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-n1ql-mobile.html">SQL++ for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-n1ql-mobile-server-diffs.html">SQL++ Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-n1ql-mobile-querybuilder-diffs.html">SQL++ Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Data Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../android/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/3.0.0/couchbase-lite-android/">API References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/3.0.0/couchbase-lite-android-ktx">Kotlin Extensions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../android/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="quickstart.html">C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-downloads.html">Download</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="c_fleece.html">Fleece API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="field-level-encryption.html">Field Level Encryption</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-n1ql-mobile.html">SQL++ for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-n1ql-mobile-server-diffs.html">SQL++ Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="replication.html">Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/3.0.0/couchbase-lite-c/">API&#160;References</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/quickstart.html">.Net</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-n1ql-mobile.html">SQL++ for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-n1ql-mobile-server-diffs.html">SQL++ Mobile - Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-n1ql-mobile-querybuilder-diffs.html">SQL++ Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Data Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/3.0.0/couchbase-lite-net/index.html">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/quickstart.html">Java</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-n1ql-mobile.html">SQL++ for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-n1ql-mobile-server-diffs.html">SQL++ Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-n1ql-mobile-querybuilder-diffs.html">SQL++ Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Data Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/3.0.0/couchbase-lite-java/">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../javascript/quickstart.html">Javascript</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../javascript/ionic.html">Ionic</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../javascript/cordova.html">Cordova</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../javascript/react.html">React</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/quickstart.html">Objective-C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-n1ql-mobile.html">SQL++ for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-n1ql-mobile-server-diffs.html">SQL++ Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-n1ql-mobile-querybuilder-diffs.html">SQL++ Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/3.0.0/couchbase-lite-objc/index.html">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-crashes.html">Troubleshooting Crashes</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/quickstart.html">Swift</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-n1ql-mobile.html">SQL++ for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-n1ql-mobile-server-diffs.html">SQL++ Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-n1ql-mobile-querybuilder-diffs.html">SQL++ Querybuilder Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#swift:landing-replications.adoc">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/3.0.0/couchbase-lite-swift/index.html">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-crashes.html">Troubleshooting Crashes</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
</ul>
      </div>
    </li>
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Sync Gateway</span>
        <select class="version_list" data-component="sync-gateway">
          <option value="3.0" data-url="../../../sync-gateway/current/index.html" selected>3.0</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0">
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/introduction.html">Introduction</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/whatsnew.html"><strong><em>New in 3.0</em></strong></a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/index.html">Quick Links</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-prepare.html">Prepare</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-verify-install.html">Verify</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/data-modeling.html">Data Modeling</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Configuration</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-bootstrap.html">Bootstrap</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-database.html">Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-db-security.html">Database Security</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-access-control.html">Access Control</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-import-filter.html">Import Filter</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-isgr.html">Inter-Sync&#160;Gateway Replication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-properties-legacy.html">Legacy Pre-3.0 Configuration</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-javascript-functions.html">Javascript Functions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-environment-variables.html">Environment Variables</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Security</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/secure-sgw-access.html">Secure Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-users.html">User Authentication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-certs.html">TLS Cert Authentication</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Access Control</span>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-concepts.html">Concepts</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-model.html">Access Control Model</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/channels.html">Channels</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/roles.html">Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/users.html">Users</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function.html">Sync Function</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api.html">API Reference</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-access-cmd.html">access()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-channel-cmd.html">channel()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-expiry-cmd.html">expiry()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-access-cmd.html">requireAccess()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-admin-cmd.html">requireAdmin()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-role-cmd.html">requireRole()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-user-cmd.html">requireUser()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-role-cmd.html">role()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-throw-cmd.html">throw()</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how.html">How-to</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-create-users.html">Create Users</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-create-roles.html">Create Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-assign-users-to-roles.html">Assign User to Role</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-control-document-access.html">Control Document Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-verify-access.html">Verify Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-use-xattrs-for-access-grants.html">Use XATTRS for Access Grants</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/auto-purge-channel-access-revocation.html">Auto-Purge Channel Access Revocation</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">REST API</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-access.html">Secure Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin.html">Admin REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-metrics.html">Metrics REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api.html">Public REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-access-rbac-roles.html">RBAC Role - Endpoint Cross-Reference</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-with-couchbase-server.html">Sync with Server</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-using-app.html">Sync with Application</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Inter-Sync Gateway Replication</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-run.html">Initialize</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-manage.html">Manage</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-monitor.html">Monitor</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-conflict-resolution.html">Inter Syncgateway Conflict Resolution</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/delta-sync.html">Delta Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/import-filter.html">Import Filter</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Manage</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/revisions.html">Revisions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/managing-tombstones.html">Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/resync.html">Resync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-monitoring.html">Stats Monitoring</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/database-offline.html">Database Offline</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Logging and Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/logging.html">Logging</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sgcollect-info.html">SG Collect Info</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Deploy</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deployment.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/command-line-options.html">Command Line Options</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/load-balancer.html">Load Balancer</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/os-level-tuning.html">OS Level Tuning</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/webhooks.html">Webhooks</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/changes-feed.html">Changes Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/integrating-external-stores.html">External Stores</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-prometheus.html">Prometheus Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/setting-up-dr-cluster.html">Disaster Recovery</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/upgrading.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Use Kubernetes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deploy-cluster-to-kubernetes.html">Deploy</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-operator::tutorial-sync-gateway-manage.adoc">Manage a Sync Gateway Cluster</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-operator::tutorial-sync-gateway-clients.adoc">Expose Sync Gateway to Couchbase Lite clients</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Server Compatibility</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-collections.html">Collections</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-eventing.html">Eventing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-transactions.html">Transactions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-xdcr.html">XDCR</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/supported-environments.html">Supported Environments</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/compatibility.html">Compatibility Matrix</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Legacy Features</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sg-replicate.html">SG Replicate</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sgreplicate-resolving-conflicts.html">SG Replicate - Resolving Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-logging-pre2-1.html">Legacy Pre-2.1 Logging</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/glossary.html">Glossary</a>
  </span>
</li>
</ul>
      </div>
    </li>
  </ul>
</div>
  </div>
</aside>
<aside class="toc sidebar"
      data-title="Contents"
      data-levels="2">
  <div class="sidebar-box">
    <div class="tools" role="navigation">
<ul>
<li class="tool edit"><a href="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/c/pages/p2p-managing-tls-id.adoc" title="Edit Page" target="_blank" rel="noopener" class="remove-ext-icon">Edit on GitHub</a></li>
</ul>
</div>
    <div class="toc-menu"></div>
    <div class="is-this-helpful-box">
      <h4> Is this page helpful?</h4>
      <div class="btn-row">
        <a href="#" class="like-btn helpful-btn" id="yesBtn" data-page-rating="like" >
                <i class="far fa-thumbs-up"></i>
            Yes

            </a>
        <a href="#" class="dislike-btn helpful-btn" id="noBtn"  data-page-rating="dislike"> <i class="far fa-thumbs-down"></i> No</a>
      </div>
      <div class="any-feedback">
        <a href="#" class="btn any-feedback-btn" id="myCustomTrigger">Leave Additional Feedback? </a>
      </div>
      <div class="dialog-box" id="dialogBox">
        <form>
            <div class="form-group " id="additionalFeedbackBox">
              <textarea class="input-control feed-back-msg" rows="8" placeholder="Any Additonal Feedback?"></textarea>

              <div class="action-btn-row ">
                <a href="#" class="skip-btn" id="skipBtnMsg">Skip</a>
                  <button class="submit-btn btn blue-btn disabled" > Submit  </button>
                  <a href="#" class="info-btn"><i class="fas fa-info-circle"></i></a>
              </div>


            </div>

        </form>

      </div>
    </div>
  </div>

</aside>

<div class="feedback-modal modal-popup">
  <div class="modal-popup-dialogue">
    <div class="popup-header">
      <a href="#" class="close-popup"><i class="fa fa-times"></i></a>
    </div>
    <div class="popup-content">
      <p>
        Please use the form below to provide your feedback. Because your feedback is valuable to us,
         the information you submit in this form is recorded in our issue tracking system (JIRA), which is publicly available.
        You can track the status of your feedback using the ticket number displayed in the dialog once you submit the form.
      </p>
    </div>
  </div>
</div>

<main class="article" data-ceiling="topbar">
<div class="article-header">
<nav class="crumbs" aria-label="breadcrumbs">
<ul>
<li class="crumb"><a href="../index.html">Couchbase Lite</a></li>
<li class="crumb"><a href="p2p-managing-tls-id.html">Managing TLS Identities</a></li>
</ul>
</nav>
</div>
<article class="doc">
<div class="page-heading-title">
<h1 class="page">Managing TLS Identities</h1>
</div>
<div class="contributor-list-box">
<span class="last-commit-date" id="commitdate">    </span>
<ul id="contributorList"></ul>
<span  id="otherContributor"> + </span>
</div><div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>Description&#8201;&#8212;&#8201;<em>Couchbase Lite - this content covers how to manage TLS identities using Couchbase Lite</em><br>
Related Content&#8201;&#8212;&#8201;<a href="http://docs.couchbase.com/mobile/3.0.0/couchbase-lite-c/C/html">API Reference</a>  |  <a href="p2psync-websocket-using-passive.html" class="page">Passive Peer</a>  |  <a href="p2psync-websocket-using-active.html" class="page">Active Peer</a></p>
</div>
</blockquote>
</div>
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>Description&#8201;&#8212;&#8201;<em>Couchbase Lite - this content covers how to manage TLS identities using Couchbase Lite</em><br></p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1 pane__frames">
<h2 id="overview"><a class="anchor" href="#overview"></a>Overview</h2>
<div class="sectionbody">
<div class="ulist no-color">
<div class="title"></div>
<ul>
<li>
<p>This describes the configuration and management of TLS identities</p>
</li>
</ul>
</div>
<div class="ulist narrow">
<div class="title">Key Concepts</div>
<ul>
<li>
<p>API: <a href="http://docs.couchbase.com/mobile/3.0.0/couchbase-lite-c/C/html/group__TLSIdentity.html">TLSIdentity</a></p>
</li>
<li>
<p><a href="p2psync-websocket.html" class="page">Peer-to-Peer</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="api-references"><a class="anchor" href="#api-references"></a>API References</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can find <a href="http://docs.couchbase.com/mobile/3.0.0/couchbase-lite-c/C/html">C API References</a> here.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-tls-identity"><a class="anchor" href="#creating-tls-identity"></a>Creating TLS Identity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are couple of options by which TLS Identity is created:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can use the <a href="#anonymous-cert">anonymous self-signed cert</a> auto-generated by Couchbase Lite</p>
</li>
<li>
<p>You can <a href="#importing-a-cert">import a cert</a> to be bundled with the app and-or stored in the keychain</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="use-anonymous-cert"><a class="anchor" href="#use-anonymous-cert"></a>Use Anonymous Cert</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Anonymous certification uses the self signed certificate auto-generated by Couchbase Lite when TLS is enabled, but no TLSIdentity is provided.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">listenerConfig.disableTLS  = false // Use with anonymous self signed cert
listenerConfig.tlsIdentity = nil</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="import-a-cert"><a class="anchor" href="#import-a-cert"></a>Import a Cert</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use the <a href="http://docs.couchbase.com/mobile/3.0.0/couchbase-lite-c/C/html/group__TLSIdentity.html">TLSIdentity</a> class&#8217;s  <a href="http://docs.couchbase.com/mobile/3.0.0/couchbase-lite-c/C/html/group__TLSIdentity.html#TLSIdentity(cm)importIdentityWithData:password:label:error:">importIdentity(withData:password:label:error:)</a> method to import a certificate that can be bundled with the app and-or added to the keychain.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First check the keychain to see if the identity already exists</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c"></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Check for an existing resource bundle</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/c/examples/code_snippets/main.c">// CBL Version 3.0.0 BETA
#include &lt;cbl/CouchbaseLite.h&gt;
#include &lt;time.h&gt;
#include &lt;inttypes.h&gt;
#ifdef _MSC_VER
#include &lt;direct.h&gt;
#include &lt;Shlwapi.h&gt;

void usleep(unsigned int us) {
    Sleep(us / 1000);
}
#else
#include &lt;unistd.h&gt;
#endif

static CBLDatabase* kDatabase;

// Helper for stop replicator in the code snippet
static void stop_replicator(CBLReplicator* replicator) {
    CBLReplicator_Stop(replicator);
    while(CBLReplicator_Status(replicator).activity != kCBLReplicatorStopped) {
        printf("Waiting for replicator to stop...");
        usleep(200000);
    }
    CBLReplicator_Release(replicator);
}

//  BEGIN lower-level function declarations

//  DOCS NOTE --
//  These functions are referred to in subsequent code samples.
//  Their tags will ensure they are shown alongide the usage examples.
//  Functions used in more than one place may hve multiple tags.

// tag::p2p-act-rep-func[]
// tag::p2p-act-rep-add-change-listener[]
// tag::replication-error-handling[]
// Purpose -- illustrate a simple change listener
static void simpleChangeListener(void* context,
                                 CBLReplicator* repl,
                                 const CBLReplicatorStatus* status)
{
     if(status-&gt;error.code != 0) {
         printf("Error %d / %d\n",
                status-&gt;error.domain,
                status-&gt;error.code);
     }
}
// end::replication-error-handling[]
// end::p2p-act-rep-add-change-listener[]
// end::p2p-act-rep-func[]

static const CBLDocument* simpleConflictResolver_localWins(
                                void* context, FLString documentID,
                                const CBLDocument* localDocument,
                                const CBLDocument* remoteDocument)
{
    return localDocument;
}

// tag::replication-push-filter[]
// tag::replication-pull-filter[]
// Purpose -- illustrate a simple replication filter function
static bool simpleReplicationFilter(void* context,
                                    CBLDocument* argDoc,
                                    CBLDocumentFlags argFlags)
{
    bool result = (argFlags == kCBLDocumentFlagsDeleted);
    return result;
}

// end::replication-push-filter[]
// end::replication-pull-filter[]

// tag::SimpleReplicationDocumentListener[]
// Purpose -- Illustrate a simple replication document listener
static void SimpleReplicationDocumentListener(
                                  void *context,
                                  CBLReplicator *replicator,
                                  bool isPush,
                                  unsigned numDocuments,
                                  const CBLReplicatedDocument *documents)
{
    if(isPush) {
        printf("We pushed %d documents",numDocuments);
    }
}

// END lower-level function declarations


static void getting_started_change_listener(void* context,
                                            CBLReplicator* repl,
                                            const CBLReplicatorStatus* status)
{
    if(status-&gt;error.code != 0) {
        printf("Error %d / %d\n", status-&gt;error.domain, status-&gt;error.code);
    }
}

// Page=build and run
// url=https://docs-staging.couchbase.com/couchbase-lite/current/c/gs-build.html
static void getting_started() {
    // tag::getting-started[]
    //  Purpose-- provide an overview of available crud  and sync functionality
    //
    // Get the database (and create it if it doesn't exist)
    CBLError err;
    CBLDatabase* database = CBLDatabase_Open(FLSTR("mydb"), NULL, &amp;err);
    if(!database) {
        // Error handling.  For brevity, this is truncated in the rest of the snippet
        // and omitted in other doc code snippets
        fprintf(stderr, "Error opening database (%d / %d)\n", err.domain, err.code);
        FLSliceResult msg = CBLError_Message(&amp;err);
        fprintf(stderr, "%.*s\n", (int)msg.size, (const char *)msg.buf);
        FLSliceResult_Release(msg);
        return;
    }

    // The lack of 'const' indicates this document is mutable
    // Create a new document (i.e. a record) in the database
    CBLDocument* mutableDoc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDoc);
    FLMutableDict_SetFloat(properties, FLSTR("version"), 3.0f);

    // Save it to the database
    if(!CBLDatabase_SaveDocument(database, mutableDoc, &amp;err)) {
        // Failed to save, do error handling as above
        return;
    }

    // Since we will release the document, make a copy of the ID since it
    // is an internal pointer.  Whenever we create or get an FLSliceResult
    // or FLStringResult we will need to free it later too!
    FLStringResult id = FLSlice_Copy(CBLDocument_ID(mutableDoc));
    CBLDocument_Release(mutableDoc);

    // Update a document
    mutableDoc = CBLDatabase_GetMutableDocument(database, FLSliceResult_AsSlice(id), &amp;err);
    if(!mutableDoc) {
        // Failed to retrieve, do error handling as above.  NOTE: error code 0 simply means
        // the document does not exist.
        return;
    }

    properties = CBLDocument_MutableProperties(mutableDoc);
    FLMutableDict_SetString(properties, FLSTR("language"), FLSTR("C"));
    if(!CBLDatabase_SaveDocument(database, mutableDoc, &amp;err)) {
        // Failed to save, do error handling as above
        return;
    }

    // Note const here, means readonly
    const CBLDocument* docAgain = CBLDatabase_GetDocument(database, FLSliceResult_AsSlice(id), &amp;err);
    if(!docAgain) {
        // Failed to retrieve, do error handling as above.  NOTE: error code 0 simply means
        // the document does not exist.
        return;
    }

    // No copy this time, so no release later (notice it is not FLStringResult this time)
    FLString retrievedID = CBLDocument_ID(docAgain);
    FLDict retrievedProperties = CBLDocument_Properties(docAgain);
    FLString retrievedLanguage = FLValue_AsString(FLDict_Get(retrievedProperties, FLSTR("language")));
    printf("Document ID :: %.*s\n", (int)retrievedID.size, (const char *)retrievedID.buf);
    printf("Learning %.*s\n", (int)retrievedLanguage.size, (const char *)retrievedLanguage.buf);

    CBLDocument_Release(mutableDoc);
    CBLDocument_Release(docAgain);
    FLSliceResult_Release(id);

    // tag::query-syntax-n1ql[]
    // Create a query to fetch documents of type SDK
    int errorPos;
    CBLQuery* query = CBLDatabase_CreateQuery(database, kCBLN1QLLanguage, FLSTR("SELECT * FROM _ WHERE type = \"SDK\""), &amp;errorPos, &amp;err);
    if(!query) {
        // Failed to create query, do error handling as above
        // Note that errorPos will contain the position in the N1QL string
        // that the parse failed, if applicable
        return;
    }

    CBLResultSet* result = CBLQuery_Execute(query, &amp;err);
    if(!result) {
        // Failed to run query, do error handling as above
        return;
    }
    // end::query-syntax-n1ql[]

    // TODO: Result set count?
    CBLResultSet_Release(result);
    CBLQuery_Release(query);

    // Create replicator to push and pull changes to and from the cloud
    CBLEndpoint* targetEndpoint = CBLEndpoint_CreateWithURL(FLSTR("ws://localhost:4984/getting-started-db"), &amp;err);
    if(!targetEndpoint) {
        // Failed to create endpoint, do error handling as above
        return;
    }

    CBLReplicatorConfiguration replConfig;
    CBLAuthenticator* basicAuth = CBLAuth_CreatePassword(FLSTR("john"), FLSTR("pass"));
    memset(&amp;replConfig, 0, sizeof(replConfig));
    replConfig.database = database;
    replConfig.endpoint = targetEndpoint;
    replConfig.authenticator = basicAuth;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;replConfig, &amp;err);
    CBLAuth_Free(basicAuth);
    CBLEndpoint_Free(targetEndpoint);
    if(!replicator) {
        // Failed to create replicator, do error handling as above
        return;
    }

    // Assume a function like the simple following
    //
    // static void getting_started_change_listener(void* context, CBLReplicator* repl, const CBLReplicatorStatus* status) {
    //     if(status-&gt;error.code != 0) {
    //         printf("Error %d / %d\n", status-&gt;error.domain, status-&gt;error.code);
    //     }
    // }

    CBLListenerToken* token = CBLReplicator_AddChangeListener(replicator, getting_started_change_listener, NULL);

    CBLReplicator_Start(replicator, false);

    // Later, stop and release the replicator
    // end::getting-started[]

    // When finished release resources ... eg
    CBLListener_Remove(token);

    stop_replicator(replicator);
}


// tag::local-win-conflict-resolver[]
static const CBLDocument* local_win_conflict_resolver(void* context,
                                                      FLString documentID,
                                                      const CBLDocument* localDocument,
                                                      const CBLDocument* remoteDocument)
{
    return localDocument;
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
static const CBLDocument* remote_win_conflict_resolver(void* context,
                                                       FLString documentID,
                                                       const CBLDocument* localDocument,
                                                       const CBLDocument* remoteDocument)
{
    return remoteDocument;
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
static const CBLDocument* merge_conflict_resolver(void* context,
                                                  FLString documentID,
                                                  const CBLDocument* localDocument,
                                                  const CBLDocument* remoteDocument)
{
    FLDict localProps = CBLDocument_Properties(localDocument);
    FLDict remoteProps = CBLDocument_Properties(remoteDocument);
    FLMutableDict mergeProps = FLDict_MutableCopy(localProps, kFLDefaultCopy);

    FLDictIterator d;
    FLDictIterator_Begin(localProps, &amp;d);
    FLValue value;
    while((value = FLDictIterator_GetValue(&amp;d))) {
        FLString key = FLDictIterator_GetKeyString(&amp;d);
        if(FLDict_Get(mergeProps, key)) {
            continue;
        }

        FLMutableDict_SetValue(mergeProps, key, value);
        FLDictIterator_Next(&amp;d);
    }

    CBLDocument* mergeDocument = CBLDocument_CreateWithID(documentID);
    CBLDocument_SetProperties(mergeDocument, mergeProps);
    FLMutableDict_Release(mergeProps);

    return mergeDocument;
}
// end::merge-conflict-resolver[]

static void test_replicator_conflict_resolve() {
    CBLDatabase* database = kDatabase;

    // tag::replication-conflict-resolver[]
    // NOTE: No error handling, for brevity (see getting started)
    CBLError err;
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(FLSTR("ws://localhost:4984/mydatabase"), &amp;err);

    CBLReplicatorConfiguration replConfig;
    memset(&amp;replConfig, 0, sizeof(replConfig));
    replConfig.database = database;
    replConfig.endpoint = target;
    replConfig.conflictResolver = local_win_conflict_resolver;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;replConfig, &amp;err);
    CBLEndpoint_Free(target);
    CBLReplicator_Start(replicator, false);

    // end::replication-conflict-resolver[]

    stop_replicator(replicator);
}

static bool custom_conflict_handler(void* context,
                                    CBLDocument* documentBeingSaved,
                                    const CBLDocument* conflictingDocument)
{
    FLDict currentProps = CBLDocument_Properties(conflictingDocument);
    FLDict updatedProps = CBLDocument_Properties(documentBeingSaved);
    FLMutableDict newProps = FLDict_MutableCopy(updatedProps, kFLDefaultCopy);

    FLDictIterator d;
    FLDictIterator_Begin(currentProps, &amp;d);
    FLValue currentValue;
    while((currentValue = FLDictIterator_GetValue(&amp;d))) {
        FLString currentKey = FLDictIterator_GetKeyString(&amp;d);
        if(FLDict_Get(newProps, currentKey)) {
            continue;
        }

        FLMutableDict_SetValue(newProps, currentKey, currentValue);
        FLDictIterator_Next(&amp;d);
    }

    return true;
}

static void test_save_with_conflict_handler() {
    CBLDatabase* database = kDatabase;

    // tag::update-document-with-conflict-handler[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDocument* mutableDocument = CBLDatabase_GetMutableDocument(database, FLSTR("xyz"), &amp;err);
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDocument);
    FLMutableDict_SetString(properties, FLSTR("name"), FLSTR("apples"));

    /*
    static bool custom_conflict_handler(void* context, CBLDocument* documentBeingSaved,
        const CBLDocument* conflictingDocument) {
        FLDict currentProps = CBLDocument_Properties(conflictingDocument);
        FLDict updatedProps = CBLDocument_Properties(documentBeingSaved);
        FLMutableDict newProps = FLDict_MutableCopy(updatedProps, kFLDefaultCopy);

        FLDictIterator d;
        FLDictIterator_Begin(currentProps, &amp;d);
        FLSlice currentKey = FLDictIterator_GetKeyString(&amp;d);
        for(; currentKey.buf; currentKey = FLDictIterator_GetKeyString(&amp;d)) {
            if(FLDict_Get(newProps, currentKey)) {
                continue;
            }

            FLValue currentValue = FLDictIterator_GetValue(&amp;d);
            FLMutableDict_SetValue(newProps, currentKey, currentValue);
        }

        return true;
    }
    */
    CBLDatabase_SaveDocumentWithConflictHandler(database, mutableDocument, custom_conflict_handler, NULL, &amp;err);

    // end::update-document-with-conflict-handler[]
}

static void use_encryption() {
    #ifdef COUCHBASE_ENTERPRISE

    // tag::database-encryption[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLDatabaseConfiguration config = CBLDatabaseConfiguration_Default();

    // This returns a boolean, so check it in production code
    CBLEncryptionKey_FromPassword(&amp;config.encryptionKey, FLSTR("password"));

    CBLError err;
    CBLDatabase* db = CBLDatabase_Open(FLSTR("seekrit"), &amp;config, &amp;err);

    // Change the encryption key (or add encryption if the DB is unencrypted)
    CBLEncryptionKey betterKey;
    CBLEncryptionKey_FromPassword(&amp;betterKey, FLSTR("betterpassw0rd"));
    CBLDatabase_ChangeEncryptionKey(db, &amp;betterKey, &amp;err);

    // Remove encryption
    CBLDatabase_ChangeEncryptionKey(db, NULL, &amp;err);
    // end::database-encryption[]

    #endif
}

static void reset_replicator_checkpoint() {
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(FLSTR("ws://localhost:4984/db"), NULL);
    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = kDatabase;
    config.endpoint = target;
    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, NULL);
    CBLEndpoint_Free(target);

    // tag::replication-reset-checkpoint-full[]
    // replicator is a CBLReplicator* instance
    CBLReplicator_Start(replicator, true); <i class="conum" data-value="1"></i><b>(1)</b>

    // end::replication-reset-checkpoint-full[]

    stop_replicator(replicator);
}

static void read_1x_attachment() {
    CBLDocument* document = CBLDocument_Create();

    // tag::1x-attachment[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    FLDict properties = CBLDocument_Properties(document);
    FLDict attachments = FLValue_AsDict(FLDict_Get(properties, FLSTR("_attachments")));
    const CBLBlob* avatar = FLDict_GetBlob(FLValue_AsDict(FLDict_Get(attachments, FLSTR("avatar"))));
    FLSliceResult content = CBLBlob_Content(avatar, &amp;err);

    FLSliceResult_Release(content);
    // end::1x-attachment[]

    CBLDocument_Release(document);
}

static void create_new_database() {
    // tag::new-database[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDatabase* db = CBLDatabase_Open(FLSTR("my-database"), NULL, &amp;err);
    // end::new-database[]

    kDatabase = db;
}

static void close_database() {
    CBLDatabase* db = kDatabase;
    // tag::close-database[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDatabase_Close(db, &amp;err);
    // end::close-database[]
}

static void change_logging() {
    // tag::logging[]
    // For output to stdout
    CBLLog_SetConsoleLevel(kCBLLogVerbose);

    // For output to custom logging
    CBLLog_SetCallbackLevel(kCBLLogVerbose);
    // end::logging[]
}

static void load_prebuilt() {
    CBL_DeleteDatabase(FLSTR("travel-sample.cblite2"), kFLSliceNull, NULL);

    // tag::prebuilt-database[]
    // Note: Getting the path to a database is platform-specific.  For desktop (including RPi)
    // this can be a simple filesystem path.  For iOS you need to get the path from the
    // main bundle.  For Android you need to extract it from your assets to a temporary directory
    // and then pass that path.

    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    const char* path = "/path/to/travel-sample.cblite2";
    if(!CBL_DatabaseExists(FLSTR("travel-sample.cblite2"), kFLSliceNull)) {
        CBL_CopyDatabase(FLStr(path), FLSTR("travel-sample"), NULL, &amp;err);
    }
    // end::prebuilt-database[]

    CBLDatabase_Close(kDatabase, NULL);
    CBLDatabase_Release(kDatabase);
    kDatabase = CBLDatabase_Open(FLSTR("travel-sample"), NULL, NULL);
}

static void query_deleted_document() {
    CBLDatabase* db = kDatabase;

    // tag::query-deleted-documents[]
    // Query documents that have been deleted
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _ WHERE meta().deleted"), NULL, &amp;err);
    // end::query-deleted-documents[]

    CBLQuery_Release(query);
}

static void create_document() {
    CBLDatabase* db = kDatabase;

    // tag::initializer[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLDocument* newTask = CBLDocument_CreateWithID(FLSTR("xyz"));
    FLMutableDict properties = CBLDocument_MutableProperties(newTask);
    FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("task"));
    FLMutableDict_SetString(properties, FLSTR("owner"), FLSTR("todo"));

    // Storing time in millisecond, bluntly
    FLMutableDict_SetUInt(properties, FLSTR("createdAt"), time(NULL) * 1000);

    CBLError err;
    CBLDatabase_SaveDocument(db, newTask, &amp;err);
    CBLDocument_Release(newTask);
    // end::initializer[]
}

static void update_document() {
    CBLDatabase* db = kDatabase;

    // tag::update-document[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDocument* mutableDocument = CBLDatabase_GetMutableDocument(db, FLSTR("xyz"), &amp;err);
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDocument);
    FLMutableDict_SetString(properties, FLSTR("name"), FLSTR("apples"));
    CBLDatabase_SaveDocument(db, mutableDocument, &amp;err);
    CBLDocument_Release(mutableDocument);
    // end::update-document[]
}

// Note use_typed_accessors not applicable

static void do_batch_operation() {
    CBLDatabase* db = kDatabase;

    // tag::batch[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDatabase_BeginTransaction(db, &amp;err);
    char buffer[7];
    for(int i = 0; i &lt; 10; i++) {
        CBLDocument* doc = CBLDocument_Create();
        FLMutableDict properties = CBLDocument_MutableProperties(doc);
        FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("user"));
        sprintf(buffer, "user %d", i);
        FLMutableDict_SetString(properties, FLSTR("name"), FLStr(buffer));
        FLMutableDict_SetBool(properties, FLSTR("admin"), false);
        CBLDatabase_SaveDocument(db, doc, &amp;err);
        CBLDocument_Release(doc);
        printf("Saved user document %s\n", buffer);
    }

    CBLDatabase_EndTransaction(db, true, &amp;err);
    // end::batch[]
}

static void document_listener(void* context, const CBLDatabase* db, FLString id) {
    CBLError err;
    const CBLDocument* doc = CBLDatabase_GetDocument(db, id, &amp;err);
    FLDict properties = CBLDocument_Properties(doc);
    FLString verified_account = FLValue_AsString(FLDict_Get(properties, FLSTR("verified_account")));
    printf("Status :: %.*s\n", (int)verified_account.size, (const char *)verified_account.buf);
    CBLDocument_Release(doc);
}

static void database_change_listener() {
    CBLDatabase* db = kDatabase;

    // tag::document-listener[]
    /*
    static void document_listener(void* context, const CBLDatabase* db, FLString id) {
        CBLError err;
        const CBLDocument* doc = CBLDatabase_GetDocument(db, id, &amp;err);
        FLDict properties = CBLDocument_Properties(doc);
        FLString verified_account = FLValue_AsString(FLDict_Get(properties, FLSTR("verified_account")));
        printf("Status :: %.*s\n", (int)verified_account.size, (const char *)verified_account.buf);
        CBLDocument_Release(doc);
    }
    */
    CBLListenerToken* token = CBLDatabase_AddDocumentChangeListener(db, FLSTR("user.john"),
        document_listener, NULL);
    // end::document-listener[]

    CBLListener_Remove(token);
}

static void document_expiration() {
    CBLDatabase* db = kDatabase;

    // tag::document-expiration[]
    // Purge the document one day from now

    // Overly simplistic for example purposes
    // NOTE: API takes milliseconds
    // NOTE: No error handling, for brevity (see getting started)
    time_t ttl = time(NULL) + 24 * 60 * 60;
    ttl *= 1000;

    CBLError err;
    CBLDatabase_SetDocumentExpiration(db, FLSTR("doc123"), ttl, &amp;err);

    // Reset expiration
    CBLDatabase_SetDocumentExpiration(db, FLSTR("doc1"), 0, &amp;err);

    // Query documents that will be expired in less than five minutes
    time_t fiveMinutesFromNow = time(NULL) + 5 * 60;
    fiveMinutesFromNow *= 1000;
    FLMutableDict parameters = FLMutableDict_New();
    FLMutableDict_SetInt(parameters, FLSTR("five_minutes"), fiveMinutesFromNow);

    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _ WHERE meta().expiration &lt; $five_minutes"), NULL, &amp;err);
    CBLQuery_SetParameters(query, parameters);
    FLMutableDict_Release(parameters);
    // end::document-expiration[]
}

static void use_blob() {
    CBLDatabase* db = kDatabase;

    CBLDocument* newTask = CBLDocument_Create();

    // tag::blob[]
    // Note: Reading the data is implementation dependent, as with prebuilt databases
    // NOTE: No error handling, for brevity (see getting started)

    uint8_t buffer[128000];
    FILE* avatar_file = fopen("avatar.jpg", "rb");
    size_t read = fread(buffer, 1, 128000, avatar_file); <i class="conum" data-value="2"></i><b>(2)</b>

    FLSliceResult avatar = FLSliceResult_CreateWith(buffer, read);
    CBLBlob* blob = CBLBlob_CreateWithData(FLSTR("image/jpeg"), FLSliceResult_AsSlice(avatar)); <i class="conum" data-value="3"></i><b>(3)</b>
    FLSliceResult_Release(avatar);

    // TODO: Create shortcut blob method
    CBLError err;
    FLMutableDict properties = CBLDocument_MutableProperties(newTask);
    FLSlot_SetBlob(FLMutableDict_Set(properties, FLSTR("avatar")), blob);
    CBLDatabase_SaveDocument(db, newTask, &amp;err); <i class="conum" data-value="4"></i><b>(4)</b>

    // end::blob[]



    CBLDocument_Release(newTask);
    CBLBlob_Release(blob);
}

static void doc_json() {
    CBLDatabase* db = kDatabase;

    // tag::tojson-document[]
    // NOTE: No error handling, for brevity (see getting started)

    FLString json = FLSTR("{\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",\"country\":\"Australia\"}");

    // Create a document and set the JSON data to the document
    CBLError err;
    CBLDocument* newDoc = CBLDocument_CreateWithID(FLSTR("hotel_1002"));
    CBLDocument_SetJSON(newDoc, json, &amp;err);

    // Save the document to the database
    CBLDatabase_SaveDocument(db, newDoc, &amp;err);

    // Release created doc after using it
    CBLDocument_Release(newDoc);

    // Get the document from the database
    const CBLDocument* doc = CBLDatabase_GetDocument(db, FLSTR("hotel_1002"), &amp;err);

    // Get document body as JSON
    FLSliceResult docJson = CBLDocument_CreateJSON(doc);
    printf("Document in JSON :: %.*s\n", (int)docJson.size, (const char *)docJson.buf);

    // Release JSON data after using it
    FLSliceResult_Release(docJson);

    // Release doc read from the database after using it
    CBLDocument_Release(doc);
    // end::tojson-document[]
}

static void dict_json() {
    // tag::tojson-dictionary[]
    // NOTE: No error handling, for brevity (see getting started)

    FLString json = FLSTR("{\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",\"country\":\"Australia\"}");

    // Create a dictionary from the JSON string
    FLError err;
    FLSliceResult jsonData1 = FLData_ConvertJSON(json, &amp;err);
    FLDict hotel = FLValue_AsDict(FLValue_FromData(FLSliceResult_AsSlice(jsonData1), kFLTrusted));

    // Iterate through the dictionary
    FLDictIterator iter;
    FLDictIterator_Begin(hotel, &amp;iter);
    FLValue value;
    while (NULL != (value = FLDictIterator_GetValue(&amp;iter))) {
        FLString key = FLDictIterator_GetKeyString(&amp;iter);
        FLString strValue = FLValue_AsString(value);
        printf("%.*s :: %.*s\n", (int)key.size, (const char*)key.buf, (int)strValue.size, (const char*)strValue.buf);
        FLDictIterator_Next(&amp;iter);
    }

    // Convert the dictionary to JSON
    FLSliceResult jsonData2 = FLValue_ToJSON((FLValue)hotel);
    printf("Hotel in JSON :: %.*s\n", (int)jsonData2.size, (const char *)jsonData2.buf);

    // Release JSON data after finish using it
    FLSliceResult_Release(jsonData1);
    FLSliceResult_Release(jsonData2);
    // end::tojson-dictionary[]
}

static void array_json() {
    // tag::tojson-array[]
    // NOTE: No error handling, for brevity (see getting started)

    FLString json = FLSTR("[\"Hotel Ned\", \"Hotel Ted\"]");

    // Create an array from the JSON string
    FLError err;
    FLSliceResult jsonData1 = FLData_ConvertJSON(json, &amp;err);
    FLArray hotels = FLValue_AsArray(FLValue_FromData(FLSliceResult_AsSlice(jsonData1), kFLTrusted));

    // Iterate through the array
    FLArrayIterator iter;
    FLArrayIterator_Begin(hotels, &amp;iter);
    FLValue value;
    while (NULL != (value = FLArrayIterator_GetValue(&amp;iter))) {
        FLString hotel = FLValue_AsString(value);
        printf("Hotel :: %.*s\n", (int)hotel.size, (const char *)hotel.buf);
        FLArrayIterator_Next(&amp;iter);
    }

    // Convert the array to JSON
    FLSliceResult jsonData2 = FLValue_ToJSON((FLValue)hotels);
    printf("Hotels in JSON :: %.*s\n", (int)jsonData2.size, (const char *)jsonData2.buf);

    // Release JSON data after finish using it
    FLSliceResult_Release(jsonData1);
    FLSliceResult_Release(jsonData2);
    // end::tojson-array[]
}

static void datatype_dictionary()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_dictionary[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    const CBLDocument *doc = CBLDatabase_GetDocument(db, FLSTR("doc1"), &amp;err);
    FLDict properties = CBLDocument_Properties(doc);

    // Getting a dictionary from the document's properties
    FLValue dictValue = FLDict_Get(properties, FLSTR("address"));
    FLDict dict = FLValue_AsDict(dictValue);

    // Access a value with a key from the dictionary
    FLValue streetVal = FLDict_Get(dict, FLSTR("street"));
    FLString street = FLValue_AsString(streetVal);

    // Iterate dictionary
    FLDictIterator iter;
    FLDictIterator_Begin(dict, &amp;iter);
    FLValue value;
    while (NULL != (value = FLDictIterator_GetValue(&amp;iter))) {
        FLString key = FLDictIterator_GetKeyString(&amp;iter);
        FLString strValue = FLValue_AsString(value);
        printf("Key :: %.*s\n", (int)key.size, (const char *)key.buf);
        printf("Value :: %.*s\n", (int)strValue.size, (const char *)strValue.buf);
        // ...
        FLDictIterator_Next(&amp;iter);
    }

    // Create a mutable copy.
    // kFLDefaultCopy is shallow which means the nested dictionaries and arrays will be
    // referenced but not copied. Use kFLDeepCopyImmutables for the deep copy.
    FLMutableDict mutableDict = FLDict_MutableCopy(dict, kFLDefaultCopy);

    // Release when finish using it
    FLMutableDict_Release(mutableDict);
    // end::datatype_dictionary[]
}

static void datatype_mutable_dictionary()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_mutable_dictionary[]
    // NOTE: No error handling, for brevity (see getting started)

    // tag::datatype_mutable_dictionary-create[]
    // Create a new mutable dictionary and populate some keys/values
    FLMutableDict dict = FLMutableDict_New();
    FLMutableDict_SetString(dict, FLSTR("street"), FLSTR("1 Main st."));
    FLMutableDict_SetString(dict, FLSTR("city"), FLSTR("San Francisco"));
    // end::datatype_mutable_dictionary-create[]

    // tag::datatype_mutable_dictionary-add-to-doc[]
    // Set the dictionary to document's properties and save the document
    CBLDocument *doc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(doc);
    FLMutableDict_SetDict(properties, FLSTR("address"), dict);
    // end::datatype_mutable_dictionary-add-to-doc[]
    CBLError err;
    CBLDatabase_SaveDocument(db, doc, &amp;err);
    CBLDocument_Release(doc);

    // Release when finish using it
    FLMutableDict_Release(dict);
    // end::datatype_mutable_dictionary[]
}

static void datatype_array()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_array[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    const CBLDocument *doc = CBLDatabase_GetDocument(db, FLSTR("doc1"), &amp;err);
    FLDict properties = CBLDocument_Properties(doc);

    // Getting a phones array from the document's properties
    FLValue arrayValue = FLDict_Get(properties, FLSTR("phones"));
    FLArray array = FLValue_AsArray(arrayValue);

    // Get element count
    int count = FLArray_Count(array);
    printf("Count :: %d\n", count);

    // Access an array element by index
    if (!FLArray_IsEmpty(array)) {
        FLValue phoneVal = FLArray_Get(array, 0);
        FLString phone = FLValue_AsString(phoneVal);
        printf("Value :: %.*s\n", (int)phone.size, (const char *)phone.buf);
    }

    // Iterate array
    FLArrayIterator iter;
    FLArrayIterator_Begin(array, &amp;iter);
    FLValue val;
    while (NULL != (val = FLArrayIterator_GetValue(&amp;iter)))
    {
        FLString str = FLValue_AsString(val);
        printf("Value :: %.*s\n", (int)str.size, (const char *)str.buf);
        FLArrayIterator_Next(&amp;iter);
    }
    // end::datatype_array[]

    // Create a mutable copy.
    // kFLDefaultCopy is shallow which means the nested dictionaries and arrays will be
    // referenced but not copied. Use kFLDeepCopyImmutables for the deep copy.
    FLMutableArray mutableArray = FLArray_MutableCopy(array, kFLDefaultCopy);

    // Release when finish using it
    FLMutableArray_Release(mutableArray);
}

static void datatype_mutable_array()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_mutable_array[]
    // NOTE: No error handling, for brevity (see getting started)

    // tag::datatype_mutable_array-create[]
    // Create a new mutable array and populate data into the array
    FLMutableArray phones = FLMutableArray_New();
    FLMutableArray_AppendString(phones, FLSTR("650-000-0000"));
    FLMutableArray_AppendString(phones, FLSTR("650-000-0001"));
    // end::datatype_mutable_array-create[]

    // tag::datatype_mutable_array-add-to-doc[]
    // Set the array to document's properties and save the document
    CBLDocument *doc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(doc);
    FLMutableDict_SetArray(properties, FLSTR("phones"), phones);
    // end::datatype_mutable_array-add-to-doc[]
    CBLError err;
    CBLDatabase_SaveDocument(db, doc, &amp;err);
    CBLDocument_Release(doc);

    // Release the created dictionary
    FLMutableArray_Release(phones);
    // end::datatype_mutable_array[]
}


static void datatype_usage() {

    // tag::datatype_usage[]
    // tag::datatype_usage_createdb[]
    // Open or create DB if it doesn't exist
    CBLError err;
    CBLDatabase* database = CBLDatabase_Open(FLSTR("mydb"), NULL, &amp;err);
    if(!database) {
        // Error handling.  For brevity, this is truncated in the rest of the snippet
        // and omitted in other doc code snippets
        fprintf(stderr, "Error opening database (%d / %d)\n", err.domain, err.code);
        FLSliceResult msg = CBLError_Message(&amp;err);
        fprintf(stderr, "%.*s\n", (int)msg.size, (const char *)msg.buf);
        FLSliceResult_Release(msg);
        return;
    }

    // end::datatype_usage_createdb[]
    // tag::datatype_usage_createdoc[]
    // Create your new document
    // The lack of 'const' indicates this document is mutable
    CBLDocument* mutableDoc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDoc);

    // end::datatype_usage_createdoc[]
    // tag::datatype_usage_mutdict[]
    // Create and populate mutable dictionary
    FLMutableDict address = FLMutableDict_New();
    FLMutableDict_SetString(address, FLSTR("street"), FLSTR("1 Main st."));
    FLMutableDict_SetString(address, FLSTR("city"), FLSTR("San Francisco"));
    FLMutableDict_SetString(address, FLSTR("state"), FLSTR("CA"));
    FLMutableDict_SetString(address, FLSTR("country"), FLSTR("USA"));
    FLMutableDict_SetString(address, FLSTR("code"), FLSTR("90210"));

    // end::datatype_usage_mutdict[]
    // tag::datatype_usage_mutarray[]
    // Create and populate mutable array
    FLMutableArray phones = FLMutableArray_New();
    FLMutableArray_AppendString(phones, FLSTR("650-000-0000"));
    FLMutableArray_AppendString(phones, FLSTR("650-000-0001"));

    // end::datatype_usage_mutarray[]
    // tag::datatype_usage_populate[]
    // Initialize and populate the document

    // Add document type to document properties <i class="conum" data-value="5"></i><b>(5)</b>
    FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("hotel"));

    // Add hotel name string to document properties <i class="conum" data-value="6"></i><b>(6)</b>
    FLMutableDict_SetString(properties, FLSTR("hotel"), FLSTR(""));

    // Add float to document properties <i class="conum" data-value="7"></i><b>(7)</b>
    FLMutableDict_SetFloat(properties, FLSTR("room_rate"), 121.75f);

    // Add dictionary to document's properties <i class="conum" data-value="8"></i><b>(8)</b>
    FLMutableDict_SetDict(properties, FLSTR("address"), dict);

    // Add array to document's properties <i class="conum" data-value="9"></i><b>(9)</b>
    FLMutableDict_SetArray(properties, FLSTR("phones"), phones);

    // end::datatype_usage_populate[]
    // tag::datatype_usage_persist[]
    // Save the document changes <i class="conum" data-value="10"></i><b>(10)</b>
    CBLError err;
    CBLDatabase_SaveDocument(database, doc, &amp;err);

    // end::datatype_usage_persist[]
    // tag::datatype_usage_closedb[]
    // Close the database <i class="conum" data-value="11"></i><b>(11)</b>
    CBLError err;
    CBLDatabase_Close(database, &amp;err);

    // end::datatype_usage_closedb[]
    // tag::datatype_usage_release[]
    // Release the created items <i class="conum" data-value="12"></i><b>(12)</b>
    CBLDatabase_Release(database);
    CBLDocument_Release(doc);
    FLMutableDict_Release(dict);
    FLMutableArray_Release(phones);
    // end::datatype_usage_release[]

    // end::datatype_usage[]

} // end datatype_usage()


static void create_index() {
    CBLDatabase* db = kDatabase;

    // tag::query-index[]
    // For value types, this is optional but provides performance enhancements
    // NOTE: No error handling, for brevity (see getting started)

    // Syntax for second argument is the same as taking from a N1QL SELECT
    // i.e. SELECT (type, name) FROM _;
    CBLValueIndexConfiguration config = {
        kCBLN1QLLanguage,
        FLSTR("type, name")
    };

    CBLError err;
    CBLDatabase_CreateValueIndex(db, FLSTR("TypeNameIndex"), config, &amp;err);
    // end::query-index[]
}

static void select_meta() {
    CBLDatabase* db = kDatabase;

    // tag::query-select-meta[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, type, name FROM _"), NULL, &amp;err);
    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString id = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("id")));
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Document ID :: %.*s\n", (int)id.size, (const char *)id.buf);
        printf("Document Name :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-select-meta[]
}

static void select_id() {
    CBLDatabase* db = kDatabase;

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _"), NULL, &amp;err);

    // tag::query-access-id[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString id = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("id")));
        printf("Document ID :: %.*s\n", (int)id.size, (const char *)id.buf);
    }
    // end::query-access-id[]

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
}

static void query_change_listener(void* context, CBLQuery* query, CBLListenerToken* token) {
    CBLError err;
    CBLResultSet* results = CBLQuery_CopyCurrentResults(query, token, &amp;err);
    while(CBLResultSet_Next(results)) {
        // Update UI
    }
}

static void select_all() {
    CBLDatabase* db = kDatabase;

    // tag::query-select-all[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _"), NULL, &amp;err);

    // All results will be available from the above query
    CBLQuery_Release(query);
    // end::query-select-all[]

    // tag::live-query[]
    /*
    static void query_change_listener(void* context, CBLQuery* query, CBLListenerToken* token) {
        CBLError err;
        CBLResultSet* results = CBLQuery_CopyCurrentResults(query, token, &amp;err);
        while(CBLResultSet_Next(results)) {
            // Update UI
        }
    }
    */

    query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _"), NULL, &amp;err); <i class="conum" data-value="13"></i><b>(13)</b>

    CBLListenerToken* token = CBLQuery_AddChangeListener(query, query_change_listener, NULL); <i class="conum" data-value="14"></i><b>(14)</b>
    // end::live-query[]

    // tag::stop-live-query[]
    CBLListener_Remove(token); // The token received from AddChangeListener
    CBLQuery_Release(query);
    // end::stop-live-query[]
}

static void select_and_access_all() {
    CBLDatabase* db = kDatabase;

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _"), NULL, &amp;err);

    // tag::query-access-all[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict dict = FLValue_AsDict(CBLResultSet_ValueForKey(results, FLSTR("_")));

        FLString id = FLValue_AsString(FLDict_Get(dict, FLSTR("id")));
        FLString type = FLValue_AsString(FLDict_Get(dict, FLSTR("type")));
        FLString name = FLValue_AsString(FLDict_Get(dict, FLSTR("name")));
        FLString city = FLValue_AsString(FLDict_Get(dict, FLSTR("city")));

        printf("ID :: %.*s\n", (int)id.size, (const char *)id.buf);
        printf("Type :: %.*s\n", (int)type.size, (const char *)type.buf);
        printf("Name :: %.*s\n", (int)name.size, (const char *)name.buf);
        printf("City :: %.*s\n", (int)city.size, (const char *)city.buf);
    }

    // All results will be available from the above query
    CBLResultSet_Release(results);
    // end::query-access-all[]

    CBLQuery_Release(query);
}

static void select_props() {
    CBLDatabase* db = kDatabase;

    // tag::query-access-props[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT type, name, city FROM _"), NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString type = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("type")));
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        FLString city = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("city")));

        printf("Type :: %.*s\n", (int)type.size, (const char *)type.buf);
        printf("Name :: %.*s\n", (int)name.size, (const char *)name.buf);
        printf("City :: %.*s\n", (int)city.size, (const char *)city.buf);
    }
    // end::query-access-props[]

    // All results will be available from the above query
    CBLResultSet_Release(results);
    CBLQuery_Release(query);
}

static void select_where() {
    CBLDatabase* db = kDatabase;

    // tag::query-where[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _ WHERE type = \"hotel\" LIMIT 10"), NULL, &amp;err);
    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict dict = FLValue_AsDict(CBLResultSet_ValueForKey(results, FLSTR("_")));
        FLString name = FLValue_AsString(FLDict_Get(dict, FLSTR("name")));
        printf("Document Name :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-where[]
}

static void use_collection_contains() {
    CBLDatabase* db = kDatabase;

    // tag::query-collection-operator-contains[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name, public_likes FROM _ WHERE type = \"hotel\" "
              "AND ARRAY_CONTAINS(public_likes, \"Armani Langworth\")"), NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLArray publicLikes = FLValue_AsArray(CBLResultSet_ValueForKey(results, FLSTR("public_likes")));
        FLStringResult json = FLValue_ToJSON((FLValue)publicLikes);
        printf("Public Likes :: %.*s\n", (int)json.size, (const char *)json.buf);
        FLSliceResult_Release(json);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-collection-operator-contains[]
}

static void use_collection_in() {
    CBLDatabase* db = kDatabase;

    // tag::query-collection-operator-in[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _ WHERE \"Armani\" IN (first, last, username)"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict body = FLValue_AsDict(CBLResultSet_ValueAtIndex(results, 0));
        FLStringResult json = FLValue_ToJSON((FLValue)body);
        printf("In results :: %.*s\n", (int)json.size, (const char *)json.buf);
        FLSliceResult_Release(json);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-collection-operator-in[]
}

static void select_like() {
    CBLDatabase* db = kDatabase;

    // tag::query-like-operator[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND lower(name) LIKE \"Royal Engineers Museum\" LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-like-operator[]
}

static void select_wildcard_like() {
    CBLDatabase* db = kDatabase;

    // tag::query-like-operator-wildcard-match[]
    // NOTE: No error handling, for brevity (see getting started)

     CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND lower(name) LIKE \"Eng%e%\" LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-like-operator-wildcard-match[]
}

static void select_wildcard_character_like() {
    CBLDatabase* db = kDatabase;

    // tag::query-like-operator-wildcard-character-match[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND lower(name) LIKE \"Royal Eng____rs Museum\" LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-like-operator-wildcard-character-match[]
}

static void select_regex() {
    CBLDatabase* db = kDatabase;

    // tag::query-regex-operator[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND regexp_like(name, \"\\bEng.*e\\b\") LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-regex-operator[]
}

static void select_join() {
    CBLDatabase* db = kDatabase;

    // tag::query-join[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT airline.name, airline.callsign, route.destinationairport, route.stops, route.airline "
              "FROM _ AS airline INNER JOIN _ AS route ON meta(airline).id = route.airlineid "
              "WHERE route.type = \"route\" AND airline.type = \"airline\" AND route.sourceairport = \"RIX\""),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-join[]
}

static void group_by() {
    CBLDatabase* db = kDatabase;

    // tag::query-groupby[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT count(*), country, tz FROM _ WHERE type = \"airport\" AND geo.alt &gt;= 300 "
              "GROUP BY country, tz"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        int64_t count = FLValue_AsInt(CBLResultSet_ValueForKey(results, FLSTR("$1")));
        FLString tz = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("tz")));
        FLString country = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("country")));
        printf("There are %" PRIi64 " airports in the %.*s timezone located in %.*s and above 300 ft\n",
            count, (int)tz.size, (const char *)tz.buf, (int)country.size, (const char *)country.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-groupby[]
}

static void order_by() {
    CBLDatabase* db = kDatabase;

    // tag::query-orderby[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, title FROM _ WHERE type = \"hotel\" ORDER BY title ASC LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString title = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("title")));
        printf("Title :: %.*s\n", (int)title.size, (const char *)title.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-orderby[]
}

static void test_explain_statement() {
    CBLDatabase* db = kDatabase;

    {
    // tag::query-explain-all[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _ WHERE type = \"hotel\" GROUP BY country ORDER BY title ASC LIMIT 10"),
        NULL, &amp;err);

    FLSliceResult explanation = CBLQuery_Explain(query);
    printf("%.*s", (int)explanation.size, (const char *)explanation.buf);
    FLSliceResult_Release(explanation);
    // end::query-explain-all[]
    }

    // DOCS NOTE: Others omitted for now
}

static void query_result_json() {
    CBLDatabase* db = kDatabase;

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id as id, name, city, type FROM _ LIMIT 10"),
        NULL, &amp;err);

    // tag::query-access-json[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict result = CBLResultSet_ResultDict(results);
        FLStringResult json = FLValue_ToJSON((FLValue)result);
        printf("JSON Result :: %.*s\n", (int)json.size, (const char *)json.buf);
        FLSliceResult_Release(json);
    }
    CBLResultSet_Release(results);

    // end::query-access-json[]

    CBLQuery_Release(query);
}

static void create_full_text_index() {
    CBLDatabase* db = kDatabase;

    const char* tasks[] = { "buy groceries", "play chess", "book travels", "buy museum tickets" };
    char idBuffer[7];
    for(int i = 0; i &lt; 4; i++) {
        const char* task = tasks[i];
        sprintf(idBuffer, "extra%d", i);
        const CBLDocument* doc = CBLDatabase_GetDocument(db, FLStr(idBuffer), NULL);
        if(doc) {
            CBLDocument_Release(doc);
            continue;
        }

        CBLDocument* mutableDoc = CBLDocument_CreateWithID(FLStr(idBuffer));
        FLMutableDict properties = CBLDocument_MutableProperties(mutableDoc);
        FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("task"));
        FLMutableDict_SetString(properties, FLSTR("task"), FLStr(task));
        CBLDatabase_SaveDocument(db, mutableDoc, NULL);
        CBLDocument_Release(mutableDoc);
    }

    // tag::fts-index[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLFullTextIndexConfiguration config = {
        kCBLN1QLLanguage,
        FLSTR("name"),
        false
    };

    CBLDatabase_CreateFullTextIndex(db, FLSTR("nameFTSIndex"), config, &amp;err);
    // end::fts-index[]
}

static void full_text_search() {
    CBLDatabase* db = kDatabase;

    // tag::fts-query[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _ WHERE MATCH(nameFTSIndex, \"'buy'\")"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString id = FLValue_AsString(CBLResultSet_ValueAtIndex(results, 0));
        printf("Document id :: %.*s\n", (int)id.size, (const char *)id.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::fts-query[]
}

static void start_replication() {
    CBLDatabase* db = kDatabase;

    /*
    * This requires Sync Gateway running with the following config, or equivalent:
    *
    * {
    *     "log":["*"],
    *     "databases": {
    *         "db": {
    *             "server":"walrus:",
    *             "users": {
    *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
    *             }
    *         }
    *     }
    * }
    */

    // tag::replication[]
    // NOTE: No error handling, for brevity (see getting started)
    // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);
    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target;
    config.replicatorType = kCBLReplicatorTypePull;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);
    CBLReplicator_Start(replicator, false);
    // end::replication[]

    stop_replicator(replicator);
}

// Console logging domain methods are not applicable to C

static void file_logging() {
    // tag::file-logging[]
    // NOTE: No error handling, for brevity (see getting started)
    // NOTE: You will need to use a platform appropriate method for finding
    // a temporary directory

    FLString tempFolder = FLSTR("/tmp/cbllog");

    CBLLogFileConfiguration config; // Don't bother zeroing, since we set all properties
    config.level = kCBLLogInfo;
    config.directory = tempFolder;
    config.maxRotateCount = 5;
    config.maxSize = 10240;
    config.usePlaintext = false;

    CBLError err;
    CBLLog_SetFileConfig(config, &amp;err);
    // end::file-logging[]
}

// tag::custom-logging[]
static void custom_log_callback(CBLLogDomain domain, CBLLogLevel level, FLString message) {
    // handle the message, for example piping it to
    // a third party framework
}
// end::custom-logging[]

static void enable_custom_logging() {
    // tag::set-custom-logging[]
    CBLLog_SetCallback(custom_log_callback);
    // end::set-custom-logging[]
}

static void enable_basic_auth() {
    CBLDatabase* db = kDatabase;

    // tag::basic-authentication-full[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/mydatabase");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);
    CBLAuthenticator* basicAuth = CBLAuth_CreatePassword(FLSTR("john"), FLSTR("pass"));

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target;
    config.authenticator = basicAuth;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);
    CBLAuth_Free(basicAuth);

    CBLReplicator_Start(replicator, false);
    // end::basic-authentication-full[]

    stop_replicator(replicator);
}

static void docsonly_N1QL_Params(CBLDatabase* argDb)
{
    CBLDatabase* database = argDb;

    // tag::query-syntax-n1ql-params[]
    int errorPos;

    CBLError err;

    FLString n1qlstr = FLSTR("SELECT * FROM _ WHERE type = $type");

    FLMutableDict n1qlparams = FLMutableDict_New();
    FLMutableDict_SetString(n1qlparams, FLSTR("type"), FLSTR("hotel"));

    CBLQuery* query = CBLDatabase_CreateQuery(database,
                          kCBLN1QLLanguage,
                          n1qlstr,
                          &amp;errorPos,
                          &amp;err);

    CBLQuery_SetParameters(query, n1qlparams);

    if(!query) {
        /* Do appropriate error handling ...
            Note that (where applicable) errorPos contains the position
            in the N1QL string that the parse failed
        */
        FLMutableDict_Release(n1qlparams);
        CBLQuery_Release(query);
        return;
    }

    CBLResultSet* result = CBLQuery_Execute(query, &amp;err);
    if(!result) {
        // Failed to run query, do error handling ...
        return;
    }

    // Release query when finished with
    FLMutableDict_Release(n1qlparams);
    CBLQuery_Release(query);

    // ... process results as required

    // Release result set then finished with
    CBLResultSet_Release(result);

    // end::query-syntax-n1ql-params[]
}



// tag::console-logging-db[]
//Placeholder for code to increase level of console logging for kCBLLogDomainDatabase domain
// end::console-logging-db[]

// tag::console-logging[]
//Placeholder for code to increase level of console logging for all domains
// end::console-logging[]

// tag::date-getter[]
//Placeholder for Date accessors.

// end::date-getter[]


// tag::query-index[]
// placeholder
// end::query-index[]


// DOCS NOTE
// Page=Data Sync &gt;&gt; Configuration Summary
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#configuration-summary
static void docs_act_replication(CBLDatabase* argDb)
{
    CBLDatabase* database = argDb;

    /*
    * This requires Sync Gateway running with the following config, or equivalent:
    *
    * {
    *     "log":["*"],
    *     "databases": {
    *         "db": {
    *             "server":"walrus:",
    *             "users": {
    *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
    *             }
    *         }
    *     }
    * }
    */

    // tag::p2p-act-rep-func[]
    // Purpose -- Show configuration , initialization and running of a replicator

    // NOTE: No error handling, for brevity (see getting started)
    // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err); <i class="conum" data-value="15"></i><b>(15)</b>

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = database;
    config.endpoint = target; <i class="conum" data-value="16"></i><b>(16)</b>

    // tag::p2p-act-rep-config-cont[]
    // Set replication direction and mode
    config.replicatorType = kCBLReplicatorTypePull; <i class="conum" data-value="17"></i><b>(17)</b>
    config.continuous = true;

    // end::p2p-act-rep-config-cont[]

    // Optionally, set auto-purge behavior (here we override default)
    config.disableAutoPurge = true; <i class="conum" data-value="18"></i><b>(18)</b>

    // Optionally, configure Client Authentication
    // Here we are using to Basic Authentication,
    // Providing username and password credentials
    CBLAuthenticator* basicAuth =
        CBLAuth_CreatePassword(FLSTR("username"),
                               FLSTR("passwd")); <i class="conum" data-value="19"></i><b>(19)</b>
    config.authenticator = basicAuth;

    // Optionally, configure how we handle conflicts
    config.conflictResolver = simpleConflictResolver_localWins; <i class="conum" data-value="20"></i><b>(20)</b>

    // Initialize replicator with created config
    CBLReplicator* replicator =
        CBLReplicator_Create(&amp;config, &amp;err); <i class="conum" data-value="21"></i><b>(21)</b>

    CBLEndpoint_Free(target);

    // Optionally, add change listener
    CBLListenerToken* token =
            CBLReplicator_AddChangeListener(replicator,
                                            simpleChangeListener,
                                            NULL); <i class="conum" data-value="22"></i><b>(22)</b>

    // Start replication
    CBLReplicator_Start(replicator, false); <i class="conum" data-value="23"></i><b>(23)</b>

    // end::p2p-act-rep-func[]

    //    ... other processing as required

    // When finished release resources e.g.
    CBLAuth_Free(basicAuth);
    stop_replicator(replicator);
}
// END configuration summary snippets


// DOCS NOTE:
// Page=Data Sync &gt;&gt; Configuration
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#configuration-summary
// This function is not pulled into docs en-bloc
// it is a slightly more in-depth than the configurationsummary above
// and the snippets within it are used individually or in sets
// to illustrate specific points as required
//
static void docs_act_replication_config_section_snippets()
{
    CBLDatabase* db = kDatabase;
    bool docs_example_ShowBasicAuth = false;
    bool docs_example_ShowSessionAuth = false;

    /*
    * This requires Sync Gateway running with the following config, or equivalent:
    *
    * {
    *     "log":["*"],
    *     "databases": {
    *         "db": {
    *             "server":"walrus:",
    *             "users": {
    *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
    *             }
    *         }
    *     }
    * }
    */
    // tag::p2p-act-rep-func-full[]
    // NOTE: No error handling, for brevity (see getting started)
    // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)

    // tag::sgw-act-rep-initialize[]
    // Initialize the configuration object and set db target
    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target =
        CBLEndpoint_CreateWithURL(url, &amp;err); <i class="conum" data-value="24"></i><b>(24)</b>

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target; <i class="conum" data-value="25"></i><b>(25)</b>

    // end::sgw-act-rep-initialize[]

    //    tag::p2p-act-rep-config-type[]
    config.replicatorType = kCBLReplicatorTypePull;

    //    end::p2p-act-rep-config-type[]
    //    tag::p2p-act-rep-config-cont[]
    config.continuous = true;

    //    end::p2p-act-rep-config-cont[]
    // tag::replication-retry-config[]
    // Configure replication retries
    // tag::replication-set-heartbeat[]
    config.heartbeat = 120; //  <i class="conum" data-value="26"></i><b>(26)</b>

    // end::replication-set-heartbeat[]
    // tag::replication-set-maxattempts[]
    config.maxAttempts = 20; //  <i class="conum" data-value="27"></i><b>(27)</b>

    // end::replication-set-maxattempts[]
    // tag::replication-set-maxattemptwaittime[]
    config.maxAttemptWaitTime = 600; //  <i class="conum" data-value="28"></i><b>(28)</b>

    // end::replication-set-maxattemptwaittime[]
    // end::replication-retry-config[]
    // tag::basic-authentication[]
    // Configure Client Authentication to Basic Authentication
    // Providing username and password credentials
    if(docs_example_ShowBasicAuth) {
        CBLAuthenticator* basicAuth =
            CBLAuth_CreatePassword(FLSTR("username"),
                                   FLSTR("passwd"));
        config.authenticator = basicAuth; <i class="conum" data-value="29"></i><b>(29)</b>
    }
    // end::basic-authentication[]

    // tag::session-authentication[]
    if(docs_example_ShowSessionAuth) {
        CBLAuthenticator* sessionAuth =
            CBLAuth_CreateSession(FLSTR("904ac010862f37c8dd99015a33ab5a3565fd8447"),
                                  FLSTR("optionalCookieName"));
        config.authenticator = sessionAuth; <i class="conum" data-value="30"></i><b>(30)</b>
    }

    // end::session-authentication[]

    // tag::replication-custom-header[]
    // Optionally, add custom headers
    FLMutableDict customHdrs = FLMutableDict_New();
    FLMutableDict_SetString(customHdrs,
                            FLSTR("customHeaderName"),
                            FLSTR("customHeaderValue"));

    config.headers = customHdrs;

    // tag::certificate-pinning[]
    char cert_buf[10000];
    FILE* cert_file = fopen("cert.pem", "r");
    size_t read = fread(cert_buf, 1, sizeof(cert_buf), cert_file);
    config.pinnedServerCertificate = (FLSlice){cert_buf, read};
    // end::certificate-pinning[]

    // end::replication-custom-header[]
    // FILTERS
    // tag::replication-push-filter[]
    // tag::replication-pull-filter[]
    // Purpose - Illustrate use of push and-or pull filter functions
    config.pushFilter = simpleReplicationFilter;

    config.pullFilter = simpleReplicationFilter;

    // end::replication-pull-filter[]
    // end::replication-push-filter[]

    //  Auto-purge over-ride
    // tag::autopurge-override[]
    config.disableAutoPurge = true; <i class="conum" data-value="31"></i><b>(31)</b>

    // end::autopurge-override[]
    // Initialize replicator with created config
    CBLReplicator* replicator =
        CBLReplicator_Create(&amp;config, &amp;err); <i class="conum" data-value="32"></i><b>(32)</b>

    CBLEndpoint_Free(target);

    // Add optional change listener
    CBLListenerToken* token_ReplChangeListener =
        CBLReplicator_AddChangeListener(replicator,
                                        simpleChangeListener,
                                        NULL); <i class="conum" data-value="33"></i><b>(33)</b>
}
// END replication.html &gt;&gt; configure section


// PAGE=Data Sync &gt;&gt; Initialize section
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#lbl-init-repl
static CBLReplicator* docs_act_replication_Intialize(
                        void* context,
                        CBLReplicatorConfiguration argConfig,
                        bool argResetRequired)
{
    CBLError err;
    bool docs_example_resetRequired = argResetRequired;
    // tag::p2p-act-rep-start-full[]
    CBLReplicator* thisRepl =
    CBLReplicator_Create(&amp;argConfig, &amp;err); <i class="conum" data-value="34"></i><b>(34)</b>

    // end::p2p-act-rep-start-full[]
    if(!docs_example_resetRequired) {
    // tag::p2p-act-rep-start-full[]
      CBLReplicator_Start(thisRepl, false); <i class="conum" data-value="35"></i><b>(35)</b>

    // end::p2p-act-rep-start-full[]
    } else {
    // tag::replication-reset-checkpoint[]
      CBLReplicator_Start(thisRepl, true); <i class="conum" data-value="36"></i><b>(36)</b>

    // end::replication-reset-checkpoint[]
    }
    return thisRepl;
}
// END replication.html &gt;&gt; initialize section

// PAGE=Data Sync &gt;&gt; Monitor section
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#lbl-repl-mon
static void docs_act_replication_Monitor(
                                       void* context,
                                       CBLReplicator* argRepl) {
    CBLError err;
    CBLReplicator* thisRepl = argRepl;
    // tag::p2p-act-rep-add-change-listener[]
    // Purpose -- illustrate addition of a Replicator change listener
    CBLListenerToken* token_ReplChangeListener =
            CBLReplicator_AddChangeListener(thisRepl,
                                            simpleChangeListener,
                                            NULL);

    // end::p2p-act-rep-add-change-listener[]
    // tag::add-document-replication-listener[]
    // Purpose -- illustrate addition of a Document Replicator  listener
    CBLListenerToken* token_ReplDocListener =
            CBLReplicator_AddDocumentReplicationListener(
                                                        thisRepl,
                                                        SimpleReplicationDocumentListener,
                                                        context);

    // end::add-document-replication-listener[]
    // tag::remove-document-replication-listener[]
    // Purpose -- illustrate removal of a listener
    CBLListener_Remove(token_ReplDocListener);
    CBLListener_Remove(token_ReplChangeListener);

    // end::remove-document-replication-listener[]

    // tag::p2p-act-rep-status[]
    // Purpose -- illustrate use of CBLReplicator_Status()
    CBLReplicatorStatus thisState = CBLReplicator_Status(thisRepl);
    if(thisState.activity==kCBLReplicatorStopped) {
        if(thisState.error.code==0) {
            CBLReplicator_Start(thisRepl,false);
        } else {
            printf("Replicator stopped -- code %d", thisState.error.code);
            // ... handle error ...
            CBLReplicator_Release(thisRepl);
        }
    }

    // end::p2p-act-rep-status[]
    // tag::replication-pendingdocuments[]
    FLDict thisPendingIdList =
        CBLReplicator_PendingDocumentIDs(thisRepl, &amp;err); <i class="conum" data-value="37"></i><b>(37)</b>
    if(!FLDict_IsEmpty(thisPendingIdList)) {
        FLDictIterator item;
        FLDictIterator_Begin(thisPendingIdList, &amp;item);
        FLValue itemValue;
        FLString pendingId;
        while(NULL != (itemValue = FLDictIterator_GetValue(&amp;item))) {
            pendingId = FLValue_AsString(itemValue);
            if(CBLReplicator_IsDocumentPending(thisRepl,
                                               pendingId,
                                               &amp;err)) {
                // ... process the still pending docid as required <i class="conum" data-value="38"></i><b>(38)</b>
            } else {
                // Doc Id no longer pending
                if(err.code==0) {
                    // No fail so must have already been pushed
                    printf("Document already pushed");
                } else {
                    // Error detected so handle it
                    printf("Error code %d checking for pendingId", err.code);
                    break;
                }
            }
            FLDictIterator_Next(&amp;item);
        }
        FLDictIterator_End(&amp;item);
        FLValue_Release(itemValue);
    } else {
        printf("No Pending Id Docs to process");
    }
    FLDict_Release(thisPendingIdList);

    // end::replication-pendingdocuments[]
}
// END replication.html &gt;&gt; Monitor section

// BEGIN replication.html &gt;&gt; Stop section
// PAGE=Data Sync &gt;&gt; Stop
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#lbl-repl-stop
static void docs_act_replication_Stop(
                                       void* context,
                                       CBLReplicator* argRepl) {
    // tag::p2p-act-rep-stop[]
    // Purpose -- show how to stop a replication
    if(CBLReplicator_Status(argRepl).activity!=kCBLReplicatorStopped) {
        CBLReplicator_Stop(argRepl);
    }

    // end::p2p-act-rep-stop[]
}
// END replication.html &gt;&gt; Stop section

static void replication_error_handling() {
    CBLDatabase* db = kDatabase;
    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);
    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);



    stop_replicator(replicator);
}

static void create_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    // tag::encryptable[]
    // NOTE: No error handling, for brevity (see getting started)

    // Create with premitive type
    CBLEncryptable* encNull = CBLEncryptable_CreateWithNull();
    CBLEncryptable* encBool = CBLEncryptable_CreateWithBool(true);
    CBLEncryptable* encInt = CBLEncryptable_CreateWithInt(256);
    CBLEncryptable* encUInt = CBLEncryptable_CreateWithUInt(1024);
    CBLEncryptable* encFloat = CBLEncryptable_CreateWithFloat(1.2);
    CBLEncryptable* encDouble = CBLEncryptable_CreateWithDouble(100.50);
    CBLEncryptable* encString = CBLEncryptable_CreateWithString(FLSTR("foo"));

    // Create with dictionary
    FLMutableDict dict = FLMutableDict_New();
    FLSlot_SetString(FLMutableDict_Set(dict, FLSTR("greeting")), FLSTR("hello"));
    CBLEncryptable* encDict = CBLEncryptable_CreateWithDict(dict);

    // Create with array
    FLMutableArray array = FLMutableArray_New();
    FLSlot_SetString(FLMutableArray_Append(array), FLSTR("item1"));
    CBLEncryptable* encArray = CBLEncryptable_CreateWithArray(array);

    // Create with FLValue
    FLMutableDict dict2 = FLMutableDict_New();
    FLSlot_SetString(FLMutableDict_Set(dict2, FLSTR("greeting")), FLSTR("hello"));
    CBLEncryptable* encValue = CBLEncryptable_CreateWithValue((FLValue)dict2);
    // end::encryptable[]

    // Release after using it
    CBLEncryptable_Release(encNull);
    CBLEncryptable_Release(encBool);
    CBLEncryptable_Release(encInt);
    CBLEncryptable_Release(encBool);
    CBLEncryptable_Release(encUInt);
    CBLEncryptable_Release(encFloat);
    CBLEncryptable_Release(encDouble);
    CBLEncryptable_Release(encString);
    CBLEncryptable_Release(encDict);
    CBLEncryptable_Release(encArray);
    CBLEncryptable_Release(encValue);

    FLMutableDict_Release(dict);
    FLMutableDict_Release(dict2);
    FLMutableArray_Release(array);

    #endif
}

static void release_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLEncryptable* encValue = CBLEncryptable_CreateWithString(FLSTR("foo"));
    // tag::release_encryptable[]
    // Release the encryptable value after finish using it
    CBLEncryptable_Release(encValue);
    // end::release_encryptable[]

    #endif
}

static void use_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLDatabase* db = kDatabase;

    // tag::use_encryptable[]
    // NOTE: No error handling, for brevity (see getting started)
    CBLDocument* doc = CBLDocument_CreateWithID(FLSTR("doc1"));

    // Set encryptable:
    FLMutableDict props = CBLDocument_MutableProperties(doc);
    CBLEncryptable* encryptable = CBLEncryptable_CreateWithString(FLSTR("My secret"));
    FLSlot_SetEncryptableValue(FLMutableDict_Set(props, FLSTR("secret")), encryptable);

    CBLError error;
    CBLDatabase_SaveDocument(db, doc, &amp;error);

    // Release
    CBLDocument_Release(doc);
    CBLEncryptable_Release(encryptable);
    // end::release_encryptable[]

    #endif
}

static void query_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLDatabase* db = kDatabase;

    // tag::use_encryptable[]
    // NOTE: No error handling, for brevity (see getting started)
    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT secret, secret.value as secretValue FROM _ WHERE type = \"profile\""), NULL, &amp;err);
    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        // Get secret as CBLEncryptable value
        FLValue value = CBLResultSet_ValueForKey(results, FLSTR("secret"));
        const CBLEncryptable* encValue = FLValue_GetEncryptableValue(value);
        FLString secretStr = FLValue_AsString(CBLEncryptable_Value(encValue));
        printf("Secret :: %.*s\n", (int)secretStr.size, (const char *)secretStr.buf);

        // Get secret value directly
        value = CBLResultSet_ValueForKey(results, FLSTR("secretValue"));
        secretStr = FLValue_AsString(value);
        printf("Secret :: %.*s\n", (int)secretStr.size, (const char *)secretStr.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::release_encryptable[]

    #endif
}

#ifdef COUCHBASE_ENTERPRISE

// tag::replicator_property_encryption[]
// tag::replicator_property_encryptor_decryptor_sample[]
// Purpose: Declare property-level encryptor callback functions
static FLSliceResult my_cipher_function(FLSlice input) {
    FLSliceResult result = FLSliceResult_New(input.size);
    for(int i = 0; i &lt; input.size; ++i) {
        ((uint8_t*)(result.buf))[i] = ((uint8_t*)input.buf)[i] ^ 'K';}
    return result;
}


static FLSliceResult property_encryptor(void* context, FLString docID, FLDict props, FLString path,
                                        FLSlice input, FLStringResult* algorithm, FLStringResult* keyID, CBLError* error) {
    *algorithm = FLSlice_Copy(FLSTR("MyEnc"));
    return my_cipher_function(input);
}


static FLSliceResult property_decryptor(void* context, FLString documentID, FLDict properties, FLString keyPath,
                                        FLSlice input, FLString algorithm, FLString keyID, CBLError* error) {
    return my_cipher_function(input);
}

// end::replicator_property_encryptor_decryptor_sample[]
// end::replicator_property_encryption[]

#endif

// PAGE=Field Level Encryption
// URL=https://docs.couchbase.com/couchbase-lite/current/c/field-level-encryption.html
//
static void replicator_property_encryption() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLDatabase* db = kDatabase;

    // tag::replicator_property_encryption[]
    // Purpose: Show how to declare en(de)cryptors in replicator config
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));

    config.database = db;
    config.endpoint = target;
    config.propertyEncryptor = property_encryptor; <i class="conum" data-value="39"></i><b>(39)</b>
    config.propertyDecryptor = property_decryptor; <i class="conum" data-value="40"></i><b>(40)</b>

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);

    CBLReplicator_Start(replicator, false);
    // end::replicator_property_encryption[]

    stop_replicator(replicator);

    #endif
}

int main(int argc, char** argv) {
    create_new_database();
    create_document();
    update_document();
    do_batch_operation();
    // Disable use_blob() as no avatar.jpg to load and crash
    // use_blob();
    doc_json();
    dict_json();
    array_json();
    load_prebuilt();
    create_index();
    select_all();
    select_and_access_all();
    select_props();
    select_meta();
    select_id();
    select_where();
    use_collection_contains();
    select_like();
    select_wildcard_like();
    select_wildcard_character_like();
    select_regex();
    select_join();
    group_by();
    order_by();
    query_result_json();

    create_full_text_index();
    full_text_search();
    start_replication();
    replicator_property_encryption();

    CBLDatabase_Close(kDatabase, NULL);

    return 0;
}</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Import from an existing resource bundle</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/c/examples/code_snippets/main.c">// CBL Version 3.0.0 BETA
#include &lt;cbl/CouchbaseLite.h&gt;
#include &lt;time.h&gt;
#include &lt;inttypes.h&gt;
#ifdef _MSC_VER
#include &lt;direct.h&gt;
#include &lt;Shlwapi.h&gt;

void usleep(unsigned int us) {
    Sleep(us / 1000);
}
#else
#include &lt;unistd.h&gt;
#endif

static CBLDatabase* kDatabase;

// Helper for stop replicator in the code snippet
static void stop_replicator(CBLReplicator* replicator) {
    CBLReplicator_Stop(replicator);
    while(CBLReplicator_Status(replicator).activity != kCBLReplicatorStopped) {
        printf("Waiting for replicator to stop...");
        usleep(200000);
    }
    CBLReplicator_Release(replicator);
}

//  BEGIN lower-level function declarations

//  DOCS NOTE --
//  These functions are referred to in subsequent code samples.
//  Their tags will ensure they are shown alongide the usage examples.
//  Functions used in more than one place may hve multiple tags.

// tag::p2p-act-rep-func[]
// tag::p2p-act-rep-add-change-listener[]
// tag::replication-error-handling[]
// Purpose -- illustrate a simple change listener
static void simpleChangeListener(void* context,
                                 CBLReplicator* repl,
                                 const CBLReplicatorStatus* status)
{
     if(status-&gt;error.code != 0) {
         printf("Error %d / %d\n",
                status-&gt;error.domain,
                status-&gt;error.code);
     }
}
// end::replication-error-handling[]
// end::p2p-act-rep-add-change-listener[]
// end::p2p-act-rep-func[]

static const CBLDocument* simpleConflictResolver_localWins(
                                void* context, FLString documentID,
                                const CBLDocument* localDocument,
                                const CBLDocument* remoteDocument)
{
    return localDocument;
}

// tag::replication-push-filter[]
// tag::replication-pull-filter[]
// Purpose -- illustrate a simple replication filter function
static bool simpleReplicationFilter(void* context,
                                    CBLDocument* argDoc,
                                    CBLDocumentFlags argFlags)
{
    bool result = (argFlags == kCBLDocumentFlagsDeleted);
    return result;
}

// end::replication-push-filter[]
// end::replication-pull-filter[]

// tag::SimpleReplicationDocumentListener[]
// Purpose -- Illustrate a simple replication document listener
static void SimpleReplicationDocumentListener(
                                  void *context,
                                  CBLReplicator *replicator,
                                  bool isPush,
                                  unsigned numDocuments,
                                  const CBLReplicatedDocument *documents)
{
    if(isPush) {
        printf("We pushed %d documents",numDocuments);
    }
}

// END lower-level function declarations


static void getting_started_change_listener(void* context,
                                            CBLReplicator* repl,
                                            const CBLReplicatorStatus* status)
{
    if(status-&gt;error.code != 0) {
        printf("Error %d / %d\n", status-&gt;error.domain, status-&gt;error.code);
    }
}

// Page=build and run
// url=https://docs-staging.couchbase.com/couchbase-lite/current/c/gs-build.html
static void getting_started() {
    // tag::getting-started[]
    //  Purpose-- provide an overview of available crud  and sync functionality
    //
    // Get the database (and create it if it doesn't exist)
    CBLError err;
    CBLDatabase* database = CBLDatabase_Open(FLSTR("mydb"), NULL, &amp;err);
    if(!database) {
        // Error handling.  For brevity, this is truncated in the rest of the snippet
        // and omitted in other doc code snippets
        fprintf(stderr, "Error opening database (%d / %d)\n", err.domain, err.code);
        FLSliceResult msg = CBLError_Message(&amp;err);
        fprintf(stderr, "%.*s\n", (int)msg.size, (const char *)msg.buf);
        FLSliceResult_Release(msg);
        return;
    }

    // The lack of 'const' indicates this document is mutable
    // Create a new document (i.e. a record) in the database
    CBLDocument* mutableDoc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDoc);
    FLMutableDict_SetFloat(properties, FLSTR("version"), 3.0f);

    // Save it to the database
    if(!CBLDatabase_SaveDocument(database, mutableDoc, &amp;err)) {
        // Failed to save, do error handling as above
        return;
    }

    // Since we will release the document, make a copy of the ID since it
    // is an internal pointer.  Whenever we create or get an FLSliceResult
    // or FLStringResult we will need to free it later too!
    FLStringResult id = FLSlice_Copy(CBLDocument_ID(mutableDoc));
    CBLDocument_Release(mutableDoc);

    // Update a document
    mutableDoc = CBLDatabase_GetMutableDocument(database, FLSliceResult_AsSlice(id), &amp;err);
    if(!mutableDoc) {
        // Failed to retrieve, do error handling as above.  NOTE: error code 0 simply means
        // the document does not exist.
        return;
    }

    properties = CBLDocument_MutableProperties(mutableDoc);
    FLMutableDict_SetString(properties, FLSTR("language"), FLSTR("C"));
    if(!CBLDatabase_SaveDocument(database, mutableDoc, &amp;err)) {
        // Failed to save, do error handling as above
        return;
    }

    // Note const here, means readonly
    const CBLDocument* docAgain = CBLDatabase_GetDocument(database, FLSliceResult_AsSlice(id), &amp;err);
    if(!docAgain) {
        // Failed to retrieve, do error handling as above.  NOTE: error code 0 simply means
        // the document does not exist.
        return;
    }

    // No copy this time, so no release later (notice it is not FLStringResult this time)
    FLString retrievedID = CBLDocument_ID(docAgain);
    FLDict retrievedProperties = CBLDocument_Properties(docAgain);
    FLString retrievedLanguage = FLValue_AsString(FLDict_Get(retrievedProperties, FLSTR("language")));
    printf("Document ID :: %.*s\n", (int)retrievedID.size, (const char *)retrievedID.buf);
    printf("Learning %.*s\n", (int)retrievedLanguage.size, (const char *)retrievedLanguage.buf);

    CBLDocument_Release(mutableDoc);
    CBLDocument_Release(docAgain);
    FLSliceResult_Release(id);

    // tag::query-syntax-n1ql[]
    // Create a query to fetch documents of type SDK
    int errorPos;
    CBLQuery* query = CBLDatabase_CreateQuery(database, kCBLN1QLLanguage, FLSTR("SELECT * FROM _ WHERE type = \"SDK\""), &amp;errorPos, &amp;err);
    if(!query) {
        // Failed to create query, do error handling as above
        // Note that errorPos will contain the position in the N1QL string
        // that the parse failed, if applicable
        return;
    }

    CBLResultSet* result = CBLQuery_Execute(query, &amp;err);
    if(!result) {
        // Failed to run query, do error handling as above
        return;
    }
    // end::query-syntax-n1ql[]

    // TODO: Result set count?
    CBLResultSet_Release(result);
    CBLQuery_Release(query);

    // Create replicator to push and pull changes to and from the cloud
    CBLEndpoint* targetEndpoint = CBLEndpoint_CreateWithURL(FLSTR("ws://localhost:4984/getting-started-db"), &amp;err);
    if(!targetEndpoint) {
        // Failed to create endpoint, do error handling as above
        return;
    }

    CBLReplicatorConfiguration replConfig;
    CBLAuthenticator* basicAuth = CBLAuth_CreatePassword(FLSTR("john"), FLSTR("pass"));
    memset(&amp;replConfig, 0, sizeof(replConfig));
    replConfig.database = database;
    replConfig.endpoint = targetEndpoint;
    replConfig.authenticator = basicAuth;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;replConfig, &amp;err);
    CBLAuth_Free(basicAuth);
    CBLEndpoint_Free(targetEndpoint);
    if(!replicator) {
        // Failed to create replicator, do error handling as above
        return;
    }

    // Assume a function like the simple following
    //
    // static void getting_started_change_listener(void* context, CBLReplicator* repl, const CBLReplicatorStatus* status) {
    //     if(status-&gt;error.code != 0) {
    //         printf("Error %d / %d\n", status-&gt;error.domain, status-&gt;error.code);
    //     }
    // }

    CBLListenerToken* token = CBLReplicator_AddChangeListener(replicator, getting_started_change_listener, NULL);

    CBLReplicator_Start(replicator, false);

    // Later, stop and release the replicator
    // end::getting-started[]

    // When finished release resources ... eg
    CBLListener_Remove(token);

    stop_replicator(replicator);
}


// tag::local-win-conflict-resolver[]
static const CBLDocument* local_win_conflict_resolver(void* context,
                                                      FLString documentID,
                                                      const CBLDocument* localDocument,
                                                      const CBLDocument* remoteDocument)
{
    return localDocument;
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
static const CBLDocument* remote_win_conflict_resolver(void* context,
                                                       FLString documentID,
                                                       const CBLDocument* localDocument,
                                                       const CBLDocument* remoteDocument)
{
    return remoteDocument;
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
static const CBLDocument* merge_conflict_resolver(void* context,
                                                  FLString documentID,
                                                  const CBLDocument* localDocument,
                                                  const CBLDocument* remoteDocument)
{
    FLDict localProps = CBLDocument_Properties(localDocument);
    FLDict remoteProps = CBLDocument_Properties(remoteDocument);
    FLMutableDict mergeProps = FLDict_MutableCopy(localProps, kFLDefaultCopy);

    FLDictIterator d;
    FLDictIterator_Begin(localProps, &amp;d);
    FLValue value;
    while((value = FLDictIterator_GetValue(&amp;d))) {
        FLString key = FLDictIterator_GetKeyString(&amp;d);
        if(FLDict_Get(mergeProps, key)) {
            continue;
        }

        FLMutableDict_SetValue(mergeProps, key, value);
        FLDictIterator_Next(&amp;d);
    }

    CBLDocument* mergeDocument = CBLDocument_CreateWithID(documentID);
    CBLDocument_SetProperties(mergeDocument, mergeProps);
    FLMutableDict_Release(mergeProps);

    return mergeDocument;
}
// end::merge-conflict-resolver[]

static void test_replicator_conflict_resolve() {
    CBLDatabase* database = kDatabase;

    // tag::replication-conflict-resolver[]
    // NOTE: No error handling, for brevity (see getting started)
    CBLError err;
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(FLSTR("ws://localhost:4984/mydatabase"), &amp;err);

    CBLReplicatorConfiguration replConfig;
    memset(&amp;replConfig, 0, sizeof(replConfig));
    replConfig.database = database;
    replConfig.endpoint = target;
    replConfig.conflictResolver = local_win_conflict_resolver;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;replConfig, &amp;err);
    CBLEndpoint_Free(target);
    CBLReplicator_Start(replicator, false);

    // end::replication-conflict-resolver[]

    stop_replicator(replicator);
}

static bool custom_conflict_handler(void* context,
                                    CBLDocument* documentBeingSaved,
                                    const CBLDocument* conflictingDocument)
{
    FLDict currentProps = CBLDocument_Properties(conflictingDocument);
    FLDict updatedProps = CBLDocument_Properties(documentBeingSaved);
    FLMutableDict newProps = FLDict_MutableCopy(updatedProps, kFLDefaultCopy);

    FLDictIterator d;
    FLDictIterator_Begin(currentProps, &amp;d);
    FLValue currentValue;
    while((currentValue = FLDictIterator_GetValue(&amp;d))) {
        FLString currentKey = FLDictIterator_GetKeyString(&amp;d);
        if(FLDict_Get(newProps, currentKey)) {
            continue;
        }

        FLMutableDict_SetValue(newProps, currentKey, currentValue);
        FLDictIterator_Next(&amp;d);
    }

    return true;
}

static void test_save_with_conflict_handler() {
    CBLDatabase* database = kDatabase;

    // tag::update-document-with-conflict-handler[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDocument* mutableDocument = CBLDatabase_GetMutableDocument(database, FLSTR("xyz"), &amp;err);
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDocument);
    FLMutableDict_SetString(properties, FLSTR("name"), FLSTR("apples"));

    /*
    static bool custom_conflict_handler(void* context, CBLDocument* documentBeingSaved,
        const CBLDocument* conflictingDocument) {
        FLDict currentProps = CBLDocument_Properties(conflictingDocument);
        FLDict updatedProps = CBLDocument_Properties(documentBeingSaved);
        FLMutableDict newProps = FLDict_MutableCopy(updatedProps, kFLDefaultCopy);

        FLDictIterator d;
        FLDictIterator_Begin(currentProps, &amp;d);
        FLSlice currentKey = FLDictIterator_GetKeyString(&amp;d);
        for(; currentKey.buf; currentKey = FLDictIterator_GetKeyString(&amp;d)) {
            if(FLDict_Get(newProps, currentKey)) {
                continue;
            }

            FLValue currentValue = FLDictIterator_GetValue(&amp;d);
            FLMutableDict_SetValue(newProps, currentKey, currentValue);
        }

        return true;
    }
    */
    CBLDatabase_SaveDocumentWithConflictHandler(database, mutableDocument, custom_conflict_handler, NULL, &amp;err);

    // end::update-document-with-conflict-handler[]
}

static void use_encryption() {
    #ifdef COUCHBASE_ENTERPRISE

    // tag::database-encryption[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLDatabaseConfiguration config = CBLDatabaseConfiguration_Default();

    // This returns a boolean, so check it in production code
    CBLEncryptionKey_FromPassword(&amp;config.encryptionKey, FLSTR("password"));

    CBLError err;
    CBLDatabase* db = CBLDatabase_Open(FLSTR("seekrit"), &amp;config, &amp;err);

    // Change the encryption key (or add encryption if the DB is unencrypted)
    CBLEncryptionKey betterKey;
    CBLEncryptionKey_FromPassword(&amp;betterKey, FLSTR("betterpassw0rd"));
    CBLDatabase_ChangeEncryptionKey(db, &amp;betterKey, &amp;err);

    // Remove encryption
    CBLDatabase_ChangeEncryptionKey(db, NULL, &amp;err);
    // end::database-encryption[]

    #endif
}

static void reset_replicator_checkpoint() {
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(FLSTR("ws://localhost:4984/db"), NULL);
    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = kDatabase;
    config.endpoint = target;
    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, NULL);
    CBLEndpoint_Free(target);

    // tag::replication-reset-checkpoint-full[]
    // replicator is a CBLReplicator* instance
    CBLReplicator_Start(replicator, true); <i class="conum" data-value="1"></i><b>(1)</b>

    // end::replication-reset-checkpoint-full[]

    stop_replicator(replicator);
}

static void read_1x_attachment() {
    CBLDocument* document = CBLDocument_Create();

    // tag::1x-attachment[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    FLDict properties = CBLDocument_Properties(document);
    FLDict attachments = FLValue_AsDict(FLDict_Get(properties, FLSTR("_attachments")));
    const CBLBlob* avatar = FLDict_GetBlob(FLValue_AsDict(FLDict_Get(attachments, FLSTR("avatar"))));
    FLSliceResult content = CBLBlob_Content(avatar, &amp;err);

    FLSliceResult_Release(content);
    // end::1x-attachment[]

    CBLDocument_Release(document);
}

static void create_new_database() {
    // tag::new-database[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDatabase* db = CBLDatabase_Open(FLSTR("my-database"), NULL, &amp;err);
    // end::new-database[]

    kDatabase = db;
}

static void close_database() {
    CBLDatabase* db = kDatabase;
    // tag::close-database[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDatabase_Close(db, &amp;err);
    // end::close-database[]
}

static void change_logging() {
    // tag::logging[]
    // For output to stdout
    CBLLog_SetConsoleLevel(kCBLLogVerbose);

    // For output to custom logging
    CBLLog_SetCallbackLevel(kCBLLogVerbose);
    // end::logging[]
}

static void load_prebuilt() {
    CBL_DeleteDatabase(FLSTR("travel-sample.cblite2"), kFLSliceNull, NULL);

    // tag::prebuilt-database[]
    // Note: Getting the path to a database is platform-specific.  For desktop (including RPi)
    // this can be a simple filesystem path.  For iOS you need to get the path from the
    // main bundle.  For Android you need to extract it from your assets to a temporary directory
    // and then pass that path.

    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    const char* path = "/path/to/travel-sample.cblite2";
    if(!CBL_DatabaseExists(FLSTR("travel-sample.cblite2"), kFLSliceNull)) {
        CBL_CopyDatabase(FLStr(path), FLSTR("travel-sample"), NULL, &amp;err);
    }
    // end::prebuilt-database[]

    CBLDatabase_Close(kDatabase, NULL);
    CBLDatabase_Release(kDatabase);
    kDatabase = CBLDatabase_Open(FLSTR("travel-sample"), NULL, NULL);
}

static void query_deleted_document() {
    CBLDatabase* db = kDatabase;

    // tag::query-deleted-documents[]
    // Query documents that have been deleted
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _ WHERE meta().deleted"), NULL, &amp;err);
    // end::query-deleted-documents[]

    CBLQuery_Release(query);
}

static void create_document() {
    CBLDatabase* db = kDatabase;

    // tag::initializer[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLDocument* newTask = CBLDocument_CreateWithID(FLSTR("xyz"));
    FLMutableDict properties = CBLDocument_MutableProperties(newTask);
    FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("task"));
    FLMutableDict_SetString(properties, FLSTR("owner"), FLSTR("todo"));

    // Storing time in millisecond, bluntly
    FLMutableDict_SetUInt(properties, FLSTR("createdAt"), time(NULL) * 1000);

    CBLError err;
    CBLDatabase_SaveDocument(db, newTask, &amp;err);
    CBLDocument_Release(newTask);
    // end::initializer[]
}

static void update_document() {
    CBLDatabase* db = kDatabase;

    // tag::update-document[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDocument* mutableDocument = CBLDatabase_GetMutableDocument(db, FLSTR("xyz"), &amp;err);
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDocument);
    FLMutableDict_SetString(properties, FLSTR("name"), FLSTR("apples"));
    CBLDatabase_SaveDocument(db, mutableDocument, &amp;err);
    CBLDocument_Release(mutableDocument);
    // end::update-document[]
}

// Note use_typed_accessors not applicable

static void do_batch_operation() {
    CBLDatabase* db = kDatabase;

    // tag::batch[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDatabase_BeginTransaction(db, &amp;err);
    char buffer[7];
    for(int i = 0; i &lt; 10; i++) {
        CBLDocument* doc = CBLDocument_Create();
        FLMutableDict properties = CBLDocument_MutableProperties(doc);
        FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("user"));
        sprintf(buffer, "user %d", i);
        FLMutableDict_SetString(properties, FLSTR("name"), FLStr(buffer));
        FLMutableDict_SetBool(properties, FLSTR("admin"), false);
        CBLDatabase_SaveDocument(db, doc, &amp;err);
        CBLDocument_Release(doc);
        printf("Saved user document %s\n", buffer);
    }

    CBLDatabase_EndTransaction(db, true, &amp;err);
    // end::batch[]
}

static void document_listener(void* context, const CBLDatabase* db, FLString id) {
    CBLError err;
    const CBLDocument* doc = CBLDatabase_GetDocument(db, id, &amp;err);
    FLDict properties = CBLDocument_Properties(doc);
    FLString verified_account = FLValue_AsString(FLDict_Get(properties, FLSTR("verified_account")));
    printf("Status :: %.*s\n", (int)verified_account.size, (const char *)verified_account.buf);
    CBLDocument_Release(doc);
}

static void database_change_listener() {
    CBLDatabase* db = kDatabase;

    // tag::document-listener[]
    /*
    static void document_listener(void* context, const CBLDatabase* db, FLString id) {
        CBLError err;
        const CBLDocument* doc = CBLDatabase_GetDocument(db, id, &amp;err);
        FLDict properties = CBLDocument_Properties(doc);
        FLString verified_account = FLValue_AsString(FLDict_Get(properties, FLSTR("verified_account")));
        printf("Status :: %.*s\n", (int)verified_account.size, (const char *)verified_account.buf);
        CBLDocument_Release(doc);
    }
    */
    CBLListenerToken* token = CBLDatabase_AddDocumentChangeListener(db, FLSTR("user.john"),
        document_listener, NULL);
    // end::document-listener[]

    CBLListener_Remove(token);
}

static void document_expiration() {
    CBLDatabase* db = kDatabase;

    // tag::document-expiration[]
    // Purge the document one day from now

    // Overly simplistic for example purposes
    // NOTE: API takes milliseconds
    // NOTE: No error handling, for brevity (see getting started)
    time_t ttl = time(NULL) + 24 * 60 * 60;
    ttl *= 1000;

    CBLError err;
    CBLDatabase_SetDocumentExpiration(db, FLSTR("doc123"), ttl, &amp;err);

    // Reset expiration
    CBLDatabase_SetDocumentExpiration(db, FLSTR("doc1"), 0, &amp;err);

    // Query documents that will be expired in less than five minutes
    time_t fiveMinutesFromNow = time(NULL) + 5 * 60;
    fiveMinutesFromNow *= 1000;
    FLMutableDict parameters = FLMutableDict_New();
    FLMutableDict_SetInt(parameters, FLSTR("five_minutes"), fiveMinutesFromNow);

    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _ WHERE meta().expiration &lt; $five_minutes"), NULL, &amp;err);
    CBLQuery_SetParameters(query, parameters);
    FLMutableDict_Release(parameters);
    // end::document-expiration[]
}

static void use_blob() {
    CBLDatabase* db = kDatabase;

    CBLDocument* newTask = CBLDocument_Create();

    // tag::blob[]
    // Note: Reading the data is implementation dependent, as with prebuilt databases
    // NOTE: No error handling, for brevity (see getting started)

    uint8_t buffer[128000];
    FILE* avatar_file = fopen("avatar.jpg", "rb");
    size_t read = fread(buffer, 1, 128000, avatar_file); <i class="conum" data-value="2"></i><b>(2)</b>

    FLSliceResult avatar = FLSliceResult_CreateWith(buffer, read);
    CBLBlob* blob = CBLBlob_CreateWithData(FLSTR("image/jpeg"), FLSliceResult_AsSlice(avatar)); <i class="conum" data-value="3"></i><b>(3)</b>
    FLSliceResult_Release(avatar);

    // TODO: Create shortcut blob method
    CBLError err;
    FLMutableDict properties = CBLDocument_MutableProperties(newTask);
    FLSlot_SetBlob(FLMutableDict_Set(properties, FLSTR("avatar")), blob);
    CBLDatabase_SaveDocument(db, newTask, &amp;err); <i class="conum" data-value="4"></i><b>(4)</b>

    // end::blob[]



    CBLDocument_Release(newTask);
    CBLBlob_Release(blob);
}

static void doc_json() {
    CBLDatabase* db = kDatabase;

    // tag::tojson-document[]
    // NOTE: No error handling, for brevity (see getting started)

    FLString json = FLSTR("{\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",\"country\":\"Australia\"}");

    // Create a document and set the JSON data to the document
    CBLError err;
    CBLDocument* newDoc = CBLDocument_CreateWithID(FLSTR("hotel_1002"));
    CBLDocument_SetJSON(newDoc, json, &amp;err);

    // Save the document to the database
    CBLDatabase_SaveDocument(db, newDoc, &amp;err);

    // Release created doc after using it
    CBLDocument_Release(newDoc);

    // Get the document from the database
    const CBLDocument* doc = CBLDatabase_GetDocument(db, FLSTR("hotel_1002"), &amp;err);

    // Get document body as JSON
    FLSliceResult docJson = CBLDocument_CreateJSON(doc);
    printf("Document in JSON :: %.*s\n", (int)docJson.size, (const char *)docJson.buf);

    // Release JSON data after using it
    FLSliceResult_Release(docJson);

    // Release doc read from the database after using it
    CBLDocument_Release(doc);
    // end::tojson-document[]
}

static void dict_json() {
    // tag::tojson-dictionary[]
    // NOTE: No error handling, for brevity (see getting started)

    FLString json = FLSTR("{\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",\"country\":\"Australia\"}");

    // Create a dictionary from the JSON string
    FLError err;
    FLSliceResult jsonData1 = FLData_ConvertJSON(json, &amp;err);
    FLDict hotel = FLValue_AsDict(FLValue_FromData(FLSliceResult_AsSlice(jsonData1), kFLTrusted));

    // Iterate through the dictionary
    FLDictIterator iter;
    FLDictIterator_Begin(hotel, &amp;iter);
    FLValue value;
    while (NULL != (value = FLDictIterator_GetValue(&amp;iter))) {
        FLString key = FLDictIterator_GetKeyString(&amp;iter);
        FLString strValue = FLValue_AsString(value);
        printf("%.*s :: %.*s\n", (int)key.size, (const char*)key.buf, (int)strValue.size, (const char*)strValue.buf);
        FLDictIterator_Next(&amp;iter);
    }

    // Convert the dictionary to JSON
    FLSliceResult jsonData2 = FLValue_ToJSON((FLValue)hotel);
    printf("Hotel in JSON :: %.*s\n", (int)jsonData2.size, (const char *)jsonData2.buf);

    // Release JSON data after finish using it
    FLSliceResult_Release(jsonData1);
    FLSliceResult_Release(jsonData2);
    // end::tojson-dictionary[]
}

static void array_json() {
    // tag::tojson-array[]
    // NOTE: No error handling, for brevity (see getting started)

    FLString json = FLSTR("[\"Hotel Ned\", \"Hotel Ted\"]");

    // Create an array from the JSON string
    FLError err;
    FLSliceResult jsonData1 = FLData_ConvertJSON(json, &amp;err);
    FLArray hotels = FLValue_AsArray(FLValue_FromData(FLSliceResult_AsSlice(jsonData1), kFLTrusted));

    // Iterate through the array
    FLArrayIterator iter;
    FLArrayIterator_Begin(hotels, &amp;iter);
    FLValue value;
    while (NULL != (value = FLArrayIterator_GetValue(&amp;iter))) {
        FLString hotel = FLValue_AsString(value);
        printf("Hotel :: %.*s\n", (int)hotel.size, (const char *)hotel.buf);
        FLArrayIterator_Next(&amp;iter);
    }

    // Convert the array to JSON
    FLSliceResult jsonData2 = FLValue_ToJSON((FLValue)hotels);
    printf("Hotels in JSON :: %.*s\n", (int)jsonData2.size, (const char *)jsonData2.buf);

    // Release JSON data after finish using it
    FLSliceResult_Release(jsonData1);
    FLSliceResult_Release(jsonData2);
    // end::tojson-array[]
}

static void datatype_dictionary()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_dictionary[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    const CBLDocument *doc = CBLDatabase_GetDocument(db, FLSTR("doc1"), &amp;err);
    FLDict properties = CBLDocument_Properties(doc);

    // Getting a dictionary from the document's properties
    FLValue dictValue = FLDict_Get(properties, FLSTR("address"));
    FLDict dict = FLValue_AsDict(dictValue);

    // Access a value with a key from the dictionary
    FLValue streetVal = FLDict_Get(dict, FLSTR("street"));
    FLString street = FLValue_AsString(streetVal);

    // Iterate dictionary
    FLDictIterator iter;
    FLDictIterator_Begin(dict, &amp;iter);
    FLValue value;
    while (NULL != (value = FLDictIterator_GetValue(&amp;iter))) {
        FLString key = FLDictIterator_GetKeyString(&amp;iter);
        FLString strValue = FLValue_AsString(value);
        printf("Key :: %.*s\n", (int)key.size, (const char *)key.buf);
        printf("Value :: %.*s\n", (int)strValue.size, (const char *)strValue.buf);
        // ...
        FLDictIterator_Next(&amp;iter);
    }

    // Create a mutable copy.
    // kFLDefaultCopy is shallow which means the nested dictionaries and arrays will be
    // referenced but not copied. Use kFLDeepCopyImmutables for the deep copy.
    FLMutableDict mutableDict = FLDict_MutableCopy(dict, kFLDefaultCopy);

    // Release when finish using it
    FLMutableDict_Release(mutableDict);
    // end::datatype_dictionary[]
}

static void datatype_mutable_dictionary()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_mutable_dictionary[]
    // NOTE: No error handling, for brevity (see getting started)

    // tag::datatype_mutable_dictionary-create[]
    // Create a new mutable dictionary and populate some keys/values
    FLMutableDict dict = FLMutableDict_New();
    FLMutableDict_SetString(dict, FLSTR("street"), FLSTR("1 Main st."));
    FLMutableDict_SetString(dict, FLSTR("city"), FLSTR("San Francisco"));
    // end::datatype_mutable_dictionary-create[]

    // tag::datatype_mutable_dictionary-add-to-doc[]
    // Set the dictionary to document's properties and save the document
    CBLDocument *doc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(doc);
    FLMutableDict_SetDict(properties, FLSTR("address"), dict);
    // end::datatype_mutable_dictionary-add-to-doc[]
    CBLError err;
    CBLDatabase_SaveDocument(db, doc, &amp;err);
    CBLDocument_Release(doc);

    // Release when finish using it
    FLMutableDict_Release(dict);
    // end::datatype_mutable_dictionary[]
}

static void datatype_array()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_array[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    const CBLDocument *doc = CBLDatabase_GetDocument(db, FLSTR("doc1"), &amp;err);
    FLDict properties = CBLDocument_Properties(doc);

    // Getting a phones array from the document's properties
    FLValue arrayValue = FLDict_Get(properties, FLSTR("phones"));
    FLArray array = FLValue_AsArray(arrayValue);

    // Get element count
    int count = FLArray_Count(array);
    printf("Count :: %d\n", count);

    // Access an array element by index
    if (!FLArray_IsEmpty(array)) {
        FLValue phoneVal = FLArray_Get(array, 0);
        FLString phone = FLValue_AsString(phoneVal);
        printf("Value :: %.*s\n", (int)phone.size, (const char *)phone.buf);
    }

    // Iterate array
    FLArrayIterator iter;
    FLArrayIterator_Begin(array, &amp;iter);
    FLValue val;
    while (NULL != (val = FLArrayIterator_GetValue(&amp;iter)))
    {
        FLString str = FLValue_AsString(val);
        printf("Value :: %.*s\n", (int)str.size, (const char *)str.buf);
        FLArrayIterator_Next(&amp;iter);
    }
    // end::datatype_array[]

    // Create a mutable copy.
    // kFLDefaultCopy is shallow which means the nested dictionaries and arrays will be
    // referenced but not copied. Use kFLDeepCopyImmutables for the deep copy.
    FLMutableArray mutableArray = FLArray_MutableCopy(array, kFLDefaultCopy);

    // Release when finish using it
    FLMutableArray_Release(mutableArray);
}

static void datatype_mutable_array()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_mutable_array[]
    // NOTE: No error handling, for brevity (see getting started)

    // tag::datatype_mutable_array-create[]
    // Create a new mutable array and populate data into the array
    FLMutableArray phones = FLMutableArray_New();
    FLMutableArray_AppendString(phones, FLSTR("650-000-0000"));
    FLMutableArray_AppendString(phones, FLSTR("650-000-0001"));
    // end::datatype_mutable_array-create[]

    // tag::datatype_mutable_array-add-to-doc[]
    // Set the array to document's properties and save the document
    CBLDocument *doc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(doc);
    FLMutableDict_SetArray(properties, FLSTR("phones"), phones);
    // end::datatype_mutable_array-add-to-doc[]
    CBLError err;
    CBLDatabase_SaveDocument(db, doc, &amp;err);
    CBLDocument_Release(doc);

    // Release the created dictionary
    FLMutableArray_Release(phones);
    // end::datatype_mutable_array[]
}


static void datatype_usage() {

    // tag::datatype_usage[]
    // tag::datatype_usage_createdb[]
    // Open or create DB if it doesn't exist
    CBLError err;
    CBLDatabase* database = CBLDatabase_Open(FLSTR("mydb"), NULL, &amp;err);
    if(!database) {
        // Error handling.  For brevity, this is truncated in the rest of the snippet
        // and omitted in other doc code snippets
        fprintf(stderr, "Error opening database (%d / %d)\n", err.domain, err.code);
        FLSliceResult msg = CBLError_Message(&amp;err);
        fprintf(stderr, "%.*s\n", (int)msg.size, (const char *)msg.buf);
        FLSliceResult_Release(msg);
        return;
    }

    // end::datatype_usage_createdb[]
    // tag::datatype_usage_createdoc[]
    // Create your new document
    // The lack of 'const' indicates this document is mutable
    CBLDocument* mutableDoc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDoc);

    // end::datatype_usage_createdoc[]
    // tag::datatype_usage_mutdict[]
    // Create and populate mutable dictionary
    FLMutableDict address = FLMutableDict_New();
    FLMutableDict_SetString(address, FLSTR("street"), FLSTR("1 Main st."));
    FLMutableDict_SetString(address, FLSTR("city"), FLSTR("San Francisco"));
    FLMutableDict_SetString(address, FLSTR("state"), FLSTR("CA"));
    FLMutableDict_SetString(address, FLSTR("country"), FLSTR("USA"));
    FLMutableDict_SetString(address, FLSTR("code"), FLSTR("90210"));

    // end::datatype_usage_mutdict[]
    // tag::datatype_usage_mutarray[]
    // Create and populate mutable array
    FLMutableArray phones = FLMutableArray_New();
    FLMutableArray_AppendString(phones, FLSTR("650-000-0000"));
    FLMutableArray_AppendString(phones, FLSTR("650-000-0001"));

    // end::datatype_usage_mutarray[]
    // tag::datatype_usage_populate[]
    // Initialize and populate the document

    // Add document type to document properties <i class="conum" data-value="5"></i><b>(5)</b>
    FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("hotel"));

    // Add hotel name string to document properties <i class="conum" data-value="6"></i><b>(6)</b>
    FLMutableDict_SetString(properties, FLSTR("hotel"), FLSTR(""));

    // Add float to document properties <i class="conum" data-value="7"></i><b>(7)</b>
    FLMutableDict_SetFloat(properties, FLSTR("room_rate"), 121.75f);

    // Add dictionary to document's properties <i class="conum" data-value="8"></i><b>(8)</b>
    FLMutableDict_SetDict(properties, FLSTR("address"), dict);

    // Add array to document's properties <i class="conum" data-value="9"></i><b>(9)</b>
    FLMutableDict_SetArray(properties, FLSTR("phones"), phones);

    // end::datatype_usage_populate[]
    // tag::datatype_usage_persist[]
    // Save the document changes <i class="conum" data-value="10"></i><b>(10)</b>
    CBLError err;
    CBLDatabase_SaveDocument(database, doc, &amp;err);

    // end::datatype_usage_persist[]
    // tag::datatype_usage_closedb[]
    // Close the database <i class="conum" data-value="11"></i><b>(11)</b>
    CBLError err;
    CBLDatabase_Close(database, &amp;err);

    // end::datatype_usage_closedb[]
    // tag::datatype_usage_release[]
    // Release the created items <i class="conum" data-value="12"></i><b>(12)</b>
    CBLDatabase_Release(database);
    CBLDocument_Release(doc);
    FLMutableDict_Release(dict);
    FLMutableArray_Release(phones);
    // end::datatype_usage_release[]

    // end::datatype_usage[]

} // end datatype_usage()


static void create_index() {
    CBLDatabase* db = kDatabase;

    // tag::query-index[]
    // For value types, this is optional but provides performance enhancements
    // NOTE: No error handling, for brevity (see getting started)

    // Syntax for second argument is the same as taking from a N1QL SELECT
    // i.e. SELECT (type, name) FROM _;
    CBLValueIndexConfiguration config = {
        kCBLN1QLLanguage,
        FLSTR("type, name")
    };

    CBLError err;
    CBLDatabase_CreateValueIndex(db, FLSTR("TypeNameIndex"), config, &amp;err);
    // end::query-index[]
}

static void select_meta() {
    CBLDatabase* db = kDatabase;

    // tag::query-select-meta[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, type, name FROM _"), NULL, &amp;err);
    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString id = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("id")));
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Document ID :: %.*s\n", (int)id.size, (const char *)id.buf);
        printf("Document Name :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-select-meta[]
}

static void select_id() {
    CBLDatabase* db = kDatabase;

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _"), NULL, &amp;err);

    // tag::query-access-id[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString id = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("id")));
        printf("Document ID :: %.*s\n", (int)id.size, (const char *)id.buf);
    }
    // end::query-access-id[]

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
}

static void query_change_listener(void* context, CBLQuery* query, CBLListenerToken* token) {
    CBLError err;
    CBLResultSet* results = CBLQuery_CopyCurrentResults(query, token, &amp;err);
    while(CBLResultSet_Next(results)) {
        // Update UI
    }
}

static void select_all() {
    CBLDatabase* db = kDatabase;

    // tag::query-select-all[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _"), NULL, &amp;err);

    // All results will be available from the above query
    CBLQuery_Release(query);
    // end::query-select-all[]

    // tag::live-query[]
    /*
    static void query_change_listener(void* context, CBLQuery* query, CBLListenerToken* token) {
        CBLError err;
        CBLResultSet* results = CBLQuery_CopyCurrentResults(query, token, &amp;err);
        while(CBLResultSet_Next(results)) {
            // Update UI
        }
    }
    */

    query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _"), NULL, &amp;err); <i class="conum" data-value="13"></i><b>(13)</b>

    CBLListenerToken* token = CBLQuery_AddChangeListener(query, query_change_listener, NULL); <i class="conum" data-value="14"></i><b>(14)</b>
    // end::live-query[]

    // tag::stop-live-query[]
    CBLListener_Remove(token); // The token received from AddChangeListener
    CBLQuery_Release(query);
    // end::stop-live-query[]
}

static void select_and_access_all() {
    CBLDatabase* db = kDatabase;

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _"), NULL, &amp;err);

    // tag::query-access-all[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict dict = FLValue_AsDict(CBLResultSet_ValueForKey(results, FLSTR("_")));

        FLString id = FLValue_AsString(FLDict_Get(dict, FLSTR("id")));
        FLString type = FLValue_AsString(FLDict_Get(dict, FLSTR("type")));
        FLString name = FLValue_AsString(FLDict_Get(dict, FLSTR("name")));
        FLString city = FLValue_AsString(FLDict_Get(dict, FLSTR("city")));

        printf("ID :: %.*s\n", (int)id.size, (const char *)id.buf);
        printf("Type :: %.*s\n", (int)type.size, (const char *)type.buf);
        printf("Name :: %.*s\n", (int)name.size, (const char *)name.buf);
        printf("City :: %.*s\n", (int)city.size, (const char *)city.buf);
    }

    // All results will be available from the above query
    CBLResultSet_Release(results);
    // end::query-access-all[]

    CBLQuery_Release(query);
}

static void select_props() {
    CBLDatabase* db = kDatabase;

    // tag::query-access-props[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT type, name, city FROM _"), NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString type = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("type")));
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        FLString city = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("city")));

        printf("Type :: %.*s\n", (int)type.size, (const char *)type.buf);
        printf("Name :: %.*s\n", (int)name.size, (const char *)name.buf);
        printf("City :: %.*s\n", (int)city.size, (const char *)city.buf);
    }
    // end::query-access-props[]

    // All results will be available from the above query
    CBLResultSet_Release(results);
    CBLQuery_Release(query);
}

static void select_where() {
    CBLDatabase* db = kDatabase;

    // tag::query-where[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _ WHERE type = \"hotel\" LIMIT 10"), NULL, &amp;err);
    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict dict = FLValue_AsDict(CBLResultSet_ValueForKey(results, FLSTR("_")));
        FLString name = FLValue_AsString(FLDict_Get(dict, FLSTR("name")));
        printf("Document Name :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-where[]
}

static void use_collection_contains() {
    CBLDatabase* db = kDatabase;

    // tag::query-collection-operator-contains[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name, public_likes FROM _ WHERE type = \"hotel\" "
              "AND ARRAY_CONTAINS(public_likes, \"Armani Langworth\")"), NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLArray publicLikes = FLValue_AsArray(CBLResultSet_ValueForKey(results, FLSTR("public_likes")));
        FLStringResult json = FLValue_ToJSON((FLValue)publicLikes);
        printf("Public Likes :: %.*s\n", (int)json.size, (const char *)json.buf);
        FLSliceResult_Release(json);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-collection-operator-contains[]
}

static void use_collection_in() {
    CBLDatabase* db = kDatabase;

    // tag::query-collection-operator-in[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _ WHERE \"Armani\" IN (first, last, username)"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict body = FLValue_AsDict(CBLResultSet_ValueAtIndex(results, 0));
        FLStringResult json = FLValue_ToJSON((FLValue)body);
        printf("In results :: %.*s\n", (int)json.size, (const char *)json.buf);
        FLSliceResult_Release(json);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-collection-operator-in[]
}

static void select_like() {
    CBLDatabase* db = kDatabase;

    // tag::query-like-operator[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND lower(name) LIKE \"Royal Engineers Museum\" LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-like-operator[]
}

static void select_wildcard_like() {
    CBLDatabase* db = kDatabase;

    // tag::query-like-operator-wildcard-match[]
    // NOTE: No error handling, for brevity (see getting started)

     CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND lower(name) LIKE \"Eng%e%\" LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-like-operator-wildcard-match[]
}

static void select_wildcard_character_like() {
    CBLDatabase* db = kDatabase;

    // tag::query-like-operator-wildcard-character-match[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND lower(name) LIKE \"Royal Eng____rs Museum\" LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-like-operator-wildcard-character-match[]
}

static void select_regex() {
    CBLDatabase* db = kDatabase;

    // tag::query-regex-operator[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND regexp_like(name, \"\\bEng.*e\\b\") LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-regex-operator[]
}

static void select_join() {
    CBLDatabase* db = kDatabase;

    // tag::query-join[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT airline.name, airline.callsign, route.destinationairport, route.stops, route.airline "
              "FROM _ AS airline INNER JOIN _ AS route ON meta(airline).id = route.airlineid "
              "WHERE route.type = \"route\" AND airline.type = \"airline\" AND route.sourceairport = \"RIX\""),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-join[]
}

static void group_by() {
    CBLDatabase* db = kDatabase;

    // tag::query-groupby[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT count(*), country, tz FROM _ WHERE type = \"airport\" AND geo.alt &gt;= 300 "
              "GROUP BY country, tz"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        int64_t count = FLValue_AsInt(CBLResultSet_ValueForKey(results, FLSTR("$1")));
        FLString tz = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("tz")));
        FLString country = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("country")));
        printf("There are %" PRIi64 " airports in the %.*s timezone located in %.*s and above 300 ft\n",
            count, (int)tz.size, (const char *)tz.buf, (int)country.size, (const char *)country.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-groupby[]
}

static void order_by() {
    CBLDatabase* db = kDatabase;

    // tag::query-orderby[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, title FROM _ WHERE type = \"hotel\" ORDER BY title ASC LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString title = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("title")));
        printf("Title :: %.*s\n", (int)title.size, (const char *)title.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-orderby[]
}

static void test_explain_statement() {
    CBLDatabase* db = kDatabase;

    {
    // tag::query-explain-all[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _ WHERE type = \"hotel\" GROUP BY country ORDER BY title ASC LIMIT 10"),
        NULL, &amp;err);

    FLSliceResult explanation = CBLQuery_Explain(query);
    printf("%.*s", (int)explanation.size, (const char *)explanation.buf);
    FLSliceResult_Release(explanation);
    // end::query-explain-all[]
    }

    // DOCS NOTE: Others omitted for now
}

static void query_result_json() {
    CBLDatabase* db = kDatabase;

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id as id, name, city, type FROM _ LIMIT 10"),
        NULL, &amp;err);

    // tag::query-access-json[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict result = CBLResultSet_ResultDict(results);
        FLStringResult json = FLValue_ToJSON((FLValue)result);
        printf("JSON Result :: %.*s\n", (int)json.size, (const char *)json.buf);
        FLSliceResult_Release(json);
    }
    CBLResultSet_Release(results);

    // end::query-access-json[]

    CBLQuery_Release(query);
}

static void create_full_text_index() {
    CBLDatabase* db = kDatabase;

    const char* tasks[] = { "buy groceries", "play chess", "book travels", "buy museum tickets" };
    char idBuffer[7];
    for(int i = 0; i &lt; 4; i++) {
        const char* task = tasks[i];
        sprintf(idBuffer, "extra%d", i);
        const CBLDocument* doc = CBLDatabase_GetDocument(db, FLStr(idBuffer), NULL);
        if(doc) {
            CBLDocument_Release(doc);
            continue;
        }

        CBLDocument* mutableDoc = CBLDocument_CreateWithID(FLStr(idBuffer));
        FLMutableDict properties = CBLDocument_MutableProperties(mutableDoc);
        FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("task"));
        FLMutableDict_SetString(properties, FLSTR("task"), FLStr(task));
        CBLDatabase_SaveDocument(db, mutableDoc, NULL);
        CBLDocument_Release(mutableDoc);
    }

    // tag::fts-index[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLFullTextIndexConfiguration config = {
        kCBLN1QLLanguage,
        FLSTR("name"),
        false
    };

    CBLDatabase_CreateFullTextIndex(db, FLSTR("nameFTSIndex"), config, &amp;err);
    // end::fts-index[]
}

static void full_text_search() {
    CBLDatabase* db = kDatabase;

    // tag::fts-query[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _ WHERE MATCH(nameFTSIndex, \"'buy'\")"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString id = FLValue_AsString(CBLResultSet_ValueAtIndex(results, 0));
        printf("Document id :: %.*s\n", (int)id.size, (const char *)id.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::fts-query[]
}

static void start_replication() {
    CBLDatabase* db = kDatabase;

    /*
    * This requires Sync Gateway running with the following config, or equivalent:
    *
    * {
    *     "log":["*"],
    *     "databases": {
    *         "db": {
    *             "server":"walrus:",
    *             "users": {
    *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
    *             }
    *         }
    *     }
    * }
    */

    // tag::replication[]
    // NOTE: No error handling, for brevity (see getting started)
    // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);
    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target;
    config.replicatorType = kCBLReplicatorTypePull;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);
    CBLReplicator_Start(replicator, false);
    // end::replication[]

    stop_replicator(replicator);
}

// Console logging domain methods are not applicable to C

static void file_logging() {
    // tag::file-logging[]
    // NOTE: No error handling, for brevity (see getting started)
    // NOTE: You will need to use a platform appropriate method for finding
    // a temporary directory

    FLString tempFolder = FLSTR("/tmp/cbllog");

    CBLLogFileConfiguration config; // Don't bother zeroing, since we set all properties
    config.level = kCBLLogInfo;
    config.directory = tempFolder;
    config.maxRotateCount = 5;
    config.maxSize = 10240;
    config.usePlaintext = false;

    CBLError err;
    CBLLog_SetFileConfig(config, &amp;err);
    // end::file-logging[]
}

// tag::custom-logging[]
static void custom_log_callback(CBLLogDomain domain, CBLLogLevel level, FLString message) {
    // handle the message, for example piping it to
    // a third party framework
}
// end::custom-logging[]

static void enable_custom_logging() {
    // tag::set-custom-logging[]
    CBLLog_SetCallback(custom_log_callback);
    // end::set-custom-logging[]
}

static void enable_basic_auth() {
    CBLDatabase* db = kDatabase;

    // tag::basic-authentication-full[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/mydatabase");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);
    CBLAuthenticator* basicAuth = CBLAuth_CreatePassword(FLSTR("john"), FLSTR("pass"));

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target;
    config.authenticator = basicAuth;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);
    CBLAuth_Free(basicAuth);

    CBLReplicator_Start(replicator, false);
    // end::basic-authentication-full[]

    stop_replicator(replicator);
}

static void docsonly_N1QL_Params(CBLDatabase* argDb)
{
    CBLDatabase* database = argDb;

    // tag::query-syntax-n1ql-params[]
    int errorPos;

    CBLError err;

    FLString n1qlstr = FLSTR("SELECT * FROM _ WHERE type = $type");

    FLMutableDict n1qlparams = FLMutableDict_New();
    FLMutableDict_SetString(n1qlparams, FLSTR("type"), FLSTR("hotel"));

    CBLQuery* query = CBLDatabase_CreateQuery(database,
                          kCBLN1QLLanguage,
                          n1qlstr,
                          &amp;errorPos,
                          &amp;err);

    CBLQuery_SetParameters(query, n1qlparams);

    if(!query) {
        /* Do appropriate error handling ...
            Note that (where applicable) errorPos contains the position
            in the N1QL string that the parse failed
        */
        FLMutableDict_Release(n1qlparams);
        CBLQuery_Release(query);
        return;
    }

    CBLResultSet* result = CBLQuery_Execute(query, &amp;err);
    if(!result) {
        // Failed to run query, do error handling ...
        return;
    }

    // Release query when finished with
    FLMutableDict_Release(n1qlparams);
    CBLQuery_Release(query);

    // ... process results as required

    // Release result set then finished with
    CBLResultSet_Release(result);

    // end::query-syntax-n1ql-params[]
}



// tag::console-logging-db[]
//Placeholder for code to increase level of console logging for kCBLLogDomainDatabase domain
// end::console-logging-db[]

// tag::console-logging[]
//Placeholder for code to increase level of console logging for all domains
// end::console-logging[]

// tag::date-getter[]
//Placeholder for Date accessors.

// end::date-getter[]


// tag::query-index[]
// placeholder
// end::query-index[]


// DOCS NOTE
// Page=Data Sync &gt;&gt; Configuration Summary
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#configuration-summary
static void docs_act_replication(CBLDatabase* argDb)
{
    CBLDatabase* database = argDb;

    /*
    * This requires Sync Gateway running with the following config, or equivalent:
    *
    * {
    *     "log":["*"],
    *     "databases": {
    *         "db": {
    *             "server":"walrus:",
    *             "users": {
    *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
    *             }
    *         }
    *     }
    * }
    */

    // tag::p2p-act-rep-func[]
    // Purpose -- Show configuration , initialization and running of a replicator

    // NOTE: No error handling, for brevity (see getting started)
    // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err); <i class="conum" data-value="15"></i><b>(15)</b>

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = database;
    config.endpoint = target; <i class="conum" data-value="16"></i><b>(16)</b>

    // tag::p2p-act-rep-config-cont[]
    // Set replication direction and mode
    config.replicatorType = kCBLReplicatorTypePull; <i class="conum" data-value="17"></i><b>(17)</b>
    config.continuous = true;

    // end::p2p-act-rep-config-cont[]

    // Optionally, set auto-purge behavior (here we override default)
    config.disableAutoPurge = true; <i class="conum" data-value="18"></i><b>(18)</b>

    // Optionally, configure Client Authentication
    // Here we are using to Basic Authentication,
    // Providing username and password credentials
    CBLAuthenticator* basicAuth =
        CBLAuth_CreatePassword(FLSTR("username"),
                               FLSTR("passwd")); <i class="conum" data-value="19"></i><b>(19)</b>
    config.authenticator = basicAuth;

    // Optionally, configure how we handle conflicts
    config.conflictResolver = simpleConflictResolver_localWins; <i class="conum" data-value="20"></i><b>(20)</b>

    // Initialize replicator with created config
    CBLReplicator* replicator =
        CBLReplicator_Create(&amp;config, &amp;err); <i class="conum" data-value="21"></i><b>(21)</b>

    CBLEndpoint_Free(target);

    // Optionally, add change listener
    CBLListenerToken* token =
            CBLReplicator_AddChangeListener(replicator,
                                            simpleChangeListener,
                                            NULL); <i class="conum" data-value="22"></i><b>(22)</b>

    // Start replication
    CBLReplicator_Start(replicator, false); <i class="conum" data-value="23"></i><b>(23)</b>

    // end::p2p-act-rep-func[]

    //    ... other processing as required

    // When finished release resources e.g.
    CBLAuth_Free(basicAuth);
    stop_replicator(replicator);
}
// END configuration summary snippets


// DOCS NOTE:
// Page=Data Sync &gt;&gt; Configuration
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#configuration-summary
// This function is not pulled into docs en-bloc
// it is a slightly more in-depth than the configurationsummary above
// and the snippets within it are used individually or in sets
// to illustrate specific points as required
//
static void docs_act_replication_config_section_snippets()
{
    CBLDatabase* db = kDatabase;
    bool docs_example_ShowBasicAuth = false;
    bool docs_example_ShowSessionAuth = false;

    /*
    * This requires Sync Gateway running with the following config, or equivalent:
    *
    * {
    *     "log":["*"],
    *     "databases": {
    *         "db": {
    *             "server":"walrus:",
    *             "users": {
    *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
    *             }
    *         }
    *     }
    * }
    */
    // tag::p2p-act-rep-func-full[]
    // NOTE: No error handling, for brevity (see getting started)
    // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)

    // tag::sgw-act-rep-initialize[]
    // Initialize the configuration object and set db target
    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target =
        CBLEndpoint_CreateWithURL(url, &amp;err); <i class="conum" data-value="24"></i><b>(24)</b>

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target; <i class="conum" data-value="25"></i><b>(25)</b>

    // end::sgw-act-rep-initialize[]

    //    tag::p2p-act-rep-config-type[]
    config.replicatorType = kCBLReplicatorTypePull;

    //    end::p2p-act-rep-config-type[]
    //    tag::p2p-act-rep-config-cont[]
    config.continuous = true;

    //    end::p2p-act-rep-config-cont[]
    // tag::replication-retry-config[]
    // Configure replication retries
    // tag::replication-set-heartbeat[]
    config.heartbeat = 120; //  <i class="conum" data-value="26"></i><b>(26)</b>

    // end::replication-set-heartbeat[]
    // tag::replication-set-maxattempts[]
    config.maxAttempts = 20; //  <i class="conum" data-value="27"></i><b>(27)</b>

    // end::replication-set-maxattempts[]
    // tag::replication-set-maxattemptwaittime[]
    config.maxAttemptWaitTime = 600; //  <i class="conum" data-value="28"></i><b>(28)</b>

    // end::replication-set-maxattemptwaittime[]
    // end::replication-retry-config[]
    // tag::basic-authentication[]
    // Configure Client Authentication to Basic Authentication
    // Providing username and password credentials
    if(docs_example_ShowBasicAuth) {
        CBLAuthenticator* basicAuth =
            CBLAuth_CreatePassword(FLSTR("username"),
                                   FLSTR("passwd"));
        config.authenticator = basicAuth; <i class="conum" data-value="29"></i><b>(29)</b>
    }
    // end::basic-authentication[]

    // tag::session-authentication[]
    if(docs_example_ShowSessionAuth) {
        CBLAuthenticator* sessionAuth =
            CBLAuth_CreateSession(FLSTR("904ac010862f37c8dd99015a33ab5a3565fd8447"),
                                  FLSTR("optionalCookieName"));
        config.authenticator = sessionAuth; <i class="conum" data-value="30"></i><b>(30)</b>
    }

    // end::session-authentication[]

    // tag::replication-custom-header[]
    // Optionally, add custom headers
    FLMutableDict customHdrs = FLMutableDict_New();
    FLMutableDict_SetString(customHdrs,
                            FLSTR("customHeaderName"),
                            FLSTR("customHeaderValue"));

    config.headers = customHdrs;

    // tag::certificate-pinning[]
    char cert_buf[10000];
    FILE* cert_file = fopen("cert.pem", "r");
    size_t read = fread(cert_buf, 1, sizeof(cert_buf), cert_file);
    config.pinnedServerCertificate = (FLSlice){cert_buf, read};
    // end::certificate-pinning[]

    // end::replication-custom-header[]
    // FILTERS
    // tag::replication-push-filter[]
    // tag::replication-pull-filter[]
    // Purpose - Illustrate use of push and-or pull filter functions
    config.pushFilter = simpleReplicationFilter;

    config.pullFilter = simpleReplicationFilter;

    // end::replication-pull-filter[]
    // end::replication-push-filter[]

    //  Auto-purge over-ride
    // tag::autopurge-override[]
    config.disableAutoPurge = true; <i class="conum" data-value="31"></i><b>(31)</b>

    // end::autopurge-override[]
    // Initialize replicator with created config
    CBLReplicator* replicator =
        CBLReplicator_Create(&amp;config, &amp;err); <i class="conum" data-value="32"></i><b>(32)</b>

    CBLEndpoint_Free(target);

    // Add optional change listener
    CBLListenerToken* token_ReplChangeListener =
        CBLReplicator_AddChangeListener(replicator,
                                        simpleChangeListener,
                                        NULL); <i class="conum" data-value="33"></i><b>(33)</b>
}
// END replication.html &gt;&gt; configure section


// PAGE=Data Sync &gt;&gt; Initialize section
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#lbl-init-repl
static CBLReplicator* docs_act_replication_Intialize(
                        void* context,
                        CBLReplicatorConfiguration argConfig,
                        bool argResetRequired)
{
    CBLError err;
    bool docs_example_resetRequired = argResetRequired;
    // tag::p2p-act-rep-start-full[]
    CBLReplicator* thisRepl =
    CBLReplicator_Create(&amp;argConfig, &amp;err); <i class="conum" data-value="34"></i><b>(34)</b>

    // end::p2p-act-rep-start-full[]
    if(!docs_example_resetRequired) {
    // tag::p2p-act-rep-start-full[]
      CBLReplicator_Start(thisRepl, false); <i class="conum" data-value="35"></i><b>(35)</b>

    // end::p2p-act-rep-start-full[]
    } else {
    // tag::replication-reset-checkpoint[]
      CBLReplicator_Start(thisRepl, true); <i class="conum" data-value="36"></i><b>(36)</b>

    // end::replication-reset-checkpoint[]
    }
    return thisRepl;
}
// END replication.html &gt;&gt; initialize section

// PAGE=Data Sync &gt;&gt; Monitor section
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#lbl-repl-mon
static void docs_act_replication_Monitor(
                                       void* context,
                                       CBLReplicator* argRepl) {
    CBLError err;
    CBLReplicator* thisRepl = argRepl;
    // tag::p2p-act-rep-add-change-listener[]
    // Purpose -- illustrate addition of a Replicator change listener
    CBLListenerToken* token_ReplChangeListener =
            CBLReplicator_AddChangeListener(thisRepl,
                                            simpleChangeListener,
                                            NULL);

    // end::p2p-act-rep-add-change-listener[]
    // tag::add-document-replication-listener[]
    // Purpose -- illustrate addition of a Document Replicator  listener
    CBLListenerToken* token_ReplDocListener =
            CBLReplicator_AddDocumentReplicationListener(
                                                        thisRepl,
                                                        SimpleReplicationDocumentListener,
                                                        context);

    // end::add-document-replication-listener[]
    // tag::remove-document-replication-listener[]
    // Purpose -- illustrate removal of a listener
    CBLListener_Remove(token_ReplDocListener);
    CBLListener_Remove(token_ReplChangeListener);

    // end::remove-document-replication-listener[]

    // tag::p2p-act-rep-status[]
    // Purpose -- illustrate use of CBLReplicator_Status()
    CBLReplicatorStatus thisState = CBLReplicator_Status(thisRepl);
    if(thisState.activity==kCBLReplicatorStopped) {
        if(thisState.error.code==0) {
            CBLReplicator_Start(thisRepl,false);
        } else {
            printf("Replicator stopped -- code %d", thisState.error.code);
            // ... handle error ...
            CBLReplicator_Release(thisRepl);
        }
    }

    // end::p2p-act-rep-status[]
    // tag::replication-pendingdocuments[]
    FLDict thisPendingIdList =
        CBLReplicator_PendingDocumentIDs(thisRepl, &amp;err); <i class="conum" data-value="37"></i><b>(37)</b>
    if(!FLDict_IsEmpty(thisPendingIdList)) {
        FLDictIterator item;
        FLDictIterator_Begin(thisPendingIdList, &amp;item);
        FLValue itemValue;
        FLString pendingId;
        while(NULL != (itemValue = FLDictIterator_GetValue(&amp;item))) {
            pendingId = FLValue_AsString(itemValue);
            if(CBLReplicator_IsDocumentPending(thisRepl,
                                               pendingId,
                                               &amp;err)) {
                // ... process the still pending docid as required <i class="conum" data-value="38"></i><b>(38)</b>
            } else {
                // Doc Id no longer pending
                if(err.code==0) {
                    // No fail so must have already been pushed
                    printf("Document already pushed");
                } else {
                    // Error detected so handle it
                    printf("Error code %d checking for pendingId", err.code);
                    break;
                }
            }
            FLDictIterator_Next(&amp;item);
        }
        FLDictIterator_End(&amp;item);
        FLValue_Release(itemValue);
    } else {
        printf("No Pending Id Docs to process");
    }
    FLDict_Release(thisPendingIdList);

    // end::replication-pendingdocuments[]
}
// END replication.html &gt;&gt; Monitor section

// BEGIN replication.html &gt;&gt; Stop section
// PAGE=Data Sync &gt;&gt; Stop
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#lbl-repl-stop
static void docs_act_replication_Stop(
                                       void* context,
                                       CBLReplicator* argRepl) {
    // tag::p2p-act-rep-stop[]
    // Purpose -- show how to stop a replication
    if(CBLReplicator_Status(argRepl).activity!=kCBLReplicatorStopped) {
        CBLReplicator_Stop(argRepl);
    }

    // end::p2p-act-rep-stop[]
}
// END replication.html &gt;&gt; Stop section

static void replication_error_handling() {
    CBLDatabase* db = kDatabase;
    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);
    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);



    stop_replicator(replicator);
}

static void create_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    // tag::encryptable[]
    // NOTE: No error handling, for brevity (see getting started)

    // Create with premitive type
    CBLEncryptable* encNull = CBLEncryptable_CreateWithNull();
    CBLEncryptable* encBool = CBLEncryptable_CreateWithBool(true);
    CBLEncryptable* encInt = CBLEncryptable_CreateWithInt(256);
    CBLEncryptable* encUInt = CBLEncryptable_CreateWithUInt(1024);
    CBLEncryptable* encFloat = CBLEncryptable_CreateWithFloat(1.2);
    CBLEncryptable* encDouble = CBLEncryptable_CreateWithDouble(100.50);
    CBLEncryptable* encString = CBLEncryptable_CreateWithString(FLSTR("foo"));

    // Create with dictionary
    FLMutableDict dict = FLMutableDict_New();
    FLSlot_SetString(FLMutableDict_Set(dict, FLSTR("greeting")), FLSTR("hello"));
    CBLEncryptable* encDict = CBLEncryptable_CreateWithDict(dict);

    // Create with array
    FLMutableArray array = FLMutableArray_New();
    FLSlot_SetString(FLMutableArray_Append(array), FLSTR("item1"));
    CBLEncryptable* encArray = CBLEncryptable_CreateWithArray(array);

    // Create with FLValue
    FLMutableDict dict2 = FLMutableDict_New();
    FLSlot_SetString(FLMutableDict_Set(dict2, FLSTR("greeting")), FLSTR("hello"));
    CBLEncryptable* encValue = CBLEncryptable_CreateWithValue((FLValue)dict2);
    // end::encryptable[]

    // Release after using it
    CBLEncryptable_Release(encNull);
    CBLEncryptable_Release(encBool);
    CBLEncryptable_Release(encInt);
    CBLEncryptable_Release(encBool);
    CBLEncryptable_Release(encUInt);
    CBLEncryptable_Release(encFloat);
    CBLEncryptable_Release(encDouble);
    CBLEncryptable_Release(encString);
    CBLEncryptable_Release(encDict);
    CBLEncryptable_Release(encArray);
    CBLEncryptable_Release(encValue);

    FLMutableDict_Release(dict);
    FLMutableDict_Release(dict2);
    FLMutableArray_Release(array);

    #endif
}

static void release_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLEncryptable* encValue = CBLEncryptable_CreateWithString(FLSTR("foo"));
    // tag::release_encryptable[]
    // Release the encryptable value after finish using it
    CBLEncryptable_Release(encValue);
    // end::release_encryptable[]

    #endif
}

static void use_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLDatabase* db = kDatabase;

    // tag::use_encryptable[]
    // NOTE: No error handling, for brevity (see getting started)
    CBLDocument* doc = CBLDocument_CreateWithID(FLSTR("doc1"));

    // Set encryptable:
    FLMutableDict props = CBLDocument_MutableProperties(doc);
    CBLEncryptable* encryptable = CBLEncryptable_CreateWithString(FLSTR("My secret"));
    FLSlot_SetEncryptableValue(FLMutableDict_Set(props, FLSTR("secret")), encryptable);

    CBLError error;
    CBLDatabase_SaveDocument(db, doc, &amp;error);

    // Release
    CBLDocument_Release(doc);
    CBLEncryptable_Release(encryptable);
    // end::release_encryptable[]

    #endif
}

static void query_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLDatabase* db = kDatabase;

    // tag::use_encryptable[]
    // NOTE: No error handling, for brevity (see getting started)
    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT secret, secret.value as secretValue FROM _ WHERE type = \"profile\""), NULL, &amp;err);
    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        // Get secret as CBLEncryptable value
        FLValue value = CBLResultSet_ValueForKey(results, FLSTR("secret"));
        const CBLEncryptable* encValue = FLValue_GetEncryptableValue(value);
        FLString secretStr = FLValue_AsString(CBLEncryptable_Value(encValue));
        printf("Secret :: %.*s\n", (int)secretStr.size, (const char *)secretStr.buf);

        // Get secret value directly
        value = CBLResultSet_ValueForKey(results, FLSTR("secretValue"));
        secretStr = FLValue_AsString(value);
        printf("Secret :: %.*s\n", (int)secretStr.size, (const char *)secretStr.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::release_encryptable[]

    #endif
}

#ifdef COUCHBASE_ENTERPRISE

// tag::replicator_property_encryption[]
// tag::replicator_property_encryptor_decryptor_sample[]
// Purpose: Declare property-level encryptor callback functions
static FLSliceResult my_cipher_function(FLSlice input) {
    FLSliceResult result = FLSliceResult_New(input.size);
    for(int i = 0; i &lt; input.size; ++i) {
        ((uint8_t*)(result.buf))[i] = ((uint8_t*)input.buf)[i] ^ 'K';}
    return result;
}


static FLSliceResult property_encryptor(void* context, FLString docID, FLDict props, FLString path,
                                        FLSlice input, FLStringResult* algorithm, FLStringResult* keyID, CBLError* error) {
    *algorithm = FLSlice_Copy(FLSTR("MyEnc"));
    return my_cipher_function(input);
}


static FLSliceResult property_decryptor(void* context, FLString documentID, FLDict properties, FLString keyPath,
                                        FLSlice input, FLString algorithm, FLString keyID, CBLError* error) {
    return my_cipher_function(input);
}

// end::replicator_property_encryptor_decryptor_sample[]
// end::replicator_property_encryption[]

#endif

// PAGE=Field Level Encryption
// URL=https://docs.couchbase.com/couchbase-lite/current/c/field-level-encryption.html
//
static void replicator_property_encryption() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLDatabase* db = kDatabase;

    // tag::replicator_property_encryption[]
    // Purpose: Show how to declare en(de)cryptors in replicator config
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));

    config.database = db;
    config.endpoint = target;
    config.propertyEncryptor = property_encryptor; <i class="conum" data-value="39"></i><b>(39)</b>
    config.propertyDecryptor = property_decryptor; <i class="conum" data-value="40"></i><b>(40)</b>

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);

    CBLReplicator_Start(replicator, false);
    // end::replicator_property_encryption[]

    stop_replicator(replicator);

    #endif
}

int main(int argc, char** argv) {
    create_new_database();
    create_document();
    update_document();
    do_batch_operation();
    // Disable use_blob() as no avatar.jpg to load and crash
    // use_blob();
    doc_json();
    dict_json();
    array_json();
    load_prebuilt();
    create_index();
    select_all();
    select_and_access_all();
    select_props();
    select_meta();
    select_id();
    select_where();
    use_collection_contains();
    select_like();
    select_wildcard_like();
    select_wildcard_character_like();
    select_regex();
    select_join();
    group_by();
    order_by();
    query_result_json();

    create_full_text_index();
    full_text_search();
    start_replication();
    replicator_property_encryption();

    CBLDatabase_Close(kDatabase, NULL);

    return 0;
}</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Store imported identity in keychain</p>
</li>
</ol>
</div>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/c/examples/code_snippets/main.c">// CBL Version 3.0.0 BETA
#include &lt;cbl/CouchbaseLite.h&gt;
#include &lt;time.h&gt;
#include &lt;inttypes.h&gt;
#ifdef _MSC_VER
#include &lt;direct.h&gt;
#include &lt;Shlwapi.h&gt;

void usleep(unsigned int us) {
    Sleep(us / 1000);
}
#else
#include &lt;unistd.h&gt;
#endif

static CBLDatabase* kDatabase;

// Helper for stop replicator in the code snippet
static void stop_replicator(CBLReplicator* replicator) {
    CBLReplicator_Stop(replicator);
    while(CBLReplicator_Status(replicator).activity != kCBLReplicatorStopped) {
        printf("Waiting for replicator to stop...");
        usleep(200000);
    }
    CBLReplicator_Release(replicator);
}

//  BEGIN lower-level function declarations

//  DOCS NOTE --
//  These functions are referred to in subsequent code samples.
//  Their tags will ensure they are shown alongide the usage examples.
//  Functions used in more than one place may hve multiple tags.

// tag::p2p-act-rep-func[]
// tag::p2p-act-rep-add-change-listener[]
// tag::replication-error-handling[]
// Purpose -- illustrate a simple change listener
static void simpleChangeListener(void* context,
                                 CBLReplicator* repl,
                                 const CBLReplicatorStatus* status)
{
     if(status-&gt;error.code != 0) {
         printf("Error %d / %d\n",
                status-&gt;error.domain,
                status-&gt;error.code);
     }
}
// end::replication-error-handling[]
// end::p2p-act-rep-add-change-listener[]
// end::p2p-act-rep-func[]

static const CBLDocument* simpleConflictResolver_localWins(
                                void* context, FLString documentID,
                                const CBLDocument* localDocument,
                                const CBLDocument* remoteDocument)
{
    return localDocument;
}

// tag::replication-push-filter[]
// tag::replication-pull-filter[]
// Purpose -- illustrate a simple replication filter function
static bool simpleReplicationFilter(void* context,
                                    CBLDocument* argDoc,
                                    CBLDocumentFlags argFlags)
{
    bool result = (argFlags == kCBLDocumentFlagsDeleted);
    return result;
}

// end::replication-push-filter[]
// end::replication-pull-filter[]

// tag::SimpleReplicationDocumentListener[]
// Purpose -- Illustrate a simple replication document listener
static void SimpleReplicationDocumentListener(
                                  void *context,
                                  CBLReplicator *replicator,
                                  bool isPush,
                                  unsigned numDocuments,
                                  const CBLReplicatedDocument *documents)
{
    if(isPush) {
        printf("We pushed %d documents",numDocuments);
    }
}

// END lower-level function declarations


static void getting_started_change_listener(void* context,
                                            CBLReplicator* repl,
                                            const CBLReplicatorStatus* status)
{
    if(status-&gt;error.code != 0) {
        printf("Error %d / %d\n", status-&gt;error.domain, status-&gt;error.code);
    }
}

// Page=build and run
// url=https://docs-staging.couchbase.com/couchbase-lite/current/c/gs-build.html
static void getting_started() {
    // tag::getting-started[]
    //  Purpose-- provide an overview of available crud  and sync functionality
    //
    // Get the database (and create it if it doesn't exist)
    CBLError err;
    CBLDatabase* database = CBLDatabase_Open(FLSTR("mydb"), NULL, &amp;err);
    if(!database) {
        // Error handling.  For brevity, this is truncated in the rest of the snippet
        // and omitted in other doc code snippets
        fprintf(stderr, "Error opening database (%d / %d)\n", err.domain, err.code);
        FLSliceResult msg = CBLError_Message(&amp;err);
        fprintf(stderr, "%.*s\n", (int)msg.size, (const char *)msg.buf);
        FLSliceResult_Release(msg);
        return;
    }

    // The lack of 'const' indicates this document is mutable
    // Create a new document (i.e. a record) in the database
    CBLDocument* mutableDoc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDoc);
    FLMutableDict_SetFloat(properties, FLSTR("version"), 3.0f);

    // Save it to the database
    if(!CBLDatabase_SaveDocument(database, mutableDoc, &amp;err)) {
        // Failed to save, do error handling as above
        return;
    }

    // Since we will release the document, make a copy of the ID since it
    // is an internal pointer.  Whenever we create or get an FLSliceResult
    // or FLStringResult we will need to free it later too!
    FLStringResult id = FLSlice_Copy(CBLDocument_ID(mutableDoc));
    CBLDocument_Release(mutableDoc);

    // Update a document
    mutableDoc = CBLDatabase_GetMutableDocument(database, FLSliceResult_AsSlice(id), &amp;err);
    if(!mutableDoc) {
        // Failed to retrieve, do error handling as above.  NOTE: error code 0 simply means
        // the document does not exist.
        return;
    }

    properties = CBLDocument_MutableProperties(mutableDoc);
    FLMutableDict_SetString(properties, FLSTR("language"), FLSTR("C"));
    if(!CBLDatabase_SaveDocument(database, mutableDoc, &amp;err)) {
        // Failed to save, do error handling as above
        return;
    }

    // Note const here, means readonly
    const CBLDocument* docAgain = CBLDatabase_GetDocument(database, FLSliceResult_AsSlice(id), &amp;err);
    if(!docAgain) {
        // Failed to retrieve, do error handling as above.  NOTE: error code 0 simply means
        // the document does not exist.
        return;
    }

    // No copy this time, so no release later (notice it is not FLStringResult this time)
    FLString retrievedID = CBLDocument_ID(docAgain);
    FLDict retrievedProperties = CBLDocument_Properties(docAgain);
    FLString retrievedLanguage = FLValue_AsString(FLDict_Get(retrievedProperties, FLSTR("language")));
    printf("Document ID :: %.*s\n", (int)retrievedID.size, (const char *)retrievedID.buf);
    printf("Learning %.*s\n", (int)retrievedLanguage.size, (const char *)retrievedLanguage.buf);

    CBLDocument_Release(mutableDoc);
    CBLDocument_Release(docAgain);
    FLSliceResult_Release(id);

    // tag::query-syntax-n1ql[]
    // Create a query to fetch documents of type SDK
    int errorPos;
    CBLQuery* query = CBLDatabase_CreateQuery(database, kCBLN1QLLanguage, FLSTR("SELECT * FROM _ WHERE type = \"SDK\""), &amp;errorPos, &amp;err);
    if(!query) {
        // Failed to create query, do error handling as above
        // Note that errorPos will contain the position in the N1QL string
        // that the parse failed, if applicable
        return;
    }

    CBLResultSet* result = CBLQuery_Execute(query, &amp;err);
    if(!result) {
        // Failed to run query, do error handling as above
        return;
    }
    // end::query-syntax-n1ql[]

    // TODO: Result set count?
    CBLResultSet_Release(result);
    CBLQuery_Release(query);

    // Create replicator to push and pull changes to and from the cloud
    CBLEndpoint* targetEndpoint = CBLEndpoint_CreateWithURL(FLSTR("ws://localhost:4984/getting-started-db"), &amp;err);
    if(!targetEndpoint) {
        // Failed to create endpoint, do error handling as above
        return;
    }

    CBLReplicatorConfiguration replConfig;
    CBLAuthenticator* basicAuth = CBLAuth_CreatePassword(FLSTR("john"), FLSTR("pass"));
    memset(&amp;replConfig, 0, sizeof(replConfig));
    replConfig.database = database;
    replConfig.endpoint = targetEndpoint;
    replConfig.authenticator = basicAuth;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;replConfig, &amp;err);
    CBLAuth_Free(basicAuth);
    CBLEndpoint_Free(targetEndpoint);
    if(!replicator) {
        // Failed to create replicator, do error handling as above
        return;
    }

    // Assume a function like the simple following
    //
    // static void getting_started_change_listener(void* context, CBLReplicator* repl, const CBLReplicatorStatus* status) {
    //     if(status-&gt;error.code != 0) {
    //         printf("Error %d / %d\n", status-&gt;error.domain, status-&gt;error.code);
    //     }
    // }

    CBLListenerToken* token = CBLReplicator_AddChangeListener(replicator, getting_started_change_listener, NULL);

    CBLReplicator_Start(replicator, false);

    // Later, stop and release the replicator
    // end::getting-started[]

    // When finished release resources ... eg
    CBLListener_Remove(token);

    stop_replicator(replicator);
}


// tag::local-win-conflict-resolver[]
static const CBLDocument* local_win_conflict_resolver(void* context,
                                                      FLString documentID,
                                                      const CBLDocument* localDocument,
                                                      const CBLDocument* remoteDocument)
{
    return localDocument;
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
static const CBLDocument* remote_win_conflict_resolver(void* context,
                                                       FLString documentID,
                                                       const CBLDocument* localDocument,
                                                       const CBLDocument* remoteDocument)
{
    return remoteDocument;
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
static const CBLDocument* merge_conflict_resolver(void* context,
                                                  FLString documentID,
                                                  const CBLDocument* localDocument,
                                                  const CBLDocument* remoteDocument)
{
    FLDict localProps = CBLDocument_Properties(localDocument);
    FLDict remoteProps = CBLDocument_Properties(remoteDocument);
    FLMutableDict mergeProps = FLDict_MutableCopy(localProps, kFLDefaultCopy);

    FLDictIterator d;
    FLDictIterator_Begin(localProps, &amp;d);
    FLValue value;
    while((value = FLDictIterator_GetValue(&amp;d))) {
        FLString key = FLDictIterator_GetKeyString(&amp;d);
        if(FLDict_Get(mergeProps, key)) {
            continue;
        }

        FLMutableDict_SetValue(mergeProps, key, value);
        FLDictIterator_Next(&amp;d);
    }

    CBLDocument* mergeDocument = CBLDocument_CreateWithID(documentID);
    CBLDocument_SetProperties(mergeDocument, mergeProps);
    FLMutableDict_Release(mergeProps);

    return mergeDocument;
}
// end::merge-conflict-resolver[]

static void test_replicator_conflict_resolve() {
    CBLDatabase* database = kDatabase;

    // tag::replication-conflict-resolver[]
    // NOTE: No error handling, for brevity (see getting started)
    CBLError err;
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(FLSTR("ws://localhost:4984/mydatabase"), &amp;err);

    CBLReplicatorConfiguration replConfig;
    memset(&amp;replConfig, 0, sizeof(replConfig));
    replConfig.database = database;
    replConfig.endpoint = target;
    replConfig.conflictResolver = local_win_conflict_resolver;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;replConfig, &amp;err);
    CBLEndpoint_Free(target);
    CBLReplicator_Start(replicator, false);

    // end::replication-conflict-resolver[]

    stop_replicator(replicator);
}

static bool custom_conflict_handler(void* context,
                                    CBLDocument* documentBeingSaved,
                                    const CBLDocument* conflictingDocument)
{
    FLDict currentProps = CBLDocument_Properties(conflictingDocument);
    FLDict updatedProps = CBLDocument_Properties(documentBeingSaved);
    FLMutableDict newProps = FLDict_MutableCopy(updatedProps, kFLDefaultCopy);

    FLDictIterator d;
    FLDictIterator_Begin(currentProps, &amp;d);
    FLValue currentValue;
    while((currentValue = FLDictIterator_GetValue(&amp;d))) {
        FLString currentKey = FLDictIterator_GetKeyString(&amp;d);
        if(FLDict_Get(newProps, currentKey)) {
            continue;
        }

        FLMutableDict_SetValue(newProps, currentKey, currentValue);
        FLDictIterator_Next(&amp;d);
    }

    return true;
}

static void test_save_with_conflict_handler() {
    CBLDatabase* database = kDatabase;

    // tag::update-document-with-conflict-handler[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDocument* mutableDocument = CBLDatabase_GetMutableDocument(database, FLSTR("xyz"), &amp;err);
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDocument);
    FLMutableDict_SetString(properties, FLSTR("name"), FLSTR("apples"));

    /*
    static bool custom_conflict_handler(void* context, CBLDocument* documentBeingSaved,
        const CBLDocument* conflictingDocument) {
        FLDict currentProps = CBLDocument_Properties(conflictingDocument);
        FLDict updatedProps = CBLDocument_Properties(documentBeingSaved);
        FLMutableDict newProps = FLDict_MutableCopy(updatedProps, kFLDefaultCopy);

        FLDictIterator d;
        FLDictIterator_Begin(currentProps, &amp;d);
        FLSlice currentKey = FLDictIterator_GetKeyString(&amp;d);
        for(; currentKey.buf; currentKey = FLDictIterator_GetKeyString(&amp;d)) {
            if(FLDict_Get(newProps, currentKey)) {
                continue;
            }

            FLValue currentValue = FLDictIterator_GetValue(&amp;d);
            FLMutableDict_SetValue(newProps, currentKey, currentValue);
        }

        return true;
    }
    */
    CBLDatabase_SaveDocumentWithConflictHandler(database, mutableDocument, custom_conflict_handler, NULL, &amp;err);

    // end::update-document-with-conflict-handler[]
}

static void use_encryption() {
    #ifdef COUCHBASE_ENTERPRISE

    // tag::database-encryption[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLDatabaseConfiguration config = CBLDatabaseConfiguration_Default();

    // This returns a boolean, so check it in production code
    CBLEncryptionKey_FromPassword(&amp;config.encryptionKey, FLSTR("password"));

    CBLError err;
    CBLDatabase* db = CBLDatabase_Open(FLSTR("seekrit"), &amp;config, &amp;err);

    // Change the encryption key (or add encryption if the DB is unencrypted)
    CBLEncryptionKey betterKey;
    CBLEncryptionKey_FromPassword(&amp;betterKey, FLSTR("betterpassw0rd"));
    CBLDatabase_ChangeEncryptionKey(db, &amp;betterKey, &amp;err);

    // Remove encryption
    CBLDatabase_ChangeEncryptionKey(db, NULL, &amp;err);
    // end::database-encryption[]

    #endif
}

static void reset_replicator_checkpoint() {
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(FLSTR("ws://localhost:4984/db"), NULL);
    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = kDatabase;
    config.endpoint = target;
    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, NULL);
    CBLEndpoint_Free(target);

    // tag::replication-reset-checkpoint-full[]
    // replicator is a CBLReplicator* instance
    CBLReplicator_Start(replicator, true); <i class="conum" data-value="1"></i><b>(1)</b>

    // end::replication-reset-checkpoint-full[]

    stop_replicator(replicator);
}

static void read_1x_attachment() {
    CBLDocument* document = CBLDocument_Create();

    // tag::1x-attachment[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    FLDict properties = CBLDocument_Properties(document);
    FLDict attachments = FLValue_AsDict(FLDict_Get(properties, FLSTR("_attachments")));
    const CBLBlob* avatar = FLDict_GetBlob(FLValue_AsDict(FLDict_Get(attachments, FLSTR("avatar"))));
    FLSliceResult content = CBLBlob_Content(avatar, &amp;err);

    FLSliceResult_Release(content);
    // end::1x-attachment[]

    CBLDocument_Release(document);
}

static void create_new_database() {
    // tag::new-database[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDatabase* db = CBLDatabase_Open(FLSTR("my-database"), NULL, &amp;err);
    // end::new-database[]

    kDatabase = db;
}

static void close_database() {
    CBLDatabase* db = kDatabase;
    // tag::close-database[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDatabase_Close(db, &amp;err);
    // end::close-database[]
}

static void change_logging() {
    // tag::logging[]
    // For output to stdout
    CBLLog_SetConsoleLevel(kCBLLogVerbose);

    // For output to custom logging
    CBLLog_SetCallbackLevel(kCBLLogVerbose);
    // end::logging[]
}

static void load_prebuilt() {
    CBL_DeleteDatabase(FLSTR("travel-sample.cblite2"), kFLSliceNull, NULL);

    // tag::prebuilt-database[]
    // Note: Getting the path to a database is platform-specific.  For desktop (including RPi)
    // this can be a simple filesystem path.  For iOS you need to get the path from the
    // main bundle.  For Android you need to extract it from your assets to a temporary directory
    // and then pass that path.

    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    const char* path = "/path/to/travel-sample.cblite2";
    if(!CBL_DatabaseExists(FLSTR("travel-sample.cblite2"), kFLSliceNull)) {
        CBL_CopyDatabase(FLStr(path), FLSTR("travel-sample"), NULL, &amp;err);
    }
    // end::prebuilt-database[]

    CBLDatabase_Close(kDatabase, NULL);
    CBLDatabase_Release(kDatabase);
    kDatabase = CBLDatabase_Open(FLSTR("travel-sample"), NULL, NULL);
}

static void query_deleted_document() {
    CBLDatabase* db = kDatabase;

    // tag::query-deleted-documents[]
    // Query documents that have been deleted
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _ WHERE meta().deleted"), NULL, &amp;err);
    // end::query-deleted-documents[]

    CBLQuery_Release(query);
}

static void create_document() {
    CBLDatabase* db = kDatabase;

    // tag::initializer[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLDocument* newTask = CBLDocument_CreateWithID(FLSTR("xyz"));
    FLMutableDict properties = CBLDocument_MutableProperties(newTask);
    FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("task"));
    FLMutableDict_SetString(properties, FLSTR("owner"), FLSTR("todo"));

    // Storing time in millisecond, bluntly
    FLMutableDict_SetUInt(properties, FLSTR("createdAt"), time(NULL) * 1000);

    CBLError err;
    CBLDatabase_SaveDocument(db, newTask, &amp;err);
    CBLDocument_Release(newTask);
    // end::initializer[]
}

static void update_document() {
    CBLDatabase* db = kDatabase;

    // tag::update-document[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDocument* mutableDocument = CBLDatabase_GetMutableDocument(db, FLSTR("xyz"), &amp;err);
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDocument);
    FLMutableDict_SetString(properties, FLSTR("name"), FLSTR("apples"));
    CBLDatabase_SaveDocument(db, mutableDocument, &amp;err);
    CBLDocument_Release(mutableDocument);
    // end::update-document[]
}

// Note use_typed_accessors not applicable

static void do_batch_operation() {
    CBLDatabase* db = kDatabase;

    // tag::batch[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDatabase_BeginTransaction(db, &amp;err);
    char buffer[7];
    for(int i = 0; i &lt; 10; i++) {
        CBLDocument* doc = CBLDocument_Create();
        FLMutableDict properties = CBLDocument_MutableProperties(doc);
        FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("user"));
        sprintf(buffer, "user %d", i);
        FLMutableDict_SetString(properties, FLSTR("name"), FLStr(buffer));
        FLMutableDict_SetBool(properties, FLSTR("admin"), false);
        CBLDatabase_SaveDocument(db, doc, &amp;err);
        CBLDocument_Release(doc);
        printf("Saved user document %s\n", buffer);
    }

    CBLDatabase_EndTransaction(db, true, &amp;err);
    // end::batch[]
}

static void document_listener(void* context, const CBLDatabase* db, FLString id) {
    CBLError err;
    const CBLDocument* doc = CBLDatabase_GetDocument(db, id, &amp;err);
    FLDict properties = CBLDocument_Properties(doc);
    FLString verified_account = FLValue_AsString(FLDict_Get(properties, FLSTR("verified_account")));
    printf("Status :: %.*s\n", (int)verified_account.size, (const char *)verified_account.buf);
    CBLDocument_Release(doc);
}

static void database_change_listener() {
    CBLDatabase* db = kDatabase;

    // tag::document-listener[]
    /*
    static void document_listener(void* context, const CBLDatabase* db, FLString id) {
        CBLError err;
        const CBLDocument* doc = CBLDatabase_GetDocument(db, id, &amp;err);
        FLDict properties = CBLDocument_Properties(doc);
        FLString verified_account = FLValue_AsString(FLDict_Get(properties, FLSTR("verified_account")));
        printf("Status :: %.*s\n", (int)verified_account.size, (const char *)verified_account.buf);
        CBLDocument_Release(doc);
    }
    */
    CBLListenerToken* token = CBLDatabase_AddDocumentChangeListener(db, FLSTR("user.john"),
        document_listener, NULL);
    // end::document-listener[]

    CBLListener_Remove(token);
}

static void document_expiration() {
    CBLDatabase* db = kDatabase;

    // tag::document-expiration[]
    // Purge the document one day from now

    // Overly simplistic for example purposes
    // NOTE: API takes milliseconds
    // NOTE: No error handling, for brevity (see getting started)
    time_t ttl = time(NULL) + 24 * 60 * 60;
    ttl *= 1000;

    CBLError err;
    CBLDatabase_SetDocumentExpiration(db, FLSTR("doc123"), ttl, &amp;err);

    // Reset expiration
    CBLDatabase_SetDocumentExpiration(db, FLSTR("doc1"), 0, &amp;err);

    // Query documents that will be expired in less than five minutes
    time_t fiveMinutesFromNow = time(NULL) + 5 * 60;
    fiveMinutesFromNow *= 1000;
    FLMutableDict parameters = FLMutableDict_New();
    FLMutableDict_SetInt(parameters, FLSTR("five_minutes"), fiveMinutesFromNow);

    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _ WHERE meta().expiration &lt; $five_minutes"), NULL, &amp;err);
    CBLQuery_SetParameters(query, parameters);
    FLMutableDict_Release(parameters);
    // end::document-expiration[]
}

static void use_blob() {
    CBLDatabase* db = kDatabase;

    CBLDocument* newTask = CBLDocument_Create();

    // tag::blob[]
    // Note: Reading the data is implementation dependent, as with prebuilt databases
    // NOTE: No error handling, for brevity (see getting started)

    uint8_t buffer[128000];
    FILE* avatar_file = fopen("avatar.jpg", "rb");
    size_t read = fread(buffer, 1, 128000, avatar_file); <i class="conum" data-value="2"></i><b>(2)</b>

    FLSliceResult avatar = FLSliceResult_CreateWith(buffer, read);
    CBLBlob* blob = CBLBlob_CreateWithData(FLSTR("image/jpeg"), FLSliceResult_AsSlice(avatar)); <i class="conum" data-value="3"></i><b>(3)</b>
    FLSliceResult_Release(avatar);

    // TODO: Create shortcut blob method
    CBLError err;
    FLMutableDict properties = CBLDocument_MutableProperties(newTask);
    FLSlot_SetBlob(FLMutableDict_Set(properties, FLSTR("avatar")), blob);
    CBLDatabase_SaveDocument(db, newTask, &amp;err); <i class="conum" data-value="4"></i><b>(4)</b>

    // end::blob[]



    CBLDocument_Release(newTask);
    CBLBlob_Release(blob);
}

static void doc_json() {
    CBLDatabase* db = kDatabase;

    // tag::tojson-document[]
    // NOTE: No error handling, for brevity (see getting started)

    FLString json = FLSTR("{\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",\"country\":\"Australia\"}");

    // Create a document and set the JSON data to the document
    CBLError err;
    CBLDocument* newDoc = CBLDocument_CreateWithID(FLSTR("hotel_1002"));
    CBLDocument_SetJSON(newDoc, json, &amp;err);

    // Save the document to the database
    CBLDatabase_SaveDocument(db, newDoc, &amp;err);

    // Release created doc after using it
    CBLDocument_Release(newDoc);

    // Get the document from the database
    const CBLDocument* doc = CBLDatabase_GetDocument(db, FLSTR("hotel_1002"), &amp;err);

    // Get document body as JSON
    FLSliceResult docJson = CBLDocument_CreateJSON(doc);
    printf("Document in JSON :: %.*s\n", (int)docJson.size, (const char *)docJson.buf);

    // Release JSON data after using it
    FLSliceResult_Release(docJson);

    // Release doc read from the database after using it
    CBLDocument_Release(doc);
    // end::tojson-document[]
}

static void dict_json() {
    // tag::tojson-dictionary[]
    // NOTE: No error handling, for brevity (see getting started)

    FLString json = FLSTR("{\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",\"country\":\"Australia\"}");

    // Create a dictionary from the JSON string
    FLError err;
    FLSliceResult jsonData1 = FLData_ConvertJSON(json, &amp;err);
    FLDict hotel = FLValue_AsDict(FLValue_FromData(FLSliceResult_AsSlice(jsonData1), kFLTrusted));

    // Iterate through the dictionary
    FLDictIterator iter;
    FLDictIterator_Begin(hotel, &amp;iter);
    FLValue value;
    while (NULL != (value = FLDictIterator_GetValue(&amp;iter))) {
        FLString key = FLDictIterator_GetKeyString(&amp;iter);
        FLString strValue = FLValue_AsString(value);
        printf("%.*s :: %.*s\n", (int)key.size, (const char*)key.buf, (int)strValue.size, (const char*)strValue.buf);
        FLDictIterator_Next(&amp;iter);
    }

    // Convert the dictionary to JSON
    FLSliceResult jsonData2 = FLValue_ToJSON((FLValue)hotel);
    printf("Hotel in JSON :: %.*s\n", (int)jsonData2.size, (const char *)jsonData2.buf);

    // Release JSON data after finish using it
    FLSliceResult_Release(jsonData1);
    FLSliceResult_Release(jsonData2);
    // end::tojson-dictionary[]
}

static void array_json() {
    // tag::tojson-array[]
    // NOTE: No error handling, for brevity (see getting started)

    FLString json = FLSTR("[\"Hotel Ned\", \"Hotel Ted\"]");

    // Create an array from the JSON string
    FLError err;
    FLSliceResult jsonData1 = FLData_ConvertJSON(json, &amp;err);
    FLArray hotels = FLValue_AsArray(FLValue_FromData(FLSliceResult_AsSlice(jsonData1), kFLTrusted));

    // Iterate through the array
    FLArrayIterator iter;
    FLArrayIterator_Begin(hotels, &amp;iter);
    FLValue value;
    while (NULL != (value = FLArrayIterator_GetValue(&amp;iter))) {
        FLString hotel = FLValue_AsString(value);
        printf("Hotel :: %.*s\n", (int)hotel.size, (const char *)hotel.buf);
        FLArrayIterator_Next(&amp;iter);
    }

    // Convert the array to JSON
    FLSliceResult jsonData2 = FLValue_ToJSON((FLValue)hotels);
    printf("Hotels in JSON :: %.*s\n", (int)jsonData2.size, (const char *)jsonData2.buf);

    // Release JSON data after finish using it
    FLSliceResult_Release(jsonData1);
    FLSliceResult_Release(jsonData2);
    // end::tojson-array[]
}

static void datatype_dictionary()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_dictionary[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    const CBLDocument *doc = CBLDatabase_GetDocument(db, FLSTR("doc1"), &amp;err);
    FLDict properties = CBLDocument_Properties(doc);

    // Getting a dictionary from the document's properties
    FLValue dictValue = FLDict_Get(properties, FLSTR("address"));
    FLDict dict = FLValue_AsDict(dictValue);

    // Access a value with a key from the dictionary
    FLValue streetVal = FLDict_Get(dict, FLSTR("street"));
    FLString street = FLValue_AsString(streetVal);

    // Iterate dictionary
    FLDictIterator iter;
    FLDictIterator_Begin(dict, &amp;iter);
    FLValue value;
    while (NULL != (value = FLDictIterator_GetValue(&amp;iter))) {
        FLString key = FLDictIterator_GetKeyString(&amp;iter);
        FLString strValue = FLValue_AsString(value);
        printf("Key :: %.*s\n", (int)key.size, (const char *)key.buf);
        printf("Value :: %.*s\n", (int)strValue.size, (const char *)strValue.buf);
        // ...
        FLDictIterator_Next(&amp;iter);
    }

    // Create a mutable copy.
    // kFLDefaultCopy is shallow which means the nested dictionaries and arrays will be
    // referenced but not copied. Use kFLDeepCopyImmutables for the deep copy.
    FLMutableDict mutableDict = FLDict_MutableCopy(dict, kFLDefaultCopy);

    // Release when finish using it
    FLMutableDict_Release(mutableDict);
    // end::datatype_dictionary[]
}

static void datatype_mutable_dictionary()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_mutable_dictionary[]
    // NOTE: No error handling, for brevity (see getting started)

    // tag::datatype_mutable_dictionary-create[]
    // Create a new mutable dictionary and populate some keys/values
    FLMutableDict dict = FLMutableDict_New();
    FLMutableDict_SetString(dict, FLSTR("street"), FLSTR("1 Main st."));
    FLMutableDict_SetString(dict, FLSTR("city"), FLSTR("San Francisco"));
    // end::datatype_mutable_dictionary-create[]

    // tag::datatype_mutable_dictionary-add-to-doc[]
    // Set the dictionary to document's properties and save the document
    CBLDocument *doc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(doc);
    FLMutableDict_SetDict(properties, FLSTR("address"), dict);
    // end::datatype_mutable_dictionary-add-to-doc[]
    CBLError err;
    CBLDatabase_SaveDocument(db, doc, &amp;err);
    CBLDocument_Release(doc);

    // Release when finish using it
    FLMutableDict_Release(dict);
    // end::datatype_mutable_dictionary[]
}

static void datatype_array()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_array[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    const CBLDocument *doc = CBLDatabase_GetDocument(db, FLSTR("doc1"), &amp;err);
    FLDict properties = CBLDocument_Properties(doc);

    // Getting a phones array from the document's properties
    FLValue arrayValue = FLDict_Get(properties, FLSTR("phones"));
    FLArray array = FLValue_AsArray(arrayValue);

    // Get element count
    int count = FLArray_Count(array);
    printf("Count :: %d\n", count);

    // Access an array element by index
    if (!FLArray_IsEmpty(array)) {
        FLValue phoneVal = FLArray_Get(array, 0);
        FLString phone = FLValue_AsString(phoneVal);
        printf("Value :: %.*s\n", (int)phone.size, (const char *)phone.buf);
    }

    // Iterate array
    FLArrayIterator iter;
    FLArrayIterator_Begin(array, &amp;iter);
    FLValue val;
    while (NULL != (val = FLArrayIterator_GetValue(&amp;iter)))
    {
        FLString str = FLValue_AsString(val);
        printf("Value :: %.*s\n", (int)str.size, (const char *)str.buf);
        FLArrayIterator_Next(&amp;iter);
    }
    // end::datatype_array[]

    // Create a mutable copy.
    // kFLDefaultCopy is shallow which means the nested dictionaries and arrays will be
    // referenced but not copied. Use kFLDeepCopyImmutables for the deep copy.
    FLMutableArray mutableArray = FLArray_MutableCopy(array, kFLDefaultCopy);

    // Release when finish using it
    FLMutableArray_Release(mutableArray);
}

static void datatype_mutable_array()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_mutable_array[]
    // NOTE: No error handling, for brevity (see getting started)

    // tag::datatype_mutable_array-create[]
    // Create a new mutable array and populate data into the array
    FLMutableArray phones = FLMutableArray_New();
    FLMutableArray_AppendString(phones, FLSTR("650-000-0000"));
    FLMutableArray_AppendString(phones, FLSTR("650-000-0001"));
    // end::datatype_mutable_array-create[]

    // tag::datatype_mutable_array-add-to-doc[]
    // Set the array to document's properties and save the document
    CBLDocument *doc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(doc);
    FLMutableDict_SetArray(properties, FLSTR("phones"), phones);
    // end::datatype_mutable_array-add-to-doc[]
    CBLError err;
    CBLDatabase_SaveDocument(db, doc, &amp;err);
    CBLDocument_Release(doc);

    // Release the created dictionary
    FLMutableArray_Release(phones);
    // end::datatype_mutable_array[]
}


static void datatype_usage() {

    // tag::datatype_usage[]
    // tag::datatype_usage_createdb[]
    // Open or create DB if it doesn't exist
    CBLError err;
    CBLDatabase* database = CBLDatabase_Open(FLSTR("mydb"), NULL, &amp;err);
    if(!database) {
        // Error handling.  For brevity, this is truncated in the rest of the snippet
        // and omitted in other doc code snippets
        fprintf(stderr, "Error opening database (%d / %d)\n", err.domain, err.code);
        FLSliceResult msg = CBLError_Message(&amp;err);
        fprintf(stderr, "%.*s\n", (int)msg.size, (const char *)msg.buf);
        FLSliceResult_Release(msg);
        return;
    }

    // end::datatype_usage_createdb[]
    // tag::datatype_usage_createdoc[]
    // Create your new document
    // The lack of 'const' indicates this document is mutable
    CBLDocument* mutableDoc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDoc);

    // end::datatype_usage_createdoc[]
    // tag::datatype_usage_mutdict[]
    // Create and populate mutable dictionary
    FLMutableDict address = FLMutableDict_New();
    FLMutableDict_SetString(address, FLSTR("street"), FLSTR("1 Main st."));
    FLMutableDict_SetString(address, FLSTR("city"), FLSTR("San Francisco"));
    FLMutableDict_SetString(address, FLSTR("state"), FLSTR("CA"));
    FLMutableDict_SetString(address, FLSTR("country"), FLSTR("USA"));
    FLMutableDict_SetString(address, FLSTR("code"), FLSTR("90210"));

    // end::datatype_usage_mutdict[]
    // tag::datatype_usage_mutarray[]
    // Create and populate mutable array
    FLMutableArray phones = FLMutableArray_New();
    FLMutableArray_AppendString(phones, FLSTR("650-000-0000"));
    FLMutableArray_AppendString(phones, FLSTR("650-000-0001"));

    // end::datatype_usage_mutarray[]
    // tag::datatype_usage_populate[]
    // Initialize and populate the document

    // Add document type to document properties <i class="conum" data-value="5"></i><b>(5)</b>
    FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("hotel"));

    // Add hotel name string to document properties <i class="conum" data-value="6"></i><b>(6)</b>
    FLMutableDict_SetString(properties, FLSTR("hotel"), FLSTR(""));

    // Add float to document properties <i class="conum" data-value="7"></i><b>(7)</b>
    FLMutableDict_SetFloat(properties, FLSTR("room_rate"), 121.75f);

    // Add dictionary to document's properties <i class="conum" data-value="8"></i><b>(8)</b>
    FLMutableDict_SetDict(properties, FLSTR("address"), dict);

    // Add array to document's properties <i class="conum" data-value="9"></i><b>(9)</b>
    FLMutableDict_SetArray(properties, FLSTR("phones"), phones);

    // end::datatype_usage_populate[]
    // tag::datatype_usage_persist[]
    // Save the document changes <i class="conum" data-value="10"></i><b>(10)</b>
    CBLError err;
    CBLDatabase_SaveDocument(database, doc, &amp;err);

    // end::datatype_usage_persist[]
    // tag::datatype_usage_closedb[]
    // Close the database <i class="conum" data-value="11"></i><b>(11)</b>
    CBLError err;
    CBLDatabase_Close(database, &amp;err);

    // end::datatype_usage_closedb[]
    // tag::datatype_usage_release[]
    // Release the created items <i class="conum" data-value="12"></i><b>(12)</b>
    CBLDatabase_Release(database);
    CBLDocument_Release(doc);
    FLMutableDict_Release(dict);
    FLMutableArray_Release(phones);
    // end::datatype_usage_release[]

    // end::datatype_usage[]

} // end datatype_usage()


static void create_index() {
    CBLDatabase* db = kDatabase;

    // tag::query-index[]
    // For value types, this is optional but provides performance enhancements
    // NOTE: No error handling, for brevity (see getting started)

    // Syntax for second argument is the same as taking from a N1QL SELECT
    // i.e. SELECT (type, name) FROM _;
    CBLValueIndexConfiguration config = {
        kCBLN1QLLanguage,
        FLSTR("type, name")
    };

    CBLError err;
    CBLDatabase_CreateValueIndex(db, FLSTR("TypeNameIndex"), config, &amp;err);
    // end::query-index[]
}

static void select_meta() {
    CBLDatabase* db = kDatabase;

    // tag::query-select-meta[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, type, name FROM _"), NULL, &amp;err);
    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString id = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("id")));
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Document ID :: %.*s\n", (int)id.size, (const char *)id.buf);
        printf("Document Name :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-select-meta[]
}

static void select_id() {
    CBLDatabase* db = kDatabase;

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _"), NULL, &amp;err);

    // tag::query-access-id[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString id = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("id")));
        printf("Document ID :: %.*s\n", (int)id.size, (const char *)id.buf);
    }
    // end::query-access-id[]

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
}

static void query_change_listener(void* context, CBLQuery* query, CBLListenerToken* token) {
    CBLError err;
    CBLResultSet* results = CBLQuery_CopyCurrentResults(query, token, &amp;err);
    while(CBLResultSet_Next(results)) {
        // Update UI
    }
}

static void select_all() {
    CBLDatabase* db = kDatabase;

    // tag::query-select-all[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _"), NULL, &amp;err);

    // All results will be available from the above query
    CBLQuery_Release(query);
    // end::query-select-all[]

    // tag::live-query[]
    /*
    static void query_change_listener(void* context, CBLQuery* query, CBLListenerToken* token) {
        CBLError err;
        CBLResultSet* results = CBLQuery_CopyCurrentResults(query, token, &amp;err);
        while(CBLResultSet_Next(results)) {
            // Update UI
        }
    }
    */

    query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _"), NULL, &amp;err); <i class="conum" data-value="13"></i><b>(13)</b>

    CBLListenerToken* token = CBLQuery_AddChangeListener(query, query_change_listener, NULL); <i class="conum" data-value="14"></i><b>(14)</b>
    // end::live-query[]

    // tag::stop-live-query[]
    CBLListener_Remove(token); // The token received from AddChangeListener
    CBLQuery_Release(query);
    // end::stop-live-query[]
}

static void select_and_access_all() {
    CBLDatabase* db = kDatabase;

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _"), NULL, &amp;err);

    // tag::query-access-all[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict dict = FLValue_AsDict(CBLResultSet_ValueForKey(results, FLSTR("_")));

        FLString id = FLValue_AsString(FLDict_Get(dict, FLSTR("id")));
        FLString type = FLValue_AsString(FLDict_Get(dict, FLSTR("type")));
        FLString name = FLValue_AsString(FLDict_Get(dict, FLSTR("name")));
        FLString city = FLValue_AsString(FLDict_Get(dict, FLSTR("city")));

        printf("ID :: %.*s\n", (int)id.size, (const char *)id.buf);
        printf("Type :: %.*s\n", (int)type.size, (const char *)type.buf);
        printf("Name :: %.*s\n", (int)name.size, (const char *)name.buf);
        printf("City :: %.*s\n", (int)city.size, (const char *)city.buf);
    }

    // All results will be available from the above query
    CBLResultSet_Release(results);
    // end::query-access-all[]

    CBLQuery_Release(query);
}

static void select_props() {
    CBLDatabase* db = kDatabase;

    // tag::query-access-props[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT type, name, city FROM _"), NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString type = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("type")));
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        FLString city = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("city")));

        printf("Type :: %.*s\n", (int)type.size, (const char *)type.buf);
        printf("Name :: %.*s\n", (int)name.size, (const char *)name.buf);
        printf("City :: %.*s\n", (int)city.size, (const char *)city.buf);
    }
    // end::query-access-props[]

    // All results will be available from the above query
    CBLResultSet_Release(results);
    CBLQuery_Release(query);
}

static void select_where() {
    CBLDatabase* db = kDatabase;

    // tag::query-where[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _ WHERE type = \"hotel\" LIMIT 10"), NULL, &amp;err);
    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict dict = FLValue_AsDict(CBLResultSet_ValueForKey(results, FLSTR("_")));
        FLString name = FLValue_AsString(FLDict_Get(dict, FLSTR("name")));
        printf("Document Name :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-where[]
}

static void use_collection_contains() {
    CBLDatabase* db = kDatabase;

    // tag::query-collection-operator-contains[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name, public_likes FROM _ WHERE type = \"hotel\" "
              "AND ARRAY_CONTAINS(public_likes, \"Armani Langworth\")"), NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLArray publicLikes = FLValue_AsArray(CBLResultSet_ValueForKey(results, FLSTR("public_likes")));
        FLStringResult json = FLValue_ToJSON((FLValue)publicLikes);
        printf("Public Likes :: %.*s\n", (int)json.size, (const char *)json.buf);
        FLSliceResult_Release(json);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-collection-operator-contains[]
}

static void use_collection_in() {
    CBLDatabase* db = kDatabase;

    // tag::query-collection-operator-in[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _ WHERE \"Armani\" IN (first, last, username)"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict body = FLValue_AsDict(CBLResultSet_ValueAtIndex(results, 0));
        FLStringResult json = FLValue_ToJSON((FLValue)body);
        printf("In results :: %.*s\n", (int)json.size, (const char *)json.buf);
        FLSliceResult_Release(json);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-collection-operator-in[]
}

static void select_like() {
    CBLDatabase* db = kDatabase;

    // tag::query-like-operator[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND lower(name) LIKE \"Royal Engineers Museum\" LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-like-operator[]
}

static void select_wildcard_like() {
    CBLDatabase* db = kDatabase;

    // tag::query-like-operator-wildcard-match[]
    // NOTE: No error handling, for brevity (see getting started)

     CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND lower(name) LIKE \"Eng%e%\" LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-like-operator-wildcard-match[]
}

static void select_wildcard_character_like() {
    CBLDatabase* db = kDatabase;

    // tag::query-like-operator-wildcard-character-match[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND lower(name) LIKE \"Royal Eng____rs Museum\" LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-like-operator-wildcard-character-match[]
}

static void select_regex() {
    CBLDatabase* db = kDatabase;

    // tag::query-regex-operator[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND regexp_like(name, \"\\bEng.*e\\b\") LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-regex-operator[]
}

static void select_join() {
    CBLDatabase* db = kDatabase;

    // tag::query-join[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT airline.name, airline.callsign, route.destinationairport, route.stops, route.airline "
              "FROM _ AS airline INNER JOIN _ AS route ON meta(airline).id = route.airlineid "
              "WHERE route.type = \"route\" AND airline.type = \"airline\" AND route.sourceairport = \"RIX\""),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-join[]
}

static void group_by() {
    CBLDatabase* db = kDatabase;

    // tag::query-groupby[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT count(*), country, tz FROM _ WHERE type = \"airport\" AND geo.alt &gt;= 300 "
              "GROUP BY country, tz"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        int64_t count = FLValue_AsInt(CBLResultSet_ValueForKey(results, FLSTR("$1")));
        FLString tz = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("tz")));
        FLString country = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("country")));
        printf("There are %" PRIi64 " airports in the %.*s timezone located in %.*s and above 300 ft\n",
            count, (int)tz.size, (const char *)tz.buf, (int)country.size, (const char *)country.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-groupby[]
}

static void order_by() {
    CBLDatabase* db = kDatabase;

    // tag::query-orderby[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, title FROM _ WHERE type = \"hotel\" ORDER BY title ASC LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString title = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("title")));
        printf("Title :: %.*s\n", (int)title.size, (const char *)title.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-orderby[]
}

static void test_explain_statement() {
    CBLDatabase* db = kDatabase;

    {
    // tag::query-explain-all[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _ WHERE type = \"hotel\" GROUP BY country ORDER BY title ASC LIMIT 10"),
        NULL, &amp;err);

    FLSliceResult explanation = CBLQuery_Explain(query);
    printf("%.*s", (int)explanation.size, (const char *)explanation.buf);
    FLSliceResult_Release(explanation);
    // end::query-explain-all[]
    }

    // DOCS NOTE: Others omitted for now
}

static void query_result_json() {
    CBLDatabase* db = kDatabase;

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id as id, name, city, type FROM _ LIMIT 10"),
        NULL, &amp;err);

    // tag::query-access-json[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict result = CBLResultSet_ResultDict(results);
        FLStringResult json = FLValue_ToJSON((FLValue)result);
        printf("JSON Result :: %.*s\n", (int)json.size, (const char *)json.buf);
        FLSliceResult_Release(json);
    }
    CBLResultSet_Release(results);

    // end::query-access-json[]

    CBLQuery_Release(query);
}

static void create_full_text_index() {
    CBLDatabase* db = kDatabase;

    const char* tasks[] = { "buy groceries", "play chess", "book travels", "buy museum tickets" };
    char idBuffer[7];
    for(int i = 0; i &lt; 4; i++) {
        const char* task = tasks[i];
        sprintf(idBuffer, "extra%d", i);
        const CBLDocument* doc = CBLDatabase_GetDocument(db, FLStr(idBuffer), NULL);
        if(doc) {
            CBLDocument_Release(doc);
            continue;
        }

        CBLDocument* mutableDoc = CBLDocument_CreateWithID(FLStr(idBuffer));
        FLMutableDict properties = CBLDocument_MutableProperties(mutableDoc);
        FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("task"));
        FLMutableDict_SetString(properties, FLSTR("task"), FLStr(task));
        CBLDatabase_SaveDocument(db, mutableDoc, NULL);
        CBLDocument_Release(mutableDoc);
    }

    // tag::fts-index[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLFullTextIndexConfiguration config = {
        kCBLN1QLLanguage,
        FLSTR("name"),
        false
    };

    CBLDatabase_CreateFullTextIndex(db, FLSTR("nameFTSIndex"), config, &amp;err);
    // end::fts-index[]
}

static void full_text_search() {
    CBLDatabase* db = kDatabase;

    // tag::fts-query[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _ WHERE MATCH(nameFTSIndex, \"'buy'\")"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString id = FLValue_AsString(CBLResultSet_ValueAtIndex(results, 0));
        printf("Document id :: %.*s\n", (int)id.size, (const char *)id.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::fts-query[]
}

static void start_replication() {
    CBLDatabase* db = kDatabase;

    /*
    * This requires Sync Gateway running with the following config, or equivalent:
    *
    * {
    *     "log":["*"],
    *     "databases": {
    *         "db": {
    *             "server":"walrus:",
    *             "users": {
    *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
    *             }
    *         }
    *     }
    * }
    */

    // tag::replication[]
    // NOTE: No error handling, for brevity (see getting started)
    // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);
    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target;
    config.replicatorType = kCBLReplicatorTypePull;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);
    CBLReplicator_Start(replicator, false);
    // end::replication[]

    stop_replicator(replicator);
}

// Console logging domain methods are not applicable to C

static void file_logging() {
    // tag::file-logging[]
    // NOTE: No error handling, for brevity (see getting started)
    // NOTE: You will need to use a platform appropriate method for finding
    // a temporary directory

    FLString tempFolder = FLSTR("/tmp/cbllog");

    CBLLogFileConfiguration config; // Don't bother zeroing, since we set all properties
    config.level = kCBLLogInfo;
    config.directory = tempFolder;
    config.maxRotateCount = 5;
    config.maxSize = 10240;
    config.usePlaintext = false;

    CBLError err;
    CBLLog_SetFileConfig(config, &amp;err);
    // end::file-logging[]
}

// tag::custom-logging[]
static void custom_log_callback(CBLLogDomain domain, CBLLogLevel level, FLString message) {
    // handle the message, for example piping it to
    // a third party framework
}
// end::custom-logging[]

static void enable_custom_logging() {
    // tag::set-custom-logging[]
    CBLLog_SetCallback(custom_log_callback);
    // end::set-custom-logging[]
}

static void enable_basic_auth() {
    CBLDatabase* db = kDatabase;

    // tag::basic-authentication-full[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/mydatabase");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);
    CBLAuthenticator* basicAuth = CBLAuth_CreatePassword(FLSTR("john"), FLSTR("pass"));

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target;
    config.authenticator = basicAuth;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);
    CBLAuth_Free(basicAuth);

    CBLReplicator_Start(replicator, false);
    // end::basic-authentication-full[]

    stop_replicator(replicator);
}

static void docsonly_N1QL_Params(CBLDatabase* argDb)
{
    CBLDatabase* database = argDb;

    // tag::query-syntax-n1ql-params[]
    int errorPos;

    CBLError err;

    FLString n1qlstr = FLSTR("SELECT * FROM _ WHERE type = $type");

    FLMutableDict n1qlparams = FLMutableDict_New();
    FLMutableDict_SetString(n1qlparams, FLSTR("type"), FLSTR("hotel"));

    CBLQuery* query = CBLDatabase_CreateQuery(database,
                          kCBLN1QLLanguage,
                          n1qlstr,
                          &amp;errorPos,
                          &amp;err);

    CBLQuery_SetParameters(query, n1qlparams);

    if(!query) {
        /* Do appropriate error handling ...
            Note that (where applicable) errorPos contains the position
            in the N1QL string that the parse failed
        */
        FLMutableDict_Release(n1qlparams);
        CBLQuery_Release(query);
        return;
    }

    CBLResultSet* result = CBLQuery_Execute(query, &amp;err);
    if(!result) {
        // Failed to run query, do error handling ...
        return;
    }

    // Release query when finished with
    FLMutableDict_Release(n1qlparams);
    CBLQuery_Release(query);

    // ... process results as required

    // Release result set then finished with
    CBLResultSet_Release(result);

    // end::query-syntax-n1ql-params[]
}



// tag::console-logging-db[]
//Placeholder for code to increase level of console logging for kCBLLogDomainDatabase domain
// end::console-logging-db[]

// tag::console-logging[]
//Placeholder for code to increase level of console logging for all domains
// end::console-logging[]

// tag::date-getter[]
//Placeholder for Date accessors.

// end::date-getter[]


// tag::query-index[]
// placeholder
// end::query-index[]


// DOCS NOTE
// Page=Data Sync &gt;&gt; Configuration Summary
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#configuration-summary
static void docs_act_replication(CBLDatabase* argDb)
{
    CBLDatabase* database = argDb;

    /*
    * This requires Sync Gateway running with the following config, or equivalent:
    *
    * {
    *     "log":["*"],
    *     "databases": {
    *         "db": {
    *             "server":"walrus:",
    *             "users": {
    *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
    *             }
    *         }
    *     }
    * }
    */

    // tag::p2p-act-rep-func[]
    // Purpose -- Show configuration , initialization and running of a replicator

    // NOTE: No error handling, for brevity (see getting started)
    // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err); <i class="conum" data-value="15"></i><b>(15)</b>

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = database;
    config.endpoint = target; <i class="conum" data-value="16"></i><b>(16)</b>

    // tag::p2p-act-rep-config-cont[]
    // Set replication direction and mode
    config.replicatorType = kCBLReplicatorTypePull; <i class="conum" data-value="17"></i><b>(17)</b>
    config.continuous = true;

    // end::p2p-act-rep-config-cont[]

    // Optionally, set auto-purge behavior (here we override default)
    config.disableAutoPurge = true; <i class="conum" data-value="18"></i><b>(18)</b>

    // Optionally, configure Client Authentication
    // Here we are using to Basic Authentication,
    // Providing username and password credentials
    CBLAuthenticator* basicAuth =
        CBLAuth_CreatePassword(FLSTR("username"),
                               FLSTR("passwd")); <i class="conum" data-value="19"></i><b>(19)</b>
    config.authenticator = basicAuth;

    // Optionally, configure how we handle conflicts
    config.conflictResolver = simpleConflictResolver_localWins; <i class="conum" data-value="20"></i><b>(20)</b>

    // Initialize replicator with created config
    CBLReplicator* replicator =
        CBLReplicator_Create(&amp;config, &amp;err); <i class="conum" data-value="21"></i><b>(21)</b>

    CBLEndpoint_Free(target);

    // Optionally, add change listener
    CBLListenerToken* token =
            CBLReplicator_AddChangeListener(replicator,
                                            simpleChangeListener,
                                            NULL); <i class="conum" data-value="22"></i><b>(22)</b>

    // Start replication
    CBLReplicator_Start(replicator, false); <i class="conum" data-value="23"></i><b>(23)</b>

    // end::p2p-act-rep-func[]

    //    ... other processing as required

    // When finished release resources e.g.
    CBLAuth_Free(basicAuth);
    stop_replicator(replicator);
}
// END configuration summary snippets


// DOCS NOTE:
// Page=Data Sync &gt;&gt; Configuration
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#configuration-summary
// This function is not pulled into docs en-bloc
// it is a slightly more in-depth than the configurationsummary above
// and the snippets within it are used individually or in sets
// to illustrate specific points as required
//
static void docs_act_replication_config_section_snippets()
{
    CBLDatabase* db = kDatabase;
    bool docs_example_ShowBasicAuth = false;
    bool docs_example_ShowSessionAuth = false;

    /*
    * This requires Sync Gateway running with the following config, or equivalent:
    *
    * {
    *     "log":["*"],
    *     "databases": {
    *         "db": {
    *             "server":"walrus:",
    *             "users": {
    *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
    *             }
    *         }
    *     }
    * }
    */
    // tag::p2p-act-rep-func-full[]
    // NOTE: No error handling, for brevity (see getting started)
    // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)

    // tag::sgw-act-rep-initialize[]
    // Initialize the configuration object and set db target
    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target =
        CBLEndpoint_CreateWithURL(url, &amp;err); <i class="conum" data-value="24"></i><b>(24)</b>

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target; <i class="conum" data-value="25"></i><b>(25)</b>

    // end::sgw-act-rep-initialize[]

    //    tag::p2p-act-rep-config-type[]
    config.replicatorType = kCBLReplicatorTypePull;

    //    end::p2p-act-rep-config-type[]
    //    tag::p2p-act-rep-config-cont[]
    config.continuous = true;

    //    end::p2p-act-rep-config-cont[]
    // tag::replication-retry-config[]
    // Configure replication retries
    // tag::replication-set-heartbeat[]
    config.heartbeat = 120; //  <i class="conum" data-value="26"></i><b>(26)</b>

    // end::replication-set-heartbeat[]
    // tag::replication-set-maxattempts[]
    config.maxAttempts = 20; //  <i class="conum" data-value="27"></i><b>(27)</b>

    // end::replication-set-maxattempts[]
    // tag::replication-set-maxattemptwaittime[]
    config.maxAttemptWaitTime = 600; //  <i class="conum" data-value="28"></i><b>(28)</b>

    // end::replication-set-maxattemptwaittime[]
    // end::replication-retry-config[]
    // tag::basic-authentication[]
    // Configure Client Authentication to Basic Authentication
    // Providing username and password credentials
    if(docs_example_ShowBasicAuth) {
        CBLAuthenticator* basicAuth =
            CBLAuth_CreatePassword(FLSTR("username"),
                                   FLSTR("passwd"));
        config.authenticator = basicAuth; <i class="conum" data-value="29"></i><b>(29)</b>
    }
    // end::basic-authentication[]

    // tag::session-authentication[]
    if(docs_example_ShowSessionAuth) {
        CBLAuthenticator* sessionAuth =
            CBLAuth_CreateSession(FLSTR("904ac010862f37c8dd99015a33ab5a3565fd8447"),
                                  FLSTR("optionalCookieName"));
        config.authenticator = sessionAuth; <i class="conum" data-value="30"></i><b>(30)</b>
    }

    // end::session-authentication[]

    // tag::replication-custom-header[]
    // Optionally, add custom headers
    FLMutableDict customHdrs = FLMutableDict_New();
    FLMutableDict_SetString(customHdrs,
                            FLSTR("customHeaderName"),
                            FLSTR("customHeaderValue"));

    config.headers = customHdrs;

    // tag::certificate-pinning[]
    char cert_buf[10000];
    FILE* cert_file = fopen("cert.pem", "r");
    size_t read = fread(cert_buf, 1, sizeof(cert_buf), cert_file);
    config.pinnedServerCertificate = (FLSlice){cert_buf, read};
    // end::certificate-pinning[]

    // end::replication-custom-header[]
    // FILTERS
    // tag::replication-push-filter[]
    // tag::replication-pull-filter[]
    // Purpose - Illustrate use of push and-or pull filter functions
    config.pushFilter = simpleReplicationFilter;

    config.pullFilter = simpleReplicationFilter;

    // end::replication-pull-filter[]
    // end::replication-push-filter[]

    //  Auto-purge over-ride
    // tag::autopurge-override[]
    config.disableAutoPurge = true; <i class="conum" data-value="31"></i><b>(31)</b>

    // end::autopurge-override[]
    // Initialize replicator with created config
    CBLReplicator* replicator =
        CBLReplicator_Create(&amp;config, &amp;err); <i class="conum" data-value="32"></i><b>(32)</b>

    CBLEndpoint_Free(target);

    // Add optional change listener
    CBLListenerToken* token_ReplChangeListener =
        CBLReplicator_AddChangeListener(replicator,
                                        simpleChangeListener,
                                        NULL); <i class="conum" data-value="33"></i><b>(33)</b>
}
// END replication.html &gt;&gt; configure section


// PAGE=Data Sync &gt;&gt; Initialize section
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#lbl-init-repl
static CBLReplicator* docs_act_replication_Intialize(
                        void* context,
                        CBLReplicatorConfiguration argConfig,
                        bool argResetRequired)
{
    CBLError err;
    bool docs_example_resetRequired = argResetRequired;
    // tag::p2p-act-rep-start-full[]
    CBLReplicator* thisRepl =
    CBLReplicator_Create(&amp;argConfig, &amp;err); <i class="conum" data-value="34"></i><b>(34)</b>

    // end::p2p-act-rep-start-full[]
    if(!docs_example_resetRequired) {
    // tag::p2p-act-rep-start-full[]
      CBLReplicator_Start(thisRepl, false); <i class="conum" data-value="35"></i><b>(35)</b>

    // end::p2p-act-rep-start-full[]
    } else {
    // tag::replication-reset-checkpoint[]
      CBLReplicator_Start(thisRepl, true); <i class="conum" data-value="36"></i><b>(36)</b>

    // end::replication-reset-checkpoint[]
    }
    return thisRepl;
}
// END replication.html &gt;&gt; initialize section

// PAGE=Data Sync &gt;&gt; Monitor section
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#lbl-repl-mon
static void docs_act_replication_Monitor(
                                       void* context,
                                       CBLReplicator* argRepl) {
    CBLError err;
    CBLReplicator* thisRepl = argRepl;
    // tag::p2p-act-rep-add-change-listener[]
    // Purpose -- illustrate addition of a Replicator change listener
    CBLListenerToken* token_ReplChangeListener =
            CBLReplicator_AddChangeListener(thisRepl,
                                            simpleChangeListener,
                                            NULL);

    // end::p2p-act-rep-add-change-listener[]
    // tag::add-document-replication-listener[]
    // Purpose -- illustrate addition of a Document Replicator  listener
    CBLListenerToken* token_ReplDocListener =
            CBLReplicator_AddDocumentReplicationListener(
                                                        thisRepl,
                                                        SimpleReplicationDocumentListener,
                                                        context);

    // end::add-document-replication-listener[]
    // tag::remove-document-replication-listener[]
    // Purpose -- illustrate removal of a listener
    CBLListener_Remove(token_ReplDocListener);
    CBLListener_Remove(token_ReplChangeListener);

    // end::remove-document-replication-listener[]

    // tag::p2p-act-rep-status[]
    // Purpose -- illustrate use of CBLReplicator_Status()
    CBLReplicatorStatus thisState = CBLReplicator_Status(thisRepl);
    if(thisState.activity==kCBLReplicatorStopped) {
        if(thisState.error.code==0) {
            CBLReplicator_Start(thisRepl,false);
        } else {
            printf("Replicator stopped -- code %d", thisState.error.code);
            // ... handle error ...
            CBLReplicator_Release(thisRepl);
        }
    }

    // end::p2p-act-rep-status[]
    // tag::replication-pendingdocuments[]
    FLDict thisPendingIdList =
        CBLReplicator_PendingDocumentIDs(thisRepl, &amp;err); <i class="conum" data-value="37"></i><b>(37)</b>
    if(!FLDict_IsEmpty(thisPendingIdList)) {
        FLDictIterator item;
        FLDictIterator_Begin(thisPendingIdList, &amp;item);
        FLValue itemValue;
        FLString pendingId;
        while(NULL != (itemValue = FLDictIterator_GetValue(&amp;item))) {
            pendingId = FLValue_AsString(itemValue);
            if(CBLReplicator_IsDocumentPending(thisRepl,
                                               pendingId,
                                               &amp;err)) {
                // ... process the still pending docid as required <i class="conum" data-value="38"></i><b>(38)</b>
            } else {
                // Doc Id no longer pending
                if(err.code==0) {
                    // No fail so must have already been pushed
                    printf("Document already pushed");
                } else {
                    // Error detected so handle it
                    printf("Error code %d checking for pendingId", err.code);
                    break;
                }
            }
            FLDictIterator_Next(&amp;item);
        }
        FLDictIterator_End(&amp;item);
        FLValue_Release(itemValue);
    } else {
        printf("No Pending Id Docs to process");
    }
    FLDict_Release(thisPendingIdList);

    // end::replication-pendingdocuments[]
}
// END replication.html &gt;&gt; Monitor section

// BEGIN replication.html &gt;&gt; Stop section
// PAGE=Data Sync &gt;&gt; Stop
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#lbl-repl-stop
static void docs_act_replication_Stop(
                                       void* context,
                                       CBLReplicator* argRepl) {
    // tag::p2p-act-rep-stop[]
    // Purpose -- show how to stop a replication
    if(CBLReplicator_Status(argRepl).activity!=kCBLReplicatorStopped) {
        CBLReplicator_Stop(argRepl);
    }

    // end::p2p-act-rep-stop[]
}
// END replication.html &gt;&gt; Stop section

static void replication_error_handling() {
    CBLDatabase* db = kDatabase;
    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);
    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);



    stop_replicator(replicator);
}

static void create_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    // tag::encryptable[]
    // NOTE: No error handling, for brevity (see getting started)

    // Create with premitive type
    CBLEncryptable* encNull = CBLEncryptable_CreateWithNull();
    CBLEncryptable* encBool = CBLEncryptable_CreateWithBool(true);
    CBLEncryptable* encInt = CBLEncryptable_CreateWithInt(256);
    CBLEncryptable* encUInt = CBLEncryptable_CreateWithUInt(1024);
    CBLEncryptable* encFloat = CBLEncryptable_CreateWithFloat(1.2);
    CBLEncryptable* encDouble = CBLEncryptable_CreateWithDouble(100.50);
    CBLEncryptable* encString = CBLEncryptable_CreateWithString(FLSTR("foo"));

    // Create with dictionary
    FLMutableDict dict = FLMutableDict_New();
    FLSlot_SetString(FLMutableDict_Set(dict, FLSTR("greeting")), FLSTR("hello"));
    CBLEncryptable* encDict = CBLEncryptable_CreateWithDict(dict);

    // Create with array
    FLMutableArray array = FLMutableArray_New();
    FLSlot_SetString(FLMutableArray_Append(array), FLSTR("item1"));
    CBLEncryptable* encArray = CBLEncryptable_CreateWithArray(array);

    // Create with FLValue
    FLMutableDict dict2 = FLMutableDict_New();
    FLSlot_SetString(FLMutableDict_Set(dict2, FLSTR("greeting")), FLSTR("hello"));
    CBLEncryptable* encValue = CBLEncryptable_CreateWithValue((FLValue)dict2);
    // end::encryptable[]

    // Release after using it
    CBLEncryptable_Release(encNull);
    CBLEncryptable_Release(encBool);
    CBLEncryptable_Release(encInt);
    CBLEncryptable_Release(encBool);
    CBLEncryptable_Release(encUInt);
    CBLEncryptable_Release(encFloat);
    CBLEncryptable_Release(encDouble);
    CBLEncryptable_Release(encString);
    CBLEncryptable_Release(encDict);
    CBLEncryptable_Release(encArray);
    CBLEncryptable_Release(encValue);

    FLMutableDict_Release(dict);
    FLMutableDict_Release(dict2);
    FLMutableArray_Release(array);

    #endif
}

static void release_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLEncryptable* encValue = CBLEncryptable_CreateWithString(FLSTR("foo"));
    // tag::release_encryptable[]
    // Release the encryptable value after finish using it
    CBLEncryptable_Release(encValue);
    // end::release_encryptable[]

    #endif
}

static void use_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLDatabase* db = kDatabase;

    // tag::use_encryptable[]
    // NOTE: No error handling, for brevity (see getting started)
    CBLDocument* doc = CBLDocument_CreateWithID(FLSTR("doc1"));

    // Set encryptable:
    FLMutableDict props = CBLDocument_MutableProperties(doc);
    CBLEncryptable* encryptable = CBLEncryptable_CreateWithString(FLSTR("My secret"));
    FLSlot_SetEncryptableValue(FLMutableDict_Set(props, FLSTR("secret")), encryptable);

    CBLError error;
    CBLDatabase_SaveDocument(db, doc, &amp;error);

    // Release
    CBLDocument_Release(doc);
    CBLEncryptable_Release(encryptable);
    // end::release_encryptable[]

    #endif
}

static void query_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLDatabase* db = kDatabase;

    // tag::use_encryptable[]
    // NOTE: No error handling, for brevity (see getting started)
    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT secret, secret.value as secretValue FROM _ WHERE type = \"profile\""), NULL, &amp;err);
    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        // Get secret as CBLEncryptable value
        FLValue value = CBLResultSet_ValueForKey(results, FLSTR("secret"));
        const CBLEncryptable* encValue = FLValue_GetEncryptableValue(value);
        FLString secretStr = FLValue_AsString(CBLEncryptable_Value(encValue));
        printf("Secret :: %.*s\n", (int)secretStr.size, (const char *)secretStr.buf);

        // Get secret value directly
        value = CBLResultSet_ValueForKey(results, FLSTR("secretValue"));
        secretStr = FLValue_AsString(value);
        printf("Secret :: %.*s\n", (int)secretStr.size, (const char *)secretStr.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::release_encryptable[]

    #endif
}

#ifdef COUCHBASE_ENTERPRISE

// tag::replicator_property_encryption[]
// tag::replicator_property_encryptor_decryptor_sample[]
// Purpose: Declare property-level encryptor callback functions
static FLSliceResult my_cipher_function(FLSlice input) {
    FLSliceResult result = FLSliceResult_New(input.size);
    for(int i = 0; i &lt; input.size; ++i) {
        ((uint8_t*)(result.buf))[i] = ((uint8_t*)input.buf)[i] ^ 'K';}
    return result;
}


static FLSliceResult property_encryptor(void* context, FLString docID, FLDict props, FLString path,
                                        FLSlice input, FLStringResult* algorithm, FLStringResult* keyID, CBLError* error) {
    *algorithm = FLSlice_Copy(FLSTR("MyEnc"));
    return my_cipher_function(input);
}


static FLSliceResult property_decryptor(void* context, FLString documentID, FLDict properties, FLString keyPath,
                                        FLSlice input, FLString algorithm, FLString keyID, CBLError* error) {
    return my_cipher_function(input);
}

// end::replicator_property_encryptor_decryptor_sample[]
// end::replicator_property_encryption[]

#endif

// PAGE=Field Level Encryption
// URL=https://docs.couchbase.com/couchbase-lite/current/c/field-level-encryption.html
//
static void replicator_property_encryption() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLDatabase* db = kDatabase;

    // tag::replicator_property_encryption[]
    // Purpose: Show how to declare en(de)cryptors in replicator config
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));

    config.database = db;
    config.endpoint = target;
    config.propertyEncryptor = property_encryptor; <i class="conum" data-value="39"></i><b>(39)</b>
    config.propertyDecryptor = property_decryptor; <i class="conum" data-value="40"></i><b>(40)</b>

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);

    CBLReplicator_Start(replicator, false);
    // end::replicator_property_encryption[]

    stop_replicator(replicator);

    #endif
}

int main(int argc, char** argv) {
    create_new_database();
    create_document();
    update_document();
    do_batch_operation();
    // Disable use_blob() as no avatar.jpg to load and crash
    // use_blob();
    doc_json();
    dict_json();
    array_json();
    load_prebuilt();
    create_index();
    select_all();
    select_and_access_all();
    select_props();
    select_meta();
    select_id();
    select_where();
    use_collection_contains();
    select_like();
    select_wildcard_like();
    select_wildcard_character_like();
    select_regex();
    select_join();
    group_by();
    order_by();
    query_result_json();

    create_full_text_index();
    full_text_search();
    start_replication();
    replicator_property_encryption();

    CBLDatabase_Close(kDatabase, NULL);

    return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use keychain identity in config</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c" data-source-url="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/c/examples/code_snippets/main.c">// CBL Version 3.0.0 BETA
#include &lt;cbl/CouchbaseLite.h&gt;
#include &lt;time.h&gt;
#include &lt;inttypes.h&gt;
#ifdef _MSC_VER
#include &lt;direct.h&gt;
#include &lt;Shlwapi.h&gt;

void usleep(unsigned int us) {
    Sleep(us / 1000);
}
#else
#include &lt;unistd.h&gt;
#endif

static CBLDatabase* kDatabase;

// Helper for stop replicator in the code snippet
static void stop_replicator(CBLReplicator* replicator) {
    CBLReplicator_Stop(replicator);
    while(CBLReplicator_Status(replicator).activity != kCBLReplicatorStopped) {
        printf("Waiting for replicator to stop...");
        usleep(200000);
    }
    CBLReplicator_Release(replicator);
}

//  BEGIN lower-level function declarations

//  DOCS NOTE --
//  These functions are referred to in subsequent code samples.
//  Their tags will ensure they are shown alongide the usage examples.
//  Functions used in more than one place may hve multiple tags.

// tag::p2p-act-rep-func[]
// tag::p2p-act-rep-add-change-listener[]
// tag::replication-error-handling[]
// Purpose -- illustrate a simple change listener
static void simpleChangeListener(void* context,
                                 CBLReplicator* repl,
                                 const CBLReplicatorStatus* status)
{
     if(status-&gt;error.code != 0) {
         printf("Error %d / %d\n",
                status-&gt;error.domain,
                status-&gt;error.code);
     }
}
// end::replication-error-handling[]
// end::p2p-act-rep-add-change-listener[]
// end::p2p-act-rep-func[]

static const CBLDocument* simpleConflictResolver_localWins(
                                void* context, FLString documentID,
                                const CBLDocument* localDocument,
                                const CBLDocument* remoteDocument)
{
    return localDocument;
}

// tag::replication-push-filter[]
// tag::replication-pull-filter[]
// Purpose -- illustrate a simple replication filter function
static bool simpleReplicationFilter(void* context,
                                    CBLDocument* argDoc,
                                    CBLDocumentFlags argFlags)
{
    bool result = (argFlags == kCBLDocumentFlagsDeleted);
    return result;
}

// end::replication-push-filter[]
// end::replication-pull-filter[]

// tag::SimpleReplicationDocumentListener[]
// Purpose -- Illustrate a simple replication document listener
static void SimpleReplicationDocumentListener(
                                  void *context,
                                  CBLReplicator *replicator,
                                  bool isPush,
                                  unsigned numDocuments,
                                  const CBLReplicatedDocument *documents)
{
    if(isPush) {
        printf("We pushed %d documents",numDocuments);
    }
}

// END lower-level function declarations


static void getting_started_change_listener(void* context,
                                            CBLReplicator* repl,
                                            const CBLReplicatorStatus* status)
{
    if(status-&gt;error.code != 0) {
        printf("Error %d / %d\n", status-&gt;error.domain, status-&gt;error.code);
    }
}

// Page=build and run
// url=https://docs-staging.couchbase.com/couchbase-lite/current/c/gs-build.html
static void getting_started() {
    // tag::getting-started[]
    //  Purpose-- provide an overview of available crud  and sync functionality
    //
    // Get the database (and create it if it doesn't exist)
    CBLError err;
    CBLDatabase* database = CBLDatabase_Open(FLSTR("mydb"), NULL, &amp;err);
    if(!database) {
        // Error handling.  For brevity, this is truncated in the rest of the snippet
        // and omitted in other doc code snippets
        fprintf(stderr, "Error opening database (%d / %d)\n", err.domain, err.code);
        FLSliceResult msg = CBLError_Message(&amp;err);
        fprintf(stderr, "%.*s\n", (int)msg.size, (const char *)msg.buf);
        FLSliceResult_Release(msg);
        return;
    }

    // The lack of 'const' indicates this document is mutable
    // Create a new document (i.e. a record) in the database
    CBLDocument* mutableDoc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDoc);
    FLMutableDict_SetFloat(properties, FLSTR("version"), 3.0f);

    // Save it to the database
    if(!CBLDatabase_SaveDocument(database, mutableDoc, &amp;err)) {
        // Failed to save, do error handling as above
        return;
    }

    // Since we will release the document, make a copy of the ID since it
    // is an internal pointer.  Whenever we create or get an FLSliceResult
    // or FLStringResult we will need to free it later too!
    FLStringResult id = FLSlice_Copy(CBLDocument_ID(mutableDoc));
    CBLDocument_Release(mutableDoc);

    // Update a document
    mutableDoc = CBLDatabase_GetMutableDocument(database, FLSliceResult_AsSlice(id), &amp;err);
    if(!mutableDoc) {
        // Failed to retrieve, do error handling as above.  NOTE: error code 0 simply means
        // the document does not exist.
        return;
    }

    properties = CBLDocument_MutableProperties(mutableDoc);
    FLMutableDict_SetString(properties, FLSTR("language"), FLSTR("C"));
    if(!CBLDatabase_SaveDocument(database, mutableDoc, &amp;err)) {
        // Failed to save, do error handling as above
        return;
    }

    // Note const here, means readonly
    const CBLDocument* docAgain = CBLDatabase_GetDocument(database, FLSliceResult_AsSlice(id), &amp;err);
    if(!docAgain) {
        // Failed to retrieve, do error handling as above.  NOTE: error code 0 simply means
        // the document does not exist.
        return;
    }

    // No copy this time, so no release later (notice it is not FLStringResult this time)
    FLString retrievedID = CBLDocument_ID(docAgain);
    FLDict retrievedProperties = CBLDocument_Properties(docAgain);
    FLString retrievedLanguage = FLValue_AsString(FLDict_Get(retrievedProperties, FLSTR("language")));
    printf("Document ID :: %.*s\n", (int)retrievedID.size, (const char *)retrievedID.buf);
    printf("Learning %.*s\n", (int)retrievedLanguage.size, (const char *)retrievedLanguage.buf);

    CBLDocument_Release(mutableDoc);
    CBLDocument_Release(docAgain);
    FLSliceResult_Release(id);

    // tag::query-syntax-n1ql[]
    // Create a query to fetch documents of type SDK
    int errorPos;
    CBLQuery* query = CBLDatabase_CreateQuery(database, kCBLN1QLLanguage, FLSTR("SELECT * FROM _ WHERE type = \"SDK\""), &amp;errorPos, &amp;err);
    if(!query) {
        // Failed to create query, do error handling as above
        // Note that errorPos will contain the position in the N1QL string
        // that the parse failed, if applicable
        return;
    }

    CBLResultSet* result = CBLQuery_Execute(query, &amp;err);
    if(!result) {
        // Failed to run query, do error handling as above
        return;
    }
    // end::query-syntax-n1ql[]

    // TODO: Result set count?
    CBLResultSet_Release(result);
    CBLQuery_Release(query);

    // Create replicator to push and pull changes to and from the cloud
    CBLEndpoint* targetEndpoint = CBLEndpoint_CreateWithURL(FLSTR("ws://localhost:4984/getting-started-db"), &amp;err);
    if(!targetEndpoint) {
        // Failed to create endpoint, do error handling as above
        return;
    }

    CBLReplicatorConfiguration replConfig;
    CBLAuthenticator* basicAuth = CBLAuth_CreatePassword(FLSTR("john"), FLSTR("pass"));
    memset(&amp;replConfig, 0, sizeof(replConfig));
    replConfig.database = database;
    replConfig.endpoint = targetEndpoint;
    replConfig.authenticator = basicAuth;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;replConfig, &amp;err);
    CBLAuth_Free(basicAuth);
    CBLEndpoint_Free(targetEndpoint);
    if(!replicator) {
        // Failed to create replicator, do error handling as above
        return;
    }

    // Assume a function like the simple following
    //
    // static void getting_started_change_listener(void* context, CBLReplicator* repl, const CBLReplicatorStatus* status) {
    //     if(status-&gt;error.code != 0) {
    //         printf("Error %d / %d\n", status-&gt;error.domain, status-&gt;error.code);
    //     }
    // }

    CBLListenerToken* token = CBLReplicator_AddChangeListener(replicator, getting_started_change_listener, NULL);

    CBLReplicator_Start(replicator, false);

    // Later, stop and release the replicator
    // end::getting-started[]

    // When finished release resources ... eg
    CBLListener_Remove(token);

    stop_replicator(replicator);
}


// tag::local-win-conflict-resolver[]
static const CBLDocument* local_win_conflict_resolver(void* context,
                                                      FLString documentID,
                                                      const CBLDocument* localDocument,
                                                      const CBLDocument* remoteDocument)
{
    return localDocument;
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
static const CBLDocument* remote_win_conflict_resolver(void* context,
                                                       FLString documentID,
                                                       const CBLDocument* localDocument,
                                                       const CBLDocument* remoteDocument)
{
    return remoteDocument;
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
static const CBLDocument* merge_conflict_resolver(void* context,
                                                  FLString documentID,
                                                  const CBLDocument* localDocument,
                                                  const CBLDocument* remoteDocument)
{
    FLDict localProps = CBLDocument_Properties(localDocument);
    FLDict remoteProps = CBLDocument_Properties(remoteDocument);
    FLMutableDict mergeProps = FLDict_MutableCopy(localProps, kFLDefaultCopy);

    FLDictIterator d;
    FLDictIterator_Begin(localProps, &amp;d);
    FLValue value;
    while((value = FLDictIterator_GetValue(&amp;d))) {
        FLString key = FLDictIterator_GetKeyString(&amp;d);
        if(FLDict_Get(mergeProps, key)) {
            continue;
        }

        FLMutableDict_SetValue(mergeProps, key, value);
        FLDictIterator_Next(&amp;d);
    }

    CBLDocument* mergeDocument = CBLDocument_CreateWithID(documentID);
    CBLDocument_SetProperties(mergeDocument, mergeProps);
    FLMutableDict_Release(mergeProps);

    return mergeDocument;
}
// end::merge-conflict-resolver[]

static void test_replicator_conflict_resolve() {
    CBLDatabase* database = kDatabase;

    // tag::replication-conflict-resolver[]
    // NOTE: No error handling, for brevity (see getting started)
    CBLError err;
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(FLSTR("ws://localhost:4984/mydatabase"), &amp;err);

    CBLReplicatorConfiguration replConfig;
    memset(&amp;replConfig, 0, sizeof(replConfig));
    replConfig.database = database;
    replConfig.endpoint = target;
    replConfig.conflictResolver = local_win_conflict_resolver;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;replConfig, &amp;err);
    CBLEndpoint_Free(target);
    CBLReplicator_Start(replicator, false);

    // end::replication-conflict-resolver[]

    stop_replicator(replicator);
}

static bool custom_conflict_handler(void* context,
                                    CBLDocument* documentBeingSaved,
                                    const CBLDocument* conflictingDocument)
{
    FLDict currentProps = CBLDocument_Properties(conflictingDocument);
    FLDict updatedProps = CBLDocument_Properties(documentBeingSaved);
    FLMutableDict newProps = FLDict_MutableCopy(updatedProps, kFLDefaultCopy);

    FLDictIterator d;
    FLDictIterator_Begin(currentProps, &amp;d);
    FLValue currentValue;
    while((currentValue = FLDictIterator_GetValue(&amp;d))) {
        FLString currentKey = FLDictIterator_GetKeyString(&amp;d);
        if(FLDict_Get(newProps, currentKey)) {
            continue;
        }

        FLMutableDict_SetValue(newProps, currentKey, currentValue);
        FLDictIterator_Next(&amp;d);
    }

    return true;
}

static void test_save_with_conflict_handler() {
    CBLDatabase* database = kDatabase;

    // tag::update-document-with-conflict-handler[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDocument* mutableDocument = CBLDatabase_GetMutableDocument(database, FLSTR("xyz"), &amp;err);
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDocument);
    FLMutableDict_SetString(properties, FLSTR("name"), FLSTR("apples"));

    /*
    static bool custom_conflict_handler(void* context, CBLDocument* documentBeingSaved,
        const CBLDocument* conflictingDocument) {
        FLDict currentProps = CBLDocument_Properties(conflictingDocument);
        FLDict updatedProps = CBLDocument_Properties(documentBeingSaved);
        FLMutableDict newProps = FLDict_MutableCopy(updatedProps, kFLDefaultCopy);

        FLDictIterator d;
        FLDictIterator_Begin(currentProps, &amp;d);
        FLSlice currentKey = FLDictIterator_GetKeyString(&amp;d);
        for(; currentKey.buf; currentKey = FLDictIterator_GetKeyString(&amp;d)) {
            if(FLDict_Get(newProps, currentKey)) {
                continue;
            }

            FLValue currentValue = FLDictIterator_GetValue(&amp;d);
            FLMutableDict_SetValue(newProps, currentKey, currentValue);
        }

        return true;
    }
    */
    CBLDatabase_SaveDocumentWithConflictHandler(database, mutableDocument, custom_conflict_handler, NULL, &amp;err);

    // end::update-document-with-conflict-handler[]
}

static void use_encryption() {
    #ifdef COUCHBASE_ENTERPRISE

    // tag::database-encryption[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLDatabaseConfiguration config = CBLDatabaseConfiguration_Default();

    // This returns a boolean, so check it in production code
    CBLEncryptionKey_FromPassword(&amp;config.encryptionKey, FLSTR("password"));

    CBLError err;
    CBLDatabase* db = CBLDatabase_Open(FLSTR("seekrit"), &amp;config, &amp;err);

    // Change the encryption key (or add encryption if the DB is unencrypted)
    CBLEncryptionKey betterKey;
    CBLEncryptionKey_FromPassword(&amp;betterKey, FLSTR("betterpassw0rd"));
    CBLDatabase_ChangeEncryptionKey(db, &amp;betterKey, &amp;err);

    // Remove encryption
    CBLDatabase_ChangeEncryptionKey(db, NULL, &amp;err);
    // end::database-encryption[]

    #endif
}

static void reset_replicator_checkpoint() {
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(FLSTR("ws://localhost:4984/db"), NULL);
    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = kDatabase;
    config.endpoint = target;
    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, NULL);
    CBLEndpoint_Free(target);

    // tag::replication-reset-checkpoint-full[]
    // replicator is a CBLReplicator* instance
    CBLReplicator_Start(replicator, true); <i class="conum" data-value="1"></i><b>(1)</b>

    // end::replication-reset-checkpoint-full[]

    stop_replicator(replicator);
}

static void read_1x_attachment() {
    CBLDocument* document = CBLDocument_Create();

    // tag::1x-attachment[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    FLDict properties = CBLDocument_Properties(document);
    FLDict attachments = FLValue_AsDict(FLDict_Get(properties, FLSTR("_attachments")));
    const CBLBlob* avatar = FLDict_GetBlob(FLValue_AsDict(FLDict_Get(attachments, FLSTR("avatar"))));
    FLSliceResult content = CBLBlob_Content(avatar, &amp;err);

    FLSliceResult_Release(content);
    // end::1x-attachment[]

    CBLDocument_Release(document);
}

static void create_new_database() {
    // tag::new-database[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDatabase* db = CBLDatabase_Open(FLSTR("my-database"), NULL, &amp;err);
    // end::new-database[]

    kDatabase = db;
}

static void close_database() {
    CBLDatabase* db = kDatabase;
    // tag::close-database[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDatabase_Close(db, &amp;err);
    // end::close-database[]
}

static void change_logging() {
    // tag::logging[]
    // For output to stdout
    CBLLog_SetConsoleLevel(kCBLLogVerbose);

    // For output to custom logging
    CBLLog_SetCallbackLevel(kCBLLogVerbose);
    // end::logging[]
}

static void load_prebuilt() {
    CBL_DeleteDatabase(FLSTR("travel-sample.cblite2"), kFLSliceNull, NULL);

    // tag::prebuilt-database[]
    // Note: Getting the path to a database is platform-specific.  For desktop (including RPi)
    // this can be a simple filesystem path.  For iOS you need to get the path from the
    // main bundle.  For Android you need to extract it from your assets to a temporary directory
    // and then pass that path.

    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    const char* path = "/path/to/travel-sample.cblite2";
    if(!CBL_DatabaseExists(FLSTR("travel-sample.cblite2"), kFLSliceNull)) {
        CBL_CopyDatabase(FLStr(path), FLSTR("travel-sample"), NULL, &amp;err);
    }
    // end::prebuilt-database[]

    CBLDatabase_Close(kDatabase, NULL);
    CBLDatabase_Release(kDatabase);
    kDatabase = CBLDatabase_Open(FLSTR("travel-sample"), NULL, NULL);
}

static void query_deleted_document() {
    CBLDatabase* db = kDatabase;

    // tag::query-deleted-documents[]
    // Query documents that have been deleted
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _ WHERE meta().deleted"), NULL, &amp;err);
    // end::query-deleted-documents[]

    CBLQuery_Release(query);
}

static void create_document() {
    CBLDatabase* db = kDatabase;

    // tag::initializer[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLDocument* newTask = CBLDocument_CreateWithID(FLSTR("xyz"));
    FLMutableDict properties = CBLDocument_MutableProperties(newTask);
    FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("task"));
    FLMutableDict_SetString(properties, FLSTR("owner"), FLSTR("todo"));

    // Storing time in millisecond, bluntly
    FLMutableDict_SetUInt(properties, FLSTR("createdAt"), time(NULL) * 1000);

    CBLError err;
    CBLDatabase_SaveDocument(db, newTask, &amp;err);
    CBLDocument_Release(newTask);
    // end::initializer[]
}

static void update_document() {
    CBLDatabase* db = kDatabase;

    // tag::update-document[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDocument* mutableDocument = CBLDatabase_GetMutableDocument(db, FLSTR("xyz"), &amp;err);
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDocument);
    FLMutableDict_SetString(properties, FLSTR("name"), FLSTR("apples"));
    CBLDatabase_SaveDocument(db, mutableDocument, &amp;err);
    CBLDocument_Release(mutableDocument);
    // end::update-document[]
}

// Note use_typed_accessors not applicable

static void do_batch_operation() {
    CBLDatabase* db = kDatabase;

    // tag::batch[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLDatabase_BeginTransaction(db, &amp;err);
    char buffer[7];
    for(int i = 0; i &lt; 10; i++) {
        CBLDocument* doc = CBLDocument_Create();
        FLMutableDict properties = CBLDocument_MutableProperties(doc);
        FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("user"));
        sprintf(buffer, "user %d", i);
        FLMutableDict_SetString(properties, FLSTR("name"), FLStr(buffer));
        FLMutableDict_SetBool(properties, FLSTR("admin"), false);
        CBLDatabase_SaveDocument(db, doc, &amp;err);
        CBLDocument_Release(doc);
        printf("Saved user document %s\n", buffer);
    }

    CBLDatabase_EndTransaction(db, true, &amp;err);
    // end::batch[]
}

static void document_listener(void* context, const CBLDatabase* db, FLString id) {
    CBLError err;
    const CBLDocument* doc = CBLDatabase_GetDocument(db, id, &amp;err);
    FLDict properties = CBLDocument_Properties(doc);
    FLString verified_account = FLValue_AsString(FLDict_Get(properties, FLSTR("verified_account")));
    printf("Status :: %.*s\n", (int)verified_account.size, (const char *)verified_account.buf);
    CBLDocument_Release(doc);
}

static void database_change_listener() {
    CBLDatabase* db = kDatabase;

    // tag::document-listener[]
    /*
    static void document_listener(void* context, const CBLDatabase* db, FLString id) {
        CBLError err;
        const CBLDocument* doc = CBLDatabase_GetDocument(db, id, &amp;err);
        FLDict properties = CBLDocument_Properties(doc);
        FLString verified_account = FLValue_AsString(FLDict_Get(properties, FLSTR("verified_account")));
        printf("Status :: %.*s\n", (int)verified_account.size, (const char *)verified_account.buf);
        CBLDocument_Release(doc);
    }
    */
    CBLListenerToken* token = CBLDatabase_AddDocumentChangeListener(db, FLSTR("user.john"),
        document_listener, NULL);
    // end::document-listener[]

    CBLListener_Remove(token);
}

static void document_expiration() {
    CBLDatabase* db = kDatabase;

    // tag::document-expiration[]
    // Purge the document one day from now

    // Overly simplistic for example purposes
    // NOTE: API takes milliseconds
    // NOTE: No error handling, for brevity (see getting started)
    time_t ttl = time(NULL) + 24 * 60 * 60;
    ttl *= 1000;

    CBLError err;
    CBLDatabase_SetDocumentExpiration(db, FLSTR("doc123"), ttl, &amp;err);

    // Reset expiration
    CBLDatabase_SetDocumentExpiration(db, FLSTR("doc1"), 0, &amp;err);

    // Query documents that will be expired in less than five minutes
    time_t fiveMinutesFromNow = time(NULL) + 5 * 60;
    fiveMinutesFromNow *= 1000;
    FLMutableDict parameters = FLMutableDict_New();
    FLMutableDict_SetInt(parameters, FLSTR("five_minutes"), fiveMinutesFromNow);

    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _ WHERE meta().expiration &lt; $five_minutes"), NULL, &amp;err);
    CBLQuery_SetParameters(query, parameters);
    FLMutableDict_Release(parameters);
    // end::document-expiration[]
}

static void use_blob() {
    CBLDatabase* db = kDatabase;

    CBLDocument* newTask = CBLDocument_Create();

    // tag::blob[]
    // Note: Reading the data is implementation dependent, as with prebuilt databases
    // NOTE: No error handling, for brevity (see getting started)

    uint8_t buffer[128000];
    FILE* avatar_file = fopen("avatar.jpg", "rb");
    size_t read = fread(buffer, 1, 128000, avatar_file); <i class="conum" data-value="2"></i><b>(2)</b>

    FLSliceResult avatar = FLSliceResult_CreateWith(buffer, read);
    CBLBlob* blob = CBLBlob_CreateWithData(FLSTR("image/jpeg"), FLSliceResult_AsSlice(avatar)); <i class="conum" data-value="3"></i><b>(3)</b>
    FLSliceResult_Release(avatar);

    // TODO: Create shortcut blob method
    CBLError err;
    FLMutableDict properties = CBLDocument_MutableProperties(newTask);
    FLSlot_SetBlob(FLMutableDict_Set(properties, FLSTR("avatar")), blob);
    CBLDatabase_SaveDocument(db, newTask, &amp;err); <i class="conum" data-value="4"></i><b>(4)</b>

    // end::blob[]



    CBLDocument_Release(newTask);
    CBLBlob_Release(blob);
}

static void doc_json() {
    CBLDatabase* db = kDatabase;

    // tag::tojson-document[]
    // NOTE: No error handling, for brevity (see getting started)

    FLString json = FLSTR("{\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",\"country\":\"Australia\"}");

    // Create a document and set the JSON data to the document
    CBLError err;
    CBLDocument* newDoc = CBLDocument_CreateWithID(FLSTR("hotel_1002"));
    CBLDocument_SetJSON(newDoc, json, &amp;err);

    // Save the document to the database
    CBLDatabase_SaveDocument(db, newDoc, &amp;err);

    // Release created doc after using it
    CBLDocument_Release(newDoc);

    // Get the document from the database
    const CBLDocument* doc = CBLDatabase_GetDocument(db, FLSTR("hotel_1002"), &amp;err);

    // Get document body as JSON
    FLSliceResult docJson = CBLDocument_CreateJSON(doc);
    printf("Document in JSON :: %.*s\n", (int)docJson.size, (const char *)docJson.buf);

    // Release JSON data after using it
    FLSliceResult_Release(docJson);

    // Release doc read from the database after using it
    CBLDocument_Release(doc);
    // end::tojson-document[]
}

static void dict_json() {
    // tag::tojson-dictionary[]
    // NOTE: No error handling, for brevity (see getting started)

    FLString json = FLSTR("{\"id\":\"1002\",\"type\":\"hotel\",\"name\":\"Hotel Ned\",\"city\":\"Balmain\",\"country\":\"Australia\"}");

    // Create a dictionary from the JSON string
    FLError err;
    FLSliceResult jsonData1 = FLData_ConvertJSON(json, &amp;err);
    FLDict hotel = FLValue_AsDict(FLValue_FromData(FLSliceResult_AsSlice(jsonData1), kFLTrusted));

    // Iterate through the dictionary
    FLDictIterator iter;
    FLDictIterator_Begin(hotel, &amp;iter);
    FLValue value;
    while (NULL != (value = FLDictIterator_GetValue(&amp;iter))) {
        FLString key = FLDictIterator_GetKeyString(&amp;iter);
        FLString strValue = FLValue_AsString(value);
        printf("%.*s :: %.*s\n", (int)key.size, (const char*)key.buf, (int)strValue.size, (const char*)strValue.buf);
        FLDictIterator_Next(&amp;iter);
    }

    // Convert the dictionary to JSON
    FLSliceResult jsonData2 = FLValue_ToJSON((FLValue)hotel);
    printf("Hotel in JSON :: %.*s\n", (int)jsonData2.size, (const char *)jsonData2.buf);

    // Release JSON data after finish using it
    FLSliceResult_Release(jsonData1);
    FLSliceResult_Release(jsonData2);
    // end::tojson-dictionary[]
}

static void array_json() {
    // tag::tojson-array[]
    // NOTE: No error handling, for brevity (see getting started)

    FLString json = FLSTR("[\"Hotel Ned\", \"Hotel Ted\"]");

    // Create an array from the JSON string
    FLError err;
    FLSliceResult jsonData1 = FLData_ConvertJSON(json, &amp;err);
    FLArray hotels = FLValue_AsArray(FLValue_FromData(FLSliceResult_AsSlice(jsonData1), kFLTrusted));

    // Iterate through the array
    FLArrayIterator iter;
    FLArrayIterator_Begin(hotels, &amp;iter);
    FLValue value;
    while (NULL != (value = FLArrayIterator_GetValue(&amp;iter))) {
        FLString hotel = FLValue_AsString(value);
        printf("Hotel :: %.*s\n", (int)hotel.size, (const char *)hotel.buf);
        FLArrayIterator_Next(&amp;iter);
    }

    // Convert the array to JSON
    FLSliceResult jsonData2 = FLValue_ToJSON((FLValue)hotels);
    printf("Hotels in JSON :: %.*s\n", (int)jsonData2.size, (const char *)jsonData2.buf);

    // Release JSON data after finish using it
    FLSliceResult_Release(jsonData1);
    FLSliceResult_Release(jsonData2);
    // end::tojson-array[]
}

static void datatype_dictionary()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_dictionary[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    const CBLDocument *doc = CBLDatabase_GetDocument(db, FLSTR("doc1"), &amp;err);
    FLDict properties = CBLDocument_Properties(doc);

    // Getting a dictionary from the document's properties
    FLValue dictValue = FLDict_Get(properties, FLSTR("address"));
    FLDict dict = FLValue_AsDict(dictValue);

    // Access a value with a key from the dictionary
    FLValue streetVal = FLDict_Get(dict, FLSTR("street"));
    FLString street = FLValue_AsString(streetVal);

    // Iterate dictionary
    FLDictIterator iter;
    FLDictIterator_Begin(dict, &amp;iter);
    FLValue value;
    while (NULL != (value = FLDictIterator_GetValue(&amp;iter))) {
        FLString key = FLDictIterator_GetKeyString(&amp;iter);
        FLString strValue = FLValue_AsString(value);
        printf("Key :: %.*s\n", (int)key.size, (const char *)key.buf);
        printf("Value :: %.*s\n", (int)strValue.size, (const char *)strValue.buf);
        // ...
        FLDictIterator_Next(&amp;iter);
    }

    // Create a mutable copy.
    // kFLDefaultCopy is shallow which means the nested dictionaries and arrays will be
    // referenced but not copied. Use kFLDeepCopyImmutables for the deep copy.
    FLMutableDict mutableDict = FLDict_MutableCopy(dict, kFLDefaultCopy);

    // Release when finish using it
    FLMutableDict_Release(mutableDict);
    // end::datatype_dictionary[]
}

static void datatype_mutable_dictionary()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_mutable_dictionary[]
    // NOTE: No error handling, for brevity (see getting started)

    // tag::datatype_mutable_dictionary-create[]
    // Create a new mutable dictionary and populate some keys/values
    FLMutableDict dict = FLMutableDict_New();
    FLMutableDict_SetString(dict, FLSTR("street"), FLSTR("1 Main st."));
    FLMutableDict_SetString(dict, FLSTR("city"), FLSTR("San Francisco"));
    // end::datatype_mutable_dictionary-create[]

    // tag::datatype_mutable_dictionary-add-to-doc[]
    // Set the dictionary to document's properties and save the document
    CBLDocument *doc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(doc);
    FLMutableDict_SetDict(properties, FLSTR("address"), dict);
    // end::datatype_mutable_dictionary-add-to-doc[]
    CBLError err;
    CBLDatabase_SaveDocument(db, doc, &amp;err);
    CBLDocument_Release(doc);

    // Release when finish using it
    FLMutableDict_Release(dict);
    // end::datatype_mutable_dictionary[]
}

static void datatype_array()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_array[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    const CBLDocument *doc = CBLDatabase_GetDocument(db, FLSTR("doc1"), &amp;err);
    FLDict properties = CBLDocument_Properties(doc);

    // Getting a phones array from the document's properties
    FLValue arrayValue = FLDict_Get(properties, FLSTR("phones"));
    FLArray array = FLValue_AsArray(arrayValue);

    // Get element count
    int count = FLArray_Count(array);
    printf("Count :: %d\n", count);

    // Access an array element by index
    if (!FLArray_IsEmpty(array)) {
        FLValue phoneVal = FLArray_Get(array, 0);
        FLString phone = FLValue_AsString(phoneVal);
        printf("Value :: %.*s\n", (int)phone.size, (const char *)phone.buf);
    }

    // Iterate array
    FLArrayIterator iter;
    FLArrayIterator_Begin(array, &amp;iter);
    FLValue val;
    while (NULL != (val = FLArrayIterator_GetValue(&amp;iter)))
    {
        FLString str = FLValue_AsString(val);
        printf("Value :: %.*s\n", (int)str.size, (const char *)str.buf);
        FLArrayIterator_Next(&amp;iter);
    }
    // end::datatype_array[]

    // Create a mutable copy.
    // kFLDefaultCopy is shallow which means the nested dictionaries and arrays will be
    // referenced but not copied. Use kFLDeepCopyImmutables for the deep copy.
    FLMutableArray mutableArray = FLArray_MutableCopy(array, kFLDefaultCopy);

    // Release when finish using it
    FLMutableArray_Release(mutableArray);
}

static void datatype_mutable_array()
{
    CBLDatabase *db = kDatabase;

    // tag::datatype_mutable_array[]
    // NOTE: No error handling, for brevity (see getting started)

    // tag::datatype_mutable_array-create[]
    // Create a new mutable array and populate data into the array
    FLMutableArray phones = FLMutableArray_New();
    FLMutableArray_AppendString(phones, FLSTR("650-000-0000"));
    FLMutableArray_AppendString(phones, FLSTR("650-000-0001"));
    // end::datatype_mutable_array-create[]

    // tag::datatype_mutable_array-add-to-doc[]
    // Set the array to document's properties and save the document
    CBLDocument *doc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(doc);
    FLMutableDict_SetArray(properties, FLSTR("phones"), phones);
    // end::datatype_mutable_array-add-to-doc[]
    CBLError err;
    CBLDatabase_SaveDocument(db, doc, &amp;err);
    CBLDocument_Release(doc);

    // Release the created dictionary
    FLMutableArray_Release(phones);
    // end::datatype_mutable_array[]
}


static void datatype_usage() {

    // tag::datatype_usage[]
    // tag::datatype_usage_createdb[]
    // Open or create DB if it doesn't exist
    CBLError err;
    CBLDatabase* database = CBLDatabase_Open(FLSTR("mydb"), NULL, &amp;err);
    if(!database) {
        // Error handling.  For brevity, this is truncated in the rest of the snippet
        // and omitted in other doc code snippets
        fprintf(stderr, "Error opening database (%d / %d)\n", err.domain, err.code);
        FLSliceResult msg = CBLError_Message(&amp;err);
        fprintf(stderr, "%.*s\n", (int)msg.size, (const char *)msg.buf);
        FLSliceResult_Release(msg);
        return;
    }

    // end::datatype_usage_createdb[]
    // tag::datatype_usage_createdoc[]
    // Create your new document
    // The lack of 'const' indicates this document is mutable
    CBLDocument* mutableDoc = CBLDocument_Create();
    FLMutableDict properties = CBLDocument_MutableProperties(mutableDoc);

    // end::datatype_usage_createdoc[]
    // tag::datatype_usage_mutdict[]
    // Create and populate mutable dictionary
    FLMutableDict address = FLMutableDict_New();
    FLMutableDict_SetString(address, FLSTR("street"), FLSTR("1 Main st."));
    FLMutableDict_SetString(address, FLSTR("city"), FLSTR("San Francisco"));
    FLMutableDict_SetString(address, FLSTR("state"), FLSTR("CA"));
    FLMutableDict_SetString(address, FLSTR("country"), FLSTR("USA"));
    FLMutableDict_SetString(address, FLSTR("code"), FLSTR("90210"));

    // end::datatype_usage_mutdict[]
    // tag::datatype_usage_mutarray[]
    // Create and populate mutable array
    FLMutableArray phones = FLMutableArray_New();
    FLMutableArray_AppendString(phones, FLSTR("650-000-0000"));
    FLMutableArray_AppendString(phones, FLSTR("650-000-0001"));

    // end::datatype_usage_mutarray[]
    // tag::datatype_usage_populate[]
    // Initialize and populate the document

    // Add document type to document properties <i class="conum" data-value="5"></i><b>(5)</b>
    FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("hotel"));

    // Add hotel name string to document properties <i class="conum" data-value="6"></i><b>(6)</b>
    FLMutableDict_SetString(properties, FLSTR("hotel"), FLSTR(""));

    // Add float to document properties <i class="conum" data-value="7"></i><b>(7)</b>
    FLMutableDict_SetFloat(properties, FLSTR("room_rate"), 121.75f);

    // Add dictionary to document's properties <i class="conum" data-value="8"></i><b>(8)</b>
    FLMutableDict_SetDict(properties, FLSTR("address"), dict);

    // Add array to document's properties <i class="conum" data-value="9"></i><b>(9)</b>
    FLMutableDict_SetArray(properties, FLSTR("phones"), phones);

    // end::datatype_usage_populate[]
    // tag::datatype_usage_persist[]
    // Save the document changes <i class="conum" data-value="10"></i><b>(10)</b>
    CBLError err;
    CBLDatabase_SaveDocument(database, doc, &amp;err);

    // end::datatype_usage_persist[]
    // tag::datatype_usage_closedb[]
    // Close the database <i class="conum" data-value="11"></i><b>(11)</b>
    CBLError err;
    CBLDatabase_Close(database, &amp;err);

    // end::datatype_usage_closedb[]
    // tag::datatype_usage_release[]
    // Release the created items <i class="conum" data-value="12"></i><b>(12)</b>
    CBLDatabase_Release(database);
    CBLDocument_Release(doc);
    FLMutableDict_Release(dict);
    FLMutableArray_Release(phones);
    // end::datatype_usage_release[]

    // end::datatype_usage[]

} // end datatype_usage()


static void create_index() {
    CBLDatabase* db = kDatabase;

    // tag::query-index[]
    // For value types, this is optional but provides performance enhancements
    // NOTE: No error handling, for brevity (see getting started)

    // Syntax for second argument is the same as taking from a N1QL SELECT
    // i.e. SELECT (type, name) FROM _;
    CBLValueIndexConfiguration config = {
        kCBLN1QLLanguage,
        FLSTR("type, name")
    };

    CBLError err;
    CBLDatabase_CreateValueIndex(db, FLSTR("TypeNameIndex"), config, &amp;err);
    // end::query-index[]
}

static void select_meta() {
    CBLDatabase* db = kDatabase;

    // tag::query-select-meta[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, type, name FROM _"), NULL, &amp;err);
    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString id = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("id")));
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Document ID :: %.*s\n", (int)id.size, (const char *)id.buf);
        printf("Document Name :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-select-meta[]
}

static void select_id() {
    CBLDatabase* db = kDatabase;

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _"), NULL, &amp;err);

    // tag::query-access-id[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString id = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("id")));
        printf("Document ID :: %.*s\n", (int)id.size, (const char *)id.buf);
    }
    // end::query-access-id[]

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
}

static void query_change_listener(void* context, CBLQuery* query, CBLListenerToken* token) {
    CBLError err;
    CBLResultSet* results = CBLQuery_CopyCurrentResults(query, token, &amp;err);
    while(CBLResultSet_Next(results)) {
        // Update UI
    }
}

static void select_all() {
    CBLDatabase* db = kDatabase;

    // tag::query-select-all[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _"), NULL, &amp;err);

    // All results will be available from the above query
    CBLQuery_Release(query);
    // end::query-select-all[]

    // tag::live-query[]
    /*
    static void query_change_listener(void* context, CBLQuery* query, CBLListenerToken* token) {
        CBLError err;
        CBLResultSet* results = CBLQuery_CopyCurrentResults(query, token, &amp;err);
        while(CBLResultSet_Next(results)) {
            // Update UI
        }
    }
    */

    query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _"), NULL, &amp;err); <i class="conum" data-value="13"></i><b>(13)</b>

    CBLListenerToken* token = CBLQuery_AddChangeListener(query, query_change_listener, NULL); <i class="conum" data-value="14"></i><b>(14)</b>
    // end::live-query[]

    // tag::stop-live-query[]
    CBLListener_Remove(token); // The token received from AddChangeListener
    CBLQuery_Release(query);
    // end::stop-live-query[]
}

static void select_and_access_all() {
    CBLDatabase* db = kDatabase;

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _"), NULL, &amp;err);

    // tag::query-access-all[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict dict = FLValue_AsDict(CBLResultSet_ValueForKey(results, FLSTR("_")));

        FLString id = FLValue_AsString(FLDict_Get(dict, FLSTR("id")));
        FLString type = FLValue_AsString(FLDict_Get(dict, FLSTR("type")));
        FLString name = FLValue_AsString(FLDict_Get(dict, FLSTR("name")));
        FLString city = FLValue_AsString(FLDict_Get(dict, FLSTR("city")));

        printf("ID :: %.*s\n", (int)id.size, (const char *)id.buf);
        printf("Type :: %.*s\n", (int)type.size, (const char *)type.buf);
        printf("Name :: %.*s\n", (int)name.size, (const char *)name.buf);
        printf("City :: %.*s\n", (int)city.size, (const char *)city.buf);
    }

    // All results will be available from the above query
    CBLResultSet_Release(results);
    // end::query-access-all[]

    CBLQuery_Release(query);
}

static void select_props() {
    CBLDatabase* db = kDatabase;

    // tag::query-access-props[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT type, name, city FROM _"), NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString type = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("type")));
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        FLString city = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("city")));

        printf("Type :: %.*s\n", (int)type.size, (const char *)type.buf);
        printf("Name :: %.*s\n", (int)name.size, (const char *)name.buf);
        printf("City :: %.*s\n", (int)city.size, (const char *)city.buf);
    }
    // end::query-access-props[]

    // All results will be available from the above query
    CBLResultSet_Release(results);
    CBLQuery_Release(query);
}

static void select_where() {
    CBLDatabase* db = kDatabase;

    // tag::query-where[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _ WHERE type = \"hotel\" LIMIT 10"), NULL, &amp;err);
    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict dict = FLValue_AsDict(CBLResultSet_ValueForKey(results, FLSTR("_")));
        FLString name = FLValue_AsString(FLDict_Get(dict, FLSTR("name")));
        printf("Document Name :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-where[]
}

static void use_collection_contains() {
    CBLDatabase* db = kDatabase;

    // tag::query-collection-operator-contains[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name, public_likes FROM _ WHERE type = \"hotel\" "
              "AND ARRAY_CONTAINS(public_likes, \"Armani Langworth\")"), NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLArray publicLikes = FLValue_AsArray(CBLResultSet_ValueForKey(results, FLSTR("public_likes")));
        FLStringResult json = FLValue_ToJSON((FLValue)publicLikes);
        printf("Public Likes :: %.*s\n", (int)json.size, (const char *)json.buf);
        FLSliceResult_Release(json);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-collection-operator-contains[]
}

static void use_collection_in() {
    CBLDatabase* db = kDatabase;

    // tag::query-collection-operator-in[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _ WHERE \"Armani\" IN (first, last, username)"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict body = FLValue_AsDict(CBLResultSet_ValueAtIndex(results, 0));
        FLStringResult json = FLValue_ToJSON((FLValue)body);
        printf("In results :: %.*s\n", (int)json.size, (const char *)json.buf);
        FLSliceResult_Release(json);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-collection-operator-in[]
}

static void select_like() {
    CBLDatabase* db = kDatabase;

    // tag::query-like-operator[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND lower(name) LIKE \"Royal Engineers Museum\" LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-like-operator[]
}

static void select_wildcard_like() {
    CBLDatabase* db = kDatabase;

    // tag::query-like-operator-wildcard-match[]
    // NOTE: No error handling, for brevity (see getting started)

     CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND lower(name) LIKE \"Eng%e%\" LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-like-operator-wildcard-match[]
}

static void select_wildcard_character_like() {
    CBLDatabase* db = kDatabase;

    // tag::query-like-operator-wildcard-character-match[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND lower(name) LIKE \"Royal Eng____rs Museum\" LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-like-operator-wildcard-character-match[]
}

static void select_regex() {
    CBLDatabase* db = kDatabase;

    // tag::query-regex-operator[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, name FROM _ WHERE type = \"landmark\" "
              "AND regexp_like(name, \"\\bEng.*e\\b\") LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-regex-operator[]
}

static void select_join() {
    CBLDatabase* db = kDatabase;

    // tag::query-join[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT airline.name, airline.callsign, route.destinationairport, route.stops, route.airline "
              "FROM _ AS airline INNER JOIN _ AS route ON meta(airline).id = route.airlineid "
              "WHERE route.type = \"route\" AND airline.type = \"airline\" AND route.sourceairport = \"RIX\""),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString name = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("name")));
        printf("Name Property :: %.*s\n", (int)name.size, (const char *)name.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-join[]
}

static void group_by() {
    CBLDatabase* db = kDatabase;

    // tag::query-groupby[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT count(*), country, tz FROM _ WHERE type = \"airport\" AND geo.alt &gt;= 300 "
              "GROUP BY country, tz"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        int64_t count = FLValue_AsInt(CBLResultSet_ValueForKey(results, FLSTR("$1")));
        FLString tz = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("tz")));
        FLString country = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("country")));
        printf("There are %" PRIi64 " airports in the %.*s timezone located in %.*s and above 300 ft\n",
            count, (int)tz.size, (const char *)tz.buf, (int)country.size, (const char *)country.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-groupby[]
}

static void order_by() {
    CBLDatabase* db = kDatabase;

    // tag::query-orderby[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id, title FROM _ WHERE type = \"hotel\" ORDER BY title ASC LIMIT 10"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString title = FLValue_AsString(CBLResultSet_ValueForKey(results, FLSTR("title")));
        printf("Title :: %.*s\n", (int)title.size, (const char *)title.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::query-orderby[]
}

static void test_explain_statement() {
    CBLDatabase* db = kDatabase;

    {
    // tag::query-explain-all[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT * FROM _ WHERE type = \"hotel\" GROUP BY country ORDER BY title ASC LIMIT 10"),
        NULL, &amp;err);

    FLSliceResult explanation = CBLQuery_Explain(query);
    printf("%.*s", (int)explanation.size, (const char *)explanation.buf);
    FLSliceResult_Release(explanation);
    // end::query-explain-all[]
    }

    // DOCS NOTE: Others omitted for now
}

static void query_result_json() {
    CBLDatabase* db = kDatabase;

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id as id, name, city, type FROM _ LIMIT 10"),
        NULL, &amp;err);

    // tag::query-access-json[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLDict result = CBLResultSet_ResultDict(results);
        FLStringResult json = FLValue_ToJSON((FLValue)result);
        printf("JSON Result :: %.*s\n", (int)json.size, (const char *)json.buf);
        FLSliceResult_Release(json);
    }
    CBLResultSet_Release(results);

    // end::query-access-json[]

    CBLQuery_Release(query);
}

static void create_full_text_index() {
    CBLDatabase* db = kDatabase;

    const char* tasks[] = { "buy groceries", "play chess", "book travels", "buy museum tickets" };
    char idBuffer[7];
    for(int i = 0; i &lt; 4; i++) {
        const char* task = tasks[i];
        sprintf(idBuffer, "extra%d", i);
        const CBLDocument* doc = CBLDatabase_GetDocument(db, FLStr(idBuffer), NULL);
        if(doc) {
            CBLDocument_Release(doc);
            continue;
        }

        CBLDocument* mutableDoc = CBLDocument_CreateWithID(FLStr(idBuffer));
        FLMutableDict properties = CBLDocument_MutableProperties(mutableDoc);
        FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("task"));
        FLMutableDict_SetString(properties, FLSTR("task"), FLStr(task));
        CBLDatabase_SaveDocument(db, mutableDoc, NULL);
        CBLDocument_Release(mutableDoc);
    }

    // tag::fts-index[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLFullTextIndexConfiguration config = {
        kCBLN1QLLanguage,
        FLSTR("name"),
        false
    };

    CBLDatabase_CreateFullTextIndex(db, FLSTR("nameFTSIndex"), config, &amp;err);
    // end::fts-index[]
}

static void full_text_search() {
    CBLDatabase* db = kDatabase;

    // tag::fts-query[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT meta().id FROM _ WHERE MATCH(nameFTSIndex, \"'buy'\")"),
        NULL, &amp;err);

    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        FLString id = FLValue_AsString(CBLResultSet_ValueAtIndex(results, 0));
        printf("Document id :: %.*s\n", (int)id.size, (const char *)id.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::fts-query[]
}

static void start_replication() {
    CBLDatabase* db = kDatabase;

    /*
    * This requires Sync Gateway running with the following config, or equivalent:
    *
    * {
    *     "log":["*"],
    *     "databases": {
    *         "db": {
    *             "server":"walrus:",
    *             "users": {
    *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
    *             }
    *         }
    *     }
    * }
    */

    // tag::replication[]
    // NOTE: No error handling, for brevity (see getting started)
    // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);
    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target;
    config.replicatorType = kCBLReplicatorTypePull;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);
    CBLReplicator_Start(replicator, false);
    // end::replication[]

    stop_replicator(replicator);
}

// Console logging domain methods are not applicable to C

static void file_logging() {
    // tag::file-logging[]
    // NOTE: No error handling, for brevity (see getting started)
    // NOTE: You will need to use a platform appropriate method for finding
    // a temporary directory

    FLString tempFolder = FLSTR("/tmp/cbllog");

    CBLLogFileConfiguration config; // Don't bother zeroing, since we set all properties
    config.level = kCBLLogInfo;
    config.directory = tempFolder;
    config.maxRotateCount = 5;
    config.maxSize = 10240;
    config.usePlaintext = false;

    CBLError err;
    CBLLog_SetFileConfig(config, &amp;err);
    // end::file-logging[]
}

// tag::custom-logging[]
static void custom_log_callback(CBLLogDomain domain, CBLLogLevel level, FLString message) {
    // handle the message, for example piping it to
    // a third party framework
}
// end::custom-logging[]

static void enable_custom_logging() {
    // tag::set-custom-logging[]
    CBLLog_SetCallback(custom_log_callback);
    // end::set-custom-logging[]
}

static void enable_basic_auth() {
    CBLDatabase* db = kDatabase;

    // tag::basic-authentication-full[]
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/mydatabase");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);
    CBLAuthenticator* basicAuth = CBLAuth_CreatePassword(FLSTR("john"), FLSTR("pass"));

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target;
    config.authenticator = basicAuth;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);
    CBLAuth_Free(basicAuth);

    CBLReplicator_Start(replicator, false);
    // end::basic-authentication-full[]

    stop_replicator(replicator);
}

static void docsonly_N1QL_Params(CBLDatabase* argDb)
{
    CBLDatabase* database = argDb;

    // tag::query-syntax-n1ql-params[]
    int errorPos;

    CBLError err;

    FLString n1qlstr = FLSTR("SELECT * FROM _ WHERE type = $type");

    FLMutableDict n1qlparams = FLMutableDict_New();
    FLMutableDict_SetString(n1qlparams, FLSTR("type"), FLSTR("hotel"));

    CBLQuery* query = CBLDatabase_CreateQuery(database,
                          kCBLN1QLLanguage,
                          n1qlstr,
                          &amp;errorPos,
                          &amp;err);

    CBLQuery_SetParameters(query, n1qlparams);

    if(!query) {
        /* Do appropriate error handling ...
            Note that (where applicable) errorPos contains the position
            in the N1QL string that the parse failed
        */
        FLMutableDict_Release(n1qlparams);
        CBLQuery_Release(query);
        return;
    }

    CBLResultSet* result = CBLQuery_Execute(query, &amp;err);
    if(!result) {
        // Failed to run query, do error handling ...
        return;
    }

    // Release query when finished with
    FLMutableDict_Release(n1qlparams);
    CBLQuery_Release(query);

    // ... process results as required

    // Release result set then finished with
    CBLResultSet_Release(result);

    // end::query-syntax-n1ql-params[]
}



// tag::console-logging-db[]
//Placeholder for code to increase level of console logging for kCBLLogDomainDatabase domain
// end::console-logging-db[]

// tag::console-logging[]
//Placeholder for code to increase level of console logging for all domains
// end::console-logging[]

// tag::date-getter[]
//Placeholder for Date accessors.

// end::date-getter[]


// tag::query-index[]
// placeholder
// end::query-index[]


// DOCS NOTE
// Page=Data Sync &gt;&gt; Configuration Summary
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#configuration-summary
static void docs_act_replication(CBLDatabase* argDb)
{
    CBLDatabase* database = argDb;

    /*
    * This requires Sync Gateway running with the following config, or equivalent:
    *
    * {
    *     "log":["*"],
    *     "databases": {
    *         "db": {
    *             "server":"walrus:",
    *             "users": {
    *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
    *             }
    *         }
    *     }
    * }
    */

    // tag::p2p-act-rep-func[]
    // Purpose -- Show configuration , initialization and running of a replicator

    // NOTE: No error handling, for brevity (see getting started)
    // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err); <i class="conum" data-value="15"></i><b>(15)</b>

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = database;
    config.endpoint = target; <i class="conum" data-value="16"></i><b>(16)</b>

    // tag::p2p-act-rep-config-cont[]
    // Set replication direction and mode
    config.replicatorType = kCBLReplicatorTypePull; <i class="conum" data-value="17"></i><b>(17)</b>
    config.continuous = true;

    // end::p2p-act-rep-config-cont[]

    // Optionally, set auto-purge behavior (here we override default)
    config.disableAutoPurge = true; <i class="conum" data-value="18"></i><b>(18)</b>

    // Optionally, configure Client Authentication
    // Here we are using to Basic Authentication,
    // Providing username and password credentials
    CBLAuthenticator* basicAuth =
        CBLAuth_CreatePassword(FLSTR("username"),
                               FLSTR("passwd")); <i class="conum" data-value="19"></i><b>(19)</b>
    config.authenticator = basicAuth;

    // Optionally, configure how we handle conflicts
    config.conflictResolver = simpleConflictResolver_localWins; <i class="conum" data-value="20"></i><b>(20)</b>

    // Initialize replicator with created config
    CBLReplicator* replicator =
        CBLReplicator_Create(&amp;config, &amp;err); <i class="conum" data-value="21"></i><b>(21)</b>

    CBLEndpoint_Free(target);

    // Optionally, add change listener
    CBLListenerToken* token =
            CBLReplicator_AddChangeListener(replicator,
                                            simpleChangeListener,
                                            NULL); <i class="conum" data-value="22"></i><b>(22)</b>

    // Start replication
    CBLReplicator_Start(replicator, false); <i class="conum" data-value="23"></i><b>(23)</b>

    // end::p2p-act-rep-func[]

    //    ... other processing as required

    // When finished release resources e.g.
    CBLAuth_Free(basicAuth);
    stop_replicator(replicator);
}
// END configuration summary snippets


// DOCS NOTE:
// Page=Data Sync &gt;&gt; Configuration
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#configuration-summary
// This function is not pulled into docs en-bloc
// it is a slightly more in-depth than the configurationsummary above
// and the snippets within it are used individually or in sets
// to illustrate specific points as required
//
static void docs_act_replication_config_section_snippets()
{
    CBLDatabase* db = kDatabase;
    bool docs_example_ShowBasicAuth = false;
    bool docs_example_ShowSessionAuth = false;

    /*
    * This requires Sync Gateway running with the following config, or equivalent:
    *
    * {
    *     "log":["*"],
    *     "databases": {
    *         "db": {
    *             "server":"walrus:",
    *             "users": {
    *                 "GUEST": {"disabled": false, "admin_channels": ["*"] }
    *             }
    *         }
    *     }
    * }
    */
    // tag::p2p-act-rep-func-full[]
    // NOTE: No error handling, for brevity (see getting started)
    // Note: Android emulator needs to use 10.0.2.2 for localhost (10.0.3.2 for GenyMotion)

    // tag::sgw-act-rep-initialize[]
    // Initialize the configuration object and set db target
    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target =
        CBLEndpoint_CreateWithURL(url, &amp;err); <i class="conum" data-value="24"></i><b>(24)</b>

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target; <i class="conum" data-value="25"></i><b>(25)</b>

    // end::sgw-act-rep-initialize[]

    //    tag::p2p-act-rep-config-type[]
    config.replicatorType = kCBLReplicatorTypePull;

    //    end::p2p-act-rep-config-type[]
    //    tag::p2p-act-rep-config-cont[]
    config.continuous = true;

    //    end::p2p-act-rep-config-cont[]
    // tag::replication-retry-config[]
    // Configure replication retries
    // tag::replication-set-heartbeat[]
    config.heartbeat = 120; //  <i class="conum" data-value="26"></i><b>(26)</b>

    // end::replication-set-heartbeat[]
    // tag::replication-set-maxattempts[]
    config.maxAttempts = 20; //  <i class="conum" data-value="27"></i><b>(27)</b>

    // end::replication-set-maxattempts[]
    // tag::replication-set-maxattemptwaittime[]
    config.maxAttemptWaitTime = 600; //  <i class="conum" data-value="28"></i><b>(28)</b>

    // end::replication-set-maxattemptwaittime[]
    // end::replication-retry-config[]
    // tag::basic-authentication[]
    // Configure Client Authentication to Basic Authentication
    // Providing username and password credentials
    if(docs_example_ShowBasicAuth) {
        CBLAuthenticator* basicAuth =
            CBLAuth_CreatePassword(FLSTR("username"),
                                   FLSTR("passwd"));
        config.authenticator = basicAuth; <i class="conum" data-value="29"></i><b>(29)</b>
    }
    // end::basic-authentication[]

    // tag::session-authentication[]
    if(docs_example_ShowSessionAuth) {
        CBLAuthenticator* sessionAuth =
            CBLAuth_CreateSession(FLSTR("904ac010862f37c8dd99015a33ab5a3565fd8447"),
                                  FLSTR("optionalCookieName"));
        config.authenticator = sessionAuth; <i class="conum" data-value="30"></i><b>(30)</b>
    }

    // end::session-authentication[]

    // tag::replication-custom-header[]
    // Optionally, add custom headers
    FLMutableDict customHdrs = FLMutableDict_New();
    FLMutableDict_SetString(customHdrs,
                            FLSTR("customHeaderName"),
                            FLSTR("customHeaderValue"));

    config.headers = customHdrs;

    // tag::certificate-pinning[]
    char cert_buf[10000];
    FILE* cert_file = fopen("cert.pem", "r");
    size_t read = fread(cert_buf, 1, sizeof(cert_buf), cert_file);
    config.pinnedServerCertificate = (FLSlice){cert_buf, read};
    // end::certificate-pinning[]

    // end::replication-custom-header[]
    // FILTERS
    // tag::replication-push-filter[]
    // tag::replication-pull-filter[]
    // Purpose - Illustrate use of push and-or pull filter functions
    config.pushFilter = simpleReplicationFilter;

    config.pullFilter = simpleReplicationFilter;

    // end::replication-pull-filter[]
    // end::replication-push-filter[]

    //  Auto-purge over-ride
    // tag::autopurge-override[]
    config.disableAutoPurge = true; <i class="conum" data-value="31"></i><b>(31)</b>

    // end::autopurge-override[]
    // Initialize replicator with created config
    CBLReplicator* replicator =
        CBLReplicator_Create(&amp;config, &amp;err); <i class="conum" data-value="32"></i><b>(32)</b>

    CBLEndpoint_Free(target);

    // Add optional change listener
    CBLListenerToken* token_ReplChangeListener =
        CBLReplicator_AddChangeListener(replicator,
                                        simpleChangeListener,
                                        NULL); <i class="conum" data-value="33"></i><b>(33)</b>
}
// END replication.html &gt;&gt; configure section


// PAGE=Data Sync &gt;&gt; Initialize section
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#lbl-init-repl
static CBLReplicator* docs_act_replication_Intialize(
                        void* context,
                        CBLReplicatorConfiguration argConfig,
                        bool argResetRequired)
{
    CBLError err;
    bool docs_example_resetRequired = argResetRequired;
    // tag::p2p-act-rep-start-full[]
    CBLReplicator* thisRepl =
    CBLReplicator_Create(&amp;argConfig, &amp;err); <i class="conum" data-value="34"></i><b>(34)</b>

    // end::p2p-act-rep-start-full[]
    if(!docs_example_resetRequired) {
    // tag::p2p-act-rep-start-full[]
      CBLReplicator_Start(thisRepl, false); <i class="conum" data-value="35"></i><b>(35)</b>

    // end::p2p-act-rep-start-full[]
    } else {
    // tag::replication-reset-checkpoint[]
      CBLReplicator_Start(thisRepl, true); <i class="conum" data-value="36"></i><b>(36)</b>

    // end::replication-reset-checkpoint[]
    }
    return thisRepl;
}
// END replication.html &gt;&gt; initialize section

// PAGE=Data Sync &gt;&gt; Monitor section
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#lbl-repl-mon
static void docs_act_replication_Monitor(
                                       void* context,
                                       CBLReplicator* argRepl) {
    CBLError err;
    CBLReplicator* thisRepl = argRepl;
    // tag::p2p-act-rep-add-change-listener[]
    // Purpose -- illustrate addition of a Replicator change listener
    CBLListenerToken* token_ReplChangeListener =
            CBLReplicator_AddChangeListener(thisRepl,
                                            simpleChangeListener,
                                            NULL);

    // end::p2p-act-rep-add-change-listener[]
    // tag::add-document-replication-listener[]
    // Purpose -- illustrate addition of a Document Replicator  listener
    CBLListenerToken* token_ReplDocListener =
            CBLReplicator_AddDocumentReplicationListener(
                                                        thisRepl,
                                                        SimpleReplicationDocumentListener,
                                                        context);

    // end::add-document-replication-listener[]
    // tag::remove-document-replication-listener[]
    // Purpose -- illustrate removal of a listener
    CBLListener_Remove(token_ReplDocListener);
    CBLListener_Remove(token_ReplChangeListener);

    // end::remove-document-replication-listener[]

    // tag::p2p-act-rep-status[]
    // Purpose -- illustrate use of CBLReplicator_Status()
    CBLReplicatorStatus thisState = CBLReplicator_Status(thisRepl);
    if(thisState.activity==kCBLReplicatorStopped) {
        if(thisState.error.code==0) {
            CBLReplicator_Start(thisRepl,false);
        } else {
            printf("Replicator stopped -- code %d", thisState.error.code);
            // ... handle error ...
            CBLReplicator_Release(thisRepl);
        }
    }

    // end::p2p-act-rep-status[]
    // tag::replication-pendingdocuments[]
    FLDict thisPendingIdList =
        CBLReplicator_PendingDocumentIDs(thisRepl, &amp;err); <i class="conum" data-value="37"></i><b>(37)</b>
    if(!FLDict_IsEmpty(thisPendingIdList)) {
        FLDictIterator item;
        FLDictIterator_Begin(thisPendingIdList, &amp;item);
        FLValue itemValue;
        FLString pendingId;
        while(NULL != (itemValue = FLDictIterator_GetValue(&amp;item))) {
            pendingId = FLValue_AsString(itemValue);
            if(CBLReplicator_IsDocumentPending(thisRepl,
                                               pendingId,
                                               &amp;err)) {
                // ... process the still pending docid as required <i class="conum" data-value="38"></i><b>(38)</b>
            } else {
                // Doc Id no longer pending
                if(err.code==0) {
                    // No fail so must have already been pushed
                    printf("Document already pushed");
                } else {
                    // Error detected so handle it
                    printf("Error code %d checking for pendingId", err.code);
                    break;
                }
            }
            FLDictIterator_Next(&amp;item);
        }
        FLDictIterator_End(&amp;item);
        FLValue_Release(itemValue);
    } else {
        printf("No Pending Id Docs to process");
    }
    FLDict_Release(thisPendingIdList);

    // end::replication-pendingdocuments[]
}
// END replication.html &gt;&gt; Monitor section

// BEGIN replication.html &gt;&gt; Stop section
// PAGE=Data Sync &gt;&gt; Stop
// URL=https://docs.couchbase.com/couchbase-lite/current/c/replication.html#lbl-repl-stop
static void docs_act_replication_Stop(
                                       void* context,
                                       CBLReplicator* argRepl) {
    // tag::p2p-act-rep-stop[]
    // Purpose -- show how to stop a replication
    if(CBLReplicator_Status(argRepl).activity!=kCBLReplicatorStopped) {
        CBLReplicator_Stop(argRepl);
    }

    // end::p2p-act-rep-stop[]
}
// END replication.html &gt;&gt; Stop section

static void replication_error_handling() {
    CBLDatabase* db = kDatabase;
    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);
    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));
    config.database = db;
    config.endpoint = target;

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);



    stop_replicator(replicator);
}

static void create_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    // tag::encryptable[]
    // NOTE: No error handling, for brevity (see getting started)

    // Create with premitive type
    CBLEncryptable* encNull = CBLEncryptable_CreateWithNull();
    CBLEncryptable* encBool = CBLEncryptable_CreateWithBool(true);
    CBLEncryptable* encInt = CBLEncryptable_CreateWithInt(256);
    CBLEncryptable* encUInt = CBLEncryptable_CreateWithUInt(1024);
    CBLEncryptable* encFloat = CBLEncryptable_CreateWithFloat(1.2);
    CBLEncryptable* encDouble = CBLEncryptable_CreateWithDouble(100.50);
    CBLEncryptable* encString = CBLEncryptable_CreateWithString(FLSTR("foo"));

    // Create with dictionary
    FLMutableDict dict = FLMutableDict_New();
    FLSlot_SetString(FLMutableDict_Set(dict, FLSTR("greeting")), FLSTR("hello"));
    CBLEncryptable* encDict = CBLEncryptable_CreateWithDict(dict);

    // Create with array
    FLMutableArray array = FLMutableArray_New();
    FLSlot_SetString(FLMutableArray_Append(array), FLSTR("item1"));
    CBLEncryptable* encArray = CBLEncryptable_CreateWithArray(array);

    // Create with FLValue
    FLMutableDict dict2 = FLMutableDict_New();
    FLSlot_SetString(FLMutableDict_Set(dict2, FLSTR("greeting")), FLSTR("hello"));
    CBLEncryptable* encValue = CBLEncryptable_CreateWithValue((FLValue)dict2);
    // end::encryptable[]

    // Release after using it
    CBLEncryptable_Release(encNull);
    CBLEncryptable_Release(encBool);
    CBLEncryptable_Release(encInt);
    CBLEncryptable_Release(encBool);
    CBLEncryptable_Release(encUInt);
    CBLEncryptable_Release(encFloat);
    CBLEncryptable_Release(encDouble);
    CBLEncryptable_Release(encString);
    CBLEncryptable_Release(encDict);
    CBLEncryptable_Release(encArray);
    CBLEncryptable_Release(encValue);

    FLMutableDict_Release(dict);
    FLMutableDict_Release(dict2);
    FLMutableArray_Release(array);

    #endif
}

static void release_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLEncryptable* encValue = CBLEncryptable_CreateWithString(FLSTR("foo"));
    // tag::release_encryptable[]
    // Release the encryptable value after finish using it
    CBLEncryptable_Release(encValue);
    // end::release_encryptable[]

    #endif
}

static void use_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLDatabase* db = kDatabase;

    // tag::use_encryptable[]
    // NOTE: No error handling, for brevity (see getting started)
    CBLDocument* doc = CBLDocument_CreateWithID(FLSTR("doc1"));

    // Set encryptable:
    FLMutableDict props = CBLDocument_MutableProperties(doc);
    CBLEncryptable* encryptable = CBLEncryptable_CreateWithString(FLSTR("My secret"));
    FLSlot_SetEncryptableValue(FLMutableDict_Set(props, FLSTR("secret")), encryptable);

    CBLError error;
    CBLDatabase_SaveDocument(db, doc, &amp;error);

    // Release
    CBLDocument_Release(doc);
    CBLEncryptable_Release(encryptable);
    // end::release_encryptable[]

    #endif
}

static void query_encryptable() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLDatabase* db = kDatabase;

    // tag::use_encryptable[]
    // NOTE: No error handling, for brevity (see getting started)
    CBLError err;
    CBLQuery* query = CBLDatabase_CreateQuery(db, kCBLN1QLLanguage,
        FLSTR("SELECT secret, secret.value as secretValue FROM _ WHERE type = \"profile\""), NULL, &amp;err);
    CBLResultSet* results = CBLQuery_Execute(query, &amp;err);
    while(CBLResultSet_Next(results)) {
        // Get secret as CBLEncryptable value
        FLValue value = CBLResultSet_ValueForKey(results, FLSTR("secret"));
        const CBLEncryptable* encValue = FLValue_GetEncryptableValue(value);
        FLString secretStr = FLValue_AsString(CBLEncryptable_Value(encValue));
        printf("Secret :: %.*s\n", (int)secretStr.size, (const char *)secretStr.buf);

        // Get secret value directly
        value = CBLResultSet_ValueForKey(results, FLSTR("secretValue"));
        secretStr = FLValue_AsString(value);
        printf("Secret :: %.*s\n", (int)secretStr.size, (const char *)secretStr.buf);
    }

    CBLResultSet_Release(results);
    CBLQuery_Release(query);
    // end::release_encryptable[]

    #endif
}

#ifdef COUCHBASE_ENTERPRISE

// tag::replicator_property_encryption[]
// tag::replicator_property_encryptor_decryptor_sample[]
// Purpose: Declare property-level encryptor callback functions
static FLSliceResult my_cipher_function(FLSlice input) {
    FLSliceResult result = FLSliceResult_New(input.size);
    for(int i = 0; i &lt; input.size; ++i) {
        ((uint8_t*)(result.buf))[i] = ((uint8_t*)input.buf)[i] ^ 'K';}
    return result;
}


static FLSliceResult property_encryptor(void* context, FLString docID, FLDict props, FLString path,
                                        FLSlice input, FLStringResult* algorithm, FLStringResult* keyID, CBLError* error) {
    *algorithm = FLSlice_Copy(FLSTR("MyEnc"));
    return my_cipher_function(input);
}


static FLSliceResult property_decryptor(void* context, FLString documentID, FLDict properties, FLString keyPath,
                                        FLSlice input, FLString algorithm, FLString keyID, CBLError* error) {
    return my_cipher_function(input);
}

// end::replicator_property_encryptor_decryptor_sample[]
// end::replicator_property_encryption[]

#endif

// PAGE=Field Level Encryption
// URL=https://docs.couchbase.com/couchbase-lite/current/c/field-level-encryption.html
//
static void replicator_property_encryption() {
    #ifdef COUCHBASE_ENTERPRISE

    CBLDatabase* db = kDatabase;

    // tag::replicator_property_encryption[]
    // Purpose: Show how to declare en(de)cryptors in replicator config
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &amp;err);

    CBLReplicatorConfiguration config;
    memset(&amp;config, 0, sizeof(CBLReplicatorConfiguration));

    config.database = db;
    config.endpoint = target;
    config.propertyEncryptor = property_encryptor; <i class="conum" data-value="39"></i><b>(39)</b>
    config.propertyDecryptor = property_decryptor; <i class="conum" data-value="40"></i><b>(40)</b>

    CBLReplicator* replicator = CBLReplicator_Create(&amp;config, &amp;err);
    CBLEndpoint_Free(target);

    CBLReplicator_Start(replicator, false);
    // end::replicator_property_encryption[]

    stop_replicator(replicator);

    #endif
}

int main(int argc, char** argv) {
    create_new_database();
    create_document();
    update_document();
    do_batch_operation();
    // Disable use_blob() as no avatar.jpg to load and crash
    // use_blob();
    doc_json();
    dict_json();
    array_json();
    load_prebuilt();
    create_index();
    select_all();
    select_and_access_all();
    select_props();
    select_meta();
    select_id();
    select_where();
    use_collection_contains();
    select_like();
    select_wildcard_like();
    select_wildcard_character_like();
    select_regex();
    select_join();
    group_by();
    order_by();
    query_result_json();

    create_full_text_index();
    full_text_search();
    start_replication();
    replicator_property_encryption();

    CBLDatabase_Close(kDatabase, NULL);

    return 0;
}</code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="delete-tls-identity"><a class="anchor" href="#delete-tls-identity"></a>Delete TLS Identity</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c"></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="related-content"><a class="anchor" href="#related-content"></a>Related Content</h2>
<div class="sectionbody">
<div class="card-row three-column-row">
<div class="sect5 column">
<h6 id=""><a class="anchor" href="#"></a></h6>
<div class="ulist">
<div class="title">How to</div>
<ul>
<li>
<p><a href="p2psync-websocket-using-passive.html" class="page">Passive Peer</a></p>
</li>
<li>
<p><a href="p2psync-websocket-using-active.html" class="page">Active Peer</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-2"><a class="anchor" href="#-2"></a></h6>
<div class="ulist">
<div class="title">Concepts</div>
<ul>
<li>
<p><a href="landing-p2psync.html" class="page">Peer-to-Peer Sync</a></p>
</li>
<li>
<p><a href="http://docs.couchbase.com/mobile/3.0.0/couchbase-lite-c/C/html">API References</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-3"><a class="anchor" href="#-3"></a></h6>
<div class="paragraph">
<div class="title">Community Resources &#8230;&#8203;</div>
<p><a href="https://forums.couchbase.com/c/mobile/14">Mobile Forum</a> |
<a href="https://blog.couchbase.com/">Blog</a> |
<a href="https://docs.couchbase.com/tutorials/">Tutorials</a></p>
</div>
<div class="paragraph">
<div class="title"></div>
<p><a href="../../../tutorials/cbl-p2p-sync-websockets/swift/cbl-p2p-sync-websockets.html" class="page">Getting Started with Peer-to-Peer Synchronization</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="related-content-2"><a class="anchor" href="#related-content-2"></a>Related Content</h2>
<div class="sectionbody">
<div class="card-row three-column-row">
<div class="sect5 column">
<h6 id="-4"><a class="anchor" href="#-4"></a></h6>
<div class="ulist">
<div class="title">How to</div>
<ul>
<li>
<p><a href="p2psync-websocket-using-passive.html" class="page">Passive Peer</a></p>
</li>
<li>
<p><a href="p2psync-websocket-using-active.html" class="page">Active Peer</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-5"><a class="anchor" href="#-5"></a></h6>
<div class="ulist">
<div class="title">Concepts</div>
<ul>
<li>
<p><a href="landing-p2psync.html" class="page">Peer-to-Peer Sync</a></p>
</li>
<li>
<p><a href="http://docs.couchbase.com/mobile/3.0.0/couchbase-lite-c/C/html">API References</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-6"><a class="anchor" href="#-6"></a></h6>
<div class="paragraph">
<div class="title">Community Resources &#8230;&#8203;</div>
<p><a href="https://forums.couchbase.com/c/mobile/14">Mobile Forum</a> |
<a href="https://blog.couchbase.com/">Blog</a> |
<a href="https://docs.couchbase.com/tutorials/">Tutorials</a></p>
</div>
<div class="paragraph">
<div class="title"></div>
<p><a href="../../../tutorials/cbl-p2p-sync-websockets/swift/cbl-p2p-sync-websockets.html" class="page">Getting Started with Peer-to-Peer Synchronization</a></p>
</div>
</div>
</div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase">
          </a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <svg  width="14" height="14" viewBox="0 0 32.1 26.1"> <path id="twitter" class="cls-1" d="M32,7.1a11.836,11.836,0,0,1-3.8,1,6.462,6.462,0,0,0,2.9-3.6,12.606,12.606,0,0,1-4.2,1.6A6.492,6.492,0,0,0,22.1,4a6.594,6.594,0,0,0-6.6,6.6,7.719,7.719,0,0,0,.2,1.5A18.458,18.458,0,0,1,2.2,5.2a6.294,6.294,0,0,0-.9,3.3A6.765,6.765,0,0,0,4.2,14a6.109,6.109,0,0,1-3-.8v.1a6.543,6.543,0,0,0,5.3,6.4,4.678,4.678,0,0,1-1.7.2,4.869,4.869,0,0,1-1.2-.1,6.679,6.679,0,0,0,6.1,4.6,12.917,12.917,0,0,1-8.2,2.8,9.151,9.151,0,0,1-1.6-.1,18.438,18.438,0,0,0,10.1,3c12.1,0,18.7-10,18.7-18.7v-.8A13.336,13.336,0,0,0,32,7.2Z" transform="translate(0.1 -4)"/></svg>
            <a href="https://twitter.com/couchbase" class="icon">
              Twitter
            </a>
          </li>
          <li>
          <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="linkedin" class="cls-1" d="M29,0H3A3.076,3.076,0,0,0,0,3V29a3.009,3.009,0,0,0,3,3H29a2.946,2.946,0,0,0,3-3V3A3.009,3.009,0,0,0,29,0ZM12,26H8V12h4ZM10,10a2,2,0,1,1,2-2A2.006,2.006,0,0,1,10,10ZM26,26H22V18a2,2,0,0,0-4,0v8H14V12h4v2.5c.8-1.1,2.1-2.5,3.5-2.5A4.736,4.736,0,0,1,26,17Z"/></svg>
              <a href="https://www.linkedin.com/company/couchbase" class="icon">
             Linkedin
            </a>
          </li>
          <li>
            <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="facebook" class="cls-1" d="M29,0H3A2.652,2.652,0,0,0,0,3V29a2.652,2.652,0,0,0,3,3H16V18H12V14h4V12a6.452,6.452,0,0,1,6-6h4v4H22a2.151,2.151,0,0,0-2,2v2h6l-1,4H20V32h9a2.652,2.652,0,0,0,3-3V3A2.652,2.652,0,0,0,29,0Z"/></svg>
            <a href="https://www.facebook.com/Couchbase" class="icon">
            Facebook
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <div class="footer-terms-copyright">
          <span> 2022 Couchbase, Inc. Couchbase, Couchbase Lite and the Couchbase logo are registered trademarks of Couchbase, Inc.</span>
      </div>
      <div class="footer-terms-links">
        <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
        <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
        <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
        <a href="https://www.couchbase.com/support-policy">Support Policy</a>
        <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
      </div>
    </div>
  </div>
</footer>
<template id="run-code-panel">
<div class="action-panel">
  <form class="action-panel-control" method="POST" action="https://couchbase.live/run" target="run-code-output">
    <input type="hidden" name="lang">
    <input type="hidden" name="code">
    <input type="hidden" name="from" value="docs">
    <div class="controls">
      <button class="control-button rerun" type="submit"><i class="fas fa-redo"></i></button>
      <span class="shell-name control-label">Output</span>
      <button class="control-button close"><i class="fas fa-times"></i> Close</button>
    </div>
  </form>
  <iframe class="run-code-output" name="run-code-output"></iframe>
</div>
</template>
<script id="site-script" src="../../../_/js/site.js"></script>
<script defer src="../../../_/js/vendor/fontawesome-icon-defs.js"></script>
<script defer src="../../../_/js/vendor/fontawesome.js" data-search-pseudo-elements="true"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
</body>
</html>
