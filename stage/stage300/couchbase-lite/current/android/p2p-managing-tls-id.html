<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Managing TLS Identities&#8201;&#8212;&#8201;Working with Peer-to-Peer Syncs | Couchbase Docs</title>
<link rel="stylesheet" href="../../../_/css/site.css">
<script src="../../../_/js/vendor/jquery.js"></script>
<meta name="description" content="Couchbase Lite&#x27;s Peer-to-Peer Synchronization enables edge devices to synchronize securely without consuming centralized cloud-server resources">
<link rel="schema.dcterms" href="https://purl.org/dc/terms/">
<meta name="dcterms.subject" content="couchbase-lite">
<meta name="dcterms.identifier" content="3.0">
<meta name="page-url" content="/couchbase-lite/current/android/p2p-managing-tls-id.html">
<meta name="generator" content="Antora 3.0.0-alpha.6">
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
</head>
<body class="article">
<header class="header fixed-top">
  <div class="header-top-row">
      <div class="container">
          <nav class="navbar navbar-expand-md flex-nowrap justify-content-between navbar-new-top">
              <ul class="navbar-brand-list">
                <li class="brand-logo">
                  <a class="navbar-brand" href="https://www.couchbase.com">
                    <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase" />
                  </a>
                </li>
                <li>
                  <a class="navbar-brand cb-documentation" href="https://ibsoln.github.io/stage/stage300/home/index.html">
                    <img src="../../../_/img/cb-documentation.svg" alt="Couchbase Documentation" class="cb-docs" />
                    <img src="../../../_/img/cb-docs-hover.svg" alt="Couchbase Documentation" class="hide cb-hover-docs" />
                  </a>
                </li>
              </ul>
              <button class="navbar-burger" data-target="topbar-menu">
                <span></span>
                <span></span>
                <span></span>
              </button>

          </nav>
      </div>
  </div>
  <div class="header-bottom-row" id="topbar-menu">
    <div class="container">
        <nav  class="navbar navbar-new-bottom">

              <div class="navbar-collapse collapse" id="navbar2">
                <ul class="navbar-nav w-100 justify-content-start">
                  <li class="nav-item">
                    <a href="https://ibsoln.github.io/stage/stage300/home/index.html" class="nav-link">
                      <i class="fas fa-home"></i>
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/server.html">
                      Server
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/mobile.html">
                      Mobile
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/cloud.html">
                      Cloud
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/sdk.html">
                      SDKs
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../tutorials/index.html">
                      Tutorials
                      <span class="arrow">
                        <i class="fas fa-arrow-right"></i>
                      </span>
                    </a>
                  </li>
                </ul>
              </div>
              <div class="primary-action">
                <a href="https://cloud.couchbase.com/sign-up" class="free-trial-link" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Free Trial'});" >
                  <i class="fas fa-cloud"></i>
                  Free Trial
                </a>
                <a class="btn btn-primary try-btn"  onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Download'});" href="https://www.couchbase.com/downloads">
                  Downloads
                </a>
              </div>

        </nav>
    </div>
   </div>
</header>
<div class="body container">
<aside class="nav left-sidebar">
  <div class="nav-container">
    <a href="#" class="menu-expand-toggle"><span>Navigation</span><i class="fas fa-times-circle"></i><i class="fas fa-chevron-circle-left"></i></a>
<div class="components">
  <div class="components_group-title">
    <a href="../../../home/mobile.html">Mobile</a>
  </div>
  <ul class="components_list">
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Couchbase Lite</span>
        <select class="version_list" data-component="couchbase-lite">
          <option value="3.0" data-url="../index.html" selected>3.0 BETA01</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0">
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../index.html">Introduction</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../cbl-whatsnew.html">New in 3.0 BETA</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="quickstart.html">Android</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="api-changes.html">API Changes (3.0 BETA)</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="kotlin.html">Kotlin</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="querybuilder-n1ql.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-n1ql-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#android:p2p-websocket.adoc">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#android:p2p-websocket-using-passive.adoc">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#android:p2p-websocket-using-active.adoc">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/3.0.0/couchbase-lite-android">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/mobile/3.0.0/couchbase-lite-kt-android">Kotlin Specific API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#android:release-notes.adoc">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../c/quickstart.html">C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/gs-downloads.html">BETA Downloads</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/field-level-encryption.html">Field Level Encryption</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/querybuilder-n1ql.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-n1ql-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/replication.html">Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-c">API&#160;References</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../c/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/quickstart.html">.Net</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/api-changes.html">API Changes (3.0 BETA)</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/querybuilder-n1ql.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-n1ql-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#csharp:p2p-websocket.adoc">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#csharp:p2p-websocket-using-passive.adoc">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#csharp:p2p-websocket-using-active.adoc">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-net">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#csharp:release-notes.adoc">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/quickstart.html">Java</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/api-changes.html">API Changes (3.0 BETA)</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/querybuilder-n1ql.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-n1ql-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#java:p2p-websocket.adoc">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#java:p2p-websocket-using-passive.adoc">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#java:p2p-websocket-using-active.adoc">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-java">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#java:release-notes.adoc">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/quickstart.html">Objective-C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/api-changes.html">API Changes (3.0 BETA)</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/querybuilder-n1ql.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-n1ql-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#objc:p2p-websocket.adoc">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#objc:p2p-websocket-using-passive.adoc">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#objc:p2p-websocket-using-active.adoc">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.{minor/couchbase-lite-objc">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-crashes.html">Troubleshooting Crashes</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#objc:release-notes.adoc">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/supported-os.html">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/quickstart.html">Swift</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-prereqs.html">Prerequisites</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/api-changes.html">API Changes (3.0 BETA)</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/querybuilder.html">Querybuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/querybuilder-n1ql.html">N1QL for Mobile</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-n1ql-diffs.html">N1QL Server Differences</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/dbreplica.html">Intra-device Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#swift:p2p-websocket.adoc">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#swift:p2p-websocket-using-passive.adoc">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#swift:p2p-websocket-using-active.adoc">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.{minor/couchbase-lite-swift">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-crashes.html">Troubleshooting Crashes</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#swift:release-notes.adoc">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#swift:compatibility.adoc">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#swift:supported-os.adoc">Supported Platforms</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../javascript.html">JavaScript</a>
  </span>
</li>
</ul>
      </div>
    </li>
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Sync Gateway</span>
        <select class="version_list" data-component="sync-gateway">
          <option value="3.0" data-url="../../../sync-gateway/current/index.html" selected>3.0 BETA01</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0">
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/introduction.html">Introduction</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/whatsnew.html"><strong><em>New in 3.0 BETA</em></strong></a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-prepare.html">Prepare</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-verify-install.html">Verify</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/data-modeling.html">Data Modeling</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Configuration</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-bootstrap.html">Bootstrap</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-database.html">Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-db-security.html">Database Security</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-access-control.html">Access Control</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-import-filter.html">Import Filter</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-isgr.html">Inter-Sync&#160;Gateway Replication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-properties.html">Legacy Pre-3.0 BETA Configuration</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-javascript-functions.html">Javascript Functions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-environment-variables.html">Environment Variables</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Security</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/secure-sgw-access.html">Secure Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-users.html">User Authentication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-certs.html">TLS Cert Authetnication</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Access Control</span>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-concepts.html">Concepts</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-model.html">Access Control Model</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/channels.html">Channels</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/roles.html">Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/users.html">Users</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function.html">Sync Function</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api.html">API Reference</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-access-cmd.html">access()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-channel-cmd.html">channel()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-expiry-cmd.html">expiry()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-access-cmd.html">requireAccess()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-admin-cmd.html">requireAdmin()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-role-cmd.html">requireRole()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-user-cmd.html">requireUser()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-role-cmd.html">role()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-throw-cmd.html">throw()</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how.html">How-to</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-create-users.html">Create Users</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-create-roles.html">Create Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-assign-users-to-roles.html">Assign User to Role</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-control-document-access.html">Control Document Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-verify-access.html">Verify Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-use-xattrs-for-access-grants.html">Use XATTRS for Access Grants</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/auto-purge-channel-access-revocation.html">Auto-Purge Channel Access Revocation</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">REST API</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-access.html">Secure Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin.html">Admin REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-metrics.html">Metrics REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api.html">Public REST API</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-with-couchbase-server.html">Sync with Server</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-using-app.html">Sync with Application</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Inter-Sync Gateway Replication</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-run.html">Initialize</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-manage.html">Manage</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-monitor.html">Monitor</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-conflict-resolution.html">Inter Syncgateway Conflict Resolution</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/revisions.html">Revisions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/what-are-tombstones.html">Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/managing-tombstones.html">Managing Tomstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/delta-sync.html">Delta Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/resync.html">Resync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/import-filter.html">Import Filter</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Manage</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-monitoring.html">Stats Monitoring</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Logging and Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/logging.html">Logging</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sgcollect-info.html">SG Collect Info</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/database-offline.html">Database Offline</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Deploy</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deployment.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/command-line-options.html">Command Line Options</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/load-balancer.html">Load Balancer</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/os-level-tuning.html">OS Level Tuning</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/webhooks.html">Webhooks</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/changes-feed.html">Changes Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/integrating-external-stores.html">External Stores</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-prometheus.html">Prometheus Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/setting-up-dr-cluster.html">Disaster Recovery</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/upgrading.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Use Kubernetes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deploy-cluster-to-kubernetes.html">Deploy</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#operator::{cao-pg-manage-sgw&amp;.adoc#8212;&amp;#8203;page">Manage a Sync Gateway Cluster</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#operator::{cao-pg-clients-sgw&amp;.adoc#8212;&amp;#8203;page">Expose Sync Gateway to Couchbase Lite clients</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Server Compatibility</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-collections.html">Collections</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-eventing.html">Eventing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-transactions.html">Transactions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-xdcr.html">XDCR</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/supported-environments.html">Supported Environments</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/compatibility.html">Compatibility Matrix</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Legacy Features</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sg-replicate.html">SG Replicate</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sgreplicate-resolving-conflicts.html">SG Replicate - Resolving Conflicts (depr)</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-logging-pre2-1.html">Legacy Pre-2.1 Logging</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/glossary.html">Glossary</a>
  </span>
</li>
</ul>
      </div>
    </li>
  </ul>
</div>
  </div>
</aside>
<aside class="toc sidebar">
  <div class="sidebar-box">
    <div class="tools" role="navigation">
<ul>
<li class="tool edit"><a href="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/pages/p2p-managing-tls-id.adoc" title="Edit Page" target="_blank" rel="noopener">Edit on GitHub</a></li>
</ul>
</div>
    <div class="toc-menu"></div>
    <div class="is-this-helpful-box">
      <h4> Is this page helpful?</h4>
      <div class="btn-row">
        <a href="#" class="like-btn helpful-btn" id="yesBtn" data-page-rating="like" >
                <i class="far fa-thumbs-up"></i>
            Yes

            </a>
        <a href="#" class="dislike-btn helpful-btn" id="noBtn"  data-page-rating="dislike"> <i class="far fa-thumbs-down"></i> No</a>
      </div>
      <div class="any-feedback">
        <a href="#" class="btn any-feedback-btn" id="myCustomTrigger">Leave Additional Feedback? </a>
      </div>
      <div class="dialog-box" id="dialogBox">
        <form>
            <div class="form-group " id="additionalFeedbackBox">
              <textarea class="input-control feed-back-msg" rows="8" placeholder="Any Additonal Feedback?"></textarea>

              <div class="action-btn-row ">
                <a href="#" class="skip-btn" id="skipBtnMsg">Skip</a>
                  <button class="submit-btn btn blue-btn disabled" > Submit  </button>
                  <a href="#" class="info-btn"><i class="fas fa-info-circle"></i></a>
              </div>


            </div>

        </form>

      </div>
    </div>
  </div>

</aside>

<div class="feedback-modal modal-popup">
  <div class="modal-popup-dialogue">
    <div class="popup-header">
      <a href="#" class="close-popup"><i class="fa fa-times"></i></a>
    </div>
    <div class="popup-content">
      <p>
        Please use the form below to provide your feedback. Because your feedback is valuable to us,
         the information you submit in this form is recorded in our issue tracking system (JIRA), which is publicly available.
        You can track the status of your feedback using the ticket number displayed in the dialog once you submit the form.
      </p>
    </div>
  </div>
</div>

<main class="article" data-ceiling="topbar">
<div class="article-header">
<nav class="crumbs" aria-label="breadcrumbs">
<ul>
<li class="crumb"><a href="../index.html">Couchbase Lite</a></li>
<li class="crumb"><a href="p2p-managing-tls-id.html">Managing TLS Identities&#8201;&#8212;&#8201;Working with Peer-to-Peer Syncs</a></li>
</ul>
</nav>
</div>
<article class="doc">
<div class="page-heading-title">
<h1 class="page">Managing TLS Identities&#8201;&#8212;&#8201;Working with Peer-to-Peer Syncs</h1>
<div class="labels">
<ul>
<li class="edition"><a href="https://www.couchbase.com/products/editions">3.0 https://www.couchbase.com/products/editions[ENTERPRISE EDITION]</a></li>
<li class="status"><span>BETA</span></li>
</ul>
</div>
</div>
<div class="contributor-list-box">
<span class="last-commit-date" id="commitdate">    </span>
<ul id="contributorList"></ul>
<span  id="otherContributor"> + </span>
</div><div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>Description&#8201;&#8212;&#8201;<em>Couchbase Lite&#8217;s Peer-to-Peer Synchronization enables edge devices to synchronize securely without consuming centralized cloud-server resources</em><br>
<em>Abstract&#8201;&#8212;&#8201;This content covers how to manage TLS identities using Couchbase Lite peer-to-peer sync</em><br>
Related Content&#8201;&#8212;&#8201;<a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/">API Reference</a>  |  <a href="p2psync-websocket-using-passive.html" class="page">Passive Peer</a>  |  <a href="p2psync-websocket-using-active.html" class="page">Active Peer</a></p>
</div>
</blockquote>
</div>
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>Description&#8201;&#8212;&#8201;<em>Couchbase Lite&#8217;s Peer-to-Peer Synchronization enables edge devices to synchronize securely without consuming centralized cloud-server resources</em><br>
<em>Abstract&#8201;&#8212;&#8201;This content covers how to manage TLS identities using Couchbase Lite peer-to-peer sync</em><br>
Related Content&#8201;&#8212;&#8201;<a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/">API Reference</a>  |  <a href="p2psync-websocket-using-passive.html" class="page">Passive Peer</a>  |  <a href="p2psync-websocket-using-active.html" class="page">Active Peer</a></p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1 pane__frames">
<h2 id="overview"><a class="anchor" href="#overview"></a>Overview</h2>
<div class="sectionbody">
<div class="ulist no-color">
<div class="title"></div>
<ul>
<li>
<p>This describes the configuration and management of TLS identities</p>
</li>
</ul>
</div>
<div class="ulist narrow">
<div class="title">Key Concepts</div>
<ul>
<li>
<p>API: <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/TLSIdentity.html">TLSIdentity</a></p>
</li>
<li>
<p><a href="p2psync-websocket.html" class="page">Peer-to-Peer</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="api-references"><a class="anchor" href="#api-references"></a>API References</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can find <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/">Android API References</a> here.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-tls-identity"><a class="anchor" href="#creating-tls-identity"></a>Creating TLS Identity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are couple of options by which TLS Identity is created:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can use the <a href="#anonymous-cert">anonymous self-signed cert</a> auto-generated by Couchbase Lite</p>
</li>
<li>
<p>You can <a href="#importing-a-cert">import a cert</a> to be bundled with the app and-or stored in the keychain</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="use-anonymous-cert"><a class="anchor" href="#use-anonymous-cert"></a>Use Anonymous Cert</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Anonymous certification uses the self signed certificate auto-generated by Couchbase Lite when TLS is enabled, but no TLSIdentity is provided.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">listenerConfig.disableTLS  = false // Use with anonymous self signed cert
listenerConfig.tlsIdentity = nil</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="import-a-cert"><a class="anchor" href="#import-a-cert"></a>Import a Cert</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/TLSIdentity.html">TLSIdentity</a> class&#8217;s  <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/TLSIdentity.html#importIdentity-java.lang.String-java.io.InputStream-char:A-java.lang.String-char:A-java.lang.String-">importIdentity()</a> method to import a certificate that can be bundled with the app and-or added to the keychain.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First check the keychain to see if the identity already exists</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">[data-source-url=https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/codesnippet_collection.kt]</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Check for an existing resource bundle</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/codesnippet_collection.kt">

// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.Conflict
import com.couchbase.lite.ConflictResolver
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.DatabaseConfiguration
import com.couchbase.lite.DatabaseEndpoint
import com.couchbase.lite.Document
import com.couchbase.lite.DocumentFlag
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.SessionAuthenticator
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.create
import com.couchbase.lite.internal.utils.PlatformUtils
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.io.InputStream
import java.net.URI
import java.net.URISyntaxException


private const val TAG = "REPLICATION"

@Throws(IOException::class)
fun InputStream.toByteArray(): ByteArray {
    val buffer = ByteArray(1024)
    val output = ByteArrayOutputStream()

    var n: Int
    while (-1 &lt; this.read(buffer).also { n = it }) {
        output.write(buffer, 0, n)
    }

    return output.toByteArray()
}

// tag::update-document-with-conflict-handler-callouts[]
//
//        &lt;.&gt; The conflict handler code is provided as a lambda.
//
//        &lt;.&gt; If the handler cannot resolve a conflict, it can return false.
//        In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.
//
//        &lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.
//
//        &lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).
//
//        &lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method
// end::update-document-with-conflict-handler-callouts[]


// tag::local-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
@Suppress("unused")
object LocalWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.localDocument
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
@Suppress("unused")
object RemoteWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.remoteDocument
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
// Using replConfig.setConflictResolver(new MergeConflictResolver());
@Suppress("unused")
object MergeConflictResolver : ConflictResolver {
    override fun resolve(conflict: Conflict): Document {
        val localDoc = conflict.localDocument?.toMap()
        val remoteDoc = conflict.remoteDocument?.toMap()

        val merge: MutableMap&lt;String, Any&gt;?
        if (localDoc == null) {
            merge = remoteDoc
        } else {
            merge = localDoc
            if (remoteDoc != null) {
                merge.putAll(remoteDoc)
            }
        }

        return if (merge == null) {
            MutableDocument(conflict.documentId)
        } else {
            MutableDocument(conflict.documentId, merge)
        }
    }
// end::merge-conflict-resolver[]

    @Suppress("unused")
    class ReplicationExamples(private val database: Database) {
        private var replicator: Replicator? = null

        @Throws(URISyntaxException::class)
        fun testReplicationBasicAuthentication() {
            // tag::basic-authentication[]

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = BasicAuthenticator("username", "password".toCharArray())
                )
            )
            repl.start()
            replicator = repl
            // end::basic-authentication[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationSessionAuthentication() {
            // tag::session-authentication[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447")
                )
            )
            repl.start()
            replicator = repl
            // end::session-authentication[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationStatus() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            // tag::replication-status[]
            // Version using Kotlin Flows to follow shortly ...
            repl.addChangeListener { change -&gt;
                if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                    Log.i(TAG, "Replication stopped")
                }
            }

            repl.start()
            replicator = repl
            // end::replication-status[]
        }

        @Throws(URISyntaxException::class)
        fun testHandlingNetworkErrors() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            // tag::replication-error-handling[]
            // Version using Kotlin Flows to follow shortly ...
            repl.addChangeListener { change -&gt;
                change.status.error?.let {
                    Log.w(TAG, "Error code: ${it.code}")
                }
            }
            repl.start()
            replicator = repl
            // end::replication-error-handling[]

            repl.stop()
        }

        @Throws(URISyntaxException::class)
        fun testReplicatorDocumentEvent() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            // tag::add-document-replication-listener[]
            val token = repl.addDocumentReplicationListener { replication -&gt;
                Log.i(TAG, "Replication type: ${if (replication.isPush) "push" else "pull"}")

                for (document in replication.documents) {
                    document.let { doc -&gt;
                        Log.i(TAG, "Doc ID: ${document.id}")
                        doc.error?.let {
                            // There was an error
                            Log.e(TAG, "Error replicating document: ", it)
                            return@addDocumentReplicationListener
                        }
                        if (doc.flags.contains(DocumentFlag.DELETED)) {
                            Log.i(TAG, "Successfully replicated a deleted document")
                        }
                    }
                }
            }

            repl.start()
            replicator = repl
            // end::add-document-replication-listener[]

            // tag::remove-document-replication-listener[]
            repl.removeChangeListener(token)
            // end::remove-document-replication-listener[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationCustomHeader() {
            // tag::replication-custom-header[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value")
                )
            )
            replicator = repl
            // end::replication-custom-header[]
        }

        // ### Certificate Pinning
        @Throws(URISyntaxException::class, IOException::class)
        fun testCertificatePinning() {
            // tag::certificate-pinning[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value"),
                    pinnedServerCertificate = PlatformUtils.getAsset("cert.cer")?.toByteArray()
                )
            )
            replicator = repl
            // end::certificate-pinning[]
        }

        // ### Reset replicator checkpoint
        @Throws(URISyntaxException::class)
        // tag::replication-startup[]
        fun testReplicationResetCheckpoint() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            // tag::replication-reset-checkpoint[]
            if (resetCheckpointRequired_Example) {
              repl.start(resetCheckpoint = true) <i class="conum" data-value="1"></i><b>(1)</b>
            else
              repl.start(resetCheckpoint = false)
            }
            // end::replication-reset-checkpoint[]

            // ... at some later time

            repl.stop()
        // end::replication-startup[]

        }

        @Throws(URISyntaxException::class)
        fun testReplicationPushFilter() {
            // tag::replication-push-filter[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { _, flags -&gt; flags.contains(DocumentFlag.DELETED) } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
            // end::replication-push-filter[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationPullFilter() {
            // tag::replication-pull-filter[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { document, _ -&gt; "draft" == document.getString("type") } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
            // end::replication-pull-filter[]
        }

        @Throws(URISyntaxException::class)
        fun testCustomRetryConfig() {
            // tag::replication-retry-config[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    //  other config params as required . .
                    // tag::replication-heartbeat-config[]
                    heartbeat = 150, <i class="conum" data-value="1"></i><b>(1)</b>
                    // end::replication-heartbeat-config[]
                    // tag::replication-maxattempts-config[]
                    maxAttempts = 20,
                    // end::replication-maxattempts-config[]
                    maxAttemptWaitTime = 600
                    // end::replication-maxattemptwaittime-config[]
                )
            )

            repl.start()
            replicator = repl
            // end::replication-retry-config[]
        }

        @Throws(CouchbaseLiteException::class)
        fun testDatabaseReplica() {
            val config = DatabaseConfiguration()
            val database1 = Database("mydb", config)
            val database2 = Database("db2", config)

            /* EE feature: code below might throw a compilation error
               if it's compiled against CBL Android Community. */
            // tag::database-replica[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database1,
                    target = DatabaseEndpoint(database2),
                    type = ReplicatorType.PULL
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
            // end::database-replica[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationWithCustomConflictResolver() {
            // tag::replication-conflict-resolver[]
            val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
            val config = ReplicatorConfiguration(database, target)
            config.conflictResolver = LocalWinConflictResolver()
            val replication = Replicator(config)
            replication.start()
            // end::replication-conflict-resolver[]
        }

        @Throws(CouchbaseLiteException::class)
        fun testSaveWithCustomConflictResolver() {
            // tag::update-document-with-conflict-handler[]
            val mutableDocument = database.getDocument("xyz")?.toMutable() ?: return
            mutableDocument.setString("name", "apples")
            database.save(mutableDocument) { newDoc, curDoc -&gt;  <i class="conum" data-value="2"></i><b>(2)</b>
                if (curDoc == null) {
                    return@save false
                } <i class="conum" data-value="3"></i><b>(3)</b>
                val dataMap: MutableMap&lt;String, Any&gt; = curDoc.toMap()
                dataMap.putAll(newDoc.toMap()) <i class="conum" data-value="4"></i><b>(4)</b>
                newDoc.setData(dataMap)
                true <i class="conum" data-value="5"></i><b>(5)</b>
            } <i class="conum" data-value="6"></i><b>(6)</b>
            // end::update-document-with-conflict-handler[]
        }
    }
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import android.widget.Toast
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.Blob
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.DatabaseConfiguration
import com.couchbase.lite.DatabaseConfigurationFactory
import com.couchbase.lite.EncryptionKey
import com.couchbase.lite.Expression
import com.couchbase.lite.LogDomain
import com.couchbase.lite.LogFileConfigurationFactory
import com.couchbase.lite.LogLevel
import com.couchbase.lite.Logger
import com.couchbase.lite.Meta
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.SelectResult
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.UnitOfWork
import com.couchbase.lite.create
import com.couchbase.lite.internal.utils.PlatformUtils
import org.junit.Test
import java.io.File
import java.io.IOException
import java.net.URI
import java.net.URISyntaxException
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.Arrays
import java.util.Date
import java.util.EnumSet


private const val TAG = "BASIC"

// tag::custom-logging[]
class LogTestLogger(private val level: LogLevel) : Logger {
  override fun getLevel() = level

  override fun log(level: LogLevel, domain: LogDomain, message: String) {
    // this method will never be called if param level &lt; this.level
    // handle the message, for example piping it to a third party framework
  }
}

// end::custom-logging[]
// tag::example-app[]
@Suppress("unused")
class BasicExamples(private val context: Context) {
    private val database: Database

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        // Get the database (and create it if it doesnt exist).
        database = Database(
            "getting-started",
            DatabaseConfigurationFactory.create(context.filesDir.absolutePath)
        )
    }

    @Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {

        // !!! Note the code moved from here to the init { } above.
        // tag::getting-started[]
        // Create a new document (i.e. a record) in the database.
        var mutableDoc = MutableDocument().setFloat("version", 2.0f).setString("type", "SDK")

        // Save it to the database.
        database.save(mutableDoc)

        // Update a document.
        mutableDoc = database.getDocument(mutableDoc.id)!!.toMutable().setString("language", "Java")
        database.save(mutableDoc)

        val document = database.getDocument(mutableDoc.id)!!
        // Log the document ID (generated by the database) and properties
        Log.i(TAG, "Document ID :: ${document.id}")
        Log.i(TAG, "Learning ${document.getString("language")}")

        // Create a query to fetch documents of type SDK.
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))
            .execute()
        Log.i(TAG, "Number of rows :: ${rs.allResults().size}")

        // Create a replicator to push and pull changes to and from the cloud.
        // Be sure to hold a reference somewhere to prevent the Replicator from being GCed
        val replicator = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(URI("ws://localhost:4984/getting-started-db")),
                type = ReplicatorType.PUSH_AND_PULL,
                authenticator = BasicAuthenticator("sync-gateway", "password".toCharArray())
            )
        )

        // Listen to replicator change events.
        // Version using Kotlin Flows to follow shortly ...

        replicator.addChangeListener { change -&gt;
            val err = change.status.error
            if (err != null) Log.i(TAG, "Error code ::  ${err.code}")
        }

        // Start replication.
        replicator.start()

        // end::getting-started[]
        database.delete()
    }
    // end::example-app[]

    @Throws(CouchbaseLiteException::class, IOException::class)
    fun test1xAttachments() {
        // if db exist, delete it
        deleteDB("android-sqlite", context.filesDir)
        ZipUtils.unzip(PlatformUtils.getAsset("replacedb/android140-sqlite.cblite2.zip"), context.filesDir)

        val db = Database("android-sqlite")
        try {
            // For Validation
            Arrays.equals(
                "attach1".toByteArray(),
                db.getDocument("doc1")?.getDictionary("_attachments")?.getBlob("attach1")?.content
            )
        } finally {
            // close db
            db.close()
            // if db exist, delete it
            deleteDB("android-sqlite", context.filesDir)
        }
        val document = MutableDocument()

        // tag::1x-attachment[]
        val content = document.getDictionary("_attachments")?.getBlob("avatar")?.content
        // end::1x-attachment[]
    }

    // ### Initializer
    fun testInitializer() {
        // tag::sdk-initializer[]
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)
        // end::sdk-initializer[]
    }

    // ### New Database
    @Throws(CouchbaseLiteException::class)
    fun testNewDatabase() {
        // tag::new-database[]
        val db = Database("my-db", DatabaseConfigurationFactory.create(context.filesDir.absolutePath)) <i class="conum" data-value="7"></i><b>(7)</b>
        // end::new-database[]
        db.delete()
    }

    // ### Database Encryption
    @Throws(CouchbaseLiteException::class)
    fun testDatabaseEncryption() {
        // tag::database-encryption[]
        val db = Database("my-db", DatabaseConfigurationFactory.create(encryptionKey = EncryptionKey("PASSWORD")))
        // end::database-encryption[]
    }

    // ### Logging
    // !!! OBSOLETE in 3.0
    fun testLogging() {
        // tag::logging[]
        // end::logging[]
    }

    fun testEnableCustomLogging() {
        // tag::set-custom-logging[]
        // this custom logger will not log an event with a log level &lt; WARNING
        Database.log.custom = LogTestLogger(LogLevel.WARNING) <i class="conum" data-value="8"></i><b>(8)</b>
        // end::set-custom-logging[]
    }

    // ### Console logging
    @Throws(CouchbaseLiteException::class)
    fun testConsoleLogging() {
        // tag::console-logging[]
        Database.log.console.domains = LogDomain.ALL_DOMAINS <i class="conum" data-value="9"></i><b>(9)</b>
        Database.log.console.level = LogLevel.VERBOSE <i class="conum" data-value="10"></i><b>(10)</b>
        // end::console-logging[]

        // tag::console-logging-db[]
        Database.log.console.domains = EnumSet.of(LogDomain.DATABASE) <i class="conum" data-value="11"></i><b>(11)</b>
        // end::console-logging-db[]
    }

    // ### File logging
    @Throws(CouchbaseLiteException::class)
    fun testFileLogging() {
        // tag::file-logging[]
        Database.log.file.let {
            it.config = LogFileConfigurationFactory.create(
                context.cacheDir.absolutePath, <i class="conum" data-value="12"></i><b>(12)</b>
                maxSize = 10240, <i class="conum" data-value="13"></i><b>(13)</b>
                maxRotateCount = 5, <i class="conum" data-value="14"></i><b>(14)</b>
                usePlainText = false
            ) <i class="conum" data-value="15"></i><b>(15)</b>
            it.level = LogLevel.INFO <i class="conum" data-value="16"></i><b>(16)</b>

            // end::file-logging[]
        }
    }

    fun writeConsoleLog() {
        // tag::write-console-logmsg[]
        Database.log.console.log(LogLevel.WARNING, LogDomain.REPLICATOR, "Any old log message")
        // end::write-console-logmsg[]
    }

    fun writeCustomLog() {
        // tag::write-custom-logmsg[]
        Database.log.custom?.log(LogLevel.WARNING, LogDomain.REPLICATOR, "Any old log message")
        // end::write-custom-logmsg[]
    }

    fun writeFileLog() {
        // tag::write-file-logmsg[]
        Database.log.file.log(LogLevel.WARNING, LogDomain.REPLICATOR, "Any old log message")
        // end::write-file-logmsg[]
    }

    /* The `tag::replication[]` example is inlined in java.adoc */
    fun testTroubleshooting() {
        // tag::replication-logging[]
        Database.log.console.let {
            it.level = LogLevel.VERBOSE
            it.domains = LogDomain.ALL_DOMAINS
        }
        // end::replication-logging[]
    }

    // ### Loading a pre-built database
    @Throws(IOException::class)
    fun testPreBuiltDatabase() {
        // tag::prebuilt-database[]
        // Note: Getting the path to a database is platform-specific.
        // For Android you need to extract the database from your assets
        // to a temporary directory and then copy it, using Database.copy()
        if (Database.exists("travel-sample", context.filesDir)) {
            return
        }
        ZipUtils.unzip(PlatformUtils.getAsset("travel-sample.cblite2.zip"), context.filesDir)
        Database.copy(File(context.filesDir, "travel-sample"), "travel-sample", DatabaseConfiguration())
        // end::prebuilt-database[]
    }

    // helper methods
    // if db exist, delete it
    fun deleteDB(name: String, dir: File) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            Database.delete(name, dir)
        }

        // ### Initializers
        fun testInitializers() {
            // tag::initializer[]
            val doc = MutableDocument()
            doc.let {
                it.setString("type", "task")
                it.setString("owner", "todo")
                it.setDate("createdAt", Date())
            }
            database.save(doc)
            // end::initializer[]
        }
    }

    // ### Mutability
    fun testMutability() {
        database.save(MutableDocument("xyz"))

        // tag::update-document[]
        database.getDocument("xyz")?.toMutable()?.let {
            it.setString("name", "apples")
            database.save(it)
        }
        // end::update-document[]
    }

    // ### Typed Accessors
    fun testTypedAccessors() {
        val doc = MutableDocument()

        // tag::date-getter[]
        doc.setValue("createdAt", Date())
        val date = doc.getDate("createdAt")
        // end::date-getter[]
    }

    // ### Batch operations
    fun testBatchOperations() {
        // tag::batch[]
        database.inBatch(UnitOfWork {
            for (i in 0..9) {
                val doc = MutableDocument()
                doc.let {
                    it.setValue("type", "user")
                    it.setValue("name", "user $i")
                    it.setBoolean("admin", false)
                }
                Log.i(TAG, "saved user document: ${doc.getString("name")}")
            }
        })
        // end::batch[]
    }

    // ### Document Expiration
    @Throws(CouchbaseLiteException::class)
    fun documentExpiration() {
        // tag::document-expiration[]
        // Purge the document one day from now
        database.setDocumentExpiration("doc123", Date(Instant.now().plus(1, ChronoUnit.DAYS).toEpochMilli()))

        // Reset expiration
        database.setDocumentExpiration("doc1", null)

        // Query documents that will be expired in less than five minutes
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.longValue(Instant.now().plus(5, ChronoUnit.MINUTES).toEpochMilli())
                )
            )
        // end::document-expiration[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testDocumentChangeListener() {
        // tag::document-listener[]
        // Version using Kotlin Flows to follow shortly ...

        database.addDocumentChangeListener("user.john") { change -&gt;
            database.getDocument(change.documentID)?.let {
                Toast.makeText(context, "Status: ${it.getString("verified_account")}", Toast.LENGTH_SHORT).show()
            }
        }
        // end::document-listener[]
    }

    // ### Blobs
    fun testBlobs() {
        val mDoc = MutableDocument()

        // tag::blob[]
        PlatformUtils.getAsset("avatar.jpg")?.use { <i class="conum" data-value="17"></i><b>(17)</b>
            mDoc.setBlob("avatar", Blob("image/jpeg", it)) <i class="conum" data-value="18"></i><b>(18)</b> <i class="conum" data-value="19"></i><b>(19)</b>
            database.save(mDoc)
        }

        val doc = database.getDocument(mDoc.id)
        val bytes = doc?.getBlob("avatar")?.content
        // end::blob[]
    }
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.Dictionary
import com.couchbase.lite.Expression
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.MutableDictionary
import com.couchbase.lite.PredictionFunction
import com.couchbase.lite.PredictiveIndex
import com.couchbase.lite.PredictiveModel
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.SelectResult
import com.couchbase.lite.ValueIndex
import com.couchbase.lite.ValueIndexItem


private const val TAG = "PREDICT"

// `tensorFlowModel` is a fake implementation
object TensorFlowModel {
    fun predictImage(data: ByteArray?) = mapOf&lt;String, Any?&gt;()
}

object ImageClassifierModel : PredictiveModel {
    const val name = "ImageClassifier"

    override fun predict(input: Dictionary): Dictionary? {
        val blob: Blob = input.getBlob("photo") ?: return null

        // this would be the implementation of the ml model you have chosen
        return MutableDictionary(TensorFlowModel.predictImage(blob.content)) <i class="conum" data-value="1"></i><b>(1)</b>
    }
} // end::predictive-model[]


@Suppress("unused")
class PredictiveQueryExamples {
    @Throws(CouchbaseLiteException::class)
    fun testPredictiveModel() {
        val database = Database("mydb")

        // tag::register-model[]
        Database.prediction.registerModel("ImageClassifier", ImageClassifierModel)
        // end::register-model[]

        // tag::predictive-query-value-index[]
        val index: ValueIndex = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")))
        database.createIndex("value-index-image-classifier", index)
        // end::predictive-query-value-index[]

        // tag::unregister-model[]
        Database.prediction.unregisterModel("ImageClassifier")
        // end::unregister-model[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveIndex() {
        val database = Database("mydb")

        // tag::predictive-query-predictive-index[]
        val inputMap: MutableMap&lt;String, Any&gt; = mutableMapOf()
        inputMap["numbers"] = Expression.property("photo")
        val input: Expression = Expression.map(inputMap)
        val index: PredictiveIndex = IndexBuilder.predictiveIndex("ImageClassifier", input, null)
        database.createIndex("predictive-index-image-classifier", index)
        // end::predictive-query-predictive-index[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveQuery() {
        val database = Database("mydb")

        // tag::predictive-query[]
        val prediction: PredictionFunction = Function.prediction(
            ImageClassifierModel.name,
            Expression.map(mutableMapOf("photo" to Expression.property("photo")) as Map&lt;String, Any&gt;?) <i class="conum" data-value="1"></i><b>(1)</b>
        )

        // !!! Is this query using that prediction function, at all?
        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("label").equalTo(Expression.string("car"))
                    .and(
                        Expression.property("probability")
                            .greaterThanOrEqualTo(Expression.doubleValue(0.8))
                    )
            )
            .execute()

        Log.d(TAG, "Number of rows: ${rs.allResults().size}")
        // end::predictive-query[]
    }
}


// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorStatus


private const val TAG = "PENDING"

@Suppress("unused")
class PendingDocsExample(private var replicator: Replicator) {
    //
    // tag::replication-pendingdocuments[]
    //
    private fun onStatusChanged(pendingDocs: Set&lt;String&gt;, status: ReplicatorStatus) {
        // ... sample onStatusChanged function
        //
        Log.i(TAG, "Replicator activity level is ${status.activityLevel}")

        // iterate and report-on previously
        // retrieved pending docids 'list'
        val itr = pendingDocs.iterator()
        while (itr.hasNext()) {
            val docId = itr.next()

            // tag::replication-push-isdocumentpending[]
            if (!replicator.isDocumentPending(docId)) { <i class="conum" data-value="20"></i><b>(20)</b>
                continue
            }

            // end::replication-push-isdocumentpending[]
            Log.i(TAG, "Doc ID $docId has been pushed")
        }
    } // end::replication-pendingdocuments[]
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Endpoint
import com.couchbase.lite.KeyStoreUtils
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.net.URI
import java.net.URISyntaxException
import java.security.KeyStore
import java.security.cert.Certificate

private const val TAG = "P2P"


@Suppress("unused")
class IBExamples(private val context: Context, private val caCert: Certificate) {
    private val database: Database
    private var thisReplicator: Replicator? = null
    private var thisListener: URLEndpointListener? = null

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        database = Database("p2p_demo")

        /* do some stuff here */
    }

    // PASSIVE PEER STUFF
    fun ibListenerSimple() {
        // tag::listener-simple[]
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database,
                authenticator
                = ListenerPasswordAuthenticator { user, pwd -&gt; (user == "daniel") &amp;&amp; (String(pwd) == "123") })
        ) <i class="conum" data-value="21"></i><b>(21)</b>
        listener.start() <i class="conum" data-value="22"></i><b>(22)</b>
        thisListener = listener

        // end::listener-simple[]
    }

    fun ibReplicatorSimple() {
        // tag::replicator-simple[]
        val theListenerEndpoint: Endpoint = URLEndpoint(URI("wss://10.0.2.2:4984/db")) <i class="conum" data-value="23"></i><b>(23)</b>
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,
                target = theListenerEndpoint,
                authenticator = BasicAuthenticator("valid.user", "valid.password.string".toCharArray()), <i class="conum" data-value="24"></i><b>(24)</b>
                acceptOnlySelfSignedServerCertificate = true
            )
        )
        repl.start() <i class="conum" data-value="25"></i><b>(25)</b>
        thisReplicator = repl
        // end::replicator-simple[]
    }

    fun ibPassListener(validUser: String, validPassword: CharArray) {
        // EXAMPLE 1
        // tag::listener-start[]
        // Initialize the listener
        // tag::listener-initialize[]
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                // tag::listener-config-db[]
                database = database, <i class="conum" data-value="26"></i><b>(26)</b>
                // end::listener-config-db[]
                // tag::listener-config-port[]
                port = 55990, <i class="conum" data-value="27"></i><b>(27)</b>
                // end::listener-config-port[]
                // tag::listener-config-netw-iface[]
                networkInterface = "10.1.1.10", <i class="conum" data-value="28"></i><b>(28)</b>

                // end::listener-config-netw-iface[]
                // tag::listener-config-delta-sync[]
                enableDeltaSync = false, <i class="conum" data-value="29"></i><b>(29)</b>

                // end::listener-config-delta-sync[]
                // tag::listener-config-tls-full[]
                // Configure server security
                // tag::listener-config-tls-enable[]
                disableTls = false, <i class="conum" data-value="30"></i><b>(30)</b>

                // end::listener-config-tls-enable[]
                // tag::listener-config-tls-id-anon[]
                // Use an Anonymous Self-Signed Cert
                identity = null, <i class="conum" data-value="31"></i><b>(31)</b>
                // end::listener-config-tls-id-anon[]

                // tag::listener-config-client-auth-pwd[]
                // Configure Client Security using an Authenticator
                // For example, Basic Authentication <i class="conum" data-value="32"></i><b>(32)</b>
                authenticator = ListenerPasswordAuthenticator { username, paassword -&gt;
                    (username === validUser) &amp;&amp; (paassword === validPassword)
                }
            ))

        // Start the listener
        listener.start() <i class="conum" data-value="33"></i><b>(33)</b>
        thisListener = listener

        // end::listener-initialize[]
        // end::listener-start[]
    }

    fun ibListenerGetNetworkInterfaces() {
        // tag::listener-get-network-interfaces[]
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        listener.start()
        Log.i(TAG, "URLS are ${listener.urls}")
        thisListener = listener
        // end::listener-get-network-interfaces[]
    }

    fun ibListenerLocalDb() {
        // tag::listener-local-db[]
        // . . . preceding application logic . . .
        CouchbaseLite.init(context) <i class="conum" data-value="34"></i><b>(34)</b>
        val thisDB = Database("passivepeerdb")
        // end::listener-local-db[]
    }

    fun ibListenerConfigTlsDisable() {
        // tag::listener-config-tls-disable[]
        URLEndpointListenerConfigurationFactory.create(database, disableTls = false) <i class="conum" data-value="35"></i><b>(35)</b>
        // end::listener-config-tls-disable[]
    }


    // !!! USERS SHOULD BE CAUTIONED THAT THIS IS INSECURE
    // Android has much better ways of importing keys
    fun ibListenerConfigTlsIdFull() {
        // tag::listener-config-tls-id-full[]
        // tag::listener-config-tls-id-caCert[]
        // Use CA Cert
        // Import a key pair into secure storage
        // Create a TLSIdentity from the imported key-pair

        this.javaClass.getResourceAsStream("serverkeypair.p12")?.use { <i class="conum" data-value="36"></i><b>(36)</b>
            KeyStoreUtils.importEntry(
                "teststore.p12",  // KeyStore type, eg: "PKCS12"
                it,  // An InputStream from the keystore
                "let me in".toCharArray(),  // The keystore password
                "topSekritKey",  // The alias to be used (in external keystore)
                null,  // The key password or null if the key has none
                "test-alias" // The alias for the imported key
            )
        }

        // end::listener-config-tls-id-caCert[]

        // tag::listener-config-tls-id-set[]
        // Set the TLS Identity
        URLEndpointListenerConfigurationFactory.create(
            database,
            identity = TLSIdentity.getIdentity("test-alias")
        ) <i class="conum" data-value="37"></i><b>(37)</b>

        // end::listener-config-tls-id-set[]
// end::listener-config-tls-id-full[]
    }

    fun ibListenerConfigClientAuthRoot() {
// tag::listener-config-client-root-ca[]
        // tag::listener-config-client-auth-root[]
        // Configure the client authenticator
        // to validate using ROOT CA
        // thisClientID.certs is a list containing a client cert to accept
        // and any other certs needed to complete a chain between the client cert
        // and a CA
        val validId = TLSIdentity.getIdentity("Our Corporate Id")
            ?: throw IllegalStateException("Cannot find corporate id")
        // accept only clients signed by the corp cert
        thisListener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                // get the identity <i class="conum" data-value="38"></i><b>(38)</b>
                database = database,
                identity = validId,
                authenticator = ListenerCertificateAuthenticator(validId.certs)
            )
        ) <i class="conum" data-value="39"></i><b>(39)</b>

        // end::listener-config-client-auth-root[]
// end::listener-config-client-root-ca[]
    }

    fun ibListenerConfigTlsDisable2() {

        // tag::listener-config-tls-disable[]
        URLEndpointListenerConfigurationFactory.create(database = database, disableTls = true)
        // end::listener-config-tls-disable[]
    }

    fun ibListenerStatusCheck() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        // tag::listener-status-check[]
        val connectionCount = listener.status?.connectionCount <i class="conum" data-value="40"></i><b>(40)</b>
        val activeConnectionCount = listener.status?.activeConnectionCount <i class="conum" data-value="41"></i><b>(41)</b>
        // end::listener-status-check[]
    }

    fun ibListenerStop() {

        // tag::listener-stop[]
        thisListener?.stop()

        // end::listener-stop[]
    }

    // ACTIVE PEER STUFF
// Replication code
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testActPeerSync() {
        // tag::p2p-act-rep-start-full[]
        // Create replicator
        // Consider holding a reference somewhere
        // to prevent the Replicator from being GCed
        val repl = Replicator( <i class="conum" data-value="42"></i><b>(42)</b>

            // tag::p2p-act-rep-func[]
            // tag::p2p-act-rep-initialize[]
            // initialize the replicator configuration
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(URI("wss://listener.com:8954")), <i class="conum" data-value="43"></i><b>(43)</b>

                // end::p2p-act-rep-initialize[]
                // tag::p2p-act-rep-config-type[]
                // Set replicator type
                type = ReplicatorType.PUSH_AND_PULL,

                // end::p2p-act-rep-config-type[]
                // tag::p2p-act-rep-config-cont[]
                // Configure Sync Mode
                continuous = false, // default value

                // end::p2p-act-rep-config-cont[]

                // tag::autopurge-override[]
                // set auto-purge behavior
                // (here we override default)
                enableAutoPurge = false, <i class="conum" data-value="44"></i><b>(44)</b>

                // end::autopurge-override[]


                // tag::p2p-act-rep-config-self-cert[]
                // Configure Server Authentication --
                // only accept self-signed certs
                acceptOnlySelfSignedServerCertificate = true, <i class="conum" data-value="45"></i><b>(45)</b>

                // end::p2p-act-rep-config-self-cert[]
                // tag::p2p-act-rep-auth[]
                // Configure the credentials the
                // client will provide if prompted
                authenticator = BasicAuthenticator("Our Username", "Our PasswordValue".toCharArray()), <i class="conum" data-value="46"></i><b>(46)</b>


                // end::p2p-act-rep-auth[]
                // tag::p2p-act-rep-config-conflict[]
                /* Optionally set custom conflict resolver call back */
                conflictResolver = null <i class="conum" data-value="47"></i><b>(47)</b>
            )
        )

        // end::p2p-act-rep-config-conflict[]

        // tag::p2p-act-rep-add-change-listener[]
        // tag::p2p-act-rep-add-change-listener-label[]
        // Optionally add a change listener <i class="conum" data-value="48"></i><b>(48)</b>
        // end::p2p-act-rep-add-change-listener-label[]
        val thisListener = repl.addChangeListener { change -&gt;
            val err: CouchbaseLiteException? = change.status.error
            if (err != null) {
                Log.i(TAG, "Error code ::  ${err.code}", err)
            }
        }

        // end::p2p-act-rep-add-change-listener[]
        // tag::p2p-act-rep-start[]
        // Start replicator
        repl.start(false) <i class="conum" data-value="49"></i><b>(49)</b>
        thisReplicator = repl

        // end::p2p-act-rep-start[]
        // end::p2p-act-rep-start-full[]
        // end::p2p-act-rep-func[]         ***** End p2p-act-rep-func
    }

    fun ibReplicatorConfig() {
        // BEGIN additional snippets
        // tag::p2p-act-rep-config-tls-full[]

        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,

                // tag::p2p-act-rep-config-cacert[]
                // Configure Server Security
                // -- only accept CA attested certs
                acceptOnlySelfSignedServerCertificate = false, <i class="conum" data-value="50"></i><b>(50)</b>

                // end::p2p-act-rep-config-cacert[]


                // tag::p2p-act-rep-config-cacert-pinned[]

                // Use the pinned certificate from the byte array (cert)
                pinnedServerCertificate = caCert.encoded, <i class="conum" data-value="51"></i><b>(51)</b>
                // end::p2p-act-rep-config-cacert-pinned[]


                // end::p2p-act-rep-config-tls-full[]
                // tag::p2p-tlsid-tlsidentity-with-label[]
                // ... other replicator configuration
                // Provide a client certificate to the server for authentication
                authenticator = ClientCertificateAuthenticator(
                    TLSIdentity.getIdentity("clientId")
                        ?: throw IllegalStateException("Cannot find client id")
                ) <i class="conum" data-value="52"></i><b>(52)</b>

                // ... other replicator configuration

            )
        )

        thisReplicator = repl
        // end::p2p-tlsid-tlsidentity-with-label[]
    }

    fun ibP2pReplicatorStatus() {
        // tag::p2p-act-rep-status[]
        thisReplicator?.status?.let {
            Log.i(TAG, "The Replicator is currently ${it.activityLevel}")
            Log.i(TAG, "The Replicator has processed ${it.progress}")
            Log.i(
                TAG,
                if (it.activityLevel === ReplicatorActivityLevel.BUSY) {
                    "Replication Processing"
                } else {
                    "It has completed ${it.progress.total} changes"
                }
            )
        }
        // end::p2p-act-rep-status[]
    }

    fun ibP2pReplicatorStop() {
        // tag::p2p-act-rep-stop[]
        // Stop replication.
        thisReplicator?.stop() <i class="conum" data-value="53"></i><b>(53)</b>
        // end::p2p-act-rep-stop[]
    }

    fun ibP2pListener() {
        CouchbaseLite.init(context)
        val thisDB = Database("passivepeerdb") <i class="conum" data-value="54"></i><b>(54)</b>


        // Initialize the listener
        val listener = URLEndpointListener( <i class="conum" data-value="55"></i><b>(55)</b>

            // Initialize the listener config
            URLEndpointListenerConfigurationFactory.create(
                database = thisDB,
                port = 55990, /* &lt;.&gt;  Optional; defaults to auto */
                disableTls = false, /* &lt;.&gt;  Optional; defaults to false */
                enableDeltaSync = true,  /* &lt;.&gt; Optional; defaults to false */

                // Configure the client authenticator (if using basic auth)
                authenticator = ListenerPasswordAuthenticator { username, password -&gt;
                    ("username" === username) &amp;&amp; (password === "password".toCharArray())  <i class="conum" data-value="56"></i><b>(56)</b>
                }
            )
        )

        // Start the listener
        listener.start() <i class="conum" data-value="57"></i><b>(57)</b>


        // tag::createTlsIdentity[]

//        Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
//                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
//                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
//        );
        val thisIdentity = TLSIdentity.createIdentity(
            true,
            mapOf(
                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
            ),
            null,
            "test-alias"
        )

        // end::createTlsIdentity[]

        // tag::p2p-tlsid-store-in-keychain[]
        // end::p2p-tlsid-store-in-keychain[]


        // tag::deleteTlsIdentity[]
        // tag::p2p-tlsid-delete-id-from-keychain[]
        val thisAlias = "alias-to-delete"
        val thisKeyStore = KeyStore.getInstance("AndroidKeyStore")
        thisKeyStore.load(null)
        thisKeyStore.deleteEntry(thisAlias)

        // end::p2p-tlsid-delete-id-from-keychain[]
        // end::deleteTlsIdentity[]

        // tag::retrieveTlsIdentity[]
        // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label
        val thatIdentity = TLSIdentity.getIdentity("couchbase-docs-cert")
        // end::retrieveTlsIdentity[]
    }

    // tag::sgw-repl-pull[]
    fun ibRplicatorPull() {
        val database = Database("ian")

        val uri = URI("wss://10.0.2.2:4984/db") <i class="conum" data-value="58"></i><b>(58)</b>

        val repl = Replicator( <i class="conum" data-value="59"></i><b>(59)</b>
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(uri),
                type = ReplicatorType.PULL
            )
        )

        repl.start()
        thisReplicator = repl
    }

    // end::sgw-repl-pull[]
// tag::sgw-act-rep-initialize[]
// initialize the replicator configuration
    val thisConfig = ReplicatorConfigurationFactory.create(
        database = database,
        target = URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))
    ) // &lt;.&gt; // end::sgw-act-rep-initialize[]

/* C A L L O U T S

// Listener Callouts

// tag::listener-callouts-full[]

// tag::listener-start-callouts[]
&lt;.&gt; Initialize the listener instance using the configuration settings.
&lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.

// end::listener-start-callouts[]

// tag::listener-status-check-callouts[]

&lt;.&gt; `connectionCount` -- the total number of connections served by the listener
&lt;.&gt; `activeConnectionCount` -- the number of active (BUSY) connections currently being served by the listener
//
// end::listener-status-check-callouts[]

// end::listener-callouts-full[]


// tag::p2p-act-rep-config-cacert-pinned-callouts[]
&lt;.&gt; Configure the pinned certificate using data from the byte array `cert`
// end::p2p-act-rep-config-cacert-pinned-callouts[]

// tag::p2p-tlsid-tlsidentity-with-label-callouts[]
&lt;.&gt; Attempt to get the identity from secure storage
&lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity

// end::p2p-tlsid-tlsidentity-with-label-callouts[]

// tag::sgw-repl-pull-callouts[]
&lt;.&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;.&gt; The URL scheme for remote database URLs uses `ws:`, or `wss:` for SSL/TLS connections over wb sockets.
In this example the hostname is `10.0.2.2` because the Android emulator runs in a VM that is generally accessible on `10.0.2.2` from the host machine (see https://developer.android.com/studio/run/emulator-networking[Android Emulator networking] documentation).
+
NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
Although `wss:` protocol URLs are not affected, in order to use the `ws:` protocol, applications must target API 27 or lower, or must configure application network security as described https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted[here].

// end::sgw-repl-pull-callouts[]
*/
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.net.URI
import java.security.KeyStore
import java.security.KeyStoreException
import java.security.NoSuchAlgorithmException
import java.security.cert.Certificate
import java.security.cert.CertificateEncodingException
import java.security.cert.CertificateException
import java.util.concurrent.CountDownLatch

private const val TAG = "LISTEN"

@Suppress("unused")
class CertAuthListener {
    companion object {
        private val CERT_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "CBL Test",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "lite@couchbase.com",
        )
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)

        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        remoteDb.save(doc)

        val serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server")

        val clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client")
        val uri = startServer(remoteDb, serverIdentity, clientIdentity.certs)
            ?: throw IOException("Failed to start the server")

        Thread {
            startClient(localDb, uri, clientIdentity, serverIdentity.certs[0])
            Log.e(TAG, "Success!!")
            deleteIdentity("server")
            Log.e(TAG, "Alias deleted: server")
            deleteIdentity("client")
            Log.e(TAG, "Alias deleted: client")
        }.start()
    }

    // start a client replicator
    @Throws(CertificateEncodingException::class, InterruptedException::class)
    fun startClient(db: Database, uri: URI, clientIdentity: TLSIdentity, cert: Certificate) {
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = db,
                target = URLEndpoint(uri),
                type = ReplicatorType.PUSH_AND_PULL,
                continuous = false,
                authenticator = ClientCertificateAuthenticator(clientIdentity),
                pinnedServerCertificate = cert.encoded
            )
        )

        val completionLatch = CountDownLatch(1)

        repl.addChangeListener { change -&gt;
            if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    // tag::listener-config-auth-cert-full[]
    /**
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     *
     *
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Throws(CouchbaseLiteException::class)
    fun startServer(db: Database, serverId: TLSIdentity, certs: List&lt;Certificate?&gt;): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0, // this is the default
                disableTls = false,
                identity = serverId,
                authenticator = ListenerCertificateAuthenticator(certs)
            )
        )
        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
    // end::listener-config-auth-cert-full[]
    // tag::listener-config-delete-cert-full[]
    /**
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    @Throws(
        KeyStoreException::class,
        CertificateException::class,
        NoSuchAlgorithmException::class,
        IOException::class
    )
    fun deleteIdentity(alias: String?) {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        keyStore.deleteEntry(alias) <i class="conum" data-value="60"></i><b>(60)</b>
    }
    // end::listener-config-delete-cert-full[]
    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /**
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     *
     *
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    @Throws(CertificateEncodingException::class)
    private fun configureClientCerts(
        config: ReplicatorConfiguration,
        cert: Certificate,
        clientIdentity: TLSIdentity
    ) {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(ClientCertificateAuthenticator(clientIdentity))

        // Configure the pinned certificate passing a byte array.
        config.pinnedServerCertificate = cert.encoded
    }
    // notend::p2p-tlsid-tlsidentity-with-label[]
    /**
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     *
     *
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    @Throws(IOException::class)
    private fun readCertMaterialFromBundle(
        context: Context,
        resId: Int
    ): ByteArray {
        val out = ByteArrayOutputStream()
        val `in` = context.resources.openRawResource(resId)
        val buf = ByteArray(1024)
        var n: Int
        while (`in`.read(buf).also { n = it } &gt;= 0) {
            out.write(buf, 0, n)
        }
        return out.toByteArray()
    }
}

@Suppress("unused")
class PasswordAuthListener {
    companion object {
        private const val VALID_USER = "Minnie"
        private val VALID_PASSWORD = "let me in!".toCharArray()
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray())
            ?: throw IOException("Failed to start the server")
        Thread {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb)
                Log.e(TAG, "Success!!")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }.start()
    }

    // start a client replicator
    @Throws(InterruptedException::class)
    fun runClient(
        uri: URI,
        username: String,
        password: CharArray,
        db: Database
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.type = ReplicatorType.PUSH_AND_PULL
        config.isContinuous = false
        config.setAuthenticator(BasicAuthenticator(username, password))
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)

        // Version using Kotlin Flows to follow shortly ...
        repl.addChangeListener { change -&gt;
            if (change.status
                    .activityLevel == ReplicatorActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    // tag::listener-config-client-auth-pwd-full[]
    /**
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     *
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    fun startServer(db: Database, username: String, password: CharArray): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0,// this is the default
                disableTls = true,
                authenticator = ListenerPasswordAuthenticator { usr, pwd -&gt;
                    (usr == username) &amp;&amp; pwd.contentEquals(password)
                })
        )

        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
// end::listener-config-client-auth-pwd-full[]
}





// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Message
import com.couchbase.lite.MessageEndpoint
import com.couchbase.lite.MessageEndpointConnection
import com.couchbase.lite.MessageEndpointDelegate
import com.couchbase.lite.MessageEndpointListener
import com.couchbase.lite.MessageEndpointListenerConfigurationFactory
import com.couchbase.lite.MessagingCloseCompletion
import com.couchbase.lite.MessagingCompletion
import com.couchbase.lite.ProtocolType
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorConnection
import com.couchbase.lite.create


@Suppress("unused")
class BrowserSessionManager : MessageEndpointDelegate {
    private var replicator: Replicator? = null

    @Throws(CouchbaseLiteException::class)
    fun initCouchbase() {
        // tag::message-endpoint[]
        val database = Database("mydb")

        // The delegate must implement the `MessageEndpointDelegate` protocol.
        val messageEndpoint = MessageEndpoint("UID:123", "active", ProtocolType.MESSAGE_STREAM, this)
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        // Create the replicator object.
        val repl = Replicator(ReplicatorConfigurationFactory.create(database = database, target = messageEndpoint))
        // Start the replication.
        repl.start()
        replicator = repl
        // end::message-endpoint-replicator[]
    }

    // tag::create-connection[]
    /* implementation of MessageEndpointDelegate */
    override fun createConnection(endpoint: MessageEndpoint) = ActivePeerConnection()
    // end::create-connection[]
}

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ----------------------------------------------------------- */

@Suppress("unused")
class ActivePeerConnection : MessageEndpointConnection {
    private var replicatorConnection: ReplicatorConnection? = null

    // tag::active-replicator-close[]
    fun disconnect() {
        replicatorConnection?.close(null)
        replicatorConnection = null
    }
    // end::active-replicator-close[]

    // tag::active-peer-open[]
    /* implementation of MessageEndpointConnection */
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    // end::active-peer-open[]
    // tag::active-peer-close[]
    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete()
    }

    // end::active-peer-close[]
    // tag::active-peer-send[]
    /* implementation of MessageEndpointConnection */
    override fun send(message: Message, completion: MessagingCompletion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null)
    }

    // end::active-peer-send[]
    fun receive(message: Message) {
        // tag::active-peer-receive[]
        replicatorConnection?.receive(message)
        // end::active-peer-receive[]
    }
}

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ----------------------------------------------------------- */

@Suppress("unused")
class PassivePeerConnection private constructor() : MessageEndpointConnection {
    private var messageEndpointListener: MessageEndpointListener? = null
    private var replicatorConnection: ReplicatorConnection? = null

    @Throws(CouchbaseLiteException::class)
    fun startListener() {
        // tag::listener[]
        val database = Database("mydb")
        messageEndpointListener = MessageEndpointListener(
            MessageEndpointListenerConfigurationFactory.create(database, ProtocolType.MESSAGE_STREAM)
        )
        // end::listener[]
    }

    fun stopListener() {
        // tag::passive-stop-listener[]
        messageEndpointListener?.closeAll()
        // end::passive-stop-listener[]
    }

    fun accept() {
        // tag::advertizer-accept[]
        val connection = PassivePeerConnection() /* implements MessageEndpointConnection */
        messageEndpointListener?.accept(connection)
        // end::advertizer-accept[]
    }

    fun disconnect() {
        // tag::passive-replicator-close[]
        replicatorConnection?.close(null)
        // end::passive-replicator-close[]
    }

    // tag::passive-peer-open[]
    /* implementation of MessageEndpointConnection */
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }
    // end::passive-peer-open[]

    // tag::passive-peer-close[]
    /* implementation of MessageEndpointConnection */
    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete()
    }

    // end::passive-peer-close[]
    // tag::passive-peer-send[]
    /* implementation of MessageEndpointConnection */
    override fun send(message: Message, completion: MessagingCompletion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null)
    }

    // end::passive-peer-send[]
    fun receive(message: Message) {
        // tag::passive-peer-receive[]
        replicatorConnection?.receive(message)
        // end::passive-peer-receive[]
    }

} // tag::predictive-model[]



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.ArrayFunction
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.Expression
import com.couchbase.lite.FullTextExpression
import com.couchbase.lite.FullTextIndexItem
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.Join
import com.couchbase.lite.Meta
import com.couchbase.lite.Ordering
import com.couchbase.lite.Query
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.SelectResult
import com.couchbase.lite.ValueIndexItem
import com.fasterxml.jackson.databind.ObjectMapper
import org.json.JSONException


private const val TAG = "QUERY"
private const val DATABASE_NAME = "database"

data class Hotel(
    var description: String? = null,
    var country: String? = null,
    var city: String? = null,
    var name: String? = null,
    var type: String? = null,
    var id: String? = null
)

@Suppress("unused")
class QueryExamples(private val database: Database) {

    // ### Indexing
    @Throws(CouchbaseLiteException::class)
    fun testIndexing() {
        // tag::query-index[]
        database.createIndex(
            "TypeNameIndex",
            IndexBuilder.valueIndex(
                ValueIndexItem.property("type"),
                ValueIndexItem.property("name")
            )
        )
        // end::query-index[]
    }

    // ### SELECT statement
    fun testSelectStatement() {
        // tag::query-select-meta[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("type")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.expression(Meta.id))
            .execute()

        for (result in rs) {
            Log.i(TAG, "hotel id -&gt;${result.getString("id")}")
            Log.i(TAG, "hotel name -&gt; ${result.getString("name")}")
        }
        // end::query-select-meta[]
    }

    // META function
    @Throws(CouchbaseLiteException::class)
    fun testMetaFunction() {
        val rs = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("airport")))
            .orderBy(Ordering.expression(Meta.id))
            .execute()

        for (result in rs) {
            Log.w(TAG, "airport id -&gt;${result.getString("id")}")
            Log.w(TAG, "airport id -&gt; ${result.getString(0)}")
        }
    }

    // ### all(*)
    @Throws(CouchbaseLiteException::class)
    fun testSelectAll() {
        // tag::query-select-all[]
        val queryAll = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
        // end::query-select-all[]

        // tag::live-query[]
        val query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="61"></i><b>(61)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        // Version using Kotlin Flows to follow shortly ...
        val token = query.addChangeListener { change -&gt;
            change.results?.let {
                for (result in it) {
                    Log.d(TAG, "results: ${result.keys}")
                    /* Update UI */
                }
            } <i class="conum" data-value="62"></i><b>(62)</b>
        }

        // end::live-query[]

        // tag::stop-live-query[]
        query.removeChangeListener(token)
        // end::stop-live-query[]

        for (result in query.execute()) {
            Log.i(TAG, "hotel -&gt; ${result.getDictionary(DATABASE_NAME)?.toMap()}")
        }
    }


    // ###WHERE statement
    @Throws(CouchbaseLiteException::class)
    fun testWhereStatement() {
        // tag::query-where[]
        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.intValue(10))
            .execute()
        for (result in rs) {
            result.getDictionary(DATABASE_NAME)?.let {
                Log.i(TAG, "name -&gt; ${it.getString("name")}")
                Log.i(TAG, "type -&gt; ${it.getString("type")}")
            }
        }
        // end::query-where[]
    }

    fun testQueryDeletedDocuments() {
        // tag::query-deleted-documents[]
        // Query documents that have been deleted
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted)
        // end::query-deleted-documents[]
    }

    // ####Collection Operators
    @Throws(CouchbaseLiteException::class)
    fun testCollectionStatement() {
        // tag::query-collection-operator-contains[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(
                        ArrayFunction.contains(
                            Expression.property("public_likes"),
                            Expression.string("Armani Langworth")
                        )
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.getArray("public_likes")?.toList()}")
        }
        // end::query-collection-operator-contains[]
    }

    // IN operator
    @Throws(CouchbaseLiteException::class)
    fun testInOperator() {
        // tag::query-collection-operator-in[]
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.string("Armani").`in`(
                    Expression.property("first"),
                    Expression.property("last"),
                    Expression.property("username")
                )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.toMap()}")
        }
        // end::query-collection-operator-in[]
    }

    // Pattern Matching
    @Throws(CouchbaseLiteException::class)
    fun testPatternMatching() {
        // tag::query-like-operator[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-like-operator[]
    }

    // ### Wildcard Match
    @Throws(CouchbaseLiteException::class)
    fun testWildcardMatch() {
        // tag::query-like-operator-wildcard-match[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-like-operator-wildcard-match[]
    }

    // Wildcard Character Match
    @Throws(CouchbaseLiteException::class)
    fun testWildCharacterMatch() {
        // tag::query-like-operator-wildcard-character-match[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng____r"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-like-operator-wildcard-character-match[]
    }

    // ### Regex Match
    @Throws(CouchbaseLiteException::class)
    fun testRegexMatch() {
        // tag::query-regex-operator[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .regex(Expression.string("\\beng.*r\\b"))
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-regex-operator[]
    }

    // JOIN statement
    @Throws(CouchbaseLiteException::class)
    fun testJoinStatement() {
        // tag::query-join[]
        val rs = QueryBuilder.select(
            SelectResult.expression(Expression.property("name").from("airline")),
            SelectResult.expression(Expression.property("callsign").from("airline")),
            SelectResult.expression(Expression.property("destinationairport").from("route")),
            SelectResult.expression(Expression.property("stops").from("route")),
            SelectResult.expression(Expression.property("airline").from("route"))
        )
            .from(DataSource.database(database).`as`("airline"))
            .join(
                Join.join(DataSource.database(database).`as`("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(
                        Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline"))
                    )
                    .and(
                        Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.toMap()}")
        }
        // end::query-join[]
    }


    // ### GROUPBY statement
    @Throws(CouchbaseLiteException::class)
    fun testGroupByStatement() {
        // tag::query-groupby[]
        val rs = QueryBuilder.select(
            SelectResult.expression(Function.count(Expression.string("*"))),
            SelectResult.property("country"),
            SelectResult.property("tz")
        )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300)))
            )
            .groupBy(
                Expression.property("country"), Expression.property("tz")
            )
            .orderBy(Ordering.expression(Function.count(Expression.string("*"))).descending())
            .execute()

        for (result in rs) {
            result.let {
                Log.i(
                    TAG,
                    "There are ${it.getInt("$1")} airports on the ${
                        it.getString("tz")
                    } timezone located in ${
                        it.getString("country")
                    } and above 300ft"
                )
            }
            // end::query-groupby[]
        }
    }

    // ### ORDER BY statement
    @Throws(CouchbaseLiteException::class)
    fun testOrderByStatement() {
        // tag::query-orderby[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("name").ascending())
            .limit(Expression.intValue(10))
            .execute()

        for (result in rs) {
            Log.i(TAG, "${result.toMap()}")
        }
        // end::query-orderby[]
    }


    // ### EXPLAIN statement
    // tag::query-explain[]
    @Throws(CouchbaseLiteException::class)
    fun testExplainStatement() {
        // tag::query-explain-all[]
        var query: Query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").descending()) <i class="conum" data-value="63"></i><b>(63)</b>
        Log.i(TAG, query.explain()) <i class="conum" data-value="64"></i><b>(64)</b>
        // end::query-explain-all[]

        // tag::query-explain-like[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%"))) <i class="conum" data-value="65"></i><b>(65)</b>
        Log.i(TAG, query.explain())
        // end::query-explain-like[]

        // tag::query-explain-nopfx[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="66"></i><b>(66)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%")))
            )
        Log.i(TAG, query.explain())
        // end::query-explain-nopfx[]

        // tag::query-explain-function[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Function.lower(
                    Expression.property("type").equalTo(Expression.string("hotel"))
                )
            ) <i class="conum" data-value="67"></i><b>(67)</b>
        Log.i(TAG, query.explain())
        // end::query-explain-function[]

        // tag::query-explain-nofunction[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))) <i class="conum" data-value="68"></i><b>(68)</b>
        Log.i(TAG, query.explain())
        // end::query-explain-nofunction[]
    }
// end::query-explain[]

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex() {
        // tag::fts-index[]
        database.createIndex(
            "nameFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("name")).ignoreAccents(false)
        )
        // end::fts-index[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS() {
        // tag::fts-query[]
        val rs = QueryBuilder.select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(FullTextExpression.index("nameFTSIndex").match("buy"))
            .execute()
        for (result in rs) {
            Log.i(TAG, "document properties${result.getString(0)}")
        }
        // end::fts-query[]
    }


    fun testQuerySyntaxAll(currentUser: String) {
        // tag::query-syntax-all[]
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(openOrCreateDatabaseForUser(currentUser)))

            // end::query-syntax-all[]
        // tag::query-access-all[]
        val hotels: HashMap&lt;String, Hotel&gt; = HashMap()

        for (result in listQuery.execute().allResults()) {
            // get the k-v pairs from the 'hotel' key's value into a dictionary
            val thisDocsProps = result.getDictionary(0) <i class="conum" data-value="69"></i><b>(69)</b>
            val thisDocsId = thisDocsProps!!.getString("id")
            val thisDocsName = thisDocsProps.getString("name")
            val thisDocsType = thisDocsProps.getString("type")
            val thisDocsCity = thisDocsProps.getString("city")

            // Alternatively, access results value dictionary directly
            val id = result.getDictionary(0)?.getString("id").toString() <i class="conum" data-value="70"></i><b>(70)</b>
            hotels[id] = Hotel(
                id,
                result.getDictionary(0)?.getString("type"),
                result.getDictionary(0)?.getString("name"),
                result.getDictionary(0)?.getString("city"),
                result.getDictionary(0)?.getString("country"),
                result.getDictionary(0)?.getString("description")
            )
        }

        // end::query-access-all[]
    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun testQuerySyntaxJson(currentUser: String, argDb: Database) {
        Database db = argDb
        // tag::query-syntax-json[]
        // Example assumes Hotel class object defined elsewhere

        // Build the query
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(db))

        // end::query-syntax-json[]
        // tag::query-access-json[]
        // Uses Jackson JSON processor
        val mapper = ObjectMapper()
        val hotels: ArrayList&lt;Hotel&gt; = ArrayList()

        for (result in listQuery.execute()) {

            // Get result as JSON string
            val json = result.toJSON() <i class="conum" data-value="71"></i><b>(71)</b>

            // Get Hashmap from JSON string
            val dictFromJSONstring = mapper.readValue(json, HashMap::class.java) <i class="conum" data-value="72"></i><b>(72)</b>

            // Use created hashmap
            val hotelId = dictFromJSONstring["id"].toString() //
            val hotelType = dictFromJSONstring["type"].toString()
            val hotelname = dictFromJSONstring["name"].toString()


            // Get custom object from JSON string
            val thisHotel = mapper.readValue(json, Hotel::class.java) <i class="conum" data-value="73"></i><b>(73)</b>
            hotels.add(thisHotel)
        }
        // end::query-access-json[]
    }
/* end func testQuerySyntaxJson */

  fun docsOnlyQuerySyntaxN1QL(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      Database db=argDb
      // tag::query-syntax-n1ql[]
      val thisQuery = dbcreateQuery(
            "SELECT META().id AS id FROM _ WHERE type = \"hotel\"") <i class="conum" data-value="74"></i><b>(74)</b>

      return thisQuery.execute().allResults()

      // end::query-syntax-n1ql[]
  }

  fun docsOnlyQuerySyntaxN1QLParams(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      // tag::query-syntax-n1ql-params[]
      val thisQuery = dbcreateQuery(
            "SELECT META().id AS id FROM _ WHERE type = \$type") <i class="conum" data-value="75"></i><b>(75)</b>

      thisQuery.parameters = Parameters().setString("type", "hotel") <i class="conum" data-value="76"></i><b>(76)</b>

      return thisQuery.execute().allResults()

      // end::query-syntax-n1ql-params[]
  }

    fun openOrCreateDatabaseForUser(argUser: String): Database = Database(argUser)
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.Database
import com.couchbase.lite.MutableDictionary

class BlobExamples {

    // Example 2: Using Blobs
    fun example2(context: Context, db: Database) {
        val doc = db.getDocument("1000") ?: return

        // Create a blob from an asset
        val blob = Blob("image/png", context.assets.open("couchbaseimage.png"))

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON()

        // Save the blob as part of a document
        db.save(doc.toMutable().setBlob("avatar", blob))

        // Experts only!!!
        db.saveBlob(blob)

        // Retrieve saved blob and get as JSON again
        val blobAsJSONString = db.getDocument("1000")?.getBlob("avatar")?.toJSON() ?: return

        // reconstitute
        val blobAsMap = MutableDictionary().setJSON(blobAsJSONString).toMap()

        // show the contents of the reconstituted blob
        for ((key, value) in blobAsMap) {
            Log.d("BLOB", "Data: $key -&gt; $value")
        }

        // verify that the reconstitued thing is still blob
        if (Blob.isBlob(blobAsMap)) {
            Log.d("BLOB", blobAsJSONString)
        }
    }
}


// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt </code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Import from an existing resource bundle</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/codesnippet_collection.kt">

// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.Conflict
import com.couchbase.lite.ConflictResolver
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.DatabaseConfiguration
import com.couchbase.lite.DatabaseEndpoint
import com.couchbase.lite.Document
import com.couchbase.lite.DocumentFlag
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.SessionAuthenticator
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.create
import com.couchbase.lite.internal.utils.PlatformUtils
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.io.InputStream
import java.net.URI
import java.net.URISyntaxException


private const val TAG = "REPLICATION"

@Throws(IOException::class)
fun InputStream.toByteArray(): ByteArray {
    val buffer = ByteArray(1024)
    val output = ByteArrayOutputStream()

    var n: Int
    while (-1 &lt; this.read(buffer).also { n = it }) {
        output.write(buffer, 0, n)
    }

    return output.toByteArray()
}

// tag::update-document-with-conflict-handler-callouts[]
//
//        &lt;.&gt; The conflict handler code is provided as a lambda.
//
//        &lt;.&gt; If the handler cannot resolve a conflict, it can return false.
//        In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.
//
//        &lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.
//
//        &lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).
//
//        &lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method
// end::update-document-with-conflict-handler-callouts[]


// tag::local-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
@Suppress("unused")
object LocalWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.localDocument
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
@Suppress("unused")
object RemoteWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.remoteDocument
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
// Using replConfig.setConflictResolver(new MergeConflictResolver());
@Suppress("unused")
object MergeConflictResolver : ConflictResolver {
    override fun resolve(conflict: Conflict): Document {
        val localDoc = conflict.localDocument?.toMap()
        val remoteDoc = conflict.remoteDocument?.toMap()

        val merge: MutableMap&lt;String, Any&gt;?
        if (localDoc == null) {
            merge = remoteDoc
        } else {
            merge = localDoc
            if (remoteDoc != null) {
                merge.putAll(remoteDoc)
            }
        }

        return if (merge == null) {
            MutableDocument(conflict.documentId)
        } else {
            MutableDocument(conflict.documentId, merge)
        }
    }
// end::merge-conflict-resolver[]

    @Suppress("unused")
    class ReplicationExamples(private val database: Database) {
        private var replicator: Replicator? = null

        @Throws(URISyntaxException::class)
        fun testReplicationBasicAuthentication() {
            // tag::basic-authentication[]

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = BasicAuthenticator("username", "password".toCharArray())
                )
            )
            repl.start()
            replicator = repl
            // end::basic-authentication[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationSessionAuthentication() {
            // tag::session-authentication[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447")
                )
            )
            repl.start()
            replicator = repl
            // end::session-authentication[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationStatus() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            // tag::replication-status[]
            // Version using Kotlin Flows to follow shortly ...
            repl.addChangeListener { change -&gt;
                if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                    Log.i(TAG, "Replication stopped")
                }
            }

            repl.start()
            replicator = repl
            // end::replication-status[]
        }

        @Throws(URISyntaxException::class)
        fun testHandlingNetworkErrors() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            // tag::replication-error-handling[]
            // Version using Kotlin Flows to follow shortly ...
            repl.addChangeListener { change -&gt;
                change.status.error?.let {
                    Log.w(TAG, "Error code: ${it.code}")
                }
            }
            repl.start()
            replicator = repl
            // end::replication-error-handling[]

            repl.stop()
        }

        @Throws(URISyntaxException::class)
        fun testReplicatorDocumentEvent() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            // tag::add-document-replication-listener[]
            val token = repl.addDocumentReplicationListener { replication -&gt;
                Log.i(TAG, "Replication type: ${if (replication.isPush) "push" else "pull"}")

                for (document in replication.documents) {
                    document.let { doc -&gt;
                        Log.i(TAG, "Doc ID: ${document.id}")
                        doc.error?.let {
                            // There was an error
                            Log.e(TAG, "Error replicating document: ", it)
                            return@addDocumentReplicationListener
                        }
                        if (doc.flags.contains(DocumentFlag.DELETED)) {
                            Log.i(TAG, "Successfully replicated a deleted document")
                        }
                    }
                }
            }

            repl.start()
            replicator = repl
            // end::add-document-replication-listener[]

            // tag::remove-document-replication-listener[]
            repl.removeChangeListener(token)
            // end::remove-document-replication-listener[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationCustomHeader() {
            // tag::replication-custom-header[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value")
                )
            )
            replicator = repl
            // end::replication-custom-header[]
        }

        // ### Certificate Pinning
        @Throws(URISyntaxException::class, IOException::class)
        fun testCertificatePinning() {
            // tag::certificate-pinning[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value"),
                    pinnedServerCertificate = PlatformUtils.getAsset("cert.cer")?.toByteArray()
                )
            )
            replicator = repl
            // end::certificate-pinning[]
        }

        // ### Reset replicator checkpoint
        @Throws(URISyntaxException::class)
        // tag::replication-startup[]
        fun testReplicationResetCheckpoint() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            // tag::replication-reset-checkpoint[]
            if (resetCheckpointRequired_Example) {
              repl.start(resetCheckpoint = true) <i class="conum" data-value="1"></i><b>(1)</b>
            else
              repl.start(resetCheckpoint = false)
            }
            // end::replication-reset-checkpoint[]

            // ... at some later time

            repl.stop()
        // end::replication-startup[]

        }

        @Throws(URISyntaxException::class)
        fun testReplicationPushFilter() {
            // tag::replication-push-filter[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { _, flags -&gt; flags.contains(DocumentFlag.DELETED) } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
            // end::replication-push-filter[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationPullFilter() {
            // tag::replication-pull-filter[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { document, _ -&gt; "draft" == document.getString("type") } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
            // end::replication-pull-filter[]
        }

        @Throws(URISyntaxException::class)
        fun testCustomRetryConfig() {
            // tag::replication-retry-config[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    //  other config params as required . .
                    // tag::replication-heartbeat-config[]
                    heartbeat = 150, <i class="conum" data-value="1"></i><b>(1)</b>
                    // end::replication-heartbeat-config[]
                    // tag::replication-maxattempts-config[]
                    maxAttempts = 20,
                    // end::replication-maxattempts-config[]
                    maxAttemptWaitTime = 600
                    // end::replication-maxattemptwaittime-config[]
                )
            )

            repl.start()
            replicator = repl
            // end::replication-retry-config[]
        }

        @Throws(CouchbaseLiteException::class)
        fun testDatabaseReplica() {
            val config = DatabaseConfiguration()
            val database1 = Database("mydb", config)
            val database2 = Database("db2", config)

            /* EE feature: code below might throw a compilation error
               if it's compiled against CBL Android Community. */
            // tag::database-replica[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database1,
                    target = DatabaseEndpoint(database2),
                    type = ReplicatorType.PULL
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
            // end::database-replica[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationWithCustomConflictResolver() {
            // tag::replication-conflict-resolver[]
            val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
            val config = ReplicatorConfiguration(database, target)
            config.conflictResolver = LocalWinConflictResolver()
            val replication = Replicator(config)
            replication.start()
            // end::replication-conflict-resolver[]
        }

        @Throws(CouchbaseLiteException::class)
        fun testSaveWithCustomConflictResolver() {
            // tag::update-document-with-conflict-handler[]
            val mutableDocument = database.getDocument("xyz")?.toMutable() ?: return
            mutableDocument.setString("name", "apples")
            database.save(mutableDocument) { newDoc, curDoc -&gt;  <i class="conum" data-value="2"></i><b>(2)</b>
                if (curDoc == null) {
                    return@save false
                } <i class="conum" data-value="3"></i><b>(3)</b>
                val dataMap: MutableMap&lt;String, Any&gt; = curDoc.toMap()
                dataMap.putAll(newDoc.toMap()) <i class="conum" data-value="4"></i><b>(4)</b>
                newDoc.setData(dataMap)
                true <i class="conum" data-value="5"></i><b>(5)</b>
            } <i class="conum" data-value="6"></i><b>(6)</b>
            // end::update-document-with-conflict-handler[]
        }
    }
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import android.widget.Toast
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.Blob
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.DatabaseConfiguration
import com.couchbase.lite.DatabaseConfigurationFactory
import com.couchbase.lite.EncryptionKey
import com.couchbase.lite.Expression
import com.couchbase.lite.LogDomain
import com.couchbase.lite.LogFileConfigurationFactory
import com.couchbase.lite.LogLevel
import com.couchbase.lite.Logger
import com.couchbase.lite.Meta
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.SelectResult
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.UnitOfWork
import com.couchbase.lite.create
import com.couchbase.lite.internal.utils.PlatformUtils
import org.junit.Test
import java.io.File
import java.io.IOException
import java.net.URI
import java.net.URISyntaxException
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.Arrays
import java.util.Date
import java.util.EnumSet


private const val TAG = "BASIC"

// tag::custom-logging[]
class LogTestLogger(private val level: LogLevel) : Logger {
  override fun getLevel() = level

  override fun log(level: LogLevel, domain: LogDomain, message: String) {
    // this method will never be called if param level &lt; this.level
    // handle the message, for example piping it to a third party framework
  }
}

// end::custom-logging[]
// tag::example-app[]
@Suppress("unused")
class BasicExamples(private val context: Context) {
    private val database: Database

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        // Get the database (and create it if it doesnt exist).
        database = Database(
            "getting-started",
            DatabaseConfigurationFactory.create(context.filesDir.absolutePath)
        )
    }

    @Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {

        // !!! Note the code moved from here to the init { } above.
        // tag::getting-started[]
        // Create a new document (i.e. a record) in the database.
        var mutableDoc = MutableDocument().setFloat("version", 2.0f).setString("type", "SDK")

        // Save it to the database.
        database.save(mutableDoc)

        // Update a document.
        mutableDoc = database.getDocument(mutableDoc.id)!!.toMutable().setString("language", "Java")
        database.save(mutableDoc)

        val document = database.getDocument(mutableDoc.id)!!
        // Log the document ID (generated by the database) and properties
        Log.i(TAG, "Document ID :: ${document.id}")
        Log.i(TAG, "Learning ${document.getString("language")}")

        // Create a query to fetch documents of type SDK.
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))
            .execute()
        Log.i(TAG, "Number of rows :: ${rs.allResults().size}")

        // Create a replicator to push and pull changes to and from the cloud.
        // Be sure to hold a reference somewhere to prevent the Replicator from being GCed
        val replicator = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(URI("ws://localhost:4984/getting-started-db")),
                type = ReplicatorType.PUSH_AND_PULL,
                authenticator = BasicAuthenticator("sync-gateway", "password".toCharArray())
            )
        )

        // Listen to replicator change events.
        // Version using Kotlin Flows to follow shortly ...

        replicator.addChangeListener { change -&gt;
            val err = change.status.error
            if (err != null) Log.i(TAG, "Error code ::  ${err.code}")
        }

        // Start replication.
        replicator.start()

        // end::getting-started[]
        database.delete()
    }
    // end::example-app[]

    @Throws(CouchbaseLiteException::class, IOException::class)
    fun test1xAttachments() {
        // if db exist, delete it
        deleteDB("android-sqlite", context.filesDir)
        ZipUtils.unzip(PlatformUtils.getAsset("replacedb/android140-sqlite.cblite2.zip"), context.filesDir)

        val db = Database("android-sqlite")
        try {
            // For Validation
            Arrays.equals(
                "attach1".toByteArray(),
                db.getDocument("doc1")?.getDictionary("_attachments")?.getBlob("attach1")?.content
            )
        } finally {
            // close db
            db.close()
            // if db exist, delete it
            deleteDB("android-sqlite", context.filesDir)
        }
        val document = MutableDocument()

        // tag::1x-attachment[]
        val content = document.getDictionary("_attachments")?.getBlob("avatar")?.content
        // end::1x-attachment[]
    }

    // ### Initializer
    fun testInitializer() {
        // tag::sdk-initializer[]
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)
        // end::sdk-initializer[]
    }

    // ### New Database
    @Throws(CouchbaseLiteException::class)
    fun testNewDatabase() {
        // tag::new-database[]
        val db = Database("my-db", DatabaseConfigurationFactory.create(context.filesDir.absolutePath)) <i class="conum" data-value="7"></i><b>(7)</b>
        // end::new-database[]
        db.delete()
    }

    // ### Database Encryption
    @Throws(CouchbaseLiteException::class)
    fun testDatabaseEncryption() {
        // tag::database-encryption[]
        val db = Database("my-db", DatabaseConfigurationFactory.create(encryptionKey = EncryptionKey("PASSWORD")))
        // end::database-encryption[]
    }

    // ### Logging
    // !!! OBSOLETE in 3.0
    fun testLogging() {
        // tag::logging[]
        // end::logging[]
    }

    fun testEnableCustomLogging() {
        // tag::set-custom-logging[]
        // this custom logger will not log an event with a log level &lt; WARNING
        Database.log.custom = LogTestLogger(LogLevel.WARNING) <i class="conum" data-value="8"></i><b>(8)</b>
        // end::set-custom-logging[]
    }

    // ### Console logging
    @Throws(CouchbaseLiteException::class)
    fun testConsoleLogging() {
        // tag::console-logging[]
        Database.log.console.domains = LogDomain.ALL_DOMAINS <i class="conum" data-value="9"></i><b>(9)</b>
        Database.log.console.level = LogLevel.VERBOSE <i class="conum" data-value="10"></i><b>(10)</b>
        // end::console-logging[]

        // tag::console-logging-db[]
        Database.log.console.domains = EnumSet.of(LogDomain.DATABASE) <i class="conum" data-value="11"></i><b>(11)</b>
        // end::console-logging-db[]
    }

    // ### File logging
    @Throws(CouchbaseLiteException::class)
    fun testFileLogging() {
        // tag::file-logging[]
        Database.log.file.let {
            it.config = LogFileConfigurationFactory.create(
                context.cacheDir.absolutePath, <i class="conum" data-value="12"></i><b>(12)</b>
                maxSize = 10240, <i class="conum" data-value="13"></i><b>(13)</b>
                maxRotateCount = 5, <i class="conum" data-value="14"></i><b>(14)</b>
                usePlainText = false
            ) <i class="conum" data-value="15"></i><b>(15)</b>
            it.level = LogLevel.INFO <i class="conum" data-value="16"></i><b>(16)</b>

            // end::file-logging[]
        }
    }

    fun writeConsoleLog() {
        // tag::write-console-logmsg[]
        Database.log.console.log(LogLevel.WARNING, LogDomain.REPLICATOR, "Any old log message")
        // end::write-console-logmsg[]
    }

    fun writeCustomLog() {
        // tag::write-custom-logmsg[]
        Database.log.custom?.log(LogLevel.WARNING, LogDomain.REPLICATOR, "Any old log message")
        // end::write-custom-logmsg[]
    }

    fun writeFileLog() {
        // tag::write-file-logmsg[]
        Database.log.file.log(LogLevel.WARNING, LogDomain.REPLICATOR, "Any old log message")
        // end::write-file-logmsg[]
    }

    /* The `tag::replication[]` example is inlined in java.adoc */
    fun testTroubleshooting() {
        // tag::replication-logging[]
        Database.log.console.let {
            it.level = LogLevel.VERBOSE
            it.domains = LogDomain.ALL_DOMAINS
        }
        // end::replication-logging[]
    }

    // ### Loading a pre-built database
    @Throws(IOException::class)
    fun testPreBuiltDatabase() {
        // tag::prebuilt-database[]
        // Note: Getting the path to a database is platform-specific.
        // For Android you need to extract the database from your assets
        // to a temporary directory and then copy it, using Database.copy()
        if (Database.exists("travel-sample", context.filesDir)) {
            return
        }
        ZipUtils.unzip(PlatformUtils.getAsset("travel-sample.cblite2.zip"), context.filesDir)
        Database.copy(File(context.filesDir, "travel-sample"), "travel-sample", DatabaseConfiguration())
        // end::prebuilt-database[]
    }

    // helper methods
    // if db exist, delete it
    fun deleteDB(name: String, dir: File) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            Database.delete(name, dir)
        }

        // ### Initializers
        fun testInitializers() {
            // tag::initializer[]
            val doc = MutableDocument()
            doc.let {
                it.setString("type", "task")
                it.setString("owner", "todo")
                it.setDate("createdAt", Date())
            }
            database.save(doc)
            // end::initializer[]
        }
    }

    // ### Mutability
    fun testMutability() {
        database.save(MutableDocument("xyz"))

        // tag::update-document[]
        database.getDocument("xyz")?.toMutable()?.let {
            it.setString("name", "apples")
            database.save(it)
        }
        // end::update-document[]
    }

    // ### Typed Accessors
    fun testTypedAccessors() {
        val doc = MutableDocument()

        // tag::date-getter[]
        doc.setValue("createdAt", Date())
        val date = doc.getDate("createdAt")
        // end::date-getter[]
    }

    // ### Batch operations
    fun testBatchOperations() {
        // tag::batch[]
        database.inBatch(UnitOfWork {
            for (i in 0..9) {
                val doc = MutableDocument()
                doc.let {
                    it.setValue("type", "user")
                    it.setValue("name", "user $i")
                    it.setBoolean("admin", false)
                }
                Log.i(TAG, "saved user document: ${doc.getString("name")}")
            }
        })
        // end::batch[]
    }

    // ### Document Expiration
    @Throws(CouchbaseLiteException::class)
    fun documentExpiration() {
        // tag::document-expiration[]
        // Purge the document one day from now
        database.setDocumentExpiration("doc123", Date(Instant.now().plus(1, ChronoUnit.DAYS).toEpochMilli()))

        // Reset expiration
        database.setDocumentExpiration("doc1", null)

        // Query documents that will be expired in less than five minutes
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.longValue(Instant.now().plus(5, ChronoUnit.MINUTES).toEpochMilli())
                )
            )
        // end::document-expiration[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testDocumentChangeListener() {
        // tag::document-listener[]
        // Version using Kotlin Flows to follow shortly ...

        database.addDocumentChangeListener("user.john") { change -&gt;
            database.getDocument(change.documentID)?.let {
                Toast.makeText(context, "Status: ${it.getString("verified_account")}", Toast.LENGTH_SHORT).show()
            }
        }
        // end::document-listener[]
    }

    // ### Blobs
    fun testBlobs() {
        val mDoc = MutableDocument()

        // tag::blob[]
        PlatformUtils.getAsset("avatar.jpg")?.use { <i class="conum" data-value="17"></i><b>(17)</b>
            mDoc.setBlob("avatar", Blob("image/jpeg", it)) <i class="conum" data-value="18"></i><b>(18)</b> <i class="conum" data-value="19"></i><b>(19)</b>
            database.save(mDoc)
        }

        val doc = database.getDocument(mDoc.id)
        val bytes = doc?.getBlob("avatar")?.content
        // end::blob[]
    }
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.Dictionary
import com.couchbase.lite.Expression
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.MutableDictionary
import com.couchbase.lite.PredictionFunction
import com.couchbase.lite.PredictiveIndex
import com.couchbase.lite.PredictiveModel
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.SelectResult
import com.couchbase.lite.ValueIndex
import com.couchbase.lite.ValueIndexItem


private const val TAG = "PREDICT"

// `tensorFlowModel` is a fake implementation
object TensorFlowModel {
    fun predictImage(data: ByteArray?) = mapOf&lt;String, Any?&gt;()
}

object ImageClassifierModel : PredictiveModel {
    const val name = "ImageClassifier"

    override fun predict(input: Dictionary): Dictionary? {
        val blob: Blob = input.getBlob("photo") ?: return null

        // this would be the implementation of the ml model you have chosen
        return MutableDictionary(TensorFlowModel.predictImage(blob.content)) <i class="conum" data-value="1"></i><b>(1)</b>
    }
} // end::predictive-model[]


@Suppress("unused")
class PredictiveQueryExamples {
    @Throws(CouchbaseLiteException::class)
    fun testPredictiveModel() {
        val database = Database("mydb")

        // tag::register-model[]
        Database.prediction.registerModel("ImageClassifier", ImageClassifierModel)
        // end::register-model[]

        // tag::predictive-query-value-index[]
        val index: ValueIndex = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")))
        database.createIndex("value-index-image-classifier", index)
        // end::predictive-query-value-index[]

        // tag::unregister-model[]
        Database.prediction.unregisterModel("ImageClassifier")
        // end::unregister-model[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveIndex() {
        val database = Database("mydb")

        // tag::predictive-query-predictive-index[]
        val inputMap: MutableMap&lt;String, Any&gt; = mutableMapOf()
        inputMap["numbers"] = Expression.property("photo")
        val input: Expression = Expression.map(inputMap)
        val index: PredictiveIndex = IndexBuilder.predictiveIndex("ImageClassifier", input, null)
        database.createIndex("predictive-index-image-classifier", index)
        // end::predictive-query-predictive-index[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveQuery() {
        val database = Database("mydb")

        // tag::predictive-query[]
        val prediction: PredictionFunction = Function.prediction(
            ImageClassifierModel.name,
            Expression.map(mutableMapOf("photo" to Expression.property("photo")) as Map&lt;String, Any&gt;?) <i class="conum" data-value="1"></i><b>(1)</b>
        )

        // !!! Is this query using that prediction function, at all?
        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("label").equalTo(Expression.string("car"))
                    .and(
                        Expression.property("probability")
                            .greaterThanOrEqualTo(Expression.doubleValue(0.8))
                    )
            )
            .execute()

        Log.d(TAG, "Number of rows: ${rs.allResults().size}")
        // end::predictive-query[]
    }
}


// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorStatus


private const val TAG = "PENDING"

@Suppress("unused")
class PendingDocsExample(private var replicator: Replicator) {
    //
    // tag::replication-pendingdocuments[]
    //
    private fun onStatusChanged(pendingDocs: Set&lt;String&gt;, status: ReplicatorStatus) {
        // ... sample onStatusChanged function
        //
        Log.i(TAG, "Replicator activity level is ${status.activityLevel}")

        // iterate and report-on previously
        // retrieved pending docids 'list'
        val itr = pendingDocs.iterator()
        while (itr.hasNext()) {
            val docId = itr.next()

            // tag::replication-push-isdocumentpending[]
            if (!replicator.isDocumentPending(docId)) { <i class="conum" data-value="20"></i><b>(20)</b>
                continue
            }

            // end::replication-push-isdocumentpending[]
            Log.i(TAG, "Doc ID $docId has been pushed")
        }
    } // end::replication-pendingdocuments[]
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Endpoint
import com.couchbase.lite.KeyStoreUtils
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.net.URI
import java.net.URISyntaxException
import java.security.KeyStore
import java.security.cert.Certificate

private const val TAG = "P2P"


@Suppress("unused")
class IBExamples(private val context: Context, private val caCert: Certificate) {
    private val database: Database
    private var thisReplicator: Replicator? = null
    private var thisListener: URLEndpointListener? = null

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        database = Database("p2p_demo")

        /* do some stuff here */
    }

    // PASSIVE PEER STUFF
    fun ibListenerSimple() {
        // tag::listener-simple[]
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database,
                authenticator
                = ListenerPasswordAuthenticator { user, pwd -&gt; (user == "daniel") &amp;&amp; (String(pwd) == "123") })
        ) <i class="conum" data-value="21"></i><b>(21)</b>
        listener.start() <i class="conum" data-value="22"></i><b>(22)</b>
        thisListener = listener

        // end::listener-simple[]
    }

    fun ibReplicatorSimple() {
        // tag::replicator-simple[]
        val theListenerEndpoint: Endpoint = URLEndpoint(URI("wss://10.0.2.2:4984/db")) <i class="conum" data-value="23"></i><b>(23)</b>
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,
                target = theListenerEndpoint,
                authenticator = BasicAuthenticator("valid.user", "valid.password.string".toCharArray()), <i class="conum" data-value="24"></i><b>(24)</b>
                acceptOnlySelfSignedServerCertificate = true
            )
        )
        repl.start() <i class="conum" data-value="25"></i><b>(25)</b>
        thisReplicator = repl
        // end::replicator-simple[]
    }

    fun ibPassListener(validUser: String, validPassword: CharArray) {
        // EXAMPLE 1
        // tag::listener-start[]
        // Initialize the listener
        // tag::listener-initialize[]
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                // tag::listener-config-db[]
                database = database, <i class="conum" data-value="26"></i><b>(26)</b>
                // end::listener-config-db[]
                // tag::listener-config-port[]
                port = 55990, <i class="conum" data-value="27"></i><b>(27)</b>
                // end::listener-config-port[]
                // tag::listener-config-netw-iface[]
                networkInterface = "10.1.1.10", <i class="conum" data-value="28"></i><b>(28)</b>

                // end::listener-config-netw-iface[]
                // tag::listener-config-delta-sync[]
                enableDeltaSync = false, <i class="conum" data-value="29"></i><b>(29)</b>

                // end::listener-config-delta-sync[]
                // tag::listener-config-tls-full[]
                // Configure server security
                // tag::listener-config-tls-enable[]
                disableTls = false, <i class="conum" data-value="30"></i><b>(30)</b>

                // end::listener-config-tls-enable[]
                // tag::listener-config-tls-id-anon[]
                // Use an Anonymous Self-Signed Cert
                identity = null, <i class="conum" data-value="31"></i><b>(31)</b>
                // end::listener-config-tls-id-anon[]

                // tag::listener-config-client-auth-pwd[]
                // Configure Client Security using an Authenticator
                // For example, Basic Authentication <i class="conum" data-value="32"></i><b>(32)</b>
                authenticator = ListenerPasswordAuthenticator { username, paassword -&gt;
                    (username === validUser) &amp;&amp; (paassword === validPassword)
                }
            ))

        // Start the listener
        listener.start() <i class="conum" data-value="33"></i><b>(33)</b>
        thisListener = listener

        // end::listener-initialize[]
        // end::listener-start[]
    }

    fun ibListenerGetNetworkInterfaces() {
        // tag::listener-get-network-interfaces[]
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        listener.start()
        Log.i(TAG, "URLS are ${listener.urls}")
        thisListener = listener
        // end::listener-get-network-interfaces[]
    }

    fun ibListenerLocalDb() {
        // tag::listener-local-db[]
        // . . . preceding application logic . . .
        CouchbaseLite.init(context) <i class="conum" data-value="34"></i><b>(34)</b>
        val thisDB = Database("passivepeerdb")
        // end::listener-local-db[]
    }

    fun ibListenerConfigTlsDisable() {
        // tag::listener-config-tls-disable[]
        URLEndpointListenerConfigurationFactory.create(database, disableTls = false) <i class="conum" data-value="35"></i><b>(35)</b>
        // end::listener-config-tls-disable[]
    }


    // !!! USERS SHOULD BE CAUTIONED THAT THIS IS INSECURE
    // Android has much better ways of importing keys
    fun ibListenerConfigTlsIdFull() {
        // tag::listener-config-tls-id-full[]
        // tag::listener-config-tls-id-caCert[]
        // Use CA Cert
        // Import a key pair into secure storage
        // Create a TLSIdentity from the imported key-pair

        this.javaClass.getResourceAsStream("serverkeypair.p12")?.use { <i class="conum" data-value="36"></i><b>(36)</b>
            KeyStoreUtils.importEntry(
                "teststore.p12",  // KeyStore type, eg: "PKCS12"
                it,  // An InputStream from the keystore
                "let me in".toCharArray(),  // The keystore password
                "topSekritKey",  // The alias to be used (in external keystore)
                null,  // The key password or null if the key has none
                "test-alias" // The alias for the imported key
            )
        }

        // end::listener-config-tls-id-caCert[]

        // tag::listener-config-tls-id-set[]
        // Set the TLS Identity
        URLEndpointListenerConfigurationFactory.create(
            database,
            identity = TLSIdentity.getIdentity("test-alias")
        ) <i class="conum" data-value="37"></i><b>(37)</b>

        // end::listener-config-tls-id-set[]
// end::listener-config-tls-id-full[]
    }

    fun ibListenerConfigClientAuthRoot() {
// tag::listener-config-client-root-ca[]
        // tag::listener-config-client-auth-root[]
        // Configure the client authenticator
        // to validate using ROOT CA
        // thisClientID.certs is a list containing a client cert to accept
        // and any other certs needed to complete a chain between the client cert
        // and a CA
        val validId = TLSIdentity.getIdentity("Our Corporate Id")
            ?: throw IllegalStateException("Cannot find corporate id")
        // accept only clients signed by the corp cert
        thisListener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                // get the identity <i class="conum" data-value="38"></i><b>(38)</b>
                database = database,
                identity = validId,
                authenticator = ListenerCertificateAuthenticator(validId.certs)
            )
        ) <i class="conum" data-value="39"></i><b>(39)</b>

        // end::listener-config-client-auth-root[]
// end::listener-config-client-root-ca[]
    }

    fun ibListenerConfigTlsDisable2() {

        // tag::listener-config-tls-disable[]
        URLEndpointListenerConfigurationFactory.create(database = database, disableTls = true)
        // end::listener-config-tls-disable[]
    }

    fun ibListenerStatusCheck() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        // tag::listener-status-check[]
        val connectionCount = listener.status?.connectionCount <i class="conum" data-value="40"></i><b>(40)</b>
        val activeConnectionCount = listener.status?.activeConnectionCount <i class="conum" data-value="41"></i><b>(41)</b>
        // end::listener-status-check[]
    }

    fun ibListenerStop() {

        // tag::listener-stop[]
        thisListener?.stop()

        // end::listener-stop[]
    }

    // ACTIVE PEER STUFF
// Replication code
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testActPeerSync() {
        // tag::p2p-act-rep-start-full[]
        // Create replicator
        // Consider holding a reference somewhere
        // to prevent the Replicator from being GCed
        val repl = Replicator( <i class="conum" data-value="42"></i><b>(42)</b>

            // tag::p2p-act-rep-func[]
            // tag::p2p-act-rep-initialize[]
            // initialize the replicator configuration
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(URI("wss://listener.com:8954")), <i class="conum" data-value="43"></i><b>(43)</b>

                // end::p2p-act-rep-initialize[]
                // tag::p2p-act-rep-config-type[]
                // Set replicator type
                type = ReplicatorType.PUSH_AND_PULL,

                // end::p2p-act-rep-config-type[]
                // tag::p2p-act-rep-config-cont[]
                // Configure Sync Mode
                continuous = false, // default value

                // end::p2p-act-rep-config-cont[]

                // tag::autopurge-override[]
                // set auto-purge behavior
                // (here we override default)
                enableAutoPurge = false, <i class="conum" data-value="44"></i><b>(44)</b>

                // end::autopurge-override[]


                // tag::p2p-act-rep-config-self-cert[]
                // Configure Server Authentication --
                // only accept self-signed certs
                acceptOnlySelfSignedServerCertificate = true, <i class="conum" data-value="45"></i><b>(45)</b>

                // end::p2p-act-rep-config-self-cert[]
                // tag::p2p-act-rep-auth[]
                // Configure the credentials the
                // client will provide if prompted
                authenticator = BasicAuthenticator("Our Username", "Our PasswordValue".toCharArray()), <i class="conum" data-value="46"></i><b>(46)</b>


                // end::p2p-act-rep-auth[]
                // tag::p2p-act-rep-config-conflict[]
                /* Optionally set custom conflict resolver call back */
                conflictResolver = null <i class="conum" data-value="47"></i><b>(47)</b>
            )
        )

        // end::p2p-act-rep-config-conflict[]

        // tag::p2p-act-rep-add-change-listener[]
        // tag::p2p-act-rep-add-change-listener-label[]
        // Optionally add a change listener <i class="conum" data-value="48"></i><b>(48)</b>
        // end::p2p-act-rep-add-change-listener-label[]
        val thisListener = repl.addChangeListener { change -&gt;
            val err: CouchbaseLiteException? = change.status.error
            if (err != null) {
                Log.i(TAG, "Error code ::  ${err.code}", err)
            }
        }

        // end::p2p-act-rep-add-change-listener[]
        // tag::p2p-act-rep-start[]
        // Start replicator
        repl.start(false) <i class="conum" data-value="49"></i><b>(49)</b>
        thisReplicator = repl

        // end::p2p-act-rep-start[]
        // end::p2p-act-rep-start-full[]
        // end::p2p-act-rep-func[]         ***** End p2p-act-rep-func
    }

    fun ibReplicatorConfig() {
        // BEGIN additional snippets
        // tag::p2p-act-rep-config-tls-full[]

        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,

                // tag::p2p-act-rep-config-cacert[]
                // Configure Server Security
                // -- only accept CA attested certs
                acceptOnlySelfSignedServerCertificate = false, <i class="conum" data-value="50"></i><b>(50)</b>

                // end::p2p-act-rep-config-cacert[]


                // tag::p2p-act-rep-config-cacert-pinned[]

                // Use the pinned certificate from the byte array (cert)
                pinnedServerCertificate = caCert.encoded, <i class="conum" data-value="51"></i><b>(51)</b>
                // end::p2p-act-rep-config-cacert-pinned[]


                // end::p2p-act-rep-config-tls-full[]
                // tag::p2p-tlsid-tlsidentity-with-label[]
                // ... other replicator configuration
                // Provide a client certificate to the server for authentication
                authenticator = ClientCertificateAuthenticator(
                    TLSIdentity.getIdentity("clientId")
                        ?: throw IllegalStateException("Cannot find client id")
                ) <i class="conum" data-value="52"></i><b>(52)</b>

                // ... other replicator configuration

            )
        )

        thisReplicator = repl
        // end::p2p-tlsid-tlsidentity-with-label[]
    }

    fun ibP2pReplicatorStatus() {
        // tag::p2p-act-rep-status[]
        thisReplicator?.status?.let {
            Log.i(TAG, "The Replicator is currently ${it.activityLevel}")
            Log.i(TAG, "The Replicator has processed ${it.progress}")
            Log.i(
                TAG,
                if (it.activityLevel === ReplicatorActivityLevel.BUSY) {
                    "Replication Processing"
                } else {
                    "It has completed ${it.progress.total} changes"
                }
            )
        }
        // end::p2p-act-rep-status[]
    }

    fun ibP2pReplicatorStop() {
        // tag::p2p-act-rep-stop[]
        // Stop replication.
        thisReplicator?.stop() <i class="conum" data-value="53"></i><b>(53)</b>
        // end::p2p-act-rep-stop[]
    }

    fun ibP2pListener() {
        CouchbaseLite.init(context)
        val thisDB = Database("passivepeerdb") <i class="conum" data-value="54"></i><b>(54)</b>


        // Initialize the listener
        val listener = URLEndpointListener( <i class="conum" data-value="55"></i><b>(55)</b>

            // Initialize the listener config
            URLEndpointListenerConfigurationFactory.create(
                database = thisDB,
                port = 55990, /* &lt;.&gt;  Optional; defaults to auto */
                disableTls = false, /* &lt;.&gt;  Optional; defaults to false */
                enableDeltaSync = true,  /* &lt;.&gt; Optional; defaults to false */

                // Configure the client authenticator (if using basic auth)
                authenticator = ListenerPasswordAuthenticator { username, password -&gt;
                    ("username" === username) &amp;&amp; (password === "password".toCharArray())  <i class="conum" data-value="56"></i><b>(56)</b>
                }
            )
        )

        // Start the listener
        listener.start() <i class="conum" data-value="57"></i><b>(57)</b>


        // tag::createTlsIdentity[]

//        Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
//                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
//                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
//        );
        val thisIdentity = TLSIdentity.createIdentity(
            true,
            mapOf(
                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
            ),
            null,
            "test-alias"
        )

        // end::createTlsIdentity[]

        // tag::p2p-tlsid-store-in-keychain[]
        // end::p2p-tlsid-store-in-keychain[]


        // tag::deleteTlsIdentity[]
        // tag::p2p-tlsid-delete-id-from-keychain[]
        val thisAlias = "alias-to-delete"
        val thisKeyStore = KeyStore.getInstance("AndroidKeyStore")
        thisKeyStore.load(null)
        thisKeyStore.deleteEntry(thisAlias)

        // end::p2p-tlsid-delete-id-from-keychain[]
        // end::deleteTlsIdentity[]

        // tag::retrieveTlsIdentity[]
        // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label
        val thatIdentity = TLSIdentity.getIdentity("couchbase-docs-cert")
        // end::retrieveTlsIdentity[]
    }

    // tag::sgw-repl-pull[]
    fun ibRplicatorPull() {
        val database = Database("ian")

        val uri = URI("wss://10.0.2.2:4984/db") <i class="conum" data-value="58"></i><b>(58)</b>

        val repl = Replicator( <i class="conum" data-value="59"></i><b>(59)</b>
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(uri),
                type = ReplicatorType.PULL
            )
        )

        repl.start()
        thisReplicator = repl
    }

    // end::sgw-repl-pull[]
// tag::sgw-act-rep-initialize[]
// initialize the replicator configuration
    val thisConfig = ReplicatorConfigurationFactory.create(
        database = database,
        target = URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))
    ) // &lt;.&gt; // end::sgw-act-rep-initialize[]

/* C A L L O U T S

// Listener Callouts

// tag::listener-callouts-full[]

// tag::listener-start-callouts[]
&lt;.&gt; Initialize the listener instance using the configuration settings.
&lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.

// end::listener-start-callouts[]

// tag::listener-status-check-callouts[]

&lt;.&gt; `connectionCount` -- the total number of connections served by the listener
&lt;.&gt; `activeConnectionCount` -- the number of active (BUSY) connections currently being served by the listener
//
// end::listener-status-check-callouts[]

// end::listener-callouts-full[]


// tag::p2p-act-rep-config-cacert-pinned-callouts[]
&lt;.&gt; Configure the pinned certificate using data from the byte array `cert`
// end::p2p-act-rep-config-cacert-pinned-callouts[]

// tag::p2p-tlsid-tlsidentity-with-label-callouts[]
&lt;.&gt; Attempt to get the identity from secure storage
&lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity

// end::p2p-tlsid-tlsidentity-with-label-callouts[]

// tag::sgw-repl-pull-callouts[]
&lt;.&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;.&gt; The URL scheme for remote database URLs uses `ws:`, or `wss:` for SSL/TLS connections over wb sockets.
In this example the hostname is `10.0.2.2` because the Android emulator runs in a VM that is generally accessible on `10.0.2.2` from the host machine (see https://developer.android.com/studio/run/emulator-networking[Android Emulator networking] documentation).
+
NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
Although `wss:` protocol URLs are not affected, in order to use the `ws:` protocol, applications must target API 27 or lower, or must configure application network security as described https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted[here].

// end::sgw-repl-pull-callouts[]
*/
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.net.URI
import java.security.KeyStore
import java.security.KeyStoreException
import java.security.NoSuchAlgorithmException
import java.security.cert.Certificate
import java.security.cert.CertificateEncodingException
import java.security.cert.CertificateException
import java.util.concurrent.CountDownLatch

private const val TAG = "LISTEN"

@Suppress("unused")
class CertAuthListener {
    companion object {
        private val CERT_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "CBL Test",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "lite@couchbase.com",
        )
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)

        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        remoteDb.save(doc)

        val serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server")

        val clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client")
        val uri = startServer(remoteDb, serverIdentity, clientIdentity.certs)
            ?: throw IOException("Failed to start the server")

        Thread {
            startClient(localDb, uri, clientIdentity, serverIdentity.certs[0])
            Log.e(TAG, "Success!!")
            deleteIdentity("server")
            Log.e(TAG, "Alias deleted: server")
            deleteIdentity("client")
            Log.e(TAG, "Alias deleted: client")
        }.start()
    }

    // start a client replicator
    @Throws(CertificateEncodingException::class, InterruptedException::class)
    fun startClient(db: Database, uri: URI, clientIdentity: TLSIdentity, cert: Certificate) {
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = db,
                target = URLEndpoint(uri),
                type = ReplicatorType.PUSH_AND_PULL,
                continuous = false,
                authenticator = ClientCertificateAuthenticator(clientIdentity),
                pinnedServerCertificate = cert.encoded
            )
        )

        val completionLatch = CountDownLatch(1)

        repl.addChangeListener { change -&gt;
            if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    // tag::listener-config-auth-cert-full[]
    /**
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     *
     *
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Throws(CouchbaseLiteException::class)
    fun startServer(db: Database, serverId: TLSIdentity, certs: List&lt;Certificate?&gt;): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0, // this is the default
                disableTls = false,
                identity = serverId,
                authenticator = ListenerCertificateAuthenticator(certs)
            )
        )
        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
    // end::listener-config-auth-cert-full[]
    // tag::listener-config-delete-cert-full[]
    /**
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    @Throws(
        KeyStoreException::class,
        CertificateException::class,
        NoSuchAlgorithmException::class,
        IOException::class
    )
    fun deleteIdentity(alias: String?) {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        keyStore.deleteEntry(alias) <i class="conum" data-value="60"></i><b>(60)</b>
    }
    // end::listener-config-delete-cert-full[]
    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /**
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     *
     *
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    @Throws(CertificateEncodingException::class)
    private fun configureClientCerts(
        config: ReplicatorConfiguration,
        cert: Certificate,
        clientIdentity: TLSIdentity
    ) {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(ClientCertificateAuthenticator(clientIdentity))

        // Configure the pinned certificate passing a byte array.
        config.pinnedServerCertificate = cert.encoded
    }
    // notend::p2p-tlsid-tlsidentity-with-label[]
    /**
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     *
     *
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    @Throws(IOException::class)
    private fun readCertMaterialFromBundle(
        context: Context,
        resId: Int
    ): ByteArray {
        val out = ByteArrayOutputStream()
        val `in` = context.resources.openRawResource(resId)
        val buf = ByteArray(1024)
        var n: Int
        while (`in`.read(buf).also { n = it } &gt;= 0) {
            out.write(buf, 0, n)
        }
        return out.toByteArray()
    }
}

@Suppress("unused")
class PasswordAuthListener {
    companion object {
        private const val VALID_USER = "Minnie"
        private val VALID_PASSWORD = "let me in!".toCharArray()
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray())
            ?: throw IOException("Failed to start the server")
        Thread {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb)
                Log.e(TAG, "Success!!")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }.start()
    }

    // start a client replicator
    @Throws(InterruptedException::class)
    fun runClient(
        uri: URI,
        username: String,
        password: CharArray,
        db: Database
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.type = ReplicatorType.PUSH_AND_PULL
        config.isContinuous = false
        config.setAuthenticator(BasicAuthenticator(username, password))
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)

        // Version using Kotlin Flows to follow shortly ...
        repl.addChangeListener { change -&gt;
            if (change.status
                    .activityLevel == ReplicatorActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    // tag::listener-config-client-auth-pwd-full[]
    /**
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     *
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    fun startServer(db: Database, username: String, password: CharArray): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0,// this is the default
                disableTls = true,
                authenticator = ListenerPasswordAuthenticator { usr, pwd -&gt;
                    (usr == username) &amp;&amp; pwd.contentEquals(password)
                })
        )

        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
// end::listener-config-client-auth-pwd-full[]
}





// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Message
import com.couchbase.lite.MessageEndpoint
import com.couchbase.lite.MessageEndpointConnection
import com.couchbase.lite.MessageEndpointDelegate
import com.couchbase.lite.MessageEndpointListener
import com.couchbase.lite.MessageEndpointListenerConfigurationFactory
import com.couchbase.lite.MessagingCloseCompletion
import com.couchbase.lite.MessagingCompletion
import com.couchbase.lite.ProtocolType
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorConnection
import com.couchbase.lite.create


@Suppress("unused")
class BrowserSessionManager : MessageEndpointDelegate {
    private var replicator: Replicator? = null

    @Throws(CouchbaseLiteException::class)
    fun initCouchbase() {
        // tag::message-endpoint[]
        val database = Database("mydb")

        // The delegate must implement the `MessageEndpointDelegate` protocol.
        val messageEndpoint = MessageEndpoint("UID:123", "active", ProtocolType.MESSAGE_STREAM, this)
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        // Create the replicator object.
        val repl = Replicator(ReplicatorConfigurationFactory.create(database = database, target = messageEndpoint))
        // Start the replication.
        repl.start()
        replicator = repl
        // end::message-endpoint-replicator[]
    }

    // tag::create-connection[]
    /* implementation of MessageEndpointDelegate */
    override fun createConnection(endpoint: MessageEndpoint) = ActivePeerConnection()
    // end::create-connection[]
}

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ----------------------------------------------------------- */

@Suppress("unused")
class ActivePeerConnection : MessageEndpointConnection {
    private var replicatorConnection: ReplicatorConnection? = null

    // tag::active-replicator-close[]
    fun disconnect() {
        replicatorConnection?.close(null)
        replicatorConnection = null
    }
    // end::active-replicator-close[]

    // tag::active-peer-open[]
    /* implementation of MessageEndpointConnection */
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    // end::active-peer-open[]
    // tag::active-peer-close[]
    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete()
    }

    // end::active-peer-close[]
    // tag::active-peer-send[]
    /* implementation of MessageEndpointConnection */
    override fun send(message: Message, completion: MessagingCompletion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null)
    }

    // end::active-peer-send[]
    fun receive(message: Message) {
        // tag::active-peer-receive[]
        replicatorConnection?.receive(message)
        // end::active-peer-receive[]
    }
}

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ----------------------------------------------------------- */

@Suppress("unused")
class PassivePeerConnection private constructor() : MessageEndpointConnection {
    private var messageEndpointListener: MessageEndpointListener? = null
    private var replicatorConnection: ReplicatorConnection? = null

    @Throws(CouchbaseLiteException::class)
    fun startListener() {
        // tag::listener[]
        val database = Database("mydb")
        messageEndpointListener = MessageEndpointListener(
            MessageEndpointListenerConfigurationFactory.create(database, ProtocolType.MESSAGE_STREAM)
        )
        // end::listener[]
    }

    fun stopListener() {
        // tag::passive-stop-listener[]
        messageEndpointListener?.closeAll()
        // end::passive-stop-listener[]
    }

    fun accept() {
        // tag::advertizer-accept[]
        val connection = PassivePeerConnection() /* implements MessageEndpointConnection */
        messageEndpointListener?.accept(connection)
        // end::advertizer-accept[]
    }

    fun disconnect() {
        // tag::passive-replicator-close[]
        replicatorConnection?.close(null)
        // end::passive-replicator-close[]
    }

    // tag::passive-peer-open[]
    /* implementation of MessageEndpointConnection */
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }
    // end::passive-peer-open[]

    // tag::passive-peer-close[]
    /* implementation of MessageEndpointConnection */
    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete()
    }

    // end::passive-peer-close[]
    // tag::passive-peer-send[]
    /* implementation of MessageEndpointConnection */
    override fun send(message: Message, completion: MessagingCompletion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null)
    }

    // end::passive-peer-send[]
    fun receive(message: Message) {
        // tag::passive-peer-receive[]
        replicatorConnection?.receive(message)
        // end::passive-peer-receive[]
    }

} // tag::predictive-model[]



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.ArrayFunction
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.Expression
import com.couchbase.lite.FullTextExpression
import com.couchbase.lite.FullTextIndexItem
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.Join
import com.couchbase.lite.Meta
import com.couchbase.lite.Ordering
import com.couchbase.lite.Query
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.SelectResult
import com.couchbase.lite.ValueIndexItem
import com.fasterxml.jackson.databind.ObjectMapper
import org.json.JSONException


private const val TAG = "QUERY"
private const val DATABASE_NAME = "database"

data class Hotel(
    var description: String? = null,
    var country: String? = null,
    var city: String? = null,
    var name: String? = null,
    var type: String? = null,
    var id: String? = null
)

@Suppress("unused")
class QueryExamples(private val database: Database) {

    // ### Indexing
    @Throws(CouchbaseLiteException::class)
    fun testIndexing() {
        // tag::query-index[]
        database.createIndex(
            "TypeNameIndex",
            IndexBuilder.valueIndex(
                ValueIndexItem.property("type"),
                ValueIndexItem.property("name")
            )
        )
        // end::query-index[]
    }

    // ### SELECT statement
    fun testSelectStatement() {
        // tag::query-select-meta[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("type")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.expression(Meta.id))
            .execute()

        for (result in rs) {
            Log.i(TAG, "hotel id -&gt;${result.getString("id")}")
            Log.i(TAG, "hotel name -&gt; ${result.getString("name")}")
        }
        // end::query-select-meta[]
    }

    // META function
    @Throws(CouchbaseLiteException::class)
    fun testMetaFunction() {
        val rs = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("airport")))
            .orderBy(Ordering.expression(Meta.id))
            .execute()

        for (result in rs) {
            Log.w(TAG, "airport id -&gt;${result.getString("id")}")
            Log.w(TAG, "airport id -&gt; ${result.getString(0)}")
        }
    }

    // ### all(*)
    @Throws(CouchbaseLiteException::class)
    fun testSelectAll() {
        // tag::query-select-all[]
        val queryAll = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
        // end::query-select-all[]

        // tag::live-query[]
        val query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="61"></i><b>(61)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        // Version using Kotlin Flows to follow shortly ...
        val token = query.addChangeListener { change -&gt;
            change.results?.let {
                for (result in it) {
                    Log.d(TAG, "results: ${result.keys}")
                    /* Update UI */
                }
            } <i class="conum" data-value="62"></i><b>(62)</b>
        }

        // end::live-query[]

        // tag::stop-live-query[]
        query.removeChangeListener(token)
        // end::stop-live-query[]

        for (result in query.execute()) {
            Log.i(TAG, "hotel -&gt; ${result.getDictionary(DATABASE_NAME)?.toMap()}")
        }
    }


    // ###WHERE statement
    @Throws(CouchbaseLiteException::class)
    fun testWhereStatement() {
        // tag::query-where[]
        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.intValue(10))
            .execute()
        for (result in rs) {
            result.getDictionary(DATABASE_NAME)?.let {
                Log.i(TAG, "name -&gt; ${it.getString("name")}")
                Log.i(TAG, "type -&gt; ${it.getString("type")}")
            }
        }
        // end::query-where[]
    }

    fun testQueryDeletedDocuments() {
        // tag::query-deleted-documents[]
        // Query documents that have been deleted
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted)
        // end::query-deleted-documents[]
    }

    // ####Collection Operators
    @Throws(CouchbaseLiteException::class)
    fun testCollectionStatement() {
        // tag::query-collection-operator-contains[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(
                        ArrayFunction.contains(
                            Expression.property("public_likes"),
                            Expression.string("Armani Langworth")
                        )
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.getArray("public_likes")?.toList()}")
        }
        // end::query-collection-operator-contains[]
    }

    // IN operator
    @Throws(CouchbaseLiteException::class)
    fun testInOperator() {
        // tag::query-collection-operator-in[]
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.string("Armani").`in`(
                    Expression.property("first"),
                    Expression.property("last"),
                    Expression.property("username")
                )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.toMap()}")
        }
        // end::query-collection-operator-in[]
    }

    // Pattern Matching
    @Throws(CouchbaseLiteException::class)
    fun testPatternMatching() {
        // tag::query-like-operator[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-like-operator[]
    }

    // ### Wildcard Match
    @Throws(CouchbaseLiteException::class)
    fun testWildcardMatch() {
        // tag::query-like-operator-wildcard-match[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-like-operator-wildcard-match[]
    }

    // Wildcard Character Match
    @Throws(CouchbaseLiteException::class)
    fun testWildCharacterMatch() {
        // tag::query-like-operator-wildcard-character-match[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng____r"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-like-operator-wildcard-character-match[]
    }

    // ### Regex Match
    @Throws(CouchbaseLiteException::class)
    fun testRegexMatch() {
        // tag::query-regex-operator[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .regex(Expression.string("\\beng.*r\\b"))
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-regex-operator[]
    }

    // JOIN statement
    @Throws(CouchbaseLiteException::class)
    fun testJoinStatement() {
        // tag::query-join[]
        val rs = QueryBuilder.select(
            SelectResult.expression(Expression.property("name").from("airline")),
            SelectResult.expression(Expression.property("callsign").from("airline")),
            SelectResult.expression(Expression.property("destinationairport").from("route")),
            SelectResult.expression(Expression.property("stops").from("route")),
            SelectResult.expression(Expression.property("airline").from("route"))
        )
            .from(DataSource.database(database).`as`("airline"))
            .join(
                Join.join(DataSource.database(database).`as`("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(
                        Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline"))
                    )
                    .and(
                        Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.toMap()}")
        }
        // end::query-join[]
    }


    // ### GROUPBY statement
    @Throws(CouchbaseLiteException::class)
    fun testGroupByStatement() {
        // tag::query-groupby[]
        val rs = QueryBuilder.select(
            SelectResult.expression(Function.count(Expression.string("*"))),
            SelectResult.property("country"),
            SelectResult.property("tz")
        )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300)))
            )
            .groupBy(
                Expression.property("country"), Expression.property("tz")
            )
            .orderBy(Ordering.expression(Function.count(Expression.string("*"))).descending())
            .execute()

        for (result in rs) {
            result.let {
                Log.i(
                    TAG,
                    "There are ${it.getInt("$1")} airports on the ${
                        it.getString("tz")
                    } timezone located in ${
                        it.getString("country")
                    } and above 300ft"
                )
            }
            // end::query-groupby[]
        }
    }

    // ### ORDER BY statement
    @Throws(CouchbaseLiteException::class)
    fun testOrderByStatement() {
        // tag::query-orderby[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("name").ascending())
            .limit(Expression.intValue(10))
            .execute()

        for (result in rs) {
            Log.i(TAG, "${result.toMap()}")
        }
        // end::query-orderby[]
    }


    // ### EXPLAIN statement
    // tag::query-explain[]
    @Throws(CouchbaseLiteException::class)
    fun testExplainStatement() {
        // tag::query-explain-all[]
        var query: Query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").descending()) <i class="conum" data-value="63"></i><b>(63)</b>
        Log.i(TAG, query.explain()) <i class="conum" data-value="64"></i><b>(64)</b>
        // end::query-explain-all[]

        // tag::query-explain-like[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%"))) <i class="conum" data-value="65"></i><b>(65)</b>
        Log.i(TAG, query.explain())
        // end::query-explain-like[]

        // tag::query-explain-nopfx[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="66"></i><b>(66)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%")))
            )
        Log.i(TAG, query.explain())
        // end::query-explain-nopfx[]

        // tag::query-explain-function[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Function.lower(
                    Expression.property("type").equalTo(Expression.string("hotel"))
                )
            ) <i class="conum" data-value="67"></i><b>(67)</b>
        Log.i(TAG, query.explain())
        // end::query-explain-function[]

        // tag::query-explain-nofunction[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))) <i class="conum" data-value="68"></i><b>(68)</b>
        Log.i(TAG, query.explain())
        // end::query-explain-nofunction[]
    }
// end::query-explain[]

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex() {
        // tag::fts-index[]
        database.createIndex(
            "nameFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("name")).ignoreAccents(false)
        )
        // end::fts-index[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS() {
        // tag::fts-query[]
        val rs = QueryBuilder.select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(FullTextExpression.index("nameFTSIndex").match("buy"))
            .execute()
        for (result in rs) {
            Log.i(TAG, "document properties${result.getString(0)}")
        }
        // end::fts-query[]
    }


    fun testQuerySyntaxAll(currentUser: String) {
        // tag::query-syntax-all[]
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(openOrCreateDatabaseForUser(currentUser)))

            // end::query-syntax-all[]
        // tag::query-access-all[]
        val hotels: HashMap&lt;String, Hotel&gt; = HashMap()

        for (result in listQuery.execute().allResults()) {
            // get the k-v pairs from the 'hotel' key's value into a dictionary
            val thisDocsProps = result.getDictionary(0) <i class="conum" data-value="69"></i><b>(69)</b>
            val thisDocsId = thisDocsProps!!.getString("id")
            val thisDocsName = thisDocsProps.getString("name")
            val thisDocsType = thisDocsProps.getString("type")
            val thisDocsCity = thisDocsProps.getString("city")

            // Alternatively, access results value dictionary directly
            val id = result.getDictionary(0)?.getString("id").toString() <i class="conum" data-value="70"></i><b>(70)</b>
            hotels[id] = Hotel(
                id,
                result.getDictionary(0)?.getString("type"),
                result.getDictionary(0)?.getString("name"),
                result.getDictionary(0)?.getString("city"),
                result.getDictionary(0)?.getString("country"),
                result.getDictionary(0)?.getString("description")
            )
        }

        // end::query-access-all[]
    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun testQuerySyntaxJson(currentUser: String, argDb: Database) {
        Database db = argDb
        // tag::query-syntax-json[]
        // Example assumes Hotel class object defined elsewhere

        // Build the query
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(db))

        // end::query-syntax-json[]
        // tag::query-access-json[]
        // Uses Jackson JSON processor
        val mapper = ObjectMapper()
        val hotels: ArrayList&lt;Hotel&gt; = ArrayList()

        for (result in listQuery.execute()) {

            // Get result as JSON string
            val json = result.toJSON() <i class="conum" data-value="71"></i><b>(71)</b>

            // Get Hashmap from JSON string
            val dictFromJSONstring = mapper.readValue(json, HashMap::class.java) <i class="conum" data-value="72"></i><b>(72)</b>

            // Use created hashmap
            val hotelId = dictFromJSONstring["id"].toString() //
            val hotelType = dictFromJSONstring["type"].toString()
            val hotelname = dictFromJSONstring["name"].toString()


            // Get custom object from JSON string
            val thisHotel = mapper.readValue(json, Hotel::class.java) <i class="conum" data-value="73"></i><b>(73)</b>
            hotels.add(thisHotel)
        }
        // end::query-access-json[]
    }
/* end func testQuerySyntaxJson */

  fun docsOnlyQuerySyntaxN1QL(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      Database db=argDb
      // tag::query-syntax-n1ql[]
      val thisQuery = dbcreateQuery(
            "SELECT META().id AS id FROM _ WHERE type = \"hotel\"") <i class="conum" data-value="74"></i><b>(74)</b>

      return thisQuery.execute().allResults()

      // end::query-syntax-n1ql[]
  }

  fun docsOnlyQuerySyntaxN1QLParams(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      // tag::query-syntax-n1ql-params[]
      val thisQuery = dbcreateQuery(
            "SELECT META().id AS id FROM _ WHERE type = \$type") <i class="conum" data-value="75"></i><b>(75)</b>

      thisQuery.parameters = Parameters().setString("type", "hotel") <i class="conum" data-value="76"></i><b>(76)</b>

      return thisQuery.execute().allResults()

      // end::query-syntax-n1ql-params[]
  }

    fun openOrCreateDatabaseForUser(argUser: String): Database = Database(argUser)
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.Database
import com.couchbase.lite.MutableDictionary

class BlobExamples {

    // Example 2: Using Blobs
    fun example2(context: Context, db: Database) {
        val doc = db.getDocument("1000") ?: return

        // Create a blob from an asset
        val blob = Blob("image/png", context.assets.open("couchbaseimage.png"))

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON()

        // Save the blob as part of a document
        db.save(doc.toMutable().setBlob("avatar", blob))

        // Experts only!!!
        db.saveBlob(blob)

        // Retrieve saved blob and get as JSON again
        val blobAsJSONString = db.getDocument("1000")?.getBlob("avatar")?.toJSON() ?: return

        // reconstitute
        val blobAsMap = MutableDictionary().setJSON(blobAsJSONString).toMap()

        // show the contents of the reconstituted blob
        for ((key, value) in blobAsMap) {
            Log.d("BLOB", "Data: $key -&gt; $value")
        }

        // verify that the reconstitued thing is still blob
        if (Blob.isBlob(blobAsMap)) {
            Log.d("BLOB", blobAsJSONString)
        }
    }
}


// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt </code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Store imported identity in keychain</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/codesnippet_collection.kt">

// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.Conflict
import com.couchbase.lite.ConflictResolver
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.DatabaseConfiguration
import com.couchbase.lite.DatabaseEndpoint
import com.couchbase.lite.Document
import com.couchbase.lite.DocumentFlag
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.SessionAuthenticator
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.create
import com.couchbase.lite.internal.utils.PlatformUtils
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.io.InputStream
import java.net.URI
import java.net.URISyntaxException


private const val TAG = "REPLICATION"

@Throws(IOException::class)
fun InputStream.toByteArray(): ByteArray {
    val buffer = ByteArray(1024)
    val output = ByteArrayOutputStream()

    var n: Int
    while (-1 &lt; this.read(buffer).also { n = it }) {
        output.write(buffer, 0, n)
    }

    return output.toByteArray()
}

// tag::update-document-with-conflict-handler-callouts[]
//
//        &lt;.&gt; The conflict handler code is provided as a lambda.
//
//        &lt;.&gt; If the handler cannot resolve a conflict, it can return false.
//        In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.
//
//        &lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.
//
//        &lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).
//
//        &lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method
// end::update-document-with-conflict-handler-callouts[]


// tag::local-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
@Suppress("unused")
object LocalWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.localDocument
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
@Suppress("unused")
object RemoteWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.remoteDocument
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
// Using replConfig.setConflictResolver(new MergeConflictResolver());
@Suppress("unused")
object MergeConflictResolver : ConflictResolver {
    override fun resolve(conflict: Conflict): Document {
        val localDoc = conflict.localDocument?.toMap()
        val remoteDoc = conflict.remoteDocument?.toMap()

        val merge: MutableMap&lt;String, Any&gt;?
        if (localDoc == null) {
            merge = remoteDoc
        } else {
            merge = localDoc
            if (remoteDoc != null) {
                merge.putAll(remoteDoc)
            }
        }

        return if (merge == null) {
            MutableDocument(conflict.documentId)
        } else {
            MutableDocument(conflict.documentId, merge)
        }
    }
// end::merge-conflict-resolver[]

    @Suppress("unused")
    class ReplicationExamples(private val database: Database) {
        private var replicator: Replicator? = null

        @Throws(URISyntaxException::class)
        fun testReplicationBasicAuthentication() {
            // tag::basic-authentication[]

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = BasicAuthenticator("username", "password".toCharArray())
                )
            )
            repl.start()
            replicator = repl
            // end::basic-authentication[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationSessionAuthentication() {
            // tag::session-authentication[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447")
                )
            )
            repl.start()
            replicator = repl
            // end::session-authentication[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationStatus() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            // tag::replication-status[]
            // Version using Kotlin Flows to follow shortly ...
            repl.addChangeListener { change -&gt;
                if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                    Log.i(TAG, "Replication stopped")
                }
            }

            repl.start()
            replicator = repl
            // end::replication-status[]
        }

        @Throws(URISyntaxException::class)
        fun testHandlingNetworkErrors() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            // tag::replication-error-handling[]
            // Version using Kotlin Flows to follow shortly ...
            repl.addChangeListener { change -&gt;
                change.status.error?.let {
                    Log.w(TAG, "Error code: ${it.code}")
                }
            }
            repl.start()
            replicator = repl
            // end::replication-error-handling[]

            repl.stop()
        }

        @Throws(URISyntaxException::class)
        fun testReplicatorDocumentEvent() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            // tag::add-document-replication-listener[]
            val token = repl.addDocumentReplicationListener { replication -&gt;
                Log.i(TAG, "Replication type: ${if (replication.isPush) "push" else "pull"}")

                for (document in replication.documents) {
                    document.let { doc -&gt;
                        Log.i(TAG, "Doc ID: ${document.id}")
                        doc.error?.let {
                            // There was an error
                            Log.e(TAG, "Error replicating document: ", it)
                            return@addDocumentReplicationListener
                        }
                        if (doc.flags.contains(DocumentFlag.DELETED)) {
                            Log.i(TAG, "Successfully replicated a deleted document")
                        }
                    }
                }
            }

            repl.start()
            replicator = repl
            // end::add-document-replication-listener[]

            // tag::remove-document-replication-listener[]
            repl.removeChangeListener(token)
            // end::remove-document-replication-listener[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationCustomHeader() {
            // tag::replication-custom-header[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value")
                )
            )
            replicator = repl
            // end::replication-custom-header[]
        }

        // ### Certificate Pinning
        @Throws(URISyntaxException::class, IOException::class)
        fun testCertificatePinning() {
            // tag::certificate-pinning[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value"),
                    pinnedServerCertificate = PlatformUtils.getAsset("cert.cer")?.toByteArray()
                )
            )
            replicator = repl
            // end::certificate-pinning[]
        }

        // ### Reset replicator checkpoint
        @Throws(URISyntaxException::class)
        // tag::replication-startup[]
        fun testReplicationResetCheckpoint() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            // tag::replication-reset-checkpoint[]
            if (resetCheckpointRequired_Example) {
              repl.start(resetCheckpoint = true) <i class="conum" data-value="1"></i><b>(1)</b>
            else
              repl.start(resetCheckpoint = false)
            }
            // end::replication-reset-checkpoint[]

            // ... at some later time

            repl.stop()
        // end::replication-startup[]

        }

        @Throws(URISyntaxException::class)
        fun testReplicationPushFilter() {
            // tag::replication-push-filter[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { _, flags -&gt; flags.contains(DocumentFlag.DELETED) } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
            // end::replication-push-filter[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationPullFilter() {
            // tag::replication-pull-filter[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { document, _ -&gt; "draft" == document.getString("type") } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
            // end::replication-pull-filter[]
        }

        @Throws(URISyntaxException::class)
        fun testCustomRetryConfig() {
            // tag::replication-retry-config[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    //  other config params as required . .
                    // tag::replication-heartbeat-config[]
                    heartbeat = 150, <i class="conum" data-value="1"></i><b>(1)</b>
                    // end::replication-heartbeat-config[]
                    // tag::replication-maxattempts-config[]
                    maxAttempts = 20,
                    // end::replication-maxattempts-config[]
                    maxAttemptWaitTime = 600
                    // end::replication-maxattemptwaittime-config[]
                )
            )

            repl.start()
            replicator = repl
            // end::replication-retry-config[]
        }

        @Throws(CouchbaseLiteException::class)
        fun testDatabaseReplica() {
            val config = DatabaseConfiguration()
            val database1 = Database("mydb", config)
            val database2 = Database("db2", config)

            /* EE feature: code below might throw a compilation error
               if it's compiled against CBL Android Community. */
            // tag::database-replica[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database1,
                    target = DatabaseEndpoint(database2),
                    type = ReplicatorType.PULL
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
            // end::database-replica[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationWithCustomConflictResolver() {
            // tag::replication-conflict-resolver[]
            val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
            val config = ReplicatorConfiguration(database, target)
            config.conflictResolver = LocalWinConflictResolver()
            val replication = Replicator(config)
            replication.start()
            // end::replication-conflict-resolver[]
        }

        @Throws(CouchbaseLiteException::class)
        fun testSaveWithCustomConflictResolver() {
            // tag::update-document-with-conflict-handler[]
            val mutableDocument = database.getDocument("xyz")?.toMutable() ?: return
            mutableDocument.setString("name", "apples")
            database.save(mutableDocument) { newDoc, curDoc -&gt;  <i class="conum" data-value="2"></i><b>(2)</b>
                if (curDoc == null) {
                    return@save false
                } <i class="conum" data-value="3"></i><b>(3)</b>
                val dataMap: MutableMap&lt;String, Any&gt; = curDoc.toMap()
                dataMap.putAll(newDoc.toMap()) <i class="conum" data-value="4"></i><b>(4)</b>
                newDoc.setData(dataMap)
                true <i class="conum" data-value="5"></i><b>(5)</b>
            } <i class="conum" data-value="6"></i><b>(6)</b>
            // end::update-document-with-conflict-handler[]
        }
    }
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import android.widget.Toast
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.Blob
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.DatabaseConfiguration
import com.couchbase.lite.DatabaseConfigurationFactory
import com.couchbase.lite.EncryptionKey
import com.couchbase.lite.Expression
import com.couchbase.lite.LogDomain
import com.couchbase.lite.LogFileConfigurationFactory
import com.couchbase.lite.LogLevel
import com.couchbase.lite.Logger
import com.couchbase.lite.Meta
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.SelectResult
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.UnitOfWork
import com.couchbase.lite.create
import com.couchbase.lite.internal.utils.PlatformUtils
import org.junit.Test
import java.io.File
import java.io.IOException
import java.net.URI
import java.net.URISyntaxException
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.Arrays
import java.util.Date
import java.util.EnumSet


private const val TAG = "BASIC"

// tag::custom-logging[]
class LogTestLogger(private val level: LogLevel) : Logger {
  override fun getLevel() = level

  override fun log(level: LogLevel, domain: LogDomain, message: String) {
    // this method will never be called if param level &lt; this.level
    // handle the message, for example piping it to a third party framework
  }
}

// end::custom-logging[]
// tag::example-app[]
@Suppress("unused")
class BasicExamples(private val context: Context) {
    private val database: Database

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        // Get the database (and create it if it doesnt exist).
        database = Database(
            "getting-started",
            DatabaseConfigurationFactory.create(context.filesDir.absolutePath)
        )
    }

    @Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {

        // !!! Note the code moved from here to the init { } above.
        // tag::getting-started[]
        // Create a new document (i.e. a record) in the database.
        var mutableDoc = MutableDocument().setFloat("version", 2.0f).setString("type", "SDK")

        // Save it to the database.
        database.save(mutableDoc)

        // Update a document.
        mutableDoc = database.getDocument(mutableDoc.id)!!.toMutable().setString("language", "Java")
        database.save(mutableDoc)

        val document = database.getDocument(mutableDoc.id)!!
        // Log the document ID (generated by the database) and properties
        Log.i(TAG, "Document ID :: ${document.id}")
        Log.i(TAG, "Learning ${document.getString("language")}")

        // Create a query to fetch documents of type SDK.
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))
            .execute()
        Log.i(TAG, "Number of rows :: ${rs.allResults().size}")

        // Create a replicator to push and pull changes to and from the cloud.
        // Be sure to hold a reference somewhere to prevent the Replicator from being GCed
        val replicator = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(URI("ws://localhost:4984/getting-started-db")),
                type = ReplicatorType.PUSH_AND_PULL,
                authenticator = BasicAuthenticator("sync-gateway", "password".toCharArray())
            )
        )

        // Listen to replicator change events.
        // Version using Kotlin Flows to follow shortly ...

        replicator.addChangeListener { change -&gt;
            val err = change.status.error
            if (err != null) Log.i(TAG, "Error code ::  ${err.code}")
        }

        // Start replication.
        replicator.start()

        // end::getting-started[]
        database.delete()
    }
    // end::example-app[]

    @Throws(CouchbaseLiteException::class, IOException::class)
    fun test1xAttachments() {
        // if db exist, delete it
        deleteDB("android-sqlite", context.filesDir)
        ZipUtils.unzip(PlatformUtils.getAsset("replacedb/android140-sqlite.cblite2.zip"), context.filesDir)

        val db = Database("android-sqlite")
        try {
            // For Validation
            Arrays.equals(
                "attach1".toByteArray(),
                db.getDocument("doc1")?.getDictionary("_attachments")?.getBlob("attach1")?.content
            )
        } finally {
            // close db
            db.close()
            // if db exist, delete it
            deleteDB("android-sqlite", context.filesDir)
        }
        val document = MutableDocument()

        // tag::1x-attachment[]
        val content = document.getDictionary("_attachments")?.getBlob("avatar")?.content
        // end::1x-attachment[]
    }

    // ### Initializer
    fun testInitializer() {
        // tag::sdk-initializer[]
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)
        // end::sdk-initializer[]
    }

    // ### New Database
    @Throws(CouchbaseLiteException::class)
    fun testNewDatabase() {
        // tag::new-database[]
        val db = Database("my-db", DatabaseConfigurationFactory.create(context.filesDir.absolutePath)) <i class="conum" data-value="7"></i><b>(7)</b>
        // end::new-database[]
        db.delete()
    }

    // ### Database Encryption
    @Throws(CouchbaseLiteException::class)
    fun testDatabaseEncryption() {
        // tag::database-encryption[]
        val db = Database("my-db", DatabaseConfigurationFactory.create(encryptionKey = EncryptionKey("PASSWORD")))
        // end::database-encryption[]
    }

    // ### Logging
    // !!! OBSOLETE in 3.0
    fun testLogging() {
        // tag::logging[]
        // end::logging[]
    }

    fun testEnableCustomLogging() {
        // tag::set-custom-logging[]
        // this custom logger will not log an event with a log level &lt; WARNING
        Database.log.custom = LogTestLogger(LogLevel.WARNING) <i class="conum" data-value="8"></i><b>(8)</b>
        // end::set-custom-logging[]
    }

    // ### Console logging
    @Throws(CouchbaseLiteException::class)
    fun testConsoleLogging() {
        // tag::console-logging[]
        Database.log.console.domains = LogDomain.ALL_DOMAINS <i class="conum" data-value="9"></i><b>(9)</b>
        Database.log.console.level = LogLevel.VERBOSE <i class="conum" data-value="10"></i><b>(10)</b>
        // end::console-logging[]

        // tag::console-logging-db[]
        Database.log.console.domains = EnumSet.of(LogDomain.DATABASE) <i class="conum" data-value="11"></i><b>(11)</b>
        // end::console-logging-db[]
    }

    // ### File logging
    @Throws(CouchbaseLiteException::class)
    fun testFileLogging() {
        // tag::file-logging[]
        Database.log.file.let {
            it.config = LogFileConfigurationFactory.create(
                context.cacheDir.absolutePath, <i class="conum" data-value="12"></i><b>(12)</b>
                maxSize = 10240, <i class="conum" data-value="13"></i><b>(13)</b>
                maxRotateCount = 5, <i class="conum" data-value="14"></i><b>(14)</b>
                usePlainText = false
            ) <i class="conum" data-value="15"></i><b>(15)</b>
            it.level = LogLevel.INFO <i class="conum" data-value="16"></i><b>(16)</b>

            // end::file-logging[]
        }
    }

    fun writeConsoleLog() {
        // tag::write-console-logmsg[]
        Database.log.console.log(LogLevel.WARNING, LogDomain.REPLICATOR, "Any old log message")
        // end::write-console-logmsg[]
    }

    fun writeCustomLog() {
        // tag::write-custom-logmsg[]
        Database.log.custom?.log(LogLevel.WARNING, LogDomain.REPLICATOR, "Any old log message")
        // end::write-custom-logmsg[]
    }

    fun writeFileLog() {
        // tag::write-file-logmsg[]
        Database.log.file.log(LogLevel.WARNING, LogDomain.REPLICATOR, "Any old log message")
        // end::write-file-logmsg[]
    }

    /* The `tag::replication[]` example is inlined in java.adoc */
    fun testTroubleshooting() {
        // tag::replication-logging[]
        Database.log.console.let {
            it.level = LogLevel.VERBOSE
            it.domains = LogDomain.ALL_DOMAINS
        }
        // end::replication-logging[]
    }

    // ### Loading a pre-built database
    @Throws(IOException::class)
    fun testPreBuiltDatabase() {
        // tag::prebuilt-database[]
        // Note: Getting the path to a database is platform-specific.
        // For Android you need to extract the database from your assets
        // to a temporary directory and then copy it, using Database.copy()
        if (Database.exists("travel-sample", context.filesDir)) {
            return
        }
        ZipUtils.unzip(PlatformUtils.getAsset("travel-sample.cblite2.zip"), context.filesDir)
        Database.copy(File(context.filesDir, "travel-sample"), "travel-sample", DatabaseConfiguration())
        // end::prebuilt-database[]
    }

    // helper methods
    // if db exist, delete it
    fun deleteDB(name: String, dir: File) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            Database.delete(name, dir)
        }

        // ### Initializers
        fun testInitializers() {
            // tag::initializer[]
            val doc = MutableDocument()
            doc.let {
                it.setString("type", "task")
                it.setString("owner", "todo")
                it.setDate("createdAt", Date())
            }
            database.save(doc)
            // end::initializer[]
        }
    }

    // ### Mutability
    fun testMutability() {
        database.save(MutableDocument("xyz"))

        // tag::update-document[]
        database.getDocument("xyz")?.toMutable()?.let {
            it.setString("name", "apples")
            database.save(it)
        }
        // end::update-document[]
    }

    // ### Typed Accessors
    fun testTypedAccessors() {
        val doc = MutableDocument()

        // tag::date-getter[]
        doc.setValue("createdAt", Date())
        val date = doc.getDate("createdAt")
        // end::date-getter[]
    }

    // ### Batch operations
    fun testBatchOperations() {
        // tag::batch[]
        database.inBatch(UnitOfWork {
            for (i in 0..9) {
                val doc = MutableDocument()
                doc.let {
                    it.setValue("type", "user")
                    it.setValue("name", "user $i")
                    it.setBoolean("admin", false)
                }
                Log.i(TAG, "saved user document: ${doc.getString("name")}")
            }
        })
        // end::batch[]
    }

    // ### Document Expiration
    @Throws(CouchbaseLiteException::class)
    fun documentExpiration() {
        // tag::document-expiration[]
        // Purge the document one day from now
        database.setDocumentExpiration("doc123", Date(Instant.now().plus(1, ChronoUnit.DAYS).toEpochMilli()))

        // Reset expiration
        database.setDocumentExpiration("doc1", null)

        // Query documents that will be expired in less than five minutes
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.longValue(Instant.now().plus(5, ChronoUnit.MINUTES).toEpochMilli())
                )
            )
        // end::document-expiration[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testDocumentChangeListener() {
        // tag::document-listener[]
        // Version using Kotlin Flows to follow shortly ...

        database.addDocumentChangeListener("user.john") { change -&gt;
            database.getDocument(change.documentID)?.let {
                Toast.makeText(context, "Status: ${it.getString("verified_account")}", Toast.LENGTH_SHORT).show()
            }
        }
        // end::document-listener[]
    }

    // ### Blobs
    fun testBlobs() {
        val mDoc = MutableDocument()

        // tag::blob[]
        PlatformUtils.getAsset("avatar.jpg")?.use { <i class="conum" data-value="17"></i><b>(17)</b>
            mDoc.setBlob("avatar", Blob("image/jpeg", it)) <i class="conum" data-value="18"></i><b>(18)</b> <i class="conum" data-value="19"></i><b>(19)</b>
            database.save(mDoc)
        }

        val doc = database.getDocument(mDoc.id)
        val bytes = doc?.getBlob("avatar")?.content
        // end::blob[]
    }
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.Dictionary
import com.couchbase.lite.Expression
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.MutableDictionary
import com.couchbase.lite.PredictionFunction
import com.couchbase.lite.PredictiveIndex
import com.couchbase.lite.PredictiveModel
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.SelectResult
import com.couchbase.lite.ValueIndex
import com.couchbase.lite.ValueIndexItem


private const val TAG = "PREDICT"

// `tensorFlowModel` is a fake implementation
object TensorFlowModel {
    fun predictImage(data: ByteArray?) = mapOf&lt;String, Any?&gt;()
}

object ImageClassifierModel : PredictiveModel {
    const val name = "ImageClassifier"

    override fun predict(input: Dictionary): Dictionary? {
        val blob: Blob = input.getBlob("photo") ?: return null

        // this would be the implementation of the ml model you have chosen
        return MutableDictionary(TensorFlowModel.predictImage(blob.content)) <i class="conum" data-value="1"></i><b>(1)</b>
    }
} // end::predictive-model[]


@Suppress("unused")
class PredictiveQueryExamples {
    @Throws(CouchbaseLiteException::class)
    fun testPredictiveModel() {
        val database = Database("mydb")

        // tag::register-model[]
        Database.prediction.registerModel("ImageClassifier", ImageClassifierModel)
        // end::register-model[]

        // tag::predictive-query-value-index[]
        val index: ValueIndex = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")))
        database.createIndex("value-index-image-classifier", index)
        // end::predictive-query-value-index[]

        // tag::unregister-model[]
        Database.prediction.unregisterModel("ImageClassifier")
        // end::unregister-model[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveIndex() {
        val database = Database("mydb")

        // tag::predictive-query-predictive-index[]
        val inputMap: MutableMap&lt;String, Any&gt; = mutableMapOf()
        inputMap["numbers"] = Expression.property("photo")
        val input: Expression = Expression.map(inputMap)
        val index: PredictiveIndex = IndexBuilder.predictiveIndex("ImageClassifier", input, null)
        database.createIndex("predictive-index-image-classifier", index)
        // end::predictive-query-predictive-index[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveQuery() {
        val database = Database("mydb")

        // tag::predictive-query[]
        val prediction: PredictionFunction = Function.prediction(
            ImageClassifierModel.name,
            Expression.map(mutableMapOf("photo" to Expression.property("photo")) as Map&lt;String, Any&gt;?) <i class="conum" data-value="1"></i><b>(1)</b>
        )

        // !!! Is this query using that prediction function, at all?
        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("label").equalTo(Expression.string("car"))
                    .and(
                        Expression.property("probability")
                            .greaterThanOrEqualTo(Expression.doubleValue(0.8))
                    )
            )
            .execute()

        Log.d(TAG, "Number of rows: ${rs.allResults().size}")
        // end::predictive-query[]
    }
}


// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorStatus


private const val TAG = "PENDING"

@Suppress("unused")
class PendingDocsExample(private var replicator: Replicator) {
    //
    // tag::replication-pendingdocuments[]
    //
    private fun onStatusChanged(pendingDocs: Set&lt;String&gt;, status: ReplicatorStatus) {
        // ... sample onStatusChanged function
        //
        Log.i(TAG, "Replicator activity level is ${status.activityLevel}")

        // iterate and report-on previously
        // retrieved pending docids 'list'
        val itr = pendingDocs.iterator()
        while (itr.hasNext()) {
            val docId = itr.next()

            // tag::replication-push-isdocumentpending[]
            if (!replicator.isDocumentPending(docId)) { <i class="conum" data-value="20"></i><b>(20)</b>
                continue
            }

            // end::replication-push-isdocumentpending[]
            Log.i(TAG, "Doc ID $docId has been pushed")
        }
    } // end::replication-pendingdocuments[]
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Endpoint
import com.couchbase.lite.KeyStoreUtils
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.net.URI
import java.net.URISyntaxException
import java.security.KeyStore
import java.security.cert.Certificate

private const val TAG = "P2P"


@Suppress("unused")
class IBExamples(private val context: Context, private val caCert: Certificate) {
    private val database: Database
    private var thisReplicator: Replicator? = null
    private var thisListener: URLEndpointListener? = null

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        database = Database("p2p_demo")

        /* do some stuff here */
    }

    // PASSIVE PEER STUFF
    fun ibListenerSimple() {
        // tag::listener-simple[]
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database,
                authenticator
                = ListenerPasswordAuthenticator { user, pwd -&gt; (user == "daniel") &amp;&amp; (String(pwd) == "123") })
        ) <i class="conum" data-value="21"></i><b>(21)</b>
        listener.start() <i class="conum" data-value="22"></i><b>(22)</b>
        thisListener = listener

        // end::listener-simple[]
    }

    fun ibReplicatorSimple() {
        // tag::replicator-simple[]
        val theListenerEndpoint: Endpoint = URLEndpoint(URI("wss://10.0.2.2:4984/db")) <i class="conum" data-value="23"></i><b>(23)</b>
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,
                target = theListenerEndpoint,
                authenticator = BasicAuthenticator("valid.user", "valid.password.string".toCharArray()), <i class="conum" data-value="24"></i><b>(24)</b>
                acceptOnlySelfSignedServerCertificate = true
            )
        )
        repl.start() <i class="conum" data-value="25"></i><b>(25)</b>
        thisReplicator = repl
        // end::replicator-simple[]
    }

    fun ibPassListener(validUser: String, validPassword: CharArray) {
        // EXAMPLE 1
        // tag::listener-start[]
        // Initialize the listener
        // tag::listener-initialize[]
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                // tag::listener-config-db[]
                database = database, <i class="conum" data-value="26"></i><b>(26)</b>
                // end::listener-config-db[]
                // tag::listener-config-port[]
                port = 55990, <i class="conum" data-value="27"></i><b>(27)</b>
                // end::listener-config-port[]
                // tag::listener-config-netw-iface[]
                networkInterface = "10.1.1.10", <i class="conum" data-value="28"></i><b>(28)</b>

                // end::listener-config-netw-iface[]
                // tag::listener-config-delta-sync[]
                enableDeltaSync = false, <i class="conum" data-value="29"></i><b>(29)</b>

                // end::listener-config-delta-sync[]
                // tag::listener-config-tls-full[]
                // Configure server security
                // tag::listener-config-tls-enable[]
                disableTls = false, <i class="conum" data-value="30"></i><b>(30)</b>

                // end::listener-config-tls-enable[]
                // tag::listener-config-tls-id-anon[]
                // Use an Anonymous Self-Signed Cert
                identity = null, <i class="conum" data-value="31"></i><b>(31)</b>
                // end::listener-config-tls-id-anon[]

                // tag::listener-config-client-auth-pwd[]
                // Configure Client Security using an Authenticator
                // For example, Basic Authentication <i class="conum" data-value="32"></i><b>(32)</b>
                authenticator = ListenerPasswordAuthenticator { username, paassword -&gt;
                    (username === validUser) &amp;&amp; (paassword === validPassword)
                }
            ))

        // Start the listener
        listener.start() <i class="conum" data-value="33"></i><b>(33)</b>
        thisListener = listener

        // end::listener-initialize[]
        // end::listener-start[]
    }

    fun ibListenerGetNetworkInterfaces() {
        // tag::listener-get-network-interfaces[]
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        listener.start()
        Log.i(TAG, "URLS are ${listener.urls}")
        thisListener = listener
        // end::listener-get-network-interfaces[]
    }

    fun ibListenerLocalDb() {
        // tag::listener-local-db[]
        // . . . preceding application logic . . .
        CouchbaseLite.init(context) <i class="conum" data-value="34"></i><b>(34)</b>
        val thisDB = Database("passivepeerdb")
        // end::listener-local-db[]
    }

    fun ibListenerConfigTlsDisable() {
        // tag::listener-config-tls-disable[]
        URLEndpointListenerConfigurationFactory.create(database, disableTls = false) <i class="conum" data-value="35"></i><b>(35)</b>
        // end::listener-config-tls-disable[]
    }


    // !!! USERS SHOULD BE CAUTIONED THAT THIS IS INSECURE
    // Android has much better ways of importing keys
    fun ibListenerConfigTlsIdFull() {
        // tag::listener-config-tls-id-full[]
        // tag::listener-config-tls-id-caCert[]
        // Use CA Cert
        // Import a key pair into secure storage
        // Create a TLSIdentity from the imported key-pair

        this.javaClass.getResourceAsStream("serverkeypair.p12")?.use { <i class="conum" data-value="36"></i><b>(36)</b>
            KeyStoreUtils.importEntry(
                "teststore.p12",  // KeyStore type, eg: "PKCS12"
                it,  // An InputStream from the keystore
                "let me in".toCharArray(),  // The keystore password
                "topSekritKey",  // The alias to be used (in external keystore)
                null,  // The key password or null if the key has none
                "test-alias" // The alias for the imported key
            )
        }

        // end::listener-config-tls-id-caCert[]

        // tag::listener-config-tls-id-set[]
        // Set the TLS Identity
        URLEndpointListenerConfigurationFactory.create(
            database,
            identity = TLSIdentity.getIdentity("test-alias")
        ) <i class="conum" data-value="37"></i><b>(37)</b>

        // end::listener-config-tls-id-set[]
// end::listener-config-tls-id-full[]
    }

    fun ibListenerConfigClientAuthRoot() {
// tag::listener-config-client-root-ca[]
        // tag::listener-config-client-auth-root[]
        // Configure the client authenticator
        // to validate using ROOT CA
        // thisClientID.certs is a list containing a client cert to accept
        // and any other certs needed to complete a chain between the client cert
        // and a CA
        val validId = TLSIdentity.getIdentity("Our Corporate Id")
            ?: throw IllegalStateException("Cannot find corporate id")
        // accept only clients signed by the corp cert
        thisListener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                // get the identity <i class="conum" data-value="38"></i><b>(38)</b>
                database = database,
                identity = validId,
                authenticator = ListenerCertificateAuthenticator(validId.certs)
            )
        ) <i class="conum" data-value="39"></i><b>(39)</b>

        // end::listener-config-client-auth-root[]
// end::listener-config-client-root-ca[]
    }

    fun ibListenerConfigTlsDisable2() {

        // tag::listener-config-tls-disable[]
        URLEndpointListenerConfigurationFactory.create(database = database, disableTls = true)
        // end::listener-config-tls-disable[]
    }

    fun ibListenerStatusCheck() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        // tag::listener-status-check[]
        val connectionCount = listener.status?.connectionCount <i class="conum" data-value="40"></i><b>(40)</b>
        val activeConnectionCount = listener.status?.activeConnectionCount <i class="conum" data-value="41"></i><b>(41)</b>
        // end::listener-status-check[]
    }

    fun ibListenerStop() {

        // tag::listener-stop[]
        thisListener?.stop()

        // end::listener-stop[]
    }

    // ACTIVE PEER STUFF
// Replication code
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testActPeerSync() {
        // tag::p2p-act-rep-start-full[]
        // Create replicator
        // Consider holding a reference somewhere
        // to prevent the Replicator from being GCed
        val repl = Replicator( <i class="conum" data-value="42"></i><b>(42)</b>

            // tag::p2p-act-rep-func[]
            // tag::p2p-act-rep-initialize[]
            // initialize the replicator configuration
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(URI("wss://listener.com:8954")), <i class="conum" data-value="43"></i><b>(43)</b>

                // end::p2p-act-rep-initialize[]
                // tag::p2p-act-rep-config-type[]
                // Set replicator type
                type = ReplicatorType.PUSH_AND_PULL,

                // end::p2p-act-rep-config-type[]
                // tag::p2p-act-rep-config-cont[]
                // Configure Sync Mode
                continuous = false, // default value

                // end::p2p-act-rep-config-cont[]

                // tag::autopurge-override[]
                // set auto-purge behavior
                // (here we override default)
                enableAutoPurge = false, <i class="conum" data-value="44"></i><b>(44)</b>

                // end::autopurge-override[]


                // tag::p2p-act-rep-config-self-cert[]
                // Configure Server Authentication --
                // only accept self-signed certs
                acceptOnlySelfSignedServerCertificate = true, <i class="conum" data-value="45"></i><b>(45)</b>

                // end::p2p-act-rep-config-self-cert[]
                // tag::p2p-act-rep-auth[]
                // Configure the credentials the
                // client will provide if prompted
                authenticator = BasicAuthenticator("Our Username", "Our PasswordValue".toCharArray()), <i class="conum" data-value="46"></i><b>(46)</b>


                // end::p2p-act-rep-auth[]
                // tag::p2p-act-rep-config-conflict[]
                /* Optionally set custom conflict resolver call back */
                conflictResolver = null <i class="conum" data-value="47"></i><b>(47)</b>
            )
        )

        // end::p2p-act-rep-config-conflict[]

        // tag::p2p-act-rep-add-change-listener[]
        // tag::p2p-act-rep-add-change-listener-label[]
        // Optionally add a change listener <i class="conum" data-value="48"></i><b>(48)</b>
        // end::p2p-act-rep-add-change-listener-label[]
        val thisListener = repl.addChangeListener { change -&gt;
            val err: CouchbaseLiteException? = change.status.error
            if (err != null) {
                Log.i(TAG, "Error code ::  ${err.code}", err)
            }
        }

        // end::p2p-act-rep-add-change-listener[]
        // tag::p2p-act-rep-start[]
        // Start replicator
        repl.start(false) <i class="conum" data-value="49"></i><b>(49)</b>
        thisReplicator = repl

        // end::p2p-act-rep-start[]
        // end::p2p-act-rep-start-full[]
        // end::p2p-act-rep-func[]         ***** End p2p-act-rep-func
    }

    fun ibReplicatorConfig() {
        // BEGIN additional snippets
        // tag::p2p-act-rep-config-tls-full[]

        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,

                // tag::p2p-act-rep-config-cacert[]
                // Configure Server Security
                // -- only accept CA attested certs
                acceptOnlySelfSignedServerCertificate = false, <i class="conum" data-value="50"></i><b>(50)</b>

                // end::p2p-act-rep-config-cacert[]


                // tag::p2p-act-rep-config-cacert-pinned[]

                // Use the pinned certificate from the byte array (cert)
                pinnedServerCertificate = caCert.encoded, <i class="conum" data-value="51"></i><b>(51)</b>
                // end::p2p-act-rep-config-cacert-pinned[]


                // end::p2p-act-rep-config-tls-full[]
                // tag::p2p-tlsid-tlsidentity-with-label[]
                // ... other replicator configuration
                // Provide a client certificate to the server for authentication
                authenticator = ClientCertificateAuthenticator(
                    TLSIdentity.getIdentity("clientId")
                        ?: throw IllegalStateException("Cannot find client id")
                ) <i class="conum" data-value="52"></i><b>(52)</b>

                // ... other replicator configuration

            )
        )

        thisReplicator = repl
        // end::p2p-tlsid-tlsidentity-with-label[]
    }

    fun ibP2pReplicatorStatus() {
        // tag::p2p-act-rep-status[]
        thisReplicator?.status?.let {
            Log.i(TAG, "The Replicator is currently ${it.activityLevel}")
            Log.i(TAG, "The Replicator has processed ${it.progress}")
            Log.i(
                TAG,
                if (it.activityLevel === ReplicatorActivityLevel.BUSY) {
                    "Replication Processing"
                } else {
                    "It has completed ${it.progress.total} changes"
                }
            )
        }
        // end::p2p-act-rep-status[]
    }

    fun ibP2pReplicatorStop() {
        // tag::p2p-act-rep-stop[]
        // Stop replication.
        thisReplicator?.stop() <i class="conum" data-value="53"></i><b>(53)</b>
        // end::p2p-act-rep-stop[]
    }

    fun ibP2pListener() {
        CouchbaseLite.init(context)
        val thisDB = Database("passivepeerdb") <i class="conum" data-value="54"></i><b>(54)</b>


        // Initialize the listener
        val listener = URLEndpointListener( <i class="conum" data-value="55"></i><b>(55)</b>

            // Initialize the listener config
            URLEndpointListenerConfigurationFactory.create(
                database = thisDB,
                port = 55990, /* &lt;.&gt;  Optional; defaults to auto */
                disableTls = false, /* &lt;.&gt;  Optional; defaults to false */
                enableDeltaSync = true,  /* &lt;.&gt; Optional; defaults to false */

                // Configure the client authenticator (if using basic auth)
                authenticator = ListenerPasswordAuthenticator { username, password -&gt;
                    ("username" === username) &amp;&amp; (password === "password".toCharArray())  <i class="conum" data-value="56"></i><b>(56)</b>
                }
            )
        )

        // Start the listener
        listener.start() <i class="conum" data-value="57"></i><b>(57)</b>


        // tag::createTlsIdentity[]

//        Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
//                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
//                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
//        );
        val thisIdentity = TLSIdentity.createIdentity(
            true,
            mapOf(
                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
            ),
            null,
            "test-alias"
        )

        // end::createTlsIdentity[]

        // tag::p2p-tlsid-store-in-keychain[]
        // end::p2p-tlsid-store-in-keychain[]


        // tag::deleteTlsIdentity[]
        // tag::p2p-tlsid-delete-id-from-keychain[]
        val thisAlias = "alias-to-delete"
        val thisKeyStore = KeyStore.getInstance("AndroidKeyStore")
        thisKeyStore.load(null)
        thisKeyStore.deleteEntry(thisAlias)

        // end::p2p-tlsid-delete-id-from-keychain[]
        // end::deleteTlsIdentity[]

        // tag::retrieveTlsIdentity[]
        // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label
        val thatIdentity = TLSIdentity.getIdentity("couchbase-docs-cert")
        // end::retrieveTlsIdentity[]
    }

    // tag::sgw-repl-pull[]
    fun ibRplicatorPull() {
        val database = Database("ian")

        val uri = URI("wss://10.0.2.2:4984/db") <i class="conum" data-value="58"></i><b>(58)</b>

        val repl = Replicator( <i class="conum" data-value="59"></i><b>(59)</b>
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(uri),
                type = ReplicatorType.PULL
            )
        )

        repl.start()
        thisReplicator = repl
    }

    // end::sgw-repl-pull[]
// tag::sgw-act-rep-initialize[]
// initialize the replicator configuration
    val thisConfig = ReplicatorConfigurationFactory.create(
        database = database,
        target = URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))
    ) // &lt;.&gt; // end::sgw-act-rep-initialize[]

/* C A L L O U T S

// Listener Callouts

// tag::listener-callouts-full[]

// tag::listener-start-callouts[]
&lt;.&gt; Initialize the listener instance using the configuration settings.
&lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.

// end::listener-start-callouts[]

// tag::listener-status-check-callouts[]

&lt;.&gt; `connectionCount` -- the total number of connections served by the listener
&lt;.&gt; `activeConnectionCount` -- the number of active (BUSY) connections currently being served by the listener
//
// end::listener-status-check-callouts[]

// end::listener-callouts-full[]


// tag::p2p-act-rep-config-cacert-pinned-callouts[]
&lt;.&gt; Configure the pinned certificate using data from the byte array `cert`
// end::p2p-act-rep-config-cacert-pinned-callouts[]

// tag::p2p-tlsid-tlsidentity-with-label-callouts[]
&lt;.&gt; Attempt to get the identity from secure storage
&lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity

// end::p2p-tlsid-tlsidentity-with-label-callouts[]

// tag::sgw-repl-pull-callouts[]
&lt;.&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;.&gt; The URL scheme for remote database URLs uses `ws:`, or `wss:` for SSL/TLS connections over wb sockets.
In this example the hostname is `10.0.2.2` because the Android emulator runs in a VM that is generally accessible on `10.0.2.2` from the host machine (see https://developer.android.com/studio/run/emulator-networking[Android Emulator networking] documentation).
+
NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
Although `wss:` protocol URLs are not affected, in order to use the `ws:` protocol, applications must target API 27 or lower, or must configure application network security as described https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted[here].

// end::sgw-repl-pull-callouts[]
*/
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.net.URI
import java.security.KeyStore
import java.security.KeyStoreException
import java.security.NoSuchAlgorithmException
import java.security.cert.Certificate
import java.security.cert.CertificateEncodingException
import java.security.cert.CertificateException
import java.util.concurrent.CountDownLatch

private const val TAG = "LISTEN"

@Suppress("unused")
class CertAuthListener {
    companion object {
        private val CERT_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "CBL Test",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "lite@couchbase.com",
        )
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)

        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        remoteDb.save(doc)

        val serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server")

        val clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client")
        val uri = startServer(remoteDb, serverIdentity, clientIdentity.certs)
            ?: throw IOException("Failed to start the server")

        Thread {
            startClient(localDb, uri, clientIdentity, serverIdentity.certs[0])
            Log.e(TAG, "Success!!")
            deleteIdentity("server")
            Log.e(TAG, "Alias deleted: server")
            deleteIdentity("client")
            Log.e(TAG, "Alias deleted: client")
        }.start()
    }

    // start a client replicator
    @Throws(CertificateEncodingException::class, InterruptedException::class)
    fun startClient(db: Database, uri: URI, clientIdentity: TLSIdentity, cert: Certificate) {
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = db,
                target = URLEndpoint(uri),
                type = ReplicatorType.PUSH_AND_PULL,
                continuous = false,
                authenticator = ClientCertificateAuthenticator(clientIdentity),
                pinnedServerCertificate = cert.encoded
            )
        )

        val completionLatch = CountDownLatch(1)

        repl.addChangeListener { change -&gt;
            if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    // tag::listener-config-auth-cert-full[]
    /**
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     *
     *
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Throws(CouchbaseLiteException::class)
    fun startServer(db: Database, serverId: TLSIdentity, certs: List&lt;Certificate?&gt;): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0, // this is the default
                disableTls = false,
                identity = serverId,
                authenticator = ListenerCertificateAuthenticator(certs)
            )
        )
        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
    // end::listener-config-auth-cert-full[]
    // tag::listener-config-delete-cert-full[]
    /**
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    @Throws(
        KeyStoreException::class,
        CertificateException::class,
        NoSuchAlgorithmException::class,
        IOException::class
    )
    fun deleteIdentity(alias: String?) {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        keyStore.deleteEntry(alias) <i class="conum" data-value="60"></i><b>(60)</b>
    }
    // end::listener-config-delete-cert-full[]
    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /**
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     *
     *
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    @Throws(CertificateEncodingException::class)
    private fun configureClientCerts(
        config: ReplicatorConfiguration,
        cert: Certificate,
        clientIdentity: TLSIdentity
    ) {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(ClientCertificateAuthenticator(clientIdentity))

        // Configure the pinned certificate passing a byte array.
        config.pinnedServerCertificate = cert.encoded
    }
    // notend::p2p-tlsid-tlsidentity-with-label[]
    /**
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     *
     *
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    @Throws(IOException::class)
    private fun readCertMaterialFromBundle(
        context: Context,
        resId: Int
    ): ByteArray {
        val out = ByteArrayOutputStream()
        val `in` = context.resources.openRawResource(resId)
        val buf = ByteArray(1024)
        var n: Int
        while (`in`.read(buf).also { n = it } &gt;= 0) {
            out.write(buf, 0, n)
        }
        return out.toByteArray()
    }
}

@Suppress("unused")
class PasswordAuthListener {
    companion object {
        private const val VALID_USER = "Minnie"
        private val VALID_PASSWORD = "let me in!".toCharArray()
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray())
            ?: throw IOException("Failed to start the server")
        Thread {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb)
                Log.e(TAG, "Success!!")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }.start()
    }

    // start a client replicator
    @Throws(InterruptedException::class)
    fun runClient(
        uri: URI,
        username: String,
        password: CharArray,
        db: Database
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.type = ReplicatorType.PUSH_AND_PULL
        config.isContinuous = false
        config.setAuthenticator(BasicAuthenticator(username, password))
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)

        // Version using Kotlin Flows to follow shortly ...
        repl.addChangeListener { change -&gt;
            if (change.status
                    .activityLevel == ReplicatorActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    // tag::listener-config-client-auth-pwd-full[]
    /**
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     *
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    fun startServer(db: Database, username: String, password: CharArray): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0,// this is the default
                disableTls = true,
                authenticator = ListenerPasswordAuthenticator { usr, pwd -&gt;
                    (usr == username) &amp;&amp; pwd.contentEquals(password)
                })
        )

        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
// end::listener-config-client-auth-pwd-full[]
}





// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Message
import com.couchbase.lite.MessageEndpoint
import com.couchbase.lite.MessageEndpointConnection
import com.couchbase.lite.MessageEndpointDelegate
import com.couchbase.lite.MessageEndpointListener
import com.couchbase.lite.MessageEndpointListenerConfigurationFactory
import com.couchbase.lite.MessagingCloseCompletion
import com.couchbase.lite.MessagingCompletion
import com.couchbase.lite.ProtocolType
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorConnection
import com.couchbase.lite.create


@Suppress("unused")
class BrowserSessionManager : MessageEndpointDelegate {
    private var replicator: Replicator? = null

    @Throws(CouchbaseLiteException::class)
    fun initCouchbase() {
        // tag::message-endpoint[]
        val database = Database("mydb")

        // The delegate must implement the `MessageEndpointDelegate` protocol.
        val messageEndpoint = MessageEndpoint("UID:123", "active", ProtocolType.MESSAGE_STREAM, this)
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        // Create the replicator object.
        val repl = Replicator(ReplicatorConfigurationFactory.create(database = database, target = messageEndpoint))
        // Start the replication.
        repl.start()
        replicator = repl
        // end::message-endpoint-replicator[]
    }

    // tag::create-connection[]
    /* implementation of MessageEndpointDelegate */
    override fun createConnection(endpoint: MessageEndpoint) = ActivePeerConnection()
    // end::create-connection[]
}

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ----------------------------------------------------------- */

@Suppress("unused")
class ActivePeerConnection : MessageEndpointConnection {
    private var replicatorConnection: ReplicatorConnection? = null

    // tag::active-replicator-close[]
    fun disconnect() {
        replicatorConnection?.close(null)
        replicatorConnection = null
    }
    // end::active-replicator-close[]

    // tag::active-peer-open[]
    /* implementation of MessageEndpointConnection */
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    // end::active-peer-open[]
    // tag::active-peer-close[]
    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete()
    }

    // end::active-peer-close[]
    // tag::active-peer-send[]
    /* implementation of MessageEndpointConnection */
    override fun send(message: Message, completion: MessagingCompletion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null)
    }

    // end::active-peer-send[]
    fun receive(message: Message) {
        // tag::active-peer-receive[]
        replicatorConnection?.receive(message)
        // end::active-peer-receive[]
    }
}

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ----------------------------------------------------------- */

@Suppress("unused")
class PassivePeerConnection private constructor() : MessageEndpointConnection {
    private var messageEndpointListener: MessageEndpointListener? = null
    private var replicatorConnection: ReplicatorConnection? = null

    @Throws(CouchbaseLiteException::class)
    fun startListener() {
        // tag::listener[]
        val database = Database("mydb")
        messageEndpointListener = MessageEndpointListener(
            MessageEndpointListenerConfigurationFactory.create(database, ProtocolType.MESSAGE_STREAM)
        )
        // end::listener[]
    }

    fun stopListener() {
        // tag::passive-stop-listener[]
        messageEndpointListener?.closeAll()
        // end::passive-stop-listener[]
    }

    fun accept() {
        // tag::advertizer-accept[]
        val connection = PassivePeerConnection() /* implements MessageEndpointConnection */
        messageEndpointListener?.accept(connection)
        // end::advertizer-accept[]
    }

    fun disconnect() {
        // tag::passive-replicator-close[]
        replicatorConnection?.close(null)
        // end::passive-replicator-close[]
    }

    // tag::passive-peer-open[]
    /* implementation of MessageEndpointConnection */
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }
    // end::passive-peer-open[]

    // tag::passive-peer-close[]
    /* implementation of MessageEndpointConnection */
    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete()
    }

    // end::passive-peer-close[]
    // tag::passive-peer-send[]
    /* implementation of MessageEndpointConnection */
    override fun send(message: Message, completion: MessagingCompletion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null)
    }

    // end::passive-peer-send[]
    fun receive(message: Message) {
        // tag::passive-peer-receive[]
        replicatorConnection?.receive(message)
        // end::passive-peer-receive[]
    }

} // tag::predictive-model[]



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.ArrayFunction
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.Expression
import com.couchbase.lite.FullTextExpression
import com.couchbase.lite.FullTextIndexItem
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.Join
import com.couchbase.lite.Meta
import com.couchbase.lite.Ordering
import com.couchbase.lite.Query
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.SelectResult
import com.couchbase.lite.ValueIndexItem
import com.fasterxml.jackson.databind.ObjectMapper
import org.json.JSONException


private const val TAG = "QUERY"
private const val DATABASE_NAME = "database"

data class Hotel(
    var description: String? = null,
    var country: String? = null,
    var city: String? = null,
    var name: String? = null,
    var type: String? = null,
    var id: String? = null
)

@Suppress("unused")
class QueryExamples(private val database: Database) {

    // ### Indexing
    @Throws(CouchbaseLiteException::class)
    fun testIndexing() {
        // tag::query-index[]
        database.createIndex(
            "TypeNameIndex",
            IndexBuilder.valueIndex(
                ValueIndexItem.property("type"),
                ValueIndexItem.property("name")
            )
        )
        // end::query-index[]
    }

    // ### SELECT statement
    fun testSelectStatement() {
        // tag::query-select-meta[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("type")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.expression(Meta.id))
            .execute()

        for (result in rs) {
            Log.i(TAG, "hotel id -&gt;${result.getString("id")}")
            Log.i(TAG, "hotel name -&gt; ${result.getString("name")}")
        }
        // end::query-select-meta[]
    }

    // META function
    @Throws(CouchbaseLiteException::class)
    fun testMetaFunction() {
        val rs = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("airport")))
            .orderBy(Ordering.expression(Meta.id))
            .execute()

        for (result in rs) {
            Log.w(TAG, "airport id -&gt;${result.getString("id")}")
            Log.w(TAG, "airport id -&gt; ${result.getString(0)}")
        }
    }

    // ### all(*)
    @Throws(CouchbaseLiteException::class)
    fun testSelectAll() {
        // tag::query-select-all[]
        val queryAll = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
        // end::query-select-all[]

        // tag::live-query[]
        val query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="61"></i><b>(61)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        // Version using Kotlin Flows to follow shortly ...
        val token = query.addChangeListener { change -&gt;
            change.results?.let {
                for (result in it) {
                    Log.d(TAG, "results: ${result.keys}")
                    /* Update UI */
                }
            } <i class="conum" data-value="62"></i><b>(62)</b>
        }

        // end::live-query[]

        // tag::stop-live-query[]
        query.removeChangeListener(token)
        // end::stop-live-query[]

        for (result in query.execute()) {
            Log.i(TAG, "hotel -&gt; ${result.getDictionary(DATABASE_NAME)?.toMap()}")
        }
    }


    // ###WHERE statement
    @Throws(CouchbaseLiteException::class)
    fun testWhereStatement() {
        // tag::query-where[]
        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.intValue(10))
            .execute()
        for (result in rs) {
            result.getDictionary(DATABASE_NAME)?.let {
                Log.i(TAG, "name -&gt; ${it.getString("name")}")
                Log.i(TAG, "type -&gt; ${it.getString("type")}")
            }
        }
        // end::query-where[]
    }

    fun testQueryDeletedDocuments() {
        // tag::query-deleted-documents[]
        // Query documents that have been deleted
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted)
        // end::query-deleted-documents[]
    }

    // ####Collection Operators
    @Throws(CouchbaseLiteException::class)
    fun testCollectionStatement() {
        // tag::query-collection-operator-contains[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(
                        ArrayFunction.contains(
                            Expression.property("public_likes"),
                            Expression.string("Armani Langworth")
                        )
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.getArray("public_likes")?.toList()}")
        }
        // end::query-collection-operator-contains[]
    }

    // IN operator
    @Throws(CouchbaseLiteException::class)
    fun testInOperator() {
        // tag::query-collection-operator-in[]
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.string("Armani").`in`(
                    Expression.property("first"),
                    Expression.property("last"),
                    Expression.property("username")
                )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.toMap()}")
        }
        // end::query-collection-operator-in[]
    }

    // Pattern Matching
    @Throws(CouchbaseLiteException::class)
    fun testPatternMatching() {
        // tag::query-like-operator[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-like-operator[]
    }

    // ### Wildcard Match
    @Throws(CouchbaseLiteException::class)
    fun testWildcardMatch() {
        // tag::query-like-operator-wildcard-match[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-like-operator-wildcard-match[]
    }

    // Wildcard Character Match
    @Throws(CouchbaseLiteException::class)
    fun testWildCharacterMatch() {
        // tag::query-like-operator-wildcard-character-match[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng____r"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-like-operator-wildcard-character-match[]
    }

    // ### Regex Match
    @Throws(CouchbaseLiteException::class)
    fun testRegexMatch() {
        // tag::query-regex-operator[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .regex(Expression.string("\\beng.*r\\b"))
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-regex-operator[]
    }

    // JOIN statement
    @Throws(CouchbaseLiteException::class)
    fun testJoinStatement() {
        // tag::query-join[]
        val rs = QueryBuilder.select(
            SelectResult.expression(Expression.property("name").from("airline")),
            SelectResult.expression(Expression.property("callsign").from("airline")),
            SelectResult.expression(Expression.property("destinationairport").from("route")),
            SelectResult.expression(Expression.property("stops").from("route")),
            SelectResult.expression(Expression.property("airline").from("route"))
        )
            .from(DataSource.database(database).`as`("airline"))
            .join(
                Join.join(DataSource.database(database).`as`("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(
                        Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline"))
                    )
                    .and(
                        Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.toMap()}")
        }
        // end::query-join[]
    }


    // ### GROUPBY statement
    @Throws(CouchbaseLiteException::class)
    fun testGroupByStatement() {
        // tag::query-groupby[]
        val rs = QueryBuilder.select(
            SelectResult.expression(Function.count(Expression.string("*"))),
            SelectResult.property("country"),
            SelectResult.property("tz")
        )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300)))
            )
            .groupBy(
                Expression.property("country"), Expression.property("tz")
            )
            .orderBy(Ordering.expression(Function.count(Expression.string("*"))).descending())
            .execute()

        for (result in rs) {
            result.let {
                Log.i(
                    TAG,
                    "There are ${it.getInt("$1")} airports on the ${
                        it.getString("tz")
                    } timezone located in ${
                        it.getString("country")
                    } and above 300ft"
                )
            }
            // end::query-groupby[]
        }
    }

    // ### ORDER BY statement
    @Throws(CouchbaseLiteException::class)
    fun testOrderByStatement() {
        // tag::query-orderby[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("name").ascending())
            .limit(Expression.intValue(10))
            .execute()

        for (result in rs) {
            Log.i(TAG, "${result.toMap()}")
        }
        // end::query-orderby[]
    }


    // ### EXPLAIN statement
    // tag::query-explain[]
    @Throws(CouchbaseLiteException::class)
    fun testExplainStatement() {
        // tag::query-explain-all[]
        var query: Query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").descending()) <i class="conum" data-value="63"></i><b>(63)</b>
        Log.i(TAG, query.explain()) <i class="conum" data-value="64"></i><b>(64)</b>
        // end::query-explain-all[]

        // tag::query-explain-like[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%"))) <i class="conum" data-value="65"></i><b>(65)</b>
        Log.i(TAG, query.explain())
        // end::query-explain-like[]

        // tag::query-explain-nopfx[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="66"></i><b>(66)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%")))
            )
        Log.i(TAG, query.explain())
        // end::query-explain-nopfx[]

        // tag::query-explain-function[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Function.lower(
                    Expression.property("type").equalTo(Expression.string("hotel"))
                )
            ) <i class="conum" data-value="67"></i><b>(67)</b>
        Log.i(TAG, query.explain())
        // end::query-explain-function[]

        // tag::query-explain-nofunction[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))) <i class="conum" data-value="68"></i><b>(68)</b>
        Log.i(TAG, query.explain())
        // end::query-explain-nofunction[]
    }
// end::query-explain[]

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex() {
        // tag::fts-index[]
        database.createIndex(
            "nameFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("name")).ignoreAccents(false)
        )
        // end::fts-index[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS() {
        // tag::fts-query[]
        val rs = QueryBuilder.select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(FullTextExpression.index("nameFTSIndex").match("buy"))
            .execute()
        for (result in rs) {
            Log.i(TAG, "document properties${result.getString(0)}")
        }
        // end::fts-query[]
    }


    fun testQuerySyntaxAll(currentUser: String) {
        // tag::query-syntax-all[]
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(openOrCreateDatabaseForUser(currentUser)))

            // end::query-syntax-all[]
        // tag::query-access-all[]
        val hotels: HashMap&lt;String, Hotel&gt; = HashMap()

        for (result in listQuery.execute().allResults()) {
            // get the k-v pairs from the 'hotel' key's value into a dictionary
            val thisDocsProps = result.getDictionary(0) <i class="conum" data-value="69"></i><b>(69)</b>
            val thisDocsId = thisDocsProps!!.getString("id")
            val thisDocsName = thisDocsProps.getString("name")
            val thisDocsType = thisDocsProps.getString("type")
            val thisDocsCity = thisDocsProps.getString("city")

            // Alternatively, access results value dictionary directly
            val id = result.getDictionary(0)?.getString("id").toString() <i class="conum" data-value="70"></i><b>(70)</b>
            hotels[id] = Hotel(
                id,
                result.getDictionary(0)?.getString("type"),
                result.getDictionary(0)?.getString("name"),
                result.getDictionary(0)?.getString("city"),
                result.getDictionary(0)?.getString("country"),
                result.getDictionary(0)?.getString("description")
            )
        }

        // end::query-access-all[]
    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun testQuerySyntaxJson(currentUser: String, argDb: Database) {
        Database db = argDb
        // tag::query-syntax-json[]
        // Example assumes Hotel class object defined elsewhere

        // Build the query
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(db))

        // end::query-syntax-json[]
        // tag::query-access-json[]
        // Uses Jackson JSON processor
        val mapper = ObjectMapper()
        val hotels: ArrayList&lt;Hotel&gt; = ArrayList()

        for (result in listQuery.execute()) {

            // Get result as JSON string
            val json = result.toJSON() <i class="conum" data-value="71"></i><b>(71)</b>

            // Get Hashmap from JSON string
            val dictFromJSONstring = mapper.readValue(json, HashMap::class.java) <i class="conum" data-value="72"></i><b>(72)</b>

            // Use created hashmap
            val hotelId = dictFromJSONstring["id"].toString() //
            val hotelType = dictFromJSONstring["type"].toString()
            val hotelname = dictFromJSONstring["name"].toString()


            // Get custom object from JSON string
            val thisHotel = mapper.readValue(json, Hotel::class.java) <i class="conum" data-value="73"></i><b>(73)</b>
            hotels.add(thisHotel)
        }
        // end::query-access-json[]
    }
/* end func testQuerySyntaxJson */

  fun docsOnlyQuerySyntaxN1QL(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      Database db=argDb
      // tag::query-syntax-n1ql[]
      val thisQuery = dbcreateQuery(
            "SELECT META().id AS id FROM _ WHERE type = \"hotel\"") <i class="conum" data-value="74"></i><b>(74)</b>

      return thisQuery.execute().allResults()

      // end::query-syntax-n1ql[]
  }

  fun docsOnlyQuerySyntaxN1QLParams(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      // tag::query-syntax-n1ql-params[]
      val thisQuery = dbcreateQuery(
            "SELECT META().id AS id FROM _ WHERE type = \$type") <i class="conum" data-value="75"></i><b>(75)</b>

      thisQuery.parameters = Parameters().setString("type", "hotel") <i class="conum" data-value="76"></i><b>(76)</b>

      return thisQuery.execute().allResults()

      // end::query-syntax-n1ql-params[]
  }

    fun openOrCreateDatabaseForUser(argUser: String): Database = Database(argUser)
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.Database
import com.couchbase.lite.MutableDictionary

class BlobExamples {

    // Example 2: Using Blobs
    fun example2(context: Context, db: Database) {
        val doc = db.getDocument("1000") ?: return

        // Create a blob from an asset
        val blob = Blob("image/png", context.assets.open("couchbaseimage.png"))

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON()

        // Save the blob as part of a document
        db.save(doc.toMutable().setBlob("avatar", blob))

        // Experts only!!!
        db.saveBlob(blob)

        // Retrieve saved blob and get as JSON again
        val blobAsJSONString = db.getDocument("1000")?.getBlob("avatar")?.toJSON() ?: return

        // reconstitute
        val blobAsMap = MutableDictionary().setJSON(blobAsJSONString).toMap()

        // show the contents of the reconstituted blob
        for ((key, value) in blobAsMap) {
            Log.d("BLOB", "Data: $key -&gt; $value")
        }

        // verify that the reconstitued thing is still blob
        if (Blob.isBlob(blobAsMap)) {
            Log.d("BLOB", blobAsJSONString)
        }
    }
}


// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt </code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Use keychain identity in config</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/codesnippet_collection.kt">

// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.Conflict
import com.couchbase.lite.ConflictResolver
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.DatabaseConfiguration
import com.couchbase.lite.DatabaseEndpoint
import com.couchbase.lite.Document
import com.couchbase.lite.DocumentFlag
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.SessionAuthenticator
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.create
import com.couchbase.lite.internal.utils.PlatformUtils
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.io.InputStream
import java.net.URI
import java.net.URISyntaxException


private const val TAG = "REPLICATION"

@Throws(IOException::class)
fun InputStream.toByteArray(): ByteArray {
    val buffer = ByteArray(1024)
    val output = ByteArrayOutputStream()

    var n: Int
    while (-1 &lt; this.read(buffer).also { n = it }) {
        output.write(buffer, 0, n)
    }

    return output.toByteArray()
}

// tag::update-document-with-conflict-handler-callouts[]
//
//        &lt;.&gt; The conflict handler code is provided as a lambda.
//
//        &lt;.&gt; If the handler cannot resolve a conflict, it can return false.
//        In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.
//
//        &lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.
//
//        &lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).
//
//        &lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method
// end::update-document-with-conflict-handler-callouts[]


// tag::local-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
@Suppress("unused")
object LocalWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.localDocument
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
@Suppress("unused")
object RemoteWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.remoteDocument
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
// Using replConfig.setConflictResolver(new MergeConflictResolver());
@Suppress("unused")
object MergeConflictResolver : ConflictResolver {
    override fun resolve(conflict: Conflict): Document {
        val localDoc = conflict.localDocument?.toMap()
        val remoteDoc = conflict.remoteDocument?.toMap()

        val merge: MutableMap&lt;String, Any&gt;?
        if (localDoc == null) {
            merge = remoteDoc
        } else {
            merge = localDoc
            if (remoteDoc != null) {
                merge.putAll(remoteDoc)
            }
        }

        return if (merge == null) {
            MutableDocument(conflict.documentId)
        } else {
            MutableDocument(conflict.documentId, merge)
        }
    }
// end::merge-conflict-resolver[]

    @Suppress("unused")
    class ReplicationExamples(private val database: Database) {
        private var replicator: Replicator? = null

        @Throws(URISyntaxException::class)
        fun testReplicationBasicAuthentication() {
            // tag::basic-authentication[]

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = BasicAuthenticator("username", "password".toCharArray())
                )
            )
            repl.start()
            replicator = repl
            // end::basic-authentication[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationSessionAuthentication() {
            // tag::session-authentication[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    authenticator = SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447")
                )
            )
            repl.start()
            replicator = repl
            // end::session-authentication[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationStatus() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            // tag::replication-status[]
            // Version using Kotlin Flows to follow shortly ...
            repl.addChangeListener { change -&gt;
                if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                    Log.i(TAG, "Replication stopped")
                }
            }

            repl.start()
            replicator = repl
            // end::replication-status[]
        }

        @Throws(URISyntaxException::class)
        fun testHandlingNetworkErrors() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            // tag::replication-error-handling[]
            // Version using Kotlin Flows to follow shortly ...
            repl.addChangeListener { change -&gt;
                change.status.error?.let {
                    Log.w(TAG, "Error code: ${it.code}")
                }
            }
            repl.start()
            replicator = repl
            // end::replication-error-handling[]

            repl.stop()
        }

        @Throws(URISyntaxException::class)
        fun testReplicatorDocumentEvent() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db"))
                )
            )

            // tag::add-document-replication-listener[]
            val token = repl.addDocumentReplicationListener { replication -&gt;
                Log.i(TAG, "Replication type: ${if (replication.isPush) "push" else "pull"}")

                for (document in replication.documents) {
                    document.let { doc -&gt;
                        Log.i(TAG, "Doc ID: ${document.id}")
                        doc.error?.let {
                            // There was an error
                            Log.e(TAG, "Error replicating document: ", it)
                            return@addDocumentReplicationListener
                        }
                        if (doc.flags.contains(DocumentFlag.DELETED)) {
                            Log.i(TAG, "Successfully replicated a deleted document")
                        }
                    }
                }
            }

            repl.start()
            replicator = repl
            // end::add-document-replication-listener[]

            // tag::remove-document-replication-listener[]
            repl.removeChangeListener(token)
            // end::remove-document-replication-listener[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationCustomHeader() {
            // tag::replication-custom-header[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value")
                )
            )
            replicator = repl
            // end::replication-custom-header[]
        }

        // ### Certificate Pinning
        @Throws(URISyntaxException::class, IOException::class)
        fun testCertificatePinning() {
            // tag::certificate-pinning[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    headers = mapOf("CustomHeaderName" to "Value"),
                    pinnedServerCertificate = PlatformUtils.getAsset("cert.cer")?.toByteArray()
                )
            )
            replicator = repl
            // end::certificate-pinning[]
        }

        // ### Reset replicator checkpoint
        @Throws(URISyntaxException::class)
        // tag::replication-startup[]
        fun testReplicationResetCheckpoint() {
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/db")),
                    type = ReplicatorType.PULL
                )
            )

            // tag::replication-reset-checkpoint[]
            if (resetCheckpointRequired_Example) {
              repl.start(resetCheckpoint = true) <i class="conum" data-value="1"></i><b>(1)</b>
            else
              repl.start(resetCheckpoint = false)
            }
            // end::replication-reset-checkpoint[]

            // ... at some later time

            repl.stop()
        // end::replication-startup[]

        }

        @Throws(URISyntaxException::class)
        fun testReplicationPushFilter() {
            // tag::replication-push-filter[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { _, flags -&gt; flags.contains(DocumentFlag.DELETED) } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
            // end::replication-push-filter[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationPullFilter() {
            // tag::replication-pull-filter[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    pushFilter = { document, _ -&gt; "draft" == document.getString("type") } <i class="conum" data-value="1"></i><b>(1)</b>
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
            // end::replication-pull-filter[]
        }

        @Throws(URISyntaxException::class)
        fun testCustomRetryConfig() {
            // tag::replication-retry-config[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database,
                    target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
                    //  other config params as required . .
                    // tag::replication-heartbeat-config[]
                    heartbeat = 150, <i class="conum" data-value="1"></i><b>(1)</b>
                    // end::replication-heartbeat-config[]
                    // tag::replication-maxattempts-config[]
                    maxAttempts = 20,
                    // end::replication-maxattempts-config[]
                    maxAttemptWaitTime = 600
                    // end::replication-maxattemptwaittime-config[]
                )
            )

            repl.start()
            replicator = repl
            // end::replication-retry-config[]
        }

        @Throws(CouchbaseLiteException::class)
        fun testDatabaseReplica() {
            val config = DatabaseConfiguration()
            val database1 = Database("mydb", config)
            val database2 = Database("db2", config)

            /* EE feature: code below might throw a compilation error
               if it's compiled against CBL Android Community. */
            // tag::database-replica[]
            val repl = Replicator(
                ReplicatorConfigurationFactory.create(
                    database = database1,
                    target = DatabaseEndpoint(database2),
                    type = ReplicatorType.PULL
                )
            )

            // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
            repl.start()
            replicator = repl
            // end::database-replica[]
        }

        @Throws(URISyntaxException::class)
        fun testReplicationWithCustomConflictResolver() {
            // tag::replication-conflict-resolver[]
            val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
            val config = ReplicatorConfiguration(database, target)
            config.conflictResolver = LocalWinConflictResolver()
            val replication = Replicator(config)
            replication.start()
            // end::replication-conflict-resolver[]
        }

        @Throws(CouchbaseLiteException::class)
        fun testSaveWithCustomConflictResolver() {
            // tag::update-document-with-conflict-handler[]
            val mutableDocument = database.getDocument("xyz")?.toMutable() ?: return
            mutableDocument.setString("name", "apples")
            database.save(mutableDocument) { newDoc, curDoc -&gt;  <i class="conum" data-value="2"></i><b>(2)</b>
                if (curDoc == null) {
                    return@save false
                } <i class="conum" data-value="3"></i><b>(3)</b>
                val dataMap: MutableMap&lt;String, Any&gt; = curDoc.toMap()
                dataMap.putAll(newDoc.toMap()) <i class="conum" data-value="4"></i><b>(4)</b>
                newDoc.setData(dataMap)
                true <i class="conum" data-value="5"></i><b>(5)</b>
            } <i class="conum" data-value="6"></i><b>(6)</b>
            // end::update-document-with-conflict-handler[]
        }
    }
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ReplicationExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import android.widget.Toast
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.Blob
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.DatabaseConfiguration
import com.couchbase.lite.DatabaseConfigurationFactory
import com.couchbase.lite.EncryptionKey
import com.couchbase.lite.Expression
import com.couchbase.lite.LogDomain
import com.couchbase.lite.LogFileConfigurationFactory
import com.couchbase.lite.LogLevel
import com.couchbase.lite.Logger
import com.couchbase.lite.Meta
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.SelectResult
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.UnitOfWork
import com.couchbase.lite.create
import com.couchbase.lite.internal.utils.PlatformUtils
import org.junit.Test
import java.io.File
import java.io.IOException
import java.net.URI
import java.net.URISyntaxException
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.Arrays
import java.util.Date
import java.util.EnumSet


private const val TAG = "BASIC"

// tag::custom-logging[]
class LogTestLogger(private val level: LogLevel) : Logger {
  override fun getLevel() = level

  override fun log(level: LogLevel, domain: LogDomain, message: String) {
    // this method will never be called if param level &lt; this.level
    // handle the message, for example piping it to a third party framework
  }
}

// end::custom-logging[]
// tag::example-app[]
@Suppress("unused")
class BasicExamples(private val context: Context) {
    private val database: Database

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        // Get the database (and create it if it doesnt exist).
        database = Database(
            "getting-started",
            DatabaseConfigurationFactory.create(context.filesDir.absolutePath)
        )
    }

    @Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {

        // !!! Note the code moved from here to the init { } above.
        // tag::getting-started[]
        // Create a new document (i.e. a record) in the database.
        var mutableDoc = MutableDocument().setFloat("version", 2.0f).setString("type", "SDK")

        // Save it to the database.
        database.save(mutableDoc)

        // Update a document.
        mutableDoc = database.getDocument(mutableDoc.id)!!.toMutable().setString("language", "Java")
        database.save(mutableDoc)

        val document = database.getDocument(mutableDoc.id)!!
        // Log the document ID (generated by the database) and properties
        Log.i(TAG, "Document ID :: ${document.id}")
        Log.i(TAG, "Learning ${document.getString("language")}")

        // Create a query to fetch documents of type SDK.
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))
            .execute()
        Log.i(TAG, "Number of rows :: ${rs.allResults().size}")

        // Create a replicator to push and pull changes to and from the cloud.
        // Be sure to hold a reference somewhere to prevent the Replicator from being GCed
        val replicator = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(URI("ws://localhost:4984/getting-started-db")),
                type = ReplicatorType.PUSH_AND_PULL,
                authenticator = BasicAuthenticator("sync-gateway", "password".toCharArray())
            )
        )

        // Listen to replicator change events.
        // Version using Kotlin Flows to follow shortly ...

        replicator.addChangeListener { change -&gt;
            val err = change.status.error
            if (err != null) Log.i(TAG, "Error code ::  ${err.code}")
        }

        // Start replication.
        replicator.start()

        // end::getting-started[]
        database.delete()
    }
    // end::example-app[]

    @Throws(CouchbaseLiteException::class, IOException::class)
    fun test1xAttachments() {
        // if db exist, delete it
        deleteDB("android-sqlite", context.filesDir)
        ZipUtils.unzip(PlatformUtils.getAsset("replacedb/android140-sqlite.cblite2.zip"), context.filesDir)

        val db = Database("android-sqlite")
        try {
            // For Validation
            Arrays.equals(
                "attach1".toByteArray(),
                db.getDocument("doc1")?.getDictionary("_attachments")?.getBlob("attach1")?.content
            )
        } finally {
            // close db
            db.close()
            // if db exist, delete it
            deleteDB("android-sqlite", context.filesDir)
        }
        val document = MutableDocument()

        // tag::1x-attachment[]
        val content = document.getDictionary("_attachments")?.getBlob("avatar")?.content
        // end::1x-attachment[]
    }

    // ### Initializer
    fun testInitializer() {
        // tag::sdk-initializer[]
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)
        // end::sdk-initializer[]
    }

    // ### New Database
    @Throws(CouchbaseLiteException::class)
    fun testNewDatabase() {
        // tag::new-database[]
        val db = Database("my-db", DatabaseConfigurationFactory.create(context.filesDir.absolutePath)) <i class="conum" data-value="7"></i><b>(7)</b>
        // end::new-database[]
        db.delete()
    }

    // ### Database Encryption
    @Throws(CouchbaseLiteException::class)
    fun testDatabaseEncryption() {
        // tag::database-encryption[]
        val db = Database("my-db", DatabaseConfigurationFactory.create(encryptionKey = EncryptionKey("PASSWORD")))
        // end::database-encryption[]
    }

    // ### Logging
    // !!! OBSOLETE in 3.0
    fun testLogging() {
        // tag::logging[]
        // end::logging[]
    }

    fun testEnableCustomLogging() {
        // tag::set-custom-logging[]
        // this custom logger will not log an event with a log level &lt; WARNING
        Database.log.custom = LogTestLogger(LogLevel.WARNING) <i class="conum" data-value="8"></i><b>(8)</b>
        // end::set-custom-logging[]
    }

    // ### Console logging
    @Throws(CouchbaseLiteException::class)
    fun testConsoleLogging() {
        // tag::console-logging[]
        Database.log.console.domains = LogDomain.ALL_DOMAINS <i class="conum" data-value="9"></i><b>(9)</b>
        Database.log.console.level = LogLevel.VERBOSE <i class="conum" data-value="10"></i><b>(10)</b>
        // end::console-logging[]

        // tag::console-logging-db[]
        Database.log.console.domains = EnumSet.of(LogDomain.DATABASE) <i class="conum" data-value="11"></i><b>(11)</b>
        // end::console-logging-db[]
    }

    // ### File logging
    @Throws(CouchbaseLiteException::class)
    fun testFileLogging() {
        // tag::file-logging[]
        Database.log.file.let {
            it.config = LogFileConfigurationFactory.create(
                context.cacheDir.absolutePath, <i class="conum" data-value="12"></i><b>(12)</b>
                maxSize = 10240, <i class="conum" data-value="13"></i><b>(13)</b>
                maxRotateCount = 5, <i class="conum" data-value="14"></i><b>(14)</b>
                usePlainText = false
            ) <i class="conum" data-value="15"></i><b>(15)</b>
            it.level = LogLevel.INFO <i class="conum" data-value="16"></i><b>(16)</b>

            // end::file-logging[]
        }
    }

    fun writeConsoleLog() {
        // tag::write-console-logmsg[]
        Database.log.console.log(LogLevel.WARNING, LogDomain.REPLICATOR, "Any old log message")
        // end::write-console-logmsg[]
    }

    fun writeCustomLog() {
        // tag::write-custom-logmsg[]
        Database.log.custom?.log(LogLevel.WARNING, LogDomain.REPLICATOR, "Any old log message")
        // end::write-custom-logmsg[]
    }

    fun writeFileLog() {
        // tag::write-file-logmsg[]
        Database.log.file.log(LogLevel.WARNING, LogDomain.REPLICATOR, "Any old log message")
        // end::write-file-logmsg[]
    }

    /* The `tag::replication[]` example is inlined in java.adoc */
    fun testTroubleshooting() {
        // tag::replication-logging[]
        Database.log.console.let {
            it.level = LogLevel.VERBOSE
            it.domains = LogDomain.ALL_DOMAINS
        }
        // end::replication-logging[]
    }

    // ### Loading a pre-built database
    @Throws(IOException::class)
    fun testPreBuiltDatabase() {
        // tag::prebuilt-database[]
        // Note: Getting the path to a database is platform-specific.
        // For Android you need to extract the database from your assets
        // to a temporary directory and then copy it, using Database.copy()
        if (Database.exists("travel-sample", context.filesDir)) {
            return
        }
        ZipUtils.unzip(PlatformUtils.getAsset("travel-sample.cblite2.zip"), context.filesDir)
        Database.copy(File(context.filesDir, "travel-sample"), "travel-sample", DatabaseConfiguration())
        // end::prebuilt-database[]
    }

    // helper methods
    // if db exist, delete it
    fun deleteDB(name: String, dir: File) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            Database.delete(name, dir)
        }

        // ### Initializers
        fun testInitializers() {
            // tag::initializer[]
            val doc = MutableDocument()
            doc.let {
                it.setString("type", "task")
                it.setString("owner", "todo")
                it.setDate("createdAt", Date())
            }
            database.save(doc)
            // end::initializer[]
        }
    }

    // ### Mutability
    fun testMutability() {
        database.save(MutableDocument("xyz"))

        // tag::update-document[]
        database.getDocument("xyz")?.toMutable()?.let {
            it.setString("name", "apples")
            database.save(it)
        }
        // end::update-document[]
    }

    // ### Typed Accessors
    fun testTypedAccessors() {
        val doc = MutableDocument()

        // tag::date-getter[]
        doc.setValue("createdAt", Date())
        val date = doc.getDate("createdAt")
        // end::date-getter[]
    }

    // ### Batch operations
    fun testBatchOperations() {
        // tag::batch[]
        database.inBatch(UnitOfWork {
            for (i in 0..9) {
                val doc = MutableDocument()
                doc.let {
                    it.setValue("type", "user")
                    it.setValue("name", "user $i")
                    it.setBoolean("admin", false)
                }
                Log.i(TAG, "saved user document: ${doc.getString("name")}")
            }
        })
        // end::batch[]
    }

    // ### Document Expiration
    @Throws(CouchbaseLiteException::class)
    fun documentExpiration() {
        // tag::document-expiration[]
        // Purge the document one day from now
        database.setDocumentExpiration("doc123", Date(Instant.now().plus(1, ChronoUnit.DAYS).toEpochMilli()))

        // Reset expiration
        database.setDocumentExpiration("doc1", null)

        // Query documents that will be expired in less than five minutes
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(
                Meta.expiration.lessThan(
                    Expression.longValue(Instant.now().plus(5, ChronoUnit.MINUTES).toEpochMilli())
                )
            )
        // end::document-expiration[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testDocumentChangeListener() {
        // tag::document-listener[]
        // Version using Kotlin Flows to follow shortly ...

        database.addDocumentChangeListener("user.john") { change -&gt;
            database.getDocument(change.documentID)?.let {
                Toast.makeText(context, "Status: ${it.getString("verified_account")}", Toast.LENGTH_SHORT).show()
            }
        }
        // end::document-listener[]
    }

    // ### Blobs
    fun testBlobs() {
        val mDoc = MutableDocument()

        // tag::blob[]
        PlatformUtils.getAsset("avatar.jpg")?.use { <i class="conum" data-value="17"></i><b>(17)</b>
            mDoc.setBlob("avatar", Blob("image/jpeg", it)) <i class="conum" data-value="18"></i><b>(18)</b> <i class="conum" data-value="19"></i><b>(19)</b>
            database.save(mDoc)
        }

        val doc = database.getDocument(mDoc.id)
        val bytes = doc?.getBlob("avatar")?.content
        // end::blob[]
    }
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BasicExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.Dictionary
import com.couchbase.lite.Expression
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.MutableDictionary
import com.couchbase.lite.PredictionFunction
import com.couchbase.lite.PredictiveIndex
import com.couchbase.lite.PredictiveModel
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.SelectResult
import com.couchbase.lite.ValueIndex
import com.couchbase.lite.ValueIndexItem


private const val TAG = "PREDICT"

// `tensorFlowModel` is a fake implementation
object TensorFlowModel {
    fun predictImage(data: ByteArray?) = mapOf&lt;String, Any?&gt;()
}

object ImageClassifierModel : PredictiveModel {
    const val name = "ImageClassifier"

    override fun predict(input: Dictionary): Dictionary? {
        val blob: Blob = input.getBlob("photo") ?: return null

        // this would be the implementation of the ml model you have chosen
        return MutableDictionary(TensorFlowModel.predictImage(blob.content)) <i class="conum" data-value="1"></i><b>(1)</b>
    }
} // end::predictive-model[]


@Suppress("unused")
class PredictiveQueryExamples {
    @Throws(CouchbaseLiteException::class)
    fun testPredictiveModel() {
        val database = Database("mydb")

        // tag::register-model[]
        Database.prediction.registerModel("ImageClassifier", ImageClassifierModel)
        // end::register-model[]

        // tag::predictive-query-value-index[]
        val index: ValueIndex = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")))
        database.createIndex("value-index-image-classifier", index)
        // end::predictive-query-value-index[]

        // tag::unregister-model[]
        Database.prediction.unregisterModel("ImageClassifier")
        // end::unregister-model[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveIndex() {
        val database = Database("mydb")

        // tag::predictive-query-predictive-index[]
        val inputMap: MutableMap&lt;String, Any&gt; = mutableMapOf()
        inputMap["numbers"] = Expression.property("photo")
        val input: Expression = Expression.map(inputMap)
        val index: PredictiveIndex = IndexBuilder.predictiveIndex("ImageClassifier", input, null)
        database.createIndex("predictive-index-image-classifier", index)
        // end::predictive-query-predictive-index[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveQuery() {
        val database = Database("mydb")

        // tag::predictive-query[]
        val prediction: PredictionFunction = Function.prediction(
            ImageClassifierModel.name,
            Expression.map(mutableMapOf("photo" to Expression.property("photo")) as Map&lt;String, Any&gt;?) <i class="conum" data-value="1"></i><b>(1)</b>
        )

        // !!! Is this query using that prediction function, at all?
        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("label").equalTo(Expression.string("car"))
                    .and(
                        Expression.property("probability")
                            .greaterThanOrEqualTo(Expression.doubleValue(0.8))
                    )
            )
            .execute()

        Log.d(TAG, "Number of rows: ${rs.allResults().size}")
        // end::predictive-query[]
    }
}


// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PredictiveQueryExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorStatus


private const val TAG = "PENDING"

@Suppress("unused")
class PendingDocsExample(private var replicator: Replicator) {
    //
    // tag::replication-pendingdocuments[]
    //
    private fun onStatusChanged(pendingDocs: Set&lt;String&gt;, status: ReplicatorStatus) {
        // ... sample onStatusChanged function
        //
        Log.i(TAG, "Replicator activity level is ${status.activityLevel}")

        // iterate and report-on previously
        // retrieved pending docids 'list'
        val itr = pendingDocs.iterator()
        while (itr.hasNext()) {
            val docId = itr.next()

            // tag::replication-push-isdocumentpending[]
            if (!replicator.isDocumentPending(docId)) { <i class="conum" data-value="20"></i><b>(20)</b>
                continue
            }

            // end::replication-push-isdocumentpending[]
            Log.i(TAG, "Doc ID $docId has been pushed")
        }
    } // end::replication-pendingdocuments[]
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/PendingDocsExample.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Endpoint
import com.couchbase.lite.KeyStoreUtils
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.net.URI
import java.net.URISyntaxException
import java.security.KeyStore
import java.security.cert.Certificate

private const val TAG = "P2P"


@Suppress("unused")
class IBExamples(private val context: Context, private val caCert: Certificate) {
    private val database: Database
    private var thisReplicator: Replicator? = null
    private var thisListener: URLEndpointListener? = null

    init {
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        database = Database("p2p_demo")

        /* do some stuff here */
    }

    // PASSIVE PEER STUFF
    fun ibListenerSimple() {
        // tag::listener-simple[]
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = database,
                authenticator
                = ListenerPasswordAuthenticator { user, pwd -&gt; (user == "daniel") &amp;&amp; (String(pwd) == "123") })
        ) <i class="conum" data-value="21"></i><b>(21)</b>
        listener.start() <i class="conum" data-value="22"></i><b>(22)</b>
        thisListener = listener

        // end::listener-simple[]
    }

    fun ibReplicatorSimple() {
        // tag::replicator-simple[]
        val theListenerEndpoint: Endpoint = URLEndpoint(URI("wss://10.0.2.2:4984/db")) <i class="conum" data-value="23"></i><b>(23)</b>
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,
                target = theListenerEndpoint,
                authenticator = BasicAuthenticator("valid.user", "valid.password.string".toCharArray()), <i class="conum" data-value="24"></i><b>(24)</b>
                acceptOnlySelfSignedServerCertificate = true
            )
        )
        repl.start() <i class="conum" data-value="25"></i><b>(25)</b>
        thisReplicator = repl
        // end::replicator-simple[]
    }

    fun ibPassListener(validUser: String, validPassword: CharArray) {
        // EXAMPLE 1
        // tag::listener-start[]
        // Initialize the listener
        // tag::listener-initialize[]
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                // tag::listener-config-db[]
                database = database, <i class="conum" data-value="26"></i><b>(26)</b>
                // end::listener-config-db[]
                // tag::listener-config-port[]
                port = 55990, <i class="conum" data-value="27"></i><b>(27)</b>
                // end::listener-config-port[]
                // tag::listener-config-netw-iface[]
                networkInterface = "10.1.1.10", <i class="conum" data-value="28"></i><b>(28)</b>

                // end::listener-config-netw-iface[]
                // tag::listener-config-delta-sync[]
                enableDeltaSync = false, <i class="conum" data-value="29"></i><b>(29)</b>

                // end::listener-config-delta-sync[]
                // tag::listener-config-tls-full[]
                // Configure server security
                // tag::listener-config-tls-enable[]
                disableTls = false, <i class="conum" data-value="30"></i><b>(30)</b>

                // end::listener-config-tls-enable[]
                // tag::listener-config-tls-id-anon[]
                // Use an Anonymous Self-Signed Cert
                identity = null, <i class="conum" data-value="31"></i><b>(31)</b>
                // end::listener-config-tls-id-anon[]

                // tag::listener-config-client-auth-pwd[]
                // Configure Client Security using an Authenticator
                // For example, Basic Authentication <i class="conum" data-value="32"></i><b>(32)</b>
                authenticator = ListenerPasswordAuthenticator { username, paassword -&gt;
                    (username === validUser) &amp;&amp; (paassword === validPassword)
                }
            ))

        // Start the listener
        listener.start() <i class="conum" data-value="33"></i><b>(33)</b>
        thisListener = listener

        // end::listener-initialize[]
        // end::listener-start[]
    }

    fun ibListenerGetNetworkInterfaces() {
        // tag::listener-get-network-interfaces[]
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        listener.start()
        Log.i(TAG, "URLS are ${listener.urls}")
        thisListener = listener
        // end::listener-get-network-interfaces[]
    }

    fun ibListenerLocalDb() {
        // tag::listener-local-db[]
        // . . . preceding application logic . . .
        CouchbaseLite.init(context) <i class="conum" data-value="34"></i><b>(34)</b>
        val thisDB = Database("passivepeerdb")
        // end::listener-local-db[]
    }

    fun ibListenerConfigTlsDisable() {
        // tag::listener-config-tls-disable[]
        URLEndpointListenerConfigurationFactory.create(database, disableTls = false) <i class="conum" data-value="35"></i><b>(35)</b>
        // end::listener-config-tls-disable[]
    }


    // !!! USERS SHOULD BE CAUTIONED THAT THIS IS INSECURE
    // Android has much better ways of importing keys
    fun ibListenerConfigTlsIdFull() {
        // tag::listener-config-tls-id-full[]
        // tag::listener-config-tls-id-caCert[]
        // Use CA Cert
        // Import a key pair into secure storage
        // Create a TLSIdentity from the imported key-pair

        this.javaClass.getResourceAsStream("serverkeypair.p12")?.use { <i class="conum" data-value="36"></i><b>(36)</b>
            KeyStoreUtils.importEntry(
                "teststore.p12",  // KeyStore type, eg: "PKCS12"
                it,  // An InputStream from the keystore
                "let me in".toCharArray(),  // The keystore password
                "topSekritKey",  // The alias to be used (in external keystore)
                null,  // The key password or null if the key has none
                "test-alias" // The alias for the imported key
            )
        }

        // end::listener-config-tls-id-caCert[]

        // tag::listener-config-tls-id-set[]
        // Set the TLS Identity
        URLEndpointListenerConfigurationFactory.create(
            database,
            identity = TLSIdentity.getIdentity("test-alias")
        ) <i class="conum" data-value="37"></i><b>(37)</b>

        // end::listener-config-tls-id-set[]
// end::listener-config-tls-id-full[]
    }

    fun ibListenerConfigClientAuthRoot() {
// tag::listener-config-client-root-ca[]
        // tag::listener-config-client-auth-root[]
        // Configure the client authenticator
        // to validate using ROOT CA
        // thisClientID.certs is a list containing a client cert to accept
        // and any other certs needed to complete a chain between the client cert
        // and a CA
        val validId = TLSIdentity.getIdentity("Our Corporate Id")
            ?: throw IllegalStateException("Cannot find corporate id")
        // accept only clients signed by the corp cert
        thisListener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                // get the identity <i class="conum" data-value="38"></i><b>(38)</b>
                database = database,
                identity = validId,
                authenticator = ListenerCertificateAuthenticator(validId.certs)
            )
        ) <i class="conum" data-value="39"></i><b>(39)</b>

        // end::listener-config-client-auth-root[]
// end::listener-config-client-root-ca[]
    }

    fun ibListenerConfigTlsDisable2() {

        // tag::listener-config-tls-disable[]
        URLEndpointListenerConfigurationFactory.create(database = database, disableTls = true)
        // end::listener-config-tls-disable[]
    }

    fun ibListenerStatusCheck() {
        val listener = URLEndpointListener(URLEndpointListenerConfigurationFactory.create(database = database))
        // tag::listener-status-check[]
        val connectionCount = listener.status?.connectionCount <i class="conum" data-value="40"></i><b>(40)</b>
        val activeConnectionCount = listener.status?.activeConnectionCount <i class="conum" data-value="41"></i><b>(41)</b>
        // end::listener-status-check[]
    }

    fun ibListenerStop() {

        // tag::listener-stop[]
        thisListener?.stop()

        // end::listener-stop[]
    }

    // ACTIVE PEER STUFF
// Replication code
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testActPeerSync() {
        // tag::p2p-act-rep-start-full[]
        // Create replicator
        // Consider holding a reference somewhere
        // to prevent the Replicator from being GCed
        val repl = Replicator( <i class="conum" data-value="42"></i><b>(42)</b>

            // tag::p2p-act-rep-func[]
            // tag::p2p-act-rep-initialize[]
            // initialize the replicator configuration
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(URI("wss://listener.com:8954")), <i class="conum" data-value="43"></i><b>(43)</b>

                // end::p2p-act-rep-initialize[]
                // tag::p2p-act-rep-config-type[]
                // Set replicator type
                type = ReplicatorType.PUSH_AND_PULL,

                // end::p2p-act-rep-config-type[]
                // tag::p2p-act-rep-config-cont[]
                // Configure Sync Mode
                continuous = false, // default value

                // end::p2p-act-rep-config-cont[]

                // tag::autopurge-override[]
                // set auto-purge behavior
                // (here we override default)
                enableAutoPurge = false, <i class="conum" data-value="44"></i><b>(44)</b>

                // end::autopurge-override[]


                // tag::p2p-act-rep-config-self-cert[]
                // Configure Server Authentication --
                // only accept self-signed certs
                acceptOnlySelfSignedServerCertificate = true, <i class="conum" data-value="45"></i><b>(45)</b>

                // end::p2p-act-rep-config-self-cert[]
                // tag::p2p-act-rep-auth[]
                // Configure the credentials the
                // client will provide if prompted
                authenticator = BasicAuthenticator("Our Username", "Our PasswordValue".toCharArray()), <i class="conum" data-value="46"></i><b>(46)</b>


                // end::p2p-act-rep-auth[]
                // tag::p2p-act-rep-config-conflict[]
                /* Optionally set custom conflict resolver call back */
                conflictResolver = null <i class="conum" data-value="47"></i><b>(47)</b>
            )
        )

        // end::p2p-act-rep-config-conflict[]

        // tag::p2p-act-rep-add-change-listener[]
        // tag::p2p-act-rep-add-change-listener-label[]
        // Optionally add a change listener <i class="conum" data-value="48"></i><b>(48)</b>
        // end::p2p-act-rep-add-change-listener-label[]
        val thisListener = repl.addChangeListener { change -&gt;
            val err: CouchbaseLiteException? = change.status.error
            if (err != null) {
                Log.i(TAG, "Error code ::  ${err.code}", err)
            }
        }

        // end::p2p-act-rep-add-change-listener[]
        // tag::p2p-act-rep-start[]
        // Start replicator
        repl.start(false) <i class="conum" data-value="49"></i><b>(49)</b>
        thisReplicator = repl

        // end::p2p-act-rep-start[]
        // end::p2p-act-rep-start-full[]
        // end::p2p-act-rep-func[]         ***** End p2p-act-rep-func
    }

    fun ibReplicatorConfig() {
        // BEGIN additional snippets
        // tag::p2p-act-rep-config-tls-full[]

        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = database,

                // tag::p2p-act-rep-config-cacert[]
                // Configure Server Security
                // -- only accept CA attested certs
                acceptOnlySelfSignedServerCertificate = false, <i class="conum" data-value="50"></i><b>(50)</b>

                // end::p2p-act-rep-config-cacert[]


                // tag::p2p-act-rep-config-cacert-pinned[]

                // Use the pinned certificate from the byte array (cert)
                pinnedServerCertificate = caCert.encoded, <i class="conum" data-value="51"></i><b>(51)</b>
                // end::p2p-act-rep-config-cacert-pinned[]


                // end::p2p-act-rep-config-tls-full[]
                // tag::p2p-tlsid-tlsidentity-with-label[]
                // ... other replicator configuration
                // Provide a client certificate to the server for authentication
                authenticator = ClientCertificateAuthenticator(
                    TLSIdentity.getIdentity("clientId")
                        ?: throw IllegalStateException("Cannot find client id")
                ) <i class="conum" data-value="52"></i><b>(52)</b>

                // ... other replicator configuration

            )
        )

        thisReplicator = repl
        // end::p2p-tlsid-tlsidentity-with-label[]
    }

    fun ibP2pReplicatorStatus() {
        // tag::p2p-act-rep-status[]
        thisReplicator?.status?.let {
            Log.i(TAG, "The Replicator is currently ${it.activityLevel}")
            Log.i(TAG, "The Replicator has processed ${it.progress}")
            Log.i(
                TAG,
                if (it.activityLevel === ReplicatorActivityLevel.BUSY) {
                    "Replication Processing"
                } else {
                    "It has completed ${it.progress.total} changes"
                }
            )
        }
        // end::p2p-act-rep-status[]
    }

    fun ibP2pReplicatorStop() {
        // tag::p2p-act-rep-stop[]
        // Stop replication.
        thisReplicator?.stop() <i class="conum" data-value="53"></i><b>(53)</b>
        // end::p2p-act-rep-stop[]
    }

    fun ibP2pListener() {
        CouchbaseLite.init(context)
        val thisDB = Database("passivepeerdb") <i class="conum" data-value="54"></i><b>(54)</b>


        // Initialize the listener
        val listener = URLEndpointListener( <i class="conum" data-value="55"></i><b>(55)</b>

            // Initialize the listener config
            URLEndpointListenerConfigurationFactory.create(
                database = thisDB,
                port = 55990, /* &lt;.&gt;  Optional; defaults to auto */
                disableTls = false, /* &lt;.&gt;  Optional; defaults to false */
                enableDeltaSync = true,  /* &lt;.&gt; Optional; defaults to false */

                // Configure the client authenticator (if using basic auth)
                authenticator = ListenerPasswordAuthenticator { username, password -&gt;
                    ("username" === username) &amp;&amp; (password === "password".toCharArray())  <i class="conum" data-value="56"></i><b>(56)</b>
                }
            )
        )

        // Start the listener
        listener.start() <i class="conum" data-value="57"></i><b>(57)</b>


        // tag::createTlsIdentity[]

//        Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
//                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
//                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
//        );
        val thisIdentity = TLSIdentity.createIdentity(
            true,
            mapOf(
                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
            ),
            null,
            "test-alias"
        )

        // end::createTlsIdentity[]

        // tag::p2p-tlsid-store-in-keychain[]
        // end::p2p-tlsid-store-in-keychain[]


        // tag::deleteTlsIdentity[]
        // tag::p2p-tlsid-delete-id-from-keychain[]
        val thisAlias = "alias-to-delete"
        val thisKeyStore = KeyStore.getInstance("AndroidKeyStore")
        thisKeyStore.load(null)
        thisKeyStore.deleteEntry(thisAlias)

        // end::p2p-tlsid-delete-id-from-keychain[]
        // end::deleteTlsIdentity[]

        // tag::retrieveTlsIdentity[]
        // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label
        val thatIdentity = TLSIdentity.getIdentity("couchbase-docs-cert")
        // end::retrieveTlsIdentity[]
    }

    // tag::sgw-repl-pull[]
    fun ibRplicatorPull() {
        val database = Database("ian")

        val uri = URI("wss://10.0.2.2:4984/db") <i class="conum" data-value="58"></i><b>(58)</b>

        val repl = Replicator( <i class="conum" data-value="59"></i><b>(59)</b>
            ReplicatorConfigurationFactory.create(
                database = database,
                target = URLEndpoint(uri),
                type = ReplicatorType.PULL
            )
        )

        repl.start()
        thisReplicator = repl
    }

    // end::sgw-repl-pull[]
// tag::sgw-act-rep-initialize[]
// initialize the replicator configuration
    val thisConfig = ReplicatorConfigurationFactory.create(
        database = database,
        target = URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))
    ) // &lt;.&gt; // end::sgw-act-rep-initialize[]

/* C A L L O U T S

// Listener Callouts

// tag::listener-callouts-full[]

// tag::listener-start-callouts[]
&lt;.&gt; Initialize the listener instance using the configuration settings.
&lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.

// end::listener-start-callouts[]

// tag::listener-status-check-callouts[]

&lt;.&gt; `connectionCount` -- the total number of connections served by the listener
&lt;.&gt; `activeConnectionCount` -- the number of active (BUSY) connections currently being served by the listener
//
// end::listener-status-check-callouts[]

// end::listener-callouts-full[]


// tag::p2p-act-rep-config-cacert-pinned-callouts[]
&lt;.&gt; Configure the pinned certificate using data from the byte array `cert`
// end::p2p-act-rep-config-cacert-pinned-callouts[]

// tag::p2p-tlsid-tlsidentity-with-label-callouts[]
&lt;.&gt; Attempt to get the identity from secure storage
&lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity

// end::p2p-tlsid-tlsidentity-with-label-callouts[]

// tag::sgw-repl-pull-callouts[]
&lt;.&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;.&gt; The URL scheme for remote database URLs uses `ws:`, or `wss:` for SSL/TLS connections over wb sockets.
In this example the hostname is `10.0.2.2` because the Android emulator runs in a VM that is generally accessible on `10.0.2.2` from the host machine (see https://developer.android.com/studio/run/emulator-networking[Android Emulator networking] documentation).
+
NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
Although `wss:` protocol URLs are not affected, in order to use the `ws:` protocol, applications must target API 27 or lower, or must configure application network security as described https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted[here].

// end::sgw-repl-pull-callouts[]
*/
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/IBExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.ClientCertificateAuthenticator
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.ListenerCertificateAuthenticator
import com.couchbase.lite.ListenerPasswordAuthenticator
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorActivityLevel
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorType
import com.couchbase.lite.TLSIdentity
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.URLEndpointListener
import com.couchbase.lite.URLEndpointListenerConfigurationFactory
import com.couchbase.lite.create
import java.io.ByteArrayOutputStream
import java.io.IOException
import java.net.URI
import java.security.KeyStore
import java.security.KeyStoreException
import java.security.NoSuchAlgorithmException
import java.security.cert.Certificate
import java.security.cert.CertificateEncodingException
import java.security.cert.CertificateException
import java.util.concurrent.CountDownLatch

private const val TAG = "LISTEN"

@Suppress("unused")
class CertAuthListener {
    companion object {
        private val CERT_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "CBL Test",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "lite@couchbase.com",
        )
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)

        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        remoteDb.save(doc)

        val serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server")

        val clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client")
        val uri = startServer(remoteDb, serverIdentity, clientIdentity.certs)
            ?: throw IOException("Failed to start the server")

        Thread {
            startClient(localDb, uri, clientIdentity, serverIdentity.certs[0])
            Log.e(TAG, "Success!!")
            deleteIdentity("server")
            Log.e(TAG, "Alias deleted: server")
            deleteIdentity("client")
            Log.e(TAG, "Alias deleted: client")
        }.start()
    }

    // start a client replicator
    @Throws(CertificateEncodingException::class, InterruptedException::class)
    fun startClient(db: Database, uri: URI, clientIdentity: TLSIdentity, cert: Certificate) {
        val repl = Replicator(
            ReplicatorConfigurationFactory.create(
                database = db,
                target = URLEndpoint(uri),
                type = ReplicatorType.PUSH_AND_PULL,
                continuous = false,
                authenticator = ClientCertificateAuthenticator(clientIdentity),
                pinnedServerCertificate = cert.encoded
            )
        )

        val completionLatch = CountDownLatch(1)

        repl.addChangeListener { change -&gt;
            if (change.status.activityLevel == ReplicatorActivityLevel.STOPPED) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    // tag::listener-config-auth-cert-full[]
    /**
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     *
     *
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Throws(CouchbaseLiteException::class)
    fun startServer(db: Database, serverId: TLSIdentity, certs: List&lt;Certificate?&gt;): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0, // this is the default
                disableTls = false,
                identity = serverId,
                authenticator = ListenerCertificateAuthenticator(certs)
            )
        )
        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
    // end::listener-config-auth-cert-full[]
    // tag::listener-config-delete-cert-full[]
    /**
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    @Throws(
        KeyStoreException::class,
        CertificateException::class,
        NoSuchAlgorithmException::class,
        IOException::class
    )
    fun deleteIdentity(alias: String?) {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        keyStore.deleteEntry(alias) <i class="conum" data-value="60"></i><b>(60)</b>
    }
    // end::listener-config-delete-cert-full[]
    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /**
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     *
     *
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    @Throws(CertificateEncodingException::class)
    private fun configureClientCerts(
        config: ReplicatorConfiguration,
        cert: Certificate,
        clientIdentity: TLSIdentity
    ) {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(ClientCertificateAuthenticator(clientIdentity))

        // Configure the pinned certificate passing a byte array.
        config.pinnedServerCertificate = cert.encoded
    }
    // notend::p2p-tlsid-tlsidentity-with-label[]
    /**
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     *
     *
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    @Throws(IOException::class)
    private fun readCertMaterialFromBundle(
        context: Context,
        resId: Int
    ): ByteArray {
        val out = ByteArrayOutputStream()
        val `in` = context.resources.openRawResource(resId)
        val buf = ByteArray(1024)
        var n: Int
        while (`in`.read(buf).also { n = it } &gt;= 0) {
            out.write(buf, 0, n)
        }
        return out.toByteArray()
    }
}

@Suppress("unused")
class PasswordAuthListener {
    companion object {
        private const val VALID_USER = "Minnie"
        private val VALID_PASSWORD = "let me in!".toCharArray()
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray())
            ?: throw IOException("Failed to start the server")
        Thread {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb)
                Log.e(TAG, "Success!!")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }.start()
    }

    // start a client replicator
    @Throws(InterruptedException::class)
    fun runClient(
        uri: URI,
        username: String,
        password: CharArray,
        db: Database
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.type = ReplicatorType.PUSH_AND_PULL
        config.isContinuous = false
        config.setAuthenticator(BasicAuthenticator(username, password))
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)

        // Version using Kotlin Flows to follow shortly ...
        repl.addChangeListener { change -&gt;
            if (change.status
                    .activityLevel == ReplicatorActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        }
        repl.start(false)
        completionLatch.await()
    }
    // tag::listener-config-client-auth-pwd-full[]
    /**
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     *
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    fun startServer(db: Database, username: String, password: CharArray): URI? {
        val listener = URLEndpointListener(
            URLEndpointListenerConfigurationFactory.create(
                database = db,
                port = 0,// this is the default
                disableTls = true,
                authenticator = ListenerPasswordAuthenticator { usr, pwd -&gt;
                    (usr == username) &amp;&amp; pwd.contentEquals(password)
                })
        )

        listener.start()
        val urls: List&lt;URI&gt; = listener.urls
        return if (urls.isEmpty()) {
            null
        } else {
            urls[0]
        }
    }
// end::listener-config-client-auth-pwd-full[]
}





// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/ListenerExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.Database
import com.couchbase.lite.Message
import com.couchbase.lite.MessageEndpoint
import com.couchbase.lite.MessageEndpointConnection
import com.couchbase.lite.MessageEndpointDelegate
import com.couchbase.lite.MessageEndpointListener
import com.couchbase.lite.MessageEndpointListenerConfigurationFactory
import com.couchbase.lite.MessagingCloseCompletion
import com.couchbase.lite.MessagingCompletion
import com.couchbase.lite.ProtocolType
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfigurationFactory
import com.couchbase.lite.ReplicatorConnection
import com.couchbase.lite.create


@Suppress("unused")
class BrowserSessionManager : MessageEndpointDelegate {
    private var replicator: Replicator? = null

    @Throws(CouchbaseLiteException::class)
    fun initCouchbase() {
        // tag::message-endpoint[]
        val database = Database("mydb")

        // The delegate must implement the `MessageEndpointDelegate` protocol.
        val messageEndpoint = MessageEndpoint("UID:123", "active", ProtocolType.MESSAGE_STREAM, this)
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        // Create the replicator object.
        val repl = Replicator(ReplicatorConfigurationFactory.create(database = database, target = messageEndpoint))
        // Start the replication.
        repl.start()
        replicator = repl
        // end::message-endpoint-replicator[]
    }

    // tag::create-connection[]
    /* implementation of MessageEndpointDelegate */
    override fun createConnection(endpoint: MessageEndpoint) = ActivePeerConnection()
    // end::create-connection[]
}

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ----------------------------------------------------------- */

@Suppress("unused")
class ActivePeerConnection : MessageEndpointConnection {
    private var replicatorConnection: ReplicatorConnection? = null

    // tag::active-replicator-close[]
    fun disconnect() {
        replicatorConnection?.close(null)
        replicatorConnection = null
    }
    // end::active-replicator-close[]

    // tag::active-peer-open[]
    /* implementation of MessageEndpointConnection */
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    // end::active-peer-open[]
    // tag::active-peer-close[]
    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete()
    }

    // end::active-peer-close[]
    // tag::active-peer-send[]
    /* implementation of MessageEndpointConnection */
    override fun send(message: Message, completion: MessagingCompletion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null)
    }

    // end::active-peer-send[]
    fun receive(message: Message) {
        // tag::active-peer-receive[]
        replicatorConnection?.receive(message)
        // end::active-peer-receive[]
    }
}

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ----------------------------------------------------------- */

@Suppress("unused")
class PassivePeerConnection private constructor() : MessageEndpointConnection {
    private var messageEndpointListener: MessageEndpointListener? = null
    private var replicatorConnection: ReplicatorConnection? = null

    @Throws(CouchbaseLiteException::class)
    fun startListener() {
        // tag::listener[]
        val database = Database("mydb")
        messageEndpointListener = MessageEndpointListener(
            MessageEndpointListenerConfigurationFactory.create(database, ProtocolType.MESSAGE_STREAM)
        )
        // end::listener[]
    }

    fun stopListener() {
        // tag::passive-stop-listener[]
        messageEndpointListener?.closeAll()
        // end::passive-stop-listener[]
    }

    fun accept() {
        // tag::advertizer-accept[]
        val connection = PassivePeerConnection() /* implements MessageEndpointConnection */
        messageEndpointListener?.accept(connection)
        // end::advertizer-accept[]
    }

    fun disconnect() {
        // tag::passive-replicator-close[]
        replicatorConnection?.close(null)
        // end::passive-replicator-close[]
    }

    // tag::passive-peer-open[]
    /* implementation of MessageEndpointConnection */
    override fun open(connection: ReplicatorConnection, completion: MessagingCompletion) {
        replicatorConnection = connection
        completion.complete(true, null)
    }
    // end::passive-peer-open[]

    // tag::passive-peer-close[]
    /* implementation of MessageEndpointConnection */
    override fun close(error: Exception?, completion: MessagingCloseCompletion) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete()
    }

    // end::passive-peer-close[]
    // tag::passive-peer-send[]
    /* implementation of MessageEndpointConnection */
    override fun send(message: Message, completion: MessagingCompletion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null)
    }

    // end::passive-peer-send[]
    fun receive(message: Message) {
        // tag::passive-peer-receive[]
        replicatorConnection?.receive(message)
        // end::passive-peer-receive[]
    }

} // tag::predictive-model[]



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Peer2PeerExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.util.Log
import com.couchbase.lite.ArrayFunction
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.Expression
import com.couchbase.lite.FullTextExpression
import com.couchbase.lite.FullTextIndexItem
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.Join
import com.couchbase.lite.Meta
import com.couchbase.lite.Ordering
import com.couchbase.lite.Query
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.SelectResult
import com.couchbase.lite.ValueIndexItem
import com.fasterxml.jackson.databind.ObjectMapper
import org.json.JSONException


private const val TAG = "QUERY"
private const val DATABASE_NAME = "database"

data class Hotel(
    var description: String? = null,
    var country: String? = null,
    var city: String? = null,
    var name: String? = null,
    var type: String? = null,
    var id: String? = null
)

@Suppress("unused")
class QueryExamples(private val database: Database) {

    // ### Indexing
    @Throws(CouchbaseLiteException::class)
    fun testIndexing() {
        // tag::query-index[]
        database.createIndex(
            "TypeNameIndex",
            IndexBuilder.valueIndex(
                ValueIndexItem.property("type"),
                ValueIndexItem.property("name")
            )
        )
        // end::query-index[]
    }

    // ### SELECT statement
    fun testSelectStatement() {
        // tag::query-select-meta[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("type")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.expression(Meta.id))
            .execute()

        for (result in rs) {
            Log.i(TAG, "hotel id -&gt;${result.getString("id")}")
            Log.i(TAG, "hotel name -&gt; ${result.getString("name")}")
        }
        // end::query-select-meta[]
    }

    // META function
    @Throws(CouchbaseLiteException::class)
    fun testMetaFunction() {
        val rs = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("airport")))
            .orderBy(Ordering.expression(Meta.id))
            .execute()

        for (result in rs) {
            Log.w(TAG, "airport id -&gt;${result.getString("id")}")
            Log.w(TAG, "airport id -&gt; ${result.getString(0)}")
        }
    }

    // ### all(*)
    @Throws(CouchbaseLiteException::class)
    fun testSelectAll() {
        // tag::query-select-all[]
        val queryAll = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
        // end::query-select-all[]

        // tag::live-query[]
        val query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database)) <i class="conum" data-value="61"></i><b>(61)</b>

        // Adds a query change listener.
        // Changes will be posted on the main queue.
        // Version using Kotlin Flows to follow shortly ...
        val token = query.addChangeListener { change -&gt;
            change.results?.let {
                for (result in it) {
                    Log.d(TAG, "results: ${result.keys}")
                    /* Update UI */
                }
            } <i class="conum" data-value="62"></i><b>(62)</b>
        }

        // end::live-query[]

        // tag::stop-live-query[]
        query.removeChangeListener(token)
        // end::stop-live-query[]

        for (result in query.execute()) {
            Log.i(TAG, "hotel -&gt; ${result.getDictionary(DATABASE_NAME)?.toMap()}")
        }
    }


    // ###WHERE statement
    @Throws(CouchbaseLiteException::class)
    fun testWhereStatement() {
        // tag::query-where[]
        val rs = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .limit(Expression.intValue(10))
            .execute()
        for (result in rs) {
            result.getDictionary(DATABASE_NAME)?.let {
                Log.i(TAG, "name -&gt; ${it.getString("name")}")
                Log.i(TAG, "type -&gt; ${it.getString("type")}")
            }
        }
        // end::query-where[]
    }

    fun testQueryDeletedDocuments() {
        // tag::query-deleted-documents[]
        // Query documents that have been deleted
        val query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted)
        // end::query-deleted-documents[]
    }

    // ####Collection Operators
    @Throws(CouchbaseLiteException::class)
    fun testCollectionStatement() {
        // tag::query-collection-operator-contains[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name"),
                SelectResult.property("public_likes")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(
                        ArrayFunction.contains(
                            Expression.property("public_likes"),
                            Expression.string("Armani Langworth")
                        )
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.getArray("public_likes")?.toList()}")
        }
        // end::query-collection-operator-contains[]
    }

    // IN operator
    @Throws(CouchbaseLiteException::class)
    fun testInOperator() {
        // tag::query-collection-operator-in[]
        val rs = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.string("Armani").`in`(
                    Expression.property("first"),
                    Expression.property("last"),
                    Expression.property("username")
                )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "public_likes -&gt; ${result.toMap()}")
        }
        // end::query-collection-operator-in[]
    }

    // Pattern Matching
    @Throws(CouchbaseLiteException::class)
    fun testPatternMatching() {
        // tag::query-like-operator[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("royal engineers museum"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-like-operator[]
    }

    // ### Wildcard Match
    @Throws(CouchbaseLiteException::class)
    fun testWildcardMatch() {
        // tag::query-like-operator-wildcard-match[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng%e%"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-like-operator-wildcard-match[]
    }

    // Wildcard Character Match
    @Throws(CouchbaseLiteException::class)
    fun testWildCharacterMatch() {
        // tag::query-like-operator-wildcard-character-match[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .like(Expression.string("eng____r"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-like-operator-wildcard-character-match[]
    }

    // ### Regex Match
    @Throws(CouchbaseLiteException::class)
    fun testRegexMatch() {
        // tag::query-regex-operator[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("country"),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(
                        Function.lower(Expression.property("name"))
                            .regex(Expression.string("\\beng.*r\\b"))
                    )
            )
            .execute()
        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.getString("name")}")
        }
        // end::query-regex-operator[]
    }

    // JOIN statement
    @Throws(CouchbaseLiteException::class)
    fun testJoinStatement() {
        // tag::query-join[]
        val rs = QueryBuilder.select(
            SelectResult.expression(Expression.property("name").from("airline")),
            SelectResult.expression(Expression.property("callsign").from("airline")),
            SelectResult.expression(Expression.property("destinationairport").from("route")),
            SelectResult.expression(Expression.property("stops").from("route")),
            SelectResult.expression(Expression.property("airline").from("route"))
        )
            .from(DataSource.database(database).`as`("airline"))
            .join(
                Join.join(DataSource.database(database).`as`("route"))
                    .on(
                        Meta.id.from("airline")
                            .equalTo(Expression.property("airlineid").from("route"))
                    )
            )
            .where(
                Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(
                        Expression.property("type").from("airline")
                            .equalTo(Expression.string("airline"))
                    )
                    .and(
                        Expression.property("sourceairport").from("route")
                            .equalTo(Expression.string("RIX"))
                    )
            )
            .execute()

        for (result in rs) {
            Log.i(TAG, "name -&gt; ${result.toMap()}")
        }
        // end::query-join[]
    }


    // ### GROUPBY statement
    @Throws(CouchbaseLiteException::class)
    fun testGroupByStatement() {
        // tag::query-groupby[]
        val rs = QueryBuilder.select(
            SelectResult.expression(Function.count(Expression.string("*"))),
            SelectResult.property("country"),
            SelectResult.property("tz")
        )
            .from(DataSource.database(database))
            .where(
                Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300)))
            )
            .groupBy(
                Expression.property("country"), Expression.property("tz")
            )
            .orderBy(Ordering.expression(Function.count(Expression.string("*"))).descending())
            .execute()

        for (result in rs) {
            result.let {
                Log.i(
                    TAG,
                    "There are ${it.getInt("$1")} airports on the ${
                        it.getString("tz")
                    } timezone located in ${
                        it.getString("country")
                    } and above 300ft"
                )
            }
            // end::query-groupby[]
        }
    }

    // ### ORDER BY statement
    @Throws(CouchbaseLiteException::class)
    fun testOrderByStatement() {
        // tag::query-orderby[]
        val rs = QueryBuilder
            .select(
                SelectResult.expression(Meta.id),
                SelectResult.property("name")
            )
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel")))
            .orderBy(Ordering.property("name").ascending())
            .limit(Expression.intValue(10))
            .execute()

        for (result in rs) {
            Log.i(TAG, "${result.toMap()}")
        }
        // end::query-orderby[]
    }


    // ### EXPLAIN statement
    // tag::query-explain[]
    @Throws(CouchbaseLiteException::class)
    fun testExplainStatement() {
        // tag::query-explain-all[]
        var query: Query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("university")))
            .groupBy(Expression.property("country"))
            .orderBy(Ordering.property("name").descending()) <i class="conum" data-value="63"></i><b>(63)</b>
        Log.i(TAG, query.explain()) <i class="conum" data-value="64"></i><b>(64)</b>
        // end::query-explain-all[]

        // tag::query-explain-like[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").like(Expression.string("%hotel%"))) <i class="conum" data-value="65"></i><b>(65)</b>
        Log.i(TAG, query.explain())
        // end::query-explain-like[]

        // tag::query-explain-nopfx[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="66"></i><b>(66)</b>
                    .and(Expression.property("name").like(Expression.string("%royal%")))
            )
        Log.i(TAG, query.explain())
        // end::query-explain-nopfx[]

        // tag::query-explain-function[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Function.lower(
                    Expression.property("type").equalTo(Expression.string("hotel"))
                )
            ) <i class="conum" data-value="67"></i><b>(67)</b>
        Log.i(TAG, query.explain())
        // end::query-explain-function[]

        // tag::query-explain-nofunction[]
        query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("hotel"))) <i class="conum" data-value="68"></i><b>(68)</b>
        Log.i(TAG, query.explain())
        // end::query-explain-nofunction[]
    }
// end::query-explain[]

    @Throws(CouchbaseLiteException::class)
    fun prepareIndex() {
        // tag::fts-index[]
        database.createIndex(
            "nameFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("name")).ignoreAccents(false)
        )
        // end::fts-index[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS() {
        // tag::fts-query[]
        val rs = QueryBuilder.select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(FullTextExpression.index("nameFTSIndex").match("buy"))
            .execute()
        for (result in rs) {
            Log.i(TAG, "document properties${result.getString(0)}")
        }
        // end::fts-query[]
    }


    fun testQuerySyntaxAll(currentUser: String) {
        // tag::query-syntax-all[]
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(openOrCreateDatabaseForUser(currentUser)))

            // end::query-syntax-all[]
        // tag::query-access-all[]
        val hotels: HashMap&lt;String, Hotel&gt; = HashMap()

        for (result in listQuery.execute().allResults()) {
            // get the k-v pairs from the 'hotel' key's value into a dictionary
            val thisDocsProps = result.getDictionary(0) <i class="conum" data-value="69"></i><b>(69)</b>
            val thisDocsId = thisDocsProps!!.getString("id")
            val thisDocsName = thisDocsProps.getString("name")
            val thisDocsType = thisDocsProps.getString("type")
            val thisDocsCity = thisDocsProps.getString("city")

            // Alternatively, access results value dictionary directly
            val id = result.getDictionary(0)?.getString("id").toString() <i class="conum" data-value="70"></i><b>(70)</b>
            hotels[id] = Hotel(
                id,
                result.getDictionary(0)?.getString("type"),
                result.getDictionary(0)?.getString("name"),
                result.getDictionary(0)?.getString("city"),
                result.getDictionary(0)?.getString("country"),
                result.getDictionary(0)?.getString("description")
            )
        }

        // end::query-access-all[]
    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun testQuerySyntaxJson(currentUser: String, argDb: Database) {
        Database db = argDb
        // tag::query-syntax-json[]
        // Example assumes Hotel class object defined elsewhere

        // Build the query
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(db))

        // end::query-syntax-json[]
        // tag::query-access-json[]
        // Uses Jackson JSON processor
        val mapper = ObjectMapper()
        val hotels: ArrayList&lt;Hotel&gt; = ArrayList()

        for (result in listQuery.execute()) {

            // Get result as JSON string
            val json = result.toJSON() <i class="conum" data-value="71"></i><b>(71)</b>

            // Get Hashmap from JSON string
            val dictFromJSONstring = mapper.readValue(json, HashMap::class.java) <i class="conum" data-value="72"></i><b>(72)</b>

            // Use created hashmap
            val hotelId = dictFromJSONstring["id"].toString() //
            val hotelType = dictFromJSONstring["type"].toString()
            val hotelname = dictFromJSONstring["name"].toString()


            // Get custom object from JSON string
            val thisHotel = mapper.readValue(json, Hotel::class.java) <i class="conum" data-value="73"></i><b>(73)</b>
            hotels.add(thisHotel)
        }
        // end::query-access-json[]
    }
/* end func testQuerySyntaxJson */

  fun docsOnlyQuerySyntaxN1QL(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      Database db=argDb
      // tag::query-syntax-n1ql[]
      val thisQuery = dbcreateQuery(
            "SELECT META().id AS id FROM _ WHERE type = \"hotel\"") <i class="conum" data-value="74"></i><b>(74)</b>

      return thisQuery.execute().allResults()

      // end::query-syntax-n1ql[]
  }

  fun docsOnlyQuerySyntaxN1QLParams(argDb: Database): List&lt;Result&gt; {
      // For Documentation -- N1QL Query using parameters
      // tag::query-syntax-n1ql-params[]
      val thisQuery = dbcreateQuery(
            "SELECT META().id AS id FROM _ WHERE type = \$type") <i class="conum" data-value="75"></i><b>(75)</b>

      thisQuery.parameters = Parameters().setString("type", "hotel") <i class="conum" data-value="76"></i><b>(76)</b>

      return thisQuery.execute().allResults()

      // end::query-syntax-n1ql-params[]
  }

    fun openOrCreateDatabaseForUser(argUser: String): Database = Database(argUser)
}



// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/QueryExamples.kt 



// BEGIN --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt 
//
// Copyright (c) 2021 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import com.couchbase.lite.Blob
import com.couchbase.lite.Database
import com.couchbase.lite.MutableDictionary

class BlobExamples {

    // Example 2: Using Blobs
    fun example2(context: Context, db: Database) {
        val doc = db.getDocument("1000") ?: return

        // Create a blob from an asset
        val blob = Blob("image/png", context.assets.open("couchbaseimage.png"))

        // This will fail:
        // IllegalStateException("A Blob may be encoded as JSON only after it has been saved in a database")
        blob.toJSON()

        // Save the blob as part of a document
        db.save(doc.toMutable().setBlob("avatar", blob))

        // Experts only!!!
        db.saveBlob(blob)

        // Retrieve saved blob and get as JSON again
        val blobAsJSONString = db.getDocument("1000")?.getBlob("avatar")?.toJSON() ?: return

        // reconstitute
        val blobAsMap = MutableDictionary().setJSON(blobAsJSONString).toMap()

        // show the contents of the reconstituted blob
        for ((key, value) in blobAsMap) {
            Log.d("BLOB", "Data: $key -&gt; $value")
        }

        // verify that the reconstitued thing is still blob
        if (Blob.isBlob(blobAsMap)) {
            Log.d("BLOB", blobAsJSONString)
        }
    }
}


// END --/Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/BlobExamples.kt </code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="delete-tls-identity"><a class="anchor" href="#delete-tls-identity"></a>Delete TLS Identity</h2>
<div class="sectionbody">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset1_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset1_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset1_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/codesnippet_collection.kt">val thisAlias = "alias-to-delete"
val thisKeyStore = KeyStore.getInstance("AndroidKeyStore")
thisKeyStore.load(null)
thisKeyStore.deleteEntry(thisAlias)</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset1_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">String thisAlias = "alias-to-delete";
final KeyStore thisKeyStore
  =  KeyStore.getInstance("AndroidKeyStore");
thisKeyStore.load(null);
thisKeyStore.deleteEntry(thisAlias);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="related-content"><a class="anchor" href="#related-content"></a>Related Content</h2>
<div class="sectionbody">
<div class="card-row three-column-row">
<div class="sect5 column">
<h6 id=""><a class="anchor" href="#"></a></h6>
<div class="ulist">
<div class="title">How to</div>
<ul>
<li>
<p><a href="p2psync-websocket-using-passive.html" class="page">Passive Peer</a></p>
</li>
<li>
<p><a href="p2psync-websocket-using-active.html" class="page">Active Peer</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-2"><a class="anchor" href="#-2"></a></h6>
<div class="ulist">
<div class="title">Concepts</div>
<ul>
<li>
<p><a href="p2psync-websocket.html" class="page">Peer-to-Peer Data Sync</a></p>
</li>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/">API References</a>
.</p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-3"><a class="anchor" href="#-3"></a></h6>
<div class="paragraph">
<div class="title">Community Resources &#8230;&#8203;</div>
<p><a href="https://forums.couchbase.com/c/mobile/14">Forum</a> |
<a href="https://blog.couchbase.com/">Blog</a> |
 <a href="https://docs.couchbase.com/tutorials/index.html">Tutorials</a></p>
</div>
<div class="paragraph">
<div class="title"></div>
<p><a href="#tutorials:cbl-p2p-sync-websockets:swift/cbl-p2p-sync-websockets.adoc" class="page unresolved">Getting Started with Peer-to-Peer Synchronization</a></p>
</div>
</div>
</div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase">
          </a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <svg  width="14" height="14" viewBox="0 0 32.1 26.1"> <path id="twitter" class="cls-1" d="M32,7.1a11.836,11.836,0,0,1-3.8,1,6.462,6.462,0,0,0,2.9-3.6,12.606,12.606,0,0,1-4.2,1.6A6.492,6.492,0,0,0,22.1,4a6.594,6.594,0,0,0-6.6,6.6,7.719,7.719,0,0,0,.2,1.5A18.458,18.458,0,0,1,2.2,5.2a6.294,6.294,0,0,0-.9,3.3A6.765,6.765,0,0,0,4.2,14a6.109,6.109,0,0,1-3-.8v.1a6.543,6.543,0,0,0,5.3,6.4,4.678,4.678,0,0,1-1.7.2,4.869,4.869,0,0,1-1.2-.1,6.679,6.679,0,0,0,6.1,4.6,12.917,12.917,0,0,1-8.2,2.8,9.151,9.151,0,0,1-1.6-.1,18.438,18.438,0,0,0,10.1,3c12.1,0,18.7-10,18.7-18.7v-.8A13.336,13.336,0,0,0,32,7.2Z" transform="translate(0.1 -4)"/></svg>
            <a href="https://twitter.com/couchbase" class="icon">
              Twitter
            </a>
          </li>
          <li>
          <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="linkedin" class="cls-1" d="M29,0H3A3.076,3.076,0,0,0,0,3V29a3.009,3.009,0,0,0,3,3H29a2.946,2.946,0,0,0,3-3V3A3.009,3.009,0,0,0,29,0ZM12,26H8V12h4ZM10,10a2,2,0,1,1,2-2A2.006,2.006,0,0,1,10,10ZM26,26H22V18a2,2,0,0,0-4,0v8H14V12h4v2.5c.8-1.1,2.1-2.5,3.5-2.5A4.736,4.736,0,0,1,26,17Z"/></svg>
              <a href="https://www.linkedin.com/company/couchbase" class="icon">
             Linkedin
            </a>
          </li>
          <li>
            <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="facebook" class="cls-1" d="M29,0H3A2.652,2.652,0,0,0,0,3V29a2.652,2.652,0,0,0,3,3H16V18H12V14h4V12a6.452,6.452,0,0,1,6-6h4v4H22a2.151,2.151,0,0,0-2,2v2h6l-1,4H20V32h9a2.652,2.652,0,0,0,3-3V3A2.652,2.652,0,0,0,29,0Z"/></svg>
            <a href="https://www.facebook.com/Couchbase" class="icon">
            Facebook
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <div class="footer-terms-copyright">
          <span> 2021 Couchbase, Inc. Couchbase, Couchbase Lite and the Couchbase logo are registered trademarks of Couchbase, Inc.</span>
      </div>
      <div class="footer-terms-links">
        <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
        <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
        <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
        <a href="https://www.couchbase.com/support-policy">Support Policy</a>
        <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
      </div>
    </div>
  </div>
</footer>
<script id="site-script" src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/fontawesome-icon-defs.js"></script>
<script async src="../../../_/js/vendor/fontawesome.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
</body>
</html>
