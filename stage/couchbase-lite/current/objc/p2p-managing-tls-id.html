<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Managing TLS Identities | Couchbase Docs</title>
<link rel="canonical" href="http://127.0.0.1:5000/couchbase-lite/current/objc/p2p-managing-tls-id.html">
<link rel="stylesheet" href="../../../_/css/site.css">
<script src="../../../_/js/vendor/jquery.js"></script>
<meta name="description" content="Couchbase Lite - this content covers how to manage TLS identities using Couchbase Lite">
<link rel="schema.dcterms" href="https://purl.org/dc/terms/">
<meta name="dcterms.subject" content="couchbase-lite">
<meta name="dcterms.identifier" content="3.0">
<meta name="page-url" content="/couchbase-lite/current/objc/p2p-managing-tls-id.html">
<meta name="generator" content="Antora 3.0.0-alpha.6">
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
</head>
<body class="article">
<header class="header fixed-top">
  <div class="header-top-row">
      <div class="container">
          <nav class="navbar navbar-expand-md flex-nowrap justify-content-between navbar-new-top">
              <ul class="navbar-brand-list">
                <li class="brand-logo">
                  <a class="navbar-brand" href="https://www.couchbase.com">
                    <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase" />
                  </a>
                </li>
                <li>
                  <a class="navbar-brand cb-documentation" href="http://127.0.0.1:5000/home/index.html">
                    <img src="../../../_/img/cb-documentation.svg" alt="Couchbase Documentation" class="cb-docs" />
                    <img src="../../../_/img/cb-docs-hover.svg" alt="Couchbase Documentation" class="hide cb-hover-docs" />
                  </a>
                </li>
              </ul>
              <button class="navbar-burger" data-target="topbar-menu">
                <span></span>
                <span></span>
                <span></span>
              </button>

          </nav>
      </div>
  </div>
  <div class="header-bottom-row" id="topbar-menu">
    <div class="container">
        <nav  class="navbar navbar-new-bottom">

              <div class="navbar-collapse collapse" id="navbar2">
                <ul class="navbar-nav w-100 justify-content-start">
                  <li class="nav-item">
                    <a href="http://127.0.0.1:5000/home/index.html" class="nav-link">
                      <i class="fas fa-home"></i>
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/server.html">
                      Server
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/mobile.html">
                      Mobile
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/cloud.html">
                      Cloud
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/sdk.html">
                      SDKs
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../tutorials/index.html">
                      Tutorials
                      <span class="arrow">
                        <i class="fas fa-arrow-right"></i>
                      </span>
                    </a>
                  </li>
                </ul>
              </div>
              <div class="primary-action">
                <a href="https://cloud.couchbase.com/sign-up" class="free-trial-link" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Free Trial'});" >
                  <i class="fas fa-cloud"></i>
                  Free Trial
                </a>
                <a class="btn btn-primary try-btn"  onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Download'});" href="https://www.couchbase.com/downloads">
                  Downloads
                </a>
              </div>

        </nav>
    </div>
   </div>
</header>
<div class="body container">
<aside class="nav left-sidebar">
  <div class="nav-container">
    <a href="#" class="menu-expand-toggle"><span>Navigation</span><i class="fas fa-times-circle"></i><i class="fas fa-chevron-circle-left"></i></a>
<div class="components">
  <div class="components_group-title">
    <a href="../../../home/mobile.html">Mobile</a>
  </div>
  <ul class="components_list">
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Couchbase Lite</span>
        <select class="version_list" data-component="couchbase-lite">
          <option value="3.0" data-url="../index.html" selected>3.0</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0">
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../android/quickstart.html">Android</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#{cbl-pg-prereqs}">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{gs-install&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{gs-build&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{kotlin&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{database&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{prebuilt-database&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{document&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{blob&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder-n1ql&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder-n1ql-diffs&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-resultsets&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-live&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-troubleshooting&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{fts&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{indexing&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">{landing-replications&#8212;&#8203;xref}</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{dbreplica&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{replication&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">{p2psync-websocket&#8212;&#8203;xref}</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-websocket-using-passive&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-websocket-using-active&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-custom&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{conflict&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{url-api-references}[API&#160;References]</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{dep-upgrade&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{troubleshooting-logs&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{troubleshooting-queries&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{release-notes&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{compatibility&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{supported-os&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{refer-glossary&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../clang/quickstart.html">C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{gs-install&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{gs-build&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{database&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{prebuilt-database&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{document&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{blob&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{field-level-encryption&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder-n1ql&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder-n1ql-diffs&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-resultsets&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-live&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-troubleshooting&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{fts&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{indexing&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">{landing-replications&#8212;&#8203;xref}</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{dbreplica&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{replication&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">{p2psync-websocket&#8212;&#8203;xref}</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-websocket-using-passive&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-websocket-using-active&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-custom&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{conflict&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{url-api-references}[API&#160;References]</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{dep-upgrade&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{troubleshooting-logs&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{troubleshooting-queries&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{release-notes&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{compatibility&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{supported-os&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{refer-glossary&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/quickstart.html">C#.Net</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{gs-install&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{gs-build&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{database&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{prebuilt-database&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{document&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{blob&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder-n1ql&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder-n1ql-diffs&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-resultsets&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-live&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-troubleshooting&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{fts&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{indexing&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">{landing-replications&#8212;&#8203;xref}</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{dbreplica&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{replication&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">{p2psync-websocket&#8212;&#8203;xref}</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-websocket-using-passive&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-websocket-using-active&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-custom&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{conflict&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{url-api-references}[API&#160;References]</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{dep-upgrade&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{troubleshooting-logs&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{troubleshooting-queries&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{release-notes&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{compatibility&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{supported-os&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{refer-glossary&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/quickstart.html">Java</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#{cbl-pg-prereqs}">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{gs-install&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{gs-build&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{database&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{prebuilt-database&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{document&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{blob&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder-n1ql&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder-n1ql-diffs&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-resultsets&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-live&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-troubleshooting&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{fts&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{indexing&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">{landing-replications&#8212;&#8203;xref}</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{dbreplica&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{replication&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">{p2psync-websocket&#8212;&#8203;xref}</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-websocket-using-passive&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-websocket-using-active&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-custom&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{conflict&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{url-api-references}[API&#160;References]</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{dep-upgrade&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{troubleshooting-logs&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{troubleshooting-queries&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{release-notes&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{compatibility&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{supported-os&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{refer-glossary&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="quickstart.html">Objective-C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#{cbl-pg-prereqs}">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{gs-install&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{gs-build&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{database&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{prebuilt-database&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{document&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{blob&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder-n1ql&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder-n1ql-diffs&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-resultsets&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-live&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-troubleshooting&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{fts&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{indexing&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">{landing-replications&#8212;&#8203;xref}</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{dbreplica&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{replication&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">{p2psync-websocket&#8212;&#8203;xref}</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-websocket-using-passive&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-websocket-using-active&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-custom&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{conflict&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{url-api-references}[API&#160;References]</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{dep-upgrade&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{troubleshooting-logs&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{troubleshooting-queries&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{troubleshooting-crashes&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{release-notes&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{compatibility&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{supported-os&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{refer-glossary&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/quickstart.html">Swift</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#{cbl-pg-prereqs}">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{gs-install&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{gs-build&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{database&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{prebuilt-database&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{document&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{blob&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder-n1ql&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{querybuilder-n1ql-diffs&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-resultsets&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-live&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{query-troubleshooting&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{fts&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{indexing&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">{landing-replications&#8212;&#8203;xref}</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{dbreplica&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{replication&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">{p2psync-websocket&#8212;&#8203;xref}</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-websocket-using-passive&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-websocket-using-active&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{p2psync-custom&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{conflict&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{url-api-references}[API&#160;References]</span>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{dep-upgrade&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{troubleshooting-logs&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{troubleshooting-queries&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{troubleshooting-crashes&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{release-notes&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{compatibility&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{supported-os&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <span class="menu_title menu_text">{refer-glossary&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../javascript.html">JavaScript</a>
  </span>
</li>
</ul>
      </div>
    </li>
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Sync Gateway</span>
        <select class="version_list" data-component="sync-gateway">
          <option value="3.0" data-url="../../../sync-gateway/current/index.html" selected>3.0</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0">
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/introduction.html">Introduction</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/whatsnew.html"><strong><em>New in 3.0</em></strong></a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-prepare.html">Prepare</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-verify-install.html">Verify</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/data-modeling.html">Data Modeling</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Configuration</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-bootstrap.html">Bootstrap schema</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin-database.html">Database schema</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin-db-security.html">Database Security schema</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin-access-control.html">Access Control schema</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin-isgr.html">Inter-Sync&#160;Gateway Replication schema</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-properties.html">Configuration <em><sup>(pre-3.0)</sup></em> schema</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-javascript-functions.html">Javascript Functions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-environment-variables.html">Environment Variables</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Security</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/secure-sgw-access.html">Secure Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-users.html">User Authentication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-certs.html">TLS Certificate Authentication</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Access Control</span>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-concepts.html">Concepts</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-model.html">Access control Model</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/channels.html">Channels</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/roles.html">Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/users.html">Users</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function.html">Sync Function</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api.html">API Reference</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-access-cmd.html">access()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-channel-cmd.html">channel()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-expiry-cmd.html">expiry()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-access-cmd.html">requireAccess()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-admin-cmd.html">requireAdmin()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-role-cmd.html">requireRole()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-require-user-cmd.html">requireUser()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-role-cmd.html">role()</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function-api-throw-cmd.html">throw()</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how.html">How-To</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-create-users.html">Create Users</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-create-roles.html">Create Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-assign-users-to-roles.html">Assign Users to Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-control-document-access.html">Control Document Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-verify-access.html">Verify Access</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/access-control-how-use-xattrs-for-access-grants.html">Use XATTRs for Access Grants</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/auto-purge-channel-access-revocation.html">Auto-purge on Channel Access Revocation</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">REST API</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-access.html">Secure Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin.html">Admin REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-metrics.html">Metrics REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api.html">Public REST API</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-with-couchbase-server.html">Sync with Couchbase Server</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-using-app.html">Sync Using App</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Inter-Sync Gateway Replication</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-run.html">Initialize</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-manage.html">Manage</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-monitor.html">Monitor</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{sgw-xref}sync-inter-syncgateway-conflict-resolution.adoc[Conflict Resolution]</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/revisions.html">Revisions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/what-are-tombstones.html">Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/managing-tombstones.html">Managing Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/delta-sync.html">Delta Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/resync.html">Resync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/import-filter.html">Import filter</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Manage</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-monitoring.html">Stats Monitoring</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Logging and Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/logging.html">Logging</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sgcollect-info.html">SGCollect Info</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/database-offline.html">Database Offline</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Deploy</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deployment.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/command-line-options.html">Command Line Options</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/load-balancer.html">Load Balancer</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/os-level-tuning.html">OS-level Tuning</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/webhooks.html">Webhooks</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/changes-feed.html">Changes Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/integrating-external-stores.html">External Stores</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-prometheus.html">Prometheus Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/setting-up-dr-cluster.html">Disaster Recovery</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/upgrading.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Use Kubernetes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deploy-cluster-to-kubernetes.html">Deploy</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#operator::tutorial-sync-gateway-manage.adoc">Manage a Sync Gateway Cluster</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#operator::tutorial-sync-gateway-clients.adoc">Expose Sync Gateway to Couchbase Lite clients</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Server Compatibility</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-collections.html">Collections</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-eventing.html">Eventing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-transactions.html">Transactions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-xdcr.html">XDCR</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/supported-environments.html">Supported Environments</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/compatibility.html">Compatibility Matrix</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Legacy Features</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sgreplicate-resolving-conflicts.html">SG-Replicate - Resolving Conflicts (depr)</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sg-replicate.html">SG-Replicate</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-logging-pre2-1.html">Legacy Logging Pre2 1</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/glossary.html">Glossary</a>
  </span>
</li>
</ul>
      </div>
    </li>
  </ul>
</div>
  </div>
</aside>
<aside class="toc sidebar">
  <div class="sidebar-box">
    <div class="tools" role="navigation">
<ul>
<li class="tool edit"><a href="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/objc/pages/p2p-managing-tls-id.adoc" title="Edit Page" target="_blank" rel="noopener">Edit on GitHub</a></li>
</ul>
</div>
    <div class="toc-menu"></div>
    <div class="is-this-helpful-box">
      <h4> Is this page helpful?</h4>
      <div class="btn-row">
        <a href="#" class="like-btn helpful-btn" id="yesBtn" data-page-rating="like" >
                <i class="far fa-thumbs-up"></i>
            Yes

            </a>
        <a href="#" class="dislike-btn helpful-btn" id="noBtn"  data-page-rating="dislike"> <i class="far fa-thumbs-down"></i> No</a>
      </div>
      <div class="any-feedback">
        <a href="#" class="btn any-feedback-btn" id="myCustomTrigger">Leave Additional Feedback? </a>
      </div>
      <div class="dialog-box" id="dialogBox">
        <form>
            <div class="form-group " id="additionalFeedbackBox">
              <textarea class="input-control feed-back-msg" rows="8" placeholder="Any Additonal Feedback?"></textarea>

              <div class="action-btn-row ">
                <a href="#" class="skip-btn" id="skipBtnMsg">Skip</a>
                  <button class="submit-btn btn blue-btn disabled" > Submit  </button>
                  <a href="#" class="info-btn"><i class="fas fa-info-circle"></i></a>
              </div>


            </div>

        </form>

      </div>
    </div>
  </div>

</aside>

<div class="feedback-modal modal-popup">
  <div class="modal-popup-dialogue">
    <div class="popup-header">
      <a href="#" class="close-popup"><i class="fa fa-times"></i></a>
    </div>
    <div class="popup-content">
      <p>
        Please use the form below to provide your feedback. Because your feedback is valuable to us,
         the information you submit in this form is recorded in our issue tracking system (JIRA), which is publicly available.
        You can track the status of your feedback using the ticket number displayed in the dialog once you submit the form.
      </p>
    </div>
  </div>
</div>

<main class="article" data-ceiling="topbar">
<div class="article-header">
<nav class="crumbs" aria-label="breadcrumbs">
<ul>
<li class="crumb"><a href="../index.html">Couchbase Lite</a></li>
<li class="crumb"><a href="p2p-managing-tls-id.html">Managing TLS Identities</a></li>
</ul>
</nav>
</div>
<article class="doc">
<div class="page-heading-title">
<h1 class="page">Managing TLS Identities</h1>
<div class="labels">
<ul>
<li class="edition"><a href="https://www.couchbase.com/products/editions">Enterprise</a></li>
</ul>
</div>
</div>
<div class="contributor-list-box">
<span class="last-commit-date" id="commitdate">    </span>
<ul id="contributorList"></ul>
<span  id="otherContributor"> + </span>
</div><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/_partials/_std-cbl-hdr.adoc - include::shared-mobile::partial$_attributes-shared.adoc[]</p>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/_partials/_glossary-links.adoc - include::shared-mobile::partial$_attributes-shared.adoc[]</p>
</div>
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>Description&#8201;&#8212;&#8201;<em>Couchbase Lite - this content covers how to manage TLS identities using Couchbase Lite</em><br>
Related Content&#8201;&#8212;&#8201;<a href="https://ibsoln.github.io/api/mobile/{major}.{minor}/couchbase-lite-objc">API Reference</a>  |  <a href="p2psync-websocket-using-passive.html" class="page">Passive Peer</a>  |  <a href="p2psync-websocket-using-active.html" class="page">Active Peer</a></p>
</div>
</blockquote>
</div>
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>Description&#8201;&#8212;&#8201;<em>Couchbase Lite - this content covers how to manage TLS identities using Couchbase Lite</em><br>
Related Content&#8201;&#8212;&#8201;<a href="https://ibsoln.github.io/api/mobile/{major}.{minor}/couchbase-lite-objc">API Reference</a>  |  <a href="p2psync-websocket-using-passive.html" class="page">Passive Peer</a>  |  <a href="p2psync-websocket-using-active.html" class="page">Active Peer</a></p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1 pane__frames">
<h2 id="overview"><a class="anchor" href="#overview"></a>Overview</h2>
<div class="sectionbody">
<div class="ulist no-color">
<div class="title"></div>
<ul>
<li>
<p>This describes the configuration and management of TLS identities</p>
</li>
</ul>
</div>
<div class="ulist narrow">
<div class="title">Key Concepts</div>
<ul>
<li>
<p>API: <a href="https://ibsoln.github.io/api/mobile/{major}.{minor}/couchbase-lite-objc/Classes/CBLTLSIdentity.html">TLSIdentity</a></p>
</li>
<li>
<p><a href="p2psync-websocket.html" class="page">Peer-to-Peer</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="api-references"><a class="anchor" href="#api-references"></a>API References</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can find <a href="https://ibsoln.github.io/api/mobile/{major}.{minor}/couchbase-lite-objc">Objective-C API References</a> here.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-tls-identity"><a class="anchor" href="#creating-tls-identity"></a>Creating TLS Identity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are couple of options by which TLS Identity is created:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can use the <a href="#anonymous-cert">anonymous self-signed cert</a> auto-generated by Couchbase Lite</p>
</li>
<li>
<p>You can <a href="#importing-a-cert">import a cert</a> to be bundled with the app and-or stored in the keychain</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="use-anonymous-cert"><a class="anchor" href="#use-anonymous-cert"></a>Use Anonymous Cert</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Anonymous certification uses the self signed certificate auto-generated by Couchbase Lite when TLS is enabled, but no TLSIdentity is provided.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc">listenerConfig.disableTLS  = false // Use with anonymous self signed cert
listenerConfig.tlsIdentity = nil</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="import-a-cert"><a class="anchor" href="#import-a-cert"></a>Import a Cert</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use the <a href="https://ibsoln.github.io/api/mobile/{major}.{minor}/couchbase-lite-objc/Classes/CBLTLSIdentity.html">TLSIdentity</a> class&#8217;s  <a href="https://ibsoln.github.io/api/mobile/{major}.{minor}/couchbase-lite-objc/Classes/CBLTLSIdentity.html#/c:objc(cs)CBLTLSIdentity(cm)importIdentityWithData:password:label:error:">importIdentity(withData:password:label:error:)</a> method to import a certificate that can be bundled with the app and-or added to the keychain.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>First check the keychain to see if the identity already exists</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc">[data-source-url=https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m]</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Check for an existing resource bundle</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">//
//  SampleCodeTest.m
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#import &lt;UIKit/UIKit.h&gt;
#import &lt;CouchbaseLite/CouchbaseLite.h&gt;
#import &lt;CoreML/CoreML.h&gt;

// tag::predictive-model[]
// `myMLModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
@interface myMLModel : NSObject

+ (NSDictionary*)predictImage: (NSData*)data;

@end

@interface ImageClassifierModel : NSObject &lt;CBLPredictiveModel&gt;

- (nullable CBLDictionary*) predict: (CBLDictionary*)input;

@end

@implementation ImageClassifierModel

- (nullable CBLDictionary*) predict: (CBLDictionary*)input; {
    CBLBlob* blob = [input blobForKey:@"photo"];

    NSData* imageData = blob.content;
    // `myMLModel` is a fake implementation
    // this would be the implementation of the ml model you have chosen
    NSDictionary* modelOutput = [myMLModel predictImage:imageData];

    CBLMutableDictionary* output = [[CBLMutableDictionary alloc] initWithData: modelOutput];
    return output; <i class="conum" data-value="1"></i><b>(1)</b>
}

@end
// end::predictive-model[]

// to avoid link error
@implementation myMLModel
+ (NSDictionary*)predictImage: (NSData*)data { return [NSDictionary dictionary]; }
@end

// tag::custom-logging[]
@interface LogTestLogger : NSObject&lt;CBLLogger&gt;

// set the log level
@property (nonatomic) CBLLogLevel level;

@end

@implementation LogTestLogger

@synthesize level=_level;

- (void) logWithLevel: (CBLLogLevel)level domain: (CBLLogDomain)domain message: (NSString*)message {
    // handle the message, for example piping it to
    // a third party framework
}

@end

// end::custom-logging[]

// tag::local-win-conflict-resolver[]
@interface LocalWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation LocalWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.localDocument;
}

@end
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
@interface RemoteWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation RemoteWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.remoteDocument;
}

@end
// end::remote-win-conflict-resolver[]


// tag::merge-conflict-resolver[]
@interface MergeConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation MergeConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    NSDictionary *localDict = conflict.localDocument.toDictionary;
    NSDictionary *remoteDict = conflict.remoteDocument.toDictionary;

    NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:localDict];
    [result addEntriesFromDictionary:remoteDict];

    return [[CBLMutableDocument alloc] initWithID:conflict.documentID
                                             data:result];
}

@end
// end::merge-conflict-resolver[]

@interface SampleCodeTest : NSObject
@property(nonatomic) CBLDatabase* db;
@property(nonatomic) NSArray* _allowlistedUsers;
@end

@implementation SampleCodeTest

#pragma mark - Database

- (void) dontTestNewDatabase {
    // tag::new-database[]
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::new-database[]

    // tag::close-database[]
    tbd

    // end::close-database[]


}

#if COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseEncryption {
    // tag::database-encryption[]
    CBLDatabaseConfiguration *config = [[CBLDatabaseConfiguration alloc] init];
    config.encryptionKey = [[CBLEncryptionKey alloc] initWithPassword:@"secretpassword"];

    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" config:config error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::database-encryption[]
}
#endif

- (void) dontTestLogging {
    // tag::logging[]
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainReplicator];
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainQuery];
    // end::logging[]
}

- (void) dontTestEnableConsoleLogging {
    // tag::console-logging[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll; <i class="conum" data-value="1"></i><b>(1)</b>
    CBLDatabase.log.console.level = kCBLLogLevelVerbose; <i class="conum" data-value="2"></i><b>(2)</b>

    // end::console-logging[]

    // tag::console-logging-db[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll;

    // end::console-logging-db[]
}

- (void) dontTestFileLogging {
    // tag::file-logging[]
    NSString* tempFolder = [NSTemporaryDirectory() stringByAppendingPathComponent:@"cbllog"];
    CBLLogFileConfiguration* config = [[CBLLogFileConfiguration alloc] initWithDirectory:tempFolder]; <i class="conum" data-value="3"></i><b>(3)</b>
    config.maxRotateCount = 2; <i class="conum" data-value="4"></i><b>(4)</b>
    config.maxSize = 1024; <i class="conum" data-value="5"></i><b>(5)</b>
    config.usePlainText = YES; <i class="conum" data-value="6"></i><b>(6)</b>
    [CBLDatabase.log.file setConfig:config];
    [CBLDatabase.log.file setLevel: kCBLLogLevelInfo]; <i class="conum" data-value="7"></i><b>(7)</b>
    // end::file-logging[]
}

- (void) dontTestEnableCustomLogging {
    // tag::set-custom-logging[]
    [CBLDatabase.log setCustom:[[LogTestLogger alloc] initWithLogLevel: kCBLLogLevelWarning]];

    // end::set-custom-logging[]
}

- (void) dontTestLoadingPrebuilt {
    // tag::prebuilt-database[]
    // Note: Getting the path to a database is platform-specific.
    // For iOS you need to get the path from the main bundle.
    if (![CBLDatabase databaseExists:@"travel-sample" inDirectory:nil]) {
        NSError*error;
        NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@"travel-sample" ofType:@"cblite2"];
        if (![CBLDatabase copyFromPath:path toDatabase:@"travel-sample" withConfig:nil error:&amp;error]) {
            [NSException raise:NSInternalInconsistencyException
                        format:@"Could not load pre-built database: %@", error];
        }
    }
    // end::prebuilt-database[]
}

#pragma mark - Document

- (void) dontTestInitializer {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::initializer[]
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];
    [newTask setString:@"task" forKey:@"task"];
    [newTask setString:@"todo" forKey:@"owner"];
    [newTask setString:@"task" forKey:@"createdAt"];
    [database saveDocument:newTask error:&amp;error];
    // end::initializer[]
}

- (void) dontTestMutability {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];
    [database saveDocument:mutableDocument error:&amp;error];
    // end::update-document[]
}

- (void) dontTestTypedAcessors {
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];

    // tag::date-getter[]
    [newTask setValue:[NSDate date] forKey:@"createdAt"];
    NSDate *date = [newTask dateForKey:@"createdAt"];
    // end::date-getter[]

    NSLog(@"Date: %@", date);
}

- (void) dontTestBatchOperations {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::batch[]
    [database inBatch:&amp;error usingBlock:^{
        for (int i = 0; i &lt; 10; i++) {
            CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
            [doc setValue:@"user" forKey:@"type"];
            [doc setValue:[NSString stringWithFormat:@"user %d", i] forKey:@"name"];
            [doc setBoolean:NO forKey:@"admin"];
            [database saveDocument:doc error: &amp;error];
        }
    }];
    // end::batch[]
}

- (void) dontTestChangeListener {
    __weak CBLDatabase *database = self.db;

    // tag::document-listener[]
    [database addDocumentChangeListenerWithID: @"user.john" listener:^(CBLDocumentChange * change) {
        CBLDocument* document = [database documentWithID: change.documentID];
        NSLog(@"Status :: %@)", [document stringForKey: @"verified_account"]);
    }];
    // end::document-listener[]
}

- (void) dontTestDocumentExpiration {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::document-expiration[]
    // Purge the document one day from now
    NSDate* ttl = [[NSCalendar currentCalendar] dateByAddingUnit: NSCalendarUnitDay
                                                           value: 1
                                                          toDate: [NSDate date]
                                                         options: 0];
    [database setDocumentExpirationWithID:@"doc123" expiration:ttl error:&amp;error];

    // Reset expiration
    [database setDocumentExpirationWithID:@"doc1" expiration:nil error: &amp;error];

    // Query documents that will be expired in less than five minutes
    NSTimeInterval fiveMinutesFromNow = [[NSDate dateWithTimeIntervalSinceNow:60 * 5] timeIntervalSince1970];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression: [CBLQueryMeta id]]]
                                         from: [CBLQueryDataSource database: database]
                                        where: [[CBLQueryMeta expiration]
                                                lessThan: [CBLQueryExpression double: fiveMinutesFromNow]]];
    // end::document-expiration[]
    NSLog(@"%@", query);
}

- (void) dontTestBlob {
#if TARGET_OS_IPHONE
    NSError *error;
    CBLDatabase *database = self.db;
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::blob[]
    UIImage *appleImage = [UIImage imageNamed:@"avatar.jpg"];
    NSData *imageData = UIImageJPEGRepresentation(appleImage, 1.0);

    CBLBlob *blob = [[CBLBlob alloc] initWithContentType:@"image/jpeg" data:imageData];
    [newTask setBlob:blob forKey:@"avatar"];
    [database saveDocument:newTask error:&amp;error];

    CBLDocument *savedTask = [database documentWithID: @"task1"];
    CBLBlob *taskBlob = [savedTask blobForKey:@"avatar"];
    UIImage *taskImage = [UIImage imageWithData:taskBlob.content];
    // end::blob[]

    NSLog(@"%@", taskImage);
#endif
}

- (void) dontTest1xAttachment {
    CBLMutableDocument *document = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::1x-attachment[]
    CBLDictionary *attachments = [document dictionaryForKey:@"_attachments"];
    CBLBlob *avatar = [attachments blobForKey:@"avatar"];
    NSData *content = [avatar content];
    // end::1x-attachment[]

    NSLog(@"%@", content);
}

#pragma mark - Query

- (void) dontTestIndexing {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-index[]
    CBLValueIndexItem *type = [CBLValueIndexItem property:@"type"];
    CBLValueIndexItem *name = [CBLValueIndexItem property:@"name"];
    CBLIndex* index = [CBLIndexBuilder valueIndexWithItems:@[type, name]];
    [database createIndex:index withName:@"TypeNameIndex" error:&amp;error];
    // end::query-index[]
}

- (void) dontTestSelect {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-select-meta[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuery *query = [CBLQueryBuilder select:@[name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression value:@"user"]] andExpression:
                                               [[CBLQueryExpression property:@"admin"] equalTo:[CBLQueryExpression boolean:NO]]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"user name :: %@", [result stringAtIndex:0]);
    }
    // end::query-select-meta[]
}

- (void) dontTestSelectAll {
    CBLDatabase *database = self.db;

    // tag::query-select-all[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];
    // end::query-select-all[]

    NSLog(@"%@", query);
}

- (void) dontTestLiveQuery {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::live-query[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];

    // Adds a query change listener.
    // Changes will be posted on the main queue.
    id&lt;CBLListenerToken&gt; token = [query addChangeListener:^(CBLQueryChange * _Nonnull change) // &lt;.&gt;{
        for (CBLQueryResultSet *result in [change results]) {
            NSLog(@"%@", result);
            /* Update UI */
        }
    }];

    // Start live query.
    [query execute: &amp;error]; <i class="conum" data-value="8"></i><b>(8)</b>
    // end::live-query[]

    // tag::stop-live-query[]
    [query removeChangeListenerWithToken:token]; <i class="conum" data-value="9"></i><b>(9)</b>
    // end::stop-live-query[]
}

- (void) dontTestWhere {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-where[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:[CBLQueryLimit limit:[CBLQueryExpression integer:10]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        CBLDictionary *dict = [result valueForKey:@"travel-sample"];
        NSLog(@"document name :: %@", [dict stringForKey:@"name"]);
    }
    // end::query-where[]

    NSLog(@"%@", query);
}

- (void) dontTestQueryDeletedDocuments {
    CBLDatabase* database = self.db;

    // tag::query-deleted-documents[]
    // Query documents that have been deleted
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression:CBLQueryMeta.id]]
                                         from: [CBLQueryDataSource database:database]
                                        where: CBLQueryMeta.isDeleted];
    // end::query-deleted-documents[]
    NSLog(@"%@", query);
}

- (void) dontTestCollectionOperatorContains {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-contains[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuerySelectResult *likes = [CBLQuerySelectResult property:@"public_likes"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]];
    CBLQueryExpression *contains = [CBLQueryArrayFunction contains:[CBLQueryExpression property:@"public_likes"]
                                                             value:[CBLQueryExpression string:@"Armani Langworth"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name, likes]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: contains]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"public_likes :: %@", [[result arrayForKey:@"public_likes"] toArray]);
    }
    // end::query-collection-operator-contains[]
}

- (void) dontTestCollectionOperatorIn {
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-in[]
    NSArray *values = @[[CBLQueryExpression property:@"first"],
                       [CBLQueryExpression property:@"last"],
                       [CBLQueryExpression property:@"username"]];

    [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                       from:[CBLQueryDataSource database:database]
                      where:[[CBLQueryExpression string:@"Armani"] in:values]];
    // end::query-collection-operator-in[]
}

- (void) dontTestLikeOperator {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-like-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"royal engineers museum"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"name property :: %@", [result stringForKey:@"name"]);
    }
    // end::query-like-operator[]
}

- (void) dontTestWildCardMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"eng%e%"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-match[]

    NSLog(@"%@", query);
}

- (void) dontTestWildCardCharacterMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-character-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryExpression property:@"name"] like:[CBLQueryExpression string:@"eng____r"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-character-match[]

    NSLog(@"%@", query);
}

- (void) dontTestRegexMatch {
    CBLDatabase *database = self.db;

    // tag::query-regex-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *regex = [[CBLQueryExpression property:@"name"] regex:[CBLQueryExpression string:@"\\bEng.*e\\b"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: regex]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-regex-operator[]

    NSLog(@"%@", query);
}

- (void) dontTestJoin {
    CBLDatabase *database = self.db;

    // tag::query-join[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"name" from:@"airline"]];
    CBLQuerySelectResult *callsign = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"callsign" from:@"airline"]];
    CBLQuerySelectResult *dest = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"destinationairport" from:@"route"]];
    CBLQuerySelectResult *stops = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"stops" from:@"route"]];
    CBLQuerySelectResult *airline = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"airline" from:@"route"]];

    CBLQueryJoin *join = [CBLQueryJoin join:[CBLQueryDataSource database:database as:@"route"]
                                         on:[[CBLQueryMeta idFrom:@"airline"] equalTo:[CBLQueryExpression property:@"airlineid" from:@"route"]]];

    CBLQueryExpression *typeRoute = [[CBLQueryExpression property:@"type" from:@"route"] equalTo:[CBLQueryExpression string:@"route"]];
    CBLQueryExpression *typeAirline = [[CBLQueryExpression property:@"type" from:@"airline"] equalTo:[CBLQueryExpression string:@"airline"]];
    CBLQueryExpression *sourceRIX = [[CBLQueryExpression property:@"sourceairport" from:@"route"] equalTo:[CBLQueryExpression string:@"RIX"]];

    CBLQuery *query = [CBLQueryBuilder select:@[name, callsign, dest, stops, airline]
                                         from:[CBLQueryDataSource database:database as:@"airline"]
                                         join:@[join]
                                        where:[[typeRoute andExpression:typeAirline] andExpression:sourceRIX]];
    // end::query-join[]

    NSLog(@"%@", query);
}

- (void) dontTestGroupBy {
    CBLDatabase *database = self.db;

    // tag::query-groupby[]
    CBLQuerySelectResult *count = [CBLQuerySelectResult expression:[CBLQueryFunction count:[CBLQueryExpression all]]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *tz = [CBLQuerySelectResult property:@"tz"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"airport"]];
    CBLQueryExpression *geoAlt = [[CBLQueryExpression property:@"geo.alt"] greaterThanOrEqualTo:[CBLQueryExpression integer:300]];

    CBLQuery *query = [CBLQueryBuilder select:@[count, country, tz]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: geoAlt]
                                      groupBy:@[[CBLQueryExpression property:@"country"],
                                                [CBLQueryExpression property:@"tz"]]];
    // end::query-groupby[]

    NSLog(@"%@", query);
}

- (void) dontTestOrderBy {
    CBLDatabase *database = self.db;

    // tag::query-orderby[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *title = [CBLQuerySelectResult property:@"title"];

    CBLQuery *query = [CBLQueryBuilder select:@[id, title]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      orderBy:@[[[CBLQueryOrdering property:@"title"] descending]]];
    // end::query-orderby[]

    NSLog(@"%@", query);
}


- (void) dontTestExplainAll {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-all[]
    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[[CBLQueryExpression property:@"type"]
                   equalTo:[CBLQueryExpression string:@"university"]]
//            groupBy:@[[CBLQueryExpression property:@"country"]] <i class="conum" data-value="10"></i><b>(10)</b>
                          orderBy:@[[[CBLQueryOrdering property:@"title"] descending]] <i class="conum" data-value="11"></i><b>(11)</b>
       ];

    NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="12"></i><b>(12)</b>

      // end::query-explain-all[]
}
- (void) dontTestExplainLike {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-like[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"%hotel%"]];
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];
      NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="13"></i><b>(13)</b>

      // end::query-explain-like[]

}
- (void) dontTestExplainNoPfx {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-nopfx[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"hotel%"]]; <i class="conum" data-value="14"></i><b>(14)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-nopfx[]
}

- (void) dontTestExplainFunction {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-function[]
    CBLQueryExpression *type =
        [[CBLQueryFunction lower:[CBLQueryExpression property:@"type"]]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="15"></i><b>(15)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
                from:[CBLQueryDataSource database:database]
                where:[type andExpression: name]];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-function[]
}

- (void) dontTestExplainNoFunction {
    CBLDatabase *database = self.db;
    NSError *error;
      // tag::query-explain-nofunction[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="16"></i><b>(16)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

      // end::query-explain-nofunction[]

}



- (void) dontTestCreateFullTextIndex {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-index[]
    // Insert documents
    NSArray *tasks = @[@"buy groceries", @"play chess", @"book travels", @"buy museum tickets"];
    for (NSString *task in tasks) {
        CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
        [doc setString:@"task" forKey:@"type"];
        [doc setString:task forKey:@"name"];
        [database saveDocument:doc error:&amp;error];
    }

    // Create index
    CBLFullTextIndex *index = [CBLIndexBuilder fullTextIndexWithItems:@[[CBLFullTextIndexItem property:@"name"]]];
    index.ignoreAccents = NO;
    [database createIndex:index withName:@"nameFTSIndex" error:&amp;error];
    // end::fts-index[]
}

- (void) dontTestFullTextSearch {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-query[]
    CBLQueryExpression *where =
      [[CBLQueryFullTextExpression indexWithName:@"nameFTSIndex"] match:@"'buy'"];
    CBLQuery *query =
      [CBLQueryBuilder
        select:@[[CBLQuerySelectResult expression:[CBLQueryMeta id]]]
        from:[CBLQueryDataSource database:database]
        where:where];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"document id %@", [result stringAtIndex:0]);
    }
    // end::fts-query[]
}

#pragma mark - Replication

/* The `tag::replication[]` example is inlined in objc.adoc */

- (void) dontTestEnableReplicatorLogging {
    // tag::replication-logging[]
    // Replicator
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainReplicator];
    // Network
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainNetwork];
    // end::replication-logging[]
}

- (void) dontTestReplicationBasicAuthentication {
    CBLDatabase *database = self.db;
    // tag::basic-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::basic-authentication[]
}

- (void) dontTestReplicationSessionAuthentication {
    CBLDatabase *database = self.db;
    // tag::session-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLSessionAuthenticator alloc] initWithSessionID:@"904ac010862f37c8dd99015a33ab5a3565fd8447"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::session-authentication[]
}

- (void) dontTestReplicatorStatus {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-status[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
        }
    }];
    // end::replication-status[]
}


//  BEGIN PendingDocuments IB -- 11/Feb/21 --
//    public void testReplicationPendingDocs() throws URISyntaxException {
      // tag::replication-pendingdocuments[]

      CBLDatabase *database = self.db;
      NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
      CBLURLEndpoint *target =
        [[CBLURLEndpoint alloc] initWithURL: url];
      CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc]
          initWithDatabase:database
          target:target];

      config.replicatorType = kCBLReplicatorTypePush;

      // tag::replication-push-pendingdocumentids[]
      CBLReplicator *replicator =
        [[CBLReplicator alloc] initWithConfig:config];

      // Get list of pending doc IDs
      NSError* err = nil;
      NSSet *mydocids =
        [NSSet setWithSet:[replicator pendingDocumentIDs:&amp;err]]; <i class="conum" data-value="17"></i><b>(17)</b>

      // end::replication-push-pendingdocumentids[]

      if ([mydocids count] &gt; 0) {

        NSLog(@"There are %lu documents pending", (unsigned long)[mydocids count]);

        [replicator addChangeListener:^(CBLReplicatorChange *change) {

          NSLog(@"Replicator activity level is %u", change.status.activity);
          // iterate and report-on the pending doc IDs  in 'mydocids'
          for (thisid in mydocids) {

            // tag::replication-push-isdocumentpending[]
            NSError* err = nil;
            if (![replicator isDocumentPending: thisid error: &amp;err]) { <i class="conum" data-value="18"></i><b>(18)</b>
              NSLog(@"Doc ID %@ now pushed", thisid);
            }
            // end::replication-push-isdocumentpending[]
          }

        }];
        [replicator start];

      };

      // end::replication-pendingdocuments[]
    }
//  END PendingDocuments IB -- 11/Feb/21 --



- (void) dontTestReplicatorDocumentEvent {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::add-document-replication-listener[]
    id token = [replicator addDocumentReplicationListener:^(CBLDocumentReplication * _Nonnull replication) {
        NSLog(@"Replication type :: %@", replication.isPush ? @"Push" : @"Pull");
        for (CBLReplicatedDocument* document in replication.documents) {
            if (document.error == nil) {
                NSLog(@"Doc ID :: %@", document.id);
                if ((document.flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
                    NSLog(@"Successfully replicated a deleted document");
                }
            } else {
                // There was an error
            }
        }
    }];

    [replicator start];
    // end::add-document-replication-listener[]

    // tag::remove-document-replication-listener[]
    [replicator removeChangeListenerWithToken: token];
    // end::remove-document-replication-listener[]
}

- (void) dontTestCustomReplicationHeader {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *endpoint = [[CBLURLEndpoint alloc] initWithURL:url];

    // tag::replication-custom-header[]
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:endpoint];
    config.headers = @{@"CustomHeaderName" : @"Value"};
    // end::replication-custom-header[]
}

- (void) dontTestHandlingReplicationError {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-error-handling[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];
    // end::replication-error-handling[]
}

- (void) dontTestReplicationResetCheckpoint {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-reset-checkpoint[]
    [replicator resetCheckpoint];
    [replicator start];
    // end::replication-reset-checkpoint[]
}

- (void) dontTestReplicationPushFilter {
    CBLDatabase *database = self.db;

    // tag::replication-push-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pushFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ([[document stringForKey: @"type"] isEqualToString: @"draft"]) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-push-filter[]
}

- (void) dontTestReplicationPullFilter {
    CBLDatabase *database = self.db;

    // tag::replication-pull-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pullFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ((flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-pull-filter[]
}

//  Added 2/Feb/21 - Ian Bridge
    - void dontTestCustomRetryConfig {
        // tag::replication-retry-config[]
        id target =
          [[CBLURLEndpoint alloc] initWithURL: [NSURL URLWithString: @"ws://foo.cbl.com/db"]];

        CBLReplicatorConfiguration* config =
            [[CBLReplicatorConfiguration alloc] initWithDatabase: db target: target];
        config.type = kCBLReplicatorTypePush;
        config.continuous: YES;
        //  other config as required . . .

        // tag::replication-heartbeat[]
        config.heartbeat = 150; <i class="conum" data-value="19"></i><b>(19)</b>

        // end::replication-heartbeat[]
        // tag::replication-maxretries[]
        config.maxretries = 20; <i class="conum" data-value="20"></i><b>(20)</b>

        // end::replication-maxretries[]
        // tag::replication-maxretrywaittime[]
        config.maxretrywaittime = 600; <i class="conum" data-value="21"></i><b>(21)</b>

        // end::replication-maxretrywaittime[]
        //  other config as required . . .
        repl = [[CBLReplicator alloc] initWithConfig: config];

        // Cleanup:
        repl = nil;

        // end::replication-retry-config[]

    }


#ifdef COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseReplica {
    CBLDatabase *database = self.db;
    CBLDatabase *database2 = self.db;

    /* EE feature: code below might throw a compilation error
     if it's compiled against CBL Swift Community. */
    // tag::database-replica[]
    CBLDatabaseEndpoint *targetDatabase = [[CBLDatabaseEndpoint alloc] initWithDatabase:database2];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetDatabase];
    config.replicatorType = kCBLReplicatorTypePush;

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::database-replica[]
}
#endif

- (void) dontTestCertificatePinning {
    CBLDatabase *database = self.db;
    // Active - Example 4
    // tag::certificate-pinning[]
    // tag=p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                                                                       target:target];
    config.pinnedServerCertificate = (SecCertificateRef)CFAutorelease(certificate);

    // end=p2p-act-rep-config-cacert-pinned[]
    // end::certificate-pinning[]

    NSLog(@"%@", config);
}

- (NSData*) dataFromResource: (NSString*)file ofType: (NSString*)type {
    return [NSData data];
}

- (void) dontTestGettingStarted {
    CBLReplicator *_replicator;
    // tag::getting-started[]
    // Get the database (and create it if it doesnt exist).
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // Create a new document (i.e. a record) in the database.
    CBLMutableDocument *mutableDoc = [[CBLMutableDocument alloc] init];
    [mutableDoc setFloat:2.0 forKey:@"version"];
    [mutableDoc setString:@"SDK" forKey:@"type"];

    // Save it to the database.
    [database saveDocument:mutableDoc error:&amp;error];

    // Update a document.
    CBLMutableDocument *mutableDoc2 = [[database documentWithID:mutableDoc.id] toMutable];
    [mutableDoc2 setString:@"Swift" forKey:@"language"];
    [database saveDocument:mutableDoc2 error:&amp;error];

    CBLDocument *document = [database documentWithID:mutableDoc2.id];
    // Log the document ID (generated by the database)
    // and properties
    NSLog(@"Document ID :: %@", document.id);
    NSLog(@"Learning %@", [document stringForKey:@"language"]);

    // Create a query to fetch documents of type SDK.
    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"SDK"]];
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                          from:[CBLQueryDataSource database:database]
                                         where:type];

    // Run the query
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);

    // Create replicators to push and pull changes to and from the cloud.
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *targetEndpoint = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *replConfig = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetEndpoint];
    replConfig.replicatorType = kCBLReplicatorTypePushAndPull;

    // Add authentication.
    replConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    // Create replicator (make sure to add an instance or static variable named _replicator)
    _replicator = [[CBLReplicator alloc] initWithConfig:replConfig];

    // Listen to replicator change events.
    [_replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];

    // Start replication
    [_replicator start];
    // end::getting-started[]
}

- (void) dontTestPredictiveModel {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::register-model[]
    ImageClassifierModel* model = [[ImageClassifierModel alloc] init];
    [[CBLDatabase prediction] registerModel:model withName:@"ImageClassifier"];
    // end::register-model[]

    // tag::predictive-query-value-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input];

    CBLValueIndex* index = [CBLIndexBuilder valueIndexWithItems:@[[CBLValueIndexItem expression:[prediction property:@"label"]]]];
    [database createIndex:index withName:@"value-index-image-classifier" error:&amp;error];
    // end::predictive-query-value-index[]

    // tag::unregister-model[]
    [[CBLDatabase prediction] unregisterModelWithName:@"ImageClassifier"];
    // end::unregister-model[]
}

- (void) dontTestPredictiveIndex {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query-predictive-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary:@{@"photo":[CBLQueryExpression property:@"photo"]}];

    CBLPredictiveIndex* index = [CBLIndexBuilder predictiveIndexWithModel:@"ImageClassifier" input:input properties:nil];
    [database createIndex:index withName:@"predictive-index-image-classifier" error:&amp;error];
    // end::predictive-query-predictive-index[]
}

- (void) dontTestPredictiveQuery {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input]; <i class="conum" data-value="1"></i><b>(1)</b>

    CBLQueryExpression* condition = [[[prediction property:@"label"] equalTo:[CBLQueryExpression string:@"car"]]
                                     andExpression:[[prediction property:@"probablity"] greaterThanOrEqualTo:[CBLQueryExpression double:0.8]]];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult all]]
                                         from: [CBLQueryDataSource database:database]
                                        where: condition];

    // Run the query.
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);
    // end::predictive-query[]
}

- (void) dontTestCoreMLPredictiveModel {
    NSError *error;

    // tag::coreml-predictive-model[]
    // Load MLModel from `ImageClassifier.mlmodel`
    NSURL* modelURL = [[NSBundle mainBundle] URLForResource:@"ImageClassifier" withExtension:@"mlmodel"];
    NSURL* compiledModelURL = [MLModel compileModelAtURL:modelURL error:&amp;error];
    MLModel* model = [MLModel modelWithContentsOfURL:compiledModelURL error:&amp;error];
    CBLCoreMLPredictiveModel* predictiveModel = [[CBLCoreMLPredictiveModel alloc] initWithMLModel:model];

    // Register model
    [[CBLDatabase prediction] registerModel:predictiveModel withName:@"ImageClassifier"];
    // end::coreml-predictive-model[]
}

- (void) dontTestReplicatorConflictResolver {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::replication-conflict-resolver[]
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.conflictResolver = [[LocalWinConflictResolver alloc] init];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-conflict-resolver[]
}

- (void) dontTestSaveWithConflictHandler {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document-with-conflict-handler[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];

    [database saveDocument:mutableDocument
           conflictHandler:^BOOL(CBLMutableDocument *new, CBLDocument *current) {
               NSDictionary *currentDict = current.toDictionary;
               NSDictionary *newDict = new.toDictionary;

               NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:currentDict];
               [result addEntriesFromDictionary:newDict];
               [new setData: result];
               return YES;
           }
                     error: &amp;error];
    // end::update-document-with-conflict-handler[]
}

#pragma mark - URLListener

- (BOOL) isValidCredentials: (NSString*)u password: (NSString*)p { return YES; } // helper
- (void) dontTestInitListener {
    CBLDatabase *database = self.db;
    CBLURLEndpointListener* listener = nil;

    // tag::init-urllistener[]
    CBLURLEndpointListenerConfiguration* config;
    config = [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: database];
    config.tlsIdentity = nil; // Use with anonymous self signed cert
    config.authenticator =
        [[CBLListenerPasswordAuthenticator alloc]
            initWithBlock: ^BOOL(
                NSString * username,
                NSString * password)
                {
                if ([self isValidCredentials: username password:password]) {
                    return  YES;
                }
                return NO;
            }];

    listener = [[CBLURLEndpointListener alloc] initWithConfig: config];
    // end::init-urllistener[]
}

- (void) dontTestListenerStart {
    NSError* error = nil;
    CBLURLEndpointListener* listener = nil;

    // tag::start-urllistener[]
    BOOL success = [listener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }
    // end::start-urllistener[]
}

- (void) dontTestListenerStop {
    CBLURLEndpointListener* listener = nil;

    // tag::stop-urllistener[]
    [listener stop];
    // end::stop-urllistener[]
}

- (void) dontTestCreateSelfSignedCert {
    NSError* error = nil;
    CBLTLSIdentity* identity = nil;
    // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
    // Example-6
    // tag::create-self-signed-cert[]
    // tag::listener-config-tls-id-SelfSigned[]

    NSDictionary* attrs = @{ kCBLCertAttrCommonName: @"Couchbase Inc" };
    identity =
      [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
        label: @"Server-Cert-Label"
        error: &amp;error];
    // end::listener-config-tls-id-SelfSigned[]
    // end::create-self-signed-cert[]
}

- (void) dontTestListenerCertificateAuthenticatorRootCert {
    CBLURLEndpointListenerConfiguration* config;

    // Example 8-tab1
    // tag::listener-certificate-authenticator-root-urllistener[]
    // tag::listener-config-client-auth-root[]

    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef rootCertRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    config.authenticator = [[CBLListenerCertificateAuthenticator alloc]
                            initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];
    // end::listener-config-client-auth-root[]
    // end::listener-certificate-authenticator-root-urllistener[]
}

- (void) dontTestListenerCertificateAuthenticatorCallback {
    CBLURLEndpointListenerConfiguration* config;
    // Example 8-tab2
    // tag::listener-certificate-authenticator-callback-urllistener[]
    // tag::listener-config-client-auth-lambda[]

    CBLListenerCertificateAuthenticator* listenerAuth =
    [[CBLListenerCertificateAuthenticator alloc] initWithBlock: ^BOOL(NSArray *certs) {
        SecCertificateRef cert = (__bridge SecCertificateRef)(certs[0]);
        CFStringRef cnRef;
        OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
        if (status == errSecSuccess) {
            NSString* cn = (NSString*)CFBridgingRelease(cnRef);
            if ([self._allowlistedUsers containsObject: cn])
                return YES;
        }
        return NO;
    }];

    config.authenticator = listenerAuth;
    // end::listener-config-client-auth-lambda[]
    // end::listener-certificate-authenticator-callback-urllistener[]
}

@end

#pragma mark -

// Singleton Pattern
// &lt;doc&gt;
@interface DataManager : NSObject

@property (nonatomic, readonly) CBLDatabase *database;

+ (id)sharedInstance;

@end

@implementation DataManager

@synthesize database=_database;

+ (id)sharedInstance {
    static DataManager *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}

- (id)init {
    if (self = [super init]) {
        NSError *error;
        _database = [[CBLDatabase alloc] initWithName:@"dbname" error:&amp;error];
        if (!_database) {
            NSLog(@"Cannot open the database: %@", error);
            return nil;
        }
    }
    return self;
}

@end
// &lt;doc&gt;

// Peer-to-Peer Sample

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface ActivePeer: NSObject &lt;CBLMessageEndpointDelegate&gt;

@end

@interface ActivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation ActivePeer

- (instancetype) init {
    self = [super init];
    if (self) {
        // tag::message-endpoint[]
        CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"dbname" error: &amp;error];

        // The delegate must implement the `CBLMessageEndpointDelegate` protocol.
        NSString* id = @"";
        CBLMessageEndpoint *endpoint =
        [[CBLMessageEndpoint alloc] initWithUID:@"UID:123"
                                         target:id
                                   protocolType:kCBLProtocolTypeMessageStream
                                       delegate:self];
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc] initWithDatabase:database target: endpoint];

        // Create the replicator object.
        CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig: config];
        [replicator start];
        // end::message-endpoint-replicator[]
    }
    return self;
}

// tag::create-connection[]
- (id&lt;CBLMessageEndpointConnection&gt;)createConnectionForEndpoint:(CBLMessageEndpoint *)endpoint {
    return [[ActivePeerConnection alloc] init];
}
// end::create-connection[]

@end


@implementation ActivePeerConnection {
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)disconnect {
    // tag::active-replicator-close[]
    [_replicatorConnection close:nil];
    // end::active-replicator-close[]
}

// tag::active-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::active-peer-open[]

// tag::active-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::active-peer-send[]

- (void)receive:(NSData*)data {
    // tag::active-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::active-peer-receive[]
}

// tag::active-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::active-peer-close[]

@end

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface PassivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)startListener;
- (void)stopListener;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation PassivePeerConnection {
    CBLMessageEndpointListener *_messageEndpointListener;
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)startListener {
    // tag::listener[]
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error: &amp;error];

    CBLMessageEndpointListenerConfiguration *config =
    [[CBLMessageEndpointListenerConfiguration alloc] initWithDatabase:database
                                                         protocolType:kCBLProtocolTypeMessageStream];
    _messageEndpointListener = [[CBLMessageEndpointListener alloc] initWithConfig:config];
    // end::listener[]
}

- (void)stopListener {
    // tag::passive-stop-listener[]
    [_messageEndpointListener closeAll];
    // end::passive-stop-listener[]
}

- (void)acceptConnection {
    // tag::advertizer-accept[]
    PassivePeerConnection *connection = [[PassivePeerConnection alloc] init]; /* implements CBLMessageEndpointConnection */
    [_messageEndpointListener accept: connection];
    // end::advertizer-accept[]
}

- (void)disconnect {
    // tag::passive-replicator-close[]
    [_replicatorConnection close:nil];
    // end::passive-replicator-close[]
}

// tag::passive-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::passive-peer-open[]

// tag::passive-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::passive-peer-send[]

- (void)receive:(NSData*)data {
    // tag::passive-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::passive-peer-receive[]
}

// tag::passive-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::passive-peer-close[]
@end



// QUERY RESULT SET HANDLING EXAMPLES
- (void) dontTestQuerySyntaxJson {
    // tag::query-syntax-all[]
    NSError *error;

    CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

    CBLQuery *listQuery = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                             from:[CBLQueryDataSource database:db]]; <i class="conum" data-value="22"></i><b>(22)</b>

    // end::query-syntax-all[]


    // tag::query-access-all[]
        NSMutableArray* matches =
          [[NSMutableArray alloc] init];

        CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

        for (CBLQueryResult *result in resultset.allResults) { // access the resultSet.allResults

            NSDictionary *match = [result valueAtIndex: 0] ;
//             toDictionary];

            // Store dictionary in array
            [matches addObject: match];

            // Use dictionary values
            NSLog(@"id = %@", [match valueForKey:@"id"]);
            NSLog(@"name = %@", [match valueForKey:@"name"]);
            NSLog(@"type = %@", [match valueForKey:@"type"]);
            NSLog(@"city = %@", [match valueForKey:@"city"]);

        } // end for

    // end::query-access-all[]

    // tag::query-access-json[]
    NSMutableArray&lt;Hotel *&gt; *hotels = NSMutableArray.new;
    for (CBLQueryResult* result in [listQuery execute:&amp;error]) {

        // Get result as a JSON string

        NSString* thisJsonString =
                    [result toJSON]; <i class="conum" data-value="23"></i><b>(23)</b>

        // Get an native Obj-C object from the Json String
        NSDictionary *thisDictFromJSON =
                [NSJSONSerialization JSONObjectWithData:
                 [thisJsonString dataUsingEncoding: NSUTF8StringEncoding]
                       options: NSJSONReadingAllowFragments
                       error: &amp;error]; <i class="conum" data-value="24"></i><b>(24)</b>
        if (error) {
            NSLog(@"Error in serialization: %@",error);
            return;
        }


        // Populate a custom object from native dictionary
        Hotel *hotelFromJson = Hotel.new;

        hotelFromJson.id = thisDictFromJSON[@"id"];  <i class="conum" data-value="25"></i><b>(25)</b>
        hotelFromJson.name = thisDictFromJSON[@"name"];
        hotelFromJson.city = thisDictFromJSON[@"city"];
        hotelFromJson.country = thisDictFromJSON[@"country"];
        hotelFromJson.descriptive = thisDictFromJSON[@"description"];

        [hotels addObject:hotelFromJson];


        // Log generated Json and Native objects
        // For demo/example purposes
        NSLog(@"Json String %@", thisJsonString);
        NSLog(@"Native Object %@", thisDictFromJSON);
        NSLog(@"Custom Object: id: %@ name: %@ city: %@ country: %@ descriptive: %@", hotelFromJson.id, hotelFromJson.name, hotelFromJson.city, hotelFromJson.country, hotelFromJson.descriptive);

       }; // end for

    // end::query-access-json[]

} // end function




// tag::query-syntax-props[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

CBLQuerySelectResult *type = [CBLQuerySelectResult property:@"type"];

CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

CBLQuerySelectResult *city = [CBLQuerySelectResult property:@"city"];

*listQuery = [CBLQueryBuilder select:@[id, type, name, city]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="26"></i><b>(26)</b>

// end::query-syntax-props[]

// tag::query-access-props[]
    NSMutableArray* matches = [[NSMutableArray alloc] init]; // save to native array

    CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

    for (CBLQueryResult *result in resultset.allResults) { // all results

        [matches addObject: [result toDictionary]];

        NSLog(@"id = %@", [result stringForKey:@"id"]);
        NSLog(@"name = %@", [result stringForKey:@"name"]);
        NSLog(@"type = %@", [result stringForKey:@"type"]);
        NSLog(@"city = %@", [result stringForKey:@"city"]);

    } // end for

// end::query-access-props[]



// tag::query-syntax-count-only[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuerySelectResult *count =
  [CBLQuerySelectResult expression:[CBLQueryFunction count:   [CBLQueryExpression all]]];

*listQuery = [CBLQueryBuilder select:@[count]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="27"></i><b>(27)</b>

// end::query-syntax-count-only[]

// tag::query-access-count-only[]
CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisCount = [match intForKey:@"mycount"] <i class="conum" data-value="28"></i><b>(28)</b>

} // end for

// end::query-access-count-only[]


// tag::query-syntax-id[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

*listQuery = [CBLQueryBuilder select:@[id]
             from:[CBLQueryDataSource database:db]]

// end::query-syntax-id[]

// tag::query-access-id[]

CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisDocsId = [match stringForKey:@"id"] <i class="conum" data-value="29"></i><b>(29)</b>

  // Now you can get the document using its ID
  // for example using
  CBLMutableDocument* thisDoc =
    [thisDB documentWithID: thisDocsId]

} // end for

// end::query-access-id[]


// tag::query-syntax-pagination[]
int thisOffset = 0;
int thisLimit = 20;
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery* listQuery =
            [CBLQueryBuilder
                select: @[[CBLQuerySelectResult all]]
                from: [CBLQueryDataSource database: db]
                limit: [CBLQueryLimit
                            limit: [CBLQueryExpression integer: thisLimit]
                            offset: [CBLQueryExpression integer: thisOffset]]
            ];

// end::query-syntax-pagination[]



// PEER-to-PEER


// tag::listener-simple[]
CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database]; <i class="conum" data-value="30"></i><b>(30)</b>

thisConfig.authenticator =
  [[CBLListenerPasswordAuthenticator alloc]
    initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
      if ([self isValidCredentials: validUser password:validPassword]) {
          return  YES;
      }
      return NO;
  }]; <i class="conum" data-value="31"></i><b>(31)</b>

CBLURLEndpointListener* thisListener = nil;
thisListener =
  [[CBLURLEndpointListener alloc] initWithConfig: thisConfig]; <i class="conum" data-value="32"></i><b>(32)</b>

BOOL success = [thisListener startWithError: &amp;error];
if (!success) {
    NSLog(@"Cannot start the listener: %@", error);
} <i class="conum" data-value="33"></i><b>(33)</b>

// end::listener-simple[]

// tag::replicator-simple[]
NSURL *url =
  [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
CBLURLEndpoint *theListenerURL =
  [[CBLURLEndpoint alloc] initWithURL:url]; <i class="conum" data-value="34"></i><b>(34)</b>

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:theListenerURL]; <i class="conum" data-value="35"></i><b>(35)</b>

thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="36"></i><b>(36)</b>

thisConfig.authenticator =
  [[CBLBasicAuthenticator alloc]
    initWithUsername:@"valid.user"
      password:@"valid.password.string"]; <i class="conum" data-value="37"></i><b>(37)</b>


CBLReplicator *_thisReplicator;
_thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="38"></i><b>(38)</b>

[_thisReplicator start]; <i class="conum" data-value="39"></i><b>(39)</b>

// end::replicator-simple[]




//
// Stuff I adapted
//


import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class cMyPassListener {
  // tag::listener-initialize[]
  // tag::listener-config-db[]
  // Initialize the listener config <i class="conum" data-value="40"></i><b>(40)</b>
  CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database];

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.port =  55990; <i class="conum" data-value="41"></i><b>(41)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    NSString *thisURL = @"10.1.1.10";
    thisConfig.networkInterface = thisURL; <i class="conum" data-value="42"></i><b>(42)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.enableDeltaSync = true; <i class="conum" data-value="43"></i><b>(43)</b>

    // end::listener-config-delta-sync[]
    // Configure server security
    // tag::listener-config-tls-enable[]
    thisConfig.disableTLS  = false; <i class="conum" data-value="44"></i><b>(44)</b>

    // end::listener-config-tls-enable[]

    // tag::listener-config-tls-id-anon[]
    // Use an anonymous self-signed cert
    thisConfig.tlsIdentity = nil; <i class="conum" data-value="45"></i><b>(45)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure Client Security using an Authenticator
    // For example, Basic Authentication <i class="conum" data-value="46"></i><b>(46)</b>
    thisConfig.authenticator =
      [[CBLListenerPasswordAuthenticator alloc]
        initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
          if ([self isValidCredentials: validUser password:validPassword]) {
              return  YES;
          }
          return NO;
      }];

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // tag::listener-init[]
    // Initialize the listener <i class="conum" data-value="47"></i><b>(47)</b>
    CBLURLEndpointListener* thisListener = nil;
    thisListener =
      [[CBLURLEndpointListener alloc] initWithConfig: thisConfig];

    // end::listener-init[]
    // start the listener <i class="conum" data-value="48"></i><b>(48)</b>
    BOOL success = [thisListener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }

    // end::listener-start[]
// end::listener-initialize[]
  } // end of class

// tag::listener-stop[]
    [thisListener stop];

// end::listener-stop[]

  }
}


// Additional Snippets

// tag::listener-get-network-interfaces[]
// . . .  code snippet to be provided

// end::listener-get-network-interfaces[]

// tag::listener-get-url-list[]
NSError* error = nil;
CBLURLEndpointListenerConfiguration* config =
  [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: self.otherDB];
CBLURLEndpointListener* listener =
  [[CBLURLEndpointListener alloc] initWithConfig: config];

[listener startWithError: &amp;error];

NSLog(@"%@", listener.urls);

// end::listener-get-url-list[]

// tag::listener-local-db[]
// . . . preceding application logic . . .
fileprivate  var _allowlistedCommonNames:[[String:String]] = []
fileprivate var _thisListener:URLEndpointListener?
fileprivate var thisDB:Database?
// Include websockets listener initializer code
// func fMyPassListener() {
CBLDatabase *thisDB = self.db;
// end::listener-local-db[]

// tag::listener-config-tls-full[]
  // Configure server authentication
  // tag::listener-config-tls-disable[]
  thisConfig.disableTLS  = true; <i class="conum" data-value="49"></i><b>(49)</b>

  // end::listener-config-tls-disable[]

  // EXAMPLE 6
  // tag::listener-config-tls-id-full[]
  // tag::listener-config-tls-id-caCert[]
  // Use CA Cert
  // Create a TLSIdentity from a key-pair and
  // certificate in secure storage
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="50"></i><b>(50)</b>

    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    CBLTLSIdentity* thisIdentity =
      [CBLTLSIdentity importIdentityWithData: data
        password: @"123"
        label: @"couchbase-docs-cert"
        error: &amp;error]; <i class="conum" data-value="51"></i><b>(51)</b>

    config.tlsIdentity = thisIdentity; <i class="conum" data-value="52"></i><b>(52)</b>

  // end::listener-config-tls-id-caCert[]
  // tag::listener-config-tls-id-SelfSigned[]
  // Use a self-signed certificate
  NSDictionary* attrs =
    @{ kCBLCertAttrCommonName: @"Couchbase Inc" }; <i class="conum" data-value="53"></i><b>(53)</b>

  thisIdentity =
    [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
              label: @" couchbase-docs-cert"
              error: &amp;error]; <i class="conum" data-value="54"></i><b>(54)</b>

  // end::listener-config-tls-id-SelfSigned[]
      // tag::listener-config-tls-id-set[]
  // set the TLS Identity
  thisConfig.tlsIdentity = thisIdentity; <i class="conum" data-value="55"></i><b>(55)</b>

  // end::listener-config-tls-id-set[]
  // end::listener-config-tls-id-full[]
// end::listener-config-tls-full[]

// EXAMPLE 8
// tag::listener-config-client-auth-root[]
// Configure the client authenticator
NSURL *certURL =
  [[NSBundle mainBundle]
    URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="56"></i><b>(56)</b>
NSData *data =
  [[NSData alloc]
    initWithContentsOfURL: certURL];
SecCertificateRef rootCertRef =
  SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

thisConfig.authenticator =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];  <i class="conum" data-value="57"></i><b>(57)</b> <i class="conum" data-value="58"></i><b>(58)</b>

// end::listener-config-client-auth-root[]
// tag::listener-config-client-auth-lambda[]
// Authenticate self-signed cert
// using application logic
CBLListenerCertificateAuthenticator* thisListenerAuth =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithBlock: ^BOOL(NSArray *certs) {
      SecCertificateRef cert =
        (__bridge SecCertificateRef)(certs[0]); <i class="conum" data-value="59"></i><b>(59)</b>
      CFStringRef cnRef;
      OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
      if (status == errSecSuccess) {
          NSString* cn = (NSString*)CFBridgingRelease(cnRef);
          if ([self._allowlistedCommonNames containsObject: cn])
              return YES;
      }
      return NO;
  }];  <i class="conum" data-value="60"></i><b>(60)</b>

thisConfig.authenticator = thisListenerAuth; <i class="conum" data-value="61"></i><b>(61)</b>

// end::listener-config-client-auth-lambda[]







// tag::xlistener-config-tls-disable[]
thisConfig.disableTLS  = true

// end::xlistener-config-tls-disable[]

// tag::listener-config-tls-id-nil[]
thisConfig.tlsIdentity = nil

// end::listener-config-tls-id-nil[]


// tag::old-listener-config-delta-sync[]
thisConfig.enableDeltaSync = true

// end::old-listener-config-delta-sync[]


// tag::listener-status-check[]
NSUInteger totalConnections = thisListener.status.connectionCount;
NSUInteger activeConnections = thisListener.status.activeConnectionCount;

// end::listener-status-check[]


// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  let rootCertData = SecCertificateCopyData(cert) as Data
  let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
  // Listener:
  thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

// end::old-listener-config-client-auth-root[]
/

// tag::listener-config-client-auth-self-signed[]
thisConfig.authenticator = ListenerCertificateAuthenticator.init {
  (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedCommonNames.contains(["name": certCommonName! as String])) {
        return true
    }
    return false
}

// end::listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}

// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
thisConfig.port = tls ? wssPort : wsPort
thisConfig.disableTLS = !tls
thisConfig.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>

// end::p2p-ws-api-urlendpointlistener-constructor[]


// Active Peer Connection Snippets

//
//  my Other Bits.swift
//  doco-sync
//
//  Created by Ian Bridge on 19/06/2020.
//  Copyright  2020 Couchbase Inc. All rights reserved.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class myActPeerClass {

  func fMyActPeer() {
    // let validUser = "syncthisUser"
    // let validPassword = "sync9455"
    // let cert:SecCertificate?
    // let passivePeerEndpoint = "10.1.1.12:8920"
    // let passivePeerPort = "8920"
    // let passiveDbName = "userdb"
    // var actDb:Database?
    // var thisReplicator:Replicator?
    // var replicatorListener:ListenerToken?

    CBLReplicator *_thisReplicator;

    CBLListenerToken *_thisListenerToken;

    CBLDatabase *database
      = [[CBLDatabase alloc] initWithName:@"thisDB" error:&amp;error];
        if (!database) {
          NSLog(@"Cannot open the database: %@", error);
        };

    // tag::p2p-act-rep-func[]
    // tag::p2p-act-rep-initialize[]
    // Set listener DB endpoint
    NSURL *url = [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
    CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

    CBLReplicatorConfiguration *thisConfig
      = [[CBLReplicatorConfiguration alloc]
          initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="62"></i><b>(62)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config[]
    // tag::p2p-act-rep-config-type[]
    thisConfig.replicatorType = kCBLReplicatorTypePush;

    // end::p2p-act-rep-config-type[]
    // tag::autopurge-override[]
    // set auto-purge behavior (here we override default)
    thisConfig.enableAutoPurge = NO; <i class="conum" data-value="63"></i><b>(63)</b>

    // end::autopurge-override[]
    // tag::p2p-act-rep-config-cont[]
    thisConfig.continuous = YES;

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Authentication
    // Here - expect and accept self-signed certs
    thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="64"></i><b>(64)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Authentication
    // tag::p2p-act-rep-auth[]
    // Here set client to use basic authentication
    // Providing username and password credentials
    // If prompted for them by server
    thisConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"Our Username" password:@"Our Password"]; <i class="conum" data-value="65"></i><b>(65)</b>

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    thisConfig.conflictResolver = [[LocalWinConflictResolver alloc] <i class="conum" data-value="66"></i><b>(66)</b>

    // end::p2p-act-rep-config-conflict[]    //
    // end::p2p-act-rep-config[]
    // tag::p2p-act-rep-start-full[]
    // Apply configuration settings to the replicator
    _thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="67"></i><b>(67)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    // Optionally add a change listener <i class="conum" data-value="68"></i><b>(68)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    // Retain token for use in deletion
    id&lt;CBLListenerToken&gt; thisListenerToken
      = [thisReplicator addChangeListener:^(CBLReplicatorChange *thisChange) {
    // tag::p2p-act-rep-status[]
          if (thisChange.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
            } else {
            NSLog(@"Status: %d", thisChange.status.activity);
            };
    // end::p2p-act-rep-status[]
        }];
// end::p2p-act-rep-add-change-listener[]
// tag::p2p-act-rep-start[]
    // Run the replicator using the config settings
    [thisReplicator start]; <i class="conum" data-value="69"></i><b>(69)</b>

// end::p2p-act-rep-start[]
// end::p2p-act-rep-start-full[]
// end::p2p-act-rep-func[]
    }

    func mystopfunc() {
// tag::p2p-act-rep-stop[]
    // Remove the change listener
    [thisReplicator removeChangeListenerWithToken: thisListenerToken];

    // Stop the replicator
    [thisReplicator stop];
// end::p2p-act-rep-stop[]
}

// Additional Snippets from above
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA Certs
    thisConfig.acceptOnlySelfSignedServerCertificate = NO; <i class="conum" data-value="70"></i><b>(70)</b>

    // end::p2p-act-rep-config-cacert[]


    // tag::p2p-act-rep-config-pinnedcert[]
    // Return the remote pinned cert (the listener's cert)
    thisConfig.pinnedServerCertificate = thisCert; // Get listener cert if pinned

    // end::p2p-act-rep-config-pinnedcert[]







// tag::p2p-tlsid-manage-func[]
//
//  cMyGetCert.swift
//  doco-sync
//
//  Created by Ian Bridge on 20/06/2020.
//  Copyright  2020 Couchbase Inc. All rights reserved.
//

import Foundation
import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity


class cMyGetCert1{

    let kListenerCertLabel = "doco-sync-server"
    let kListenerCertKeyP12File = "listener-cert-pkey"
    let kListenerPinnedCertFile = "listener-pinned-cert"
    let kListenerCertKeyExportPassword = "couchbase"
    //var importedItems : NSArray
    let thisData : CFData?
    var items : CFArray?

    func fMyGetCert() -&gt;TLSIdentity? {
        var kcStatus = errSecSuccess // Zero
        let thisLabel : String? = "doco-sync-server"

        //var thisData : CFData?
        // tag::p2p-tlsid-tlsidentity-with-label[]
        // tag::p2p-tlsid-check-keychain[]
        // Check if Id exists in keychain and if so, use it
        CBLTLSIdentity* identity =
          [CBLTLSIdentity identityWithLabel: @"doco-sync-server" error: &amp;error]; <i class="conum" data-value="71"></i><b>(71)</b>

        // end::p2p-tlsid-check-keychain[]
        thisConfig.authenticator =
          [[CBLClientCertificateAuthenticator alloc] initWithIdentity: identity]; <i class="conum" data-value="72"></i><b>(72)</b>

        // end::p2p-tlsid-tlsidentity-with-label[]


// tag::p2p-tlsid-check-bundled[]
// CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let pathToCert = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
                let thisData = NSData(contentsOfFile: pathToCert)
            else
                {return nil}
// end::p2p-tlsid-check-bundled[]

// tag::p2p-tlsid-import-from-bundled[]
        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        kcStatus = SecPKCS12Import(thisData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;items)
            if kcStatus != errSecSuccess {
             print("failed to import data from provided with error :\(kcStatus) ")
             return nil
            }
        let importedItems = items! as NSArray
        let thisItem = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let thisSecId = thisItem[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var thisPrivateKey : SecKey?
        kcStatus = SecIdentityCopyPrivateKey(thisSecId, &amp;thisPrivateKey)
            if kcStatus != errSecSuccess {
                print("failed to import private key from provided with error :\(kcStatus) ")
                return nil
            }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let thisCertChain = thisItem[String(kSecImportItemCertChain)] as? [SecCertificate]

        // Return nil Id if errors in key or cert chain at this stage
        guard let pKey = thisPrivateKey, let pubCerts = thisCertChain else {
            return nil
        }
// end::p2p-tlsid-import-from-bundled[]

// tag::p2p-tlsid-store-in-keychain[]
// STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN

        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       pKey
        ]
        kcStatus = SecItemAdd(params as CFDictionary, nil)
            if kcStatus != errSecSuccess {
                print("Unable to store private key")
                return nil
            }
       // Store all Certs for Id in Keychain:
       var i = 0;
       for cert in thisCertChain! {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
                ]
            kcStatus = SecItemAdd(params as CFDictionary, nil)
                if kcStatus != errSecSuccess {
                    print("Unable to store certs")
                    return nil
                }
            i=i+1
        }
// end::p2p-tlsid-store-in-keychain[]

// tag::p2p-tlsid-return-id-from-keychain[]
// RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
do {
    return try TLSIdentity.identity(withIdentity: thisSecId, certs: [pubCerts[0]])
} catch {
    print("Error while loading self signed cert : \(error)")
    return nil
}
// end::p2p-tlsid-return-id-from-keychain[]
    } // fMyGetCert
} // cMyGetCert


// tag::p2p-tlsid-delete-id-from-keychain[]

[CBLTLSIdentity deleteIdentityWithLabel:thisSecId error: &amp;error];

// end::p2p-tlsid-delete-id-from-keychain[]



// end::p2p-tlsid-manage-func[]



// tag::p2p-act-rep-config-cacert-pinned-func[]
func fMyCaCertPinned() {
  // do {
  let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
  let targetEndpoint = URLEndpoint(url: tgtUrl)
  let actDb:Database?
  let config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint)
  // tag::p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate =
      SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url =
      [NSURL URLWithString:@"ws://localhost:4984/db"];

    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *thisConfig =
      [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                          target:target];
    thisConfig.pinnedServerCertificate =
      (SecCertificateRef)CFAutorelease(certificate);

    thisConfig.acceptOnlySelfSignedServerCertificate=false;

  // end::p2p-act-rep-config-cacert-pinned[]
  // end::p2p-act-rep-config-cacert-pinned-func[]
}



// For replications

// BEGIN -- snippets --
//    Purpose -- code samples for use in replication topic

// tag::sgw-repl-pull[]
@interface MyClass : NSObject
@property (nonatomic) CBLDatabase *database;
@property (nonatomic) CBLReplicator *replicator; <i class="conum" data-value="1"></i><b>(1)</b>
@end

@implementation MyClass
@synthesize database=_database;
@synthesize replicator=_replicator;

- (void) startReplication {
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"]; <i class="conum" data-value="2"></i><b>(2)</b>
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:_database
                                                                                       target:target];
    config.replicatorType = kCBLReplicatorTypePull;
    _replicator = [[CBLReplicator alloc] initWithConfig:config];
    [_replicator start];
}
@end

// end::sgw-repl-pull[]

// tag::sgw-repl-pull-callouts[]
&lt;1&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;2&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
You should now use `ws:`, or `wss:` for SSL/TLS connections.


// end::sgw-repl-pull-callouts[]

// tag::sgw-act-rep-initialize[]
// Set listener DB endpoint
NSURL *url = [NSURL URLWithString:@"ws://10.0.2.2.com:55990/travel-sample"];
CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="73"></i><b>(73)</b>

// end::sgw-act-rep-initialize[]
// END -- snippets --</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Import from an existing resource bundle</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">//
//  SampleCodeTest.m
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#import &lt;UIKit/UIKit.h&gt;
#import &lt;CouchbaseLite/CouchbaseLite.h&gt;
#import &lt;CoreML/CoreML.h&gt;

// tag::predictive-model[]
// `myMLModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
@interface myMLModel : NSObject

+ (NSDictionary*)predictImage: (NSData*)data;

@end

@interface ImageClassifierModel : NSObject &lt;CBLPredictiveModel&gt;

- (nullable CBLDictionary*) predict: (CBLDictionary*)input;

@end

@implementation ImageClassifierModel

- (nullable CBLDictionary*) predict: (CBLDictionary*)input; {
    CBLBlob* blob = [input blobForKey:@"photo"];

    NSData* imageData = blob.content;
    // `myMLModel` is a fake implementation
    // this would be the implementation of the ml model you have chosen
    NSDictionary* modelOutput = [myMLModel predictImage:imageData];

    CBLMutableDictionary* output = [[CBLMutableDictionary alloc] initWithData: modelOutput];
    return output; <i class="conum" data-value="1"></i><b>(1)</b>
}

@end
// end::predictive-model[]

// to avoid link error
@implementation myMLModel
+ (NSDictionary*)predictImage: (NSData*)data { return [NSDictionary dictionary]; }
@end

// tag::custom-logging[]
@interface LogTestLogger : NSObject&lt;CBLLogger&gt;

// set the log level
@property (nonatomic) CBLLogLevel level;

@end

@implementation LogTestLogger

@synthesize level=_level;

- (void) logWithLevel: (CBLLogLevel)level domain: (CBLLogDomain)domain message: (NSString*)message {
    // handle the message, for example piping it to
    // a third party framework
}

@end

// end::custom-logging[]

// tag::local-win-conflict-resolver[]
@interface LocalWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation LocalWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.localDocument;
}

@end
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
@interface RemoteWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation RemoteWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.remoteDocument;
}

@end
// end::remote-win-conflict-resolver[]


// tag::merge-conflict-resolver[]
@interface MergeConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation MergeConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    NSDictionary *localDict = conflict.localDocument.toDictionary;
    NSDictionary *remoteDict = conflict.remoteDocument.toDictionary;

    NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:localDict];
    [result addEntriesFromDictionary:remoteDict];

    return [[CBLMutableDocument alloc] initWithID:conflict.documentID
                                             data:result];
}

@end
// end::merge-conflict-resolver[]

@interface SampleCodeTest : NSObject
@property(nonatomic) CBLDatabase* db;
@property(nonatomic) NSArray* _allowlistedUsers;
@end

@implementation SampleCodeTest

#pragma mark - Database

- (void) dontTestNewDatabase {
    // tag::new-database[]
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::new-database[]

    // tag::close-database[]
    tbd

    // end::close-database[]


}

#if COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseEncryption {
    // tag::database-encryption[]
    CBLDatabaseConfiguration *config = [[CBLDatabaseConfiguration alloc] init];
    config.encryptionKey = [[CBLEncryptionKey alloc] initWithPassword:@"secretpassword"];

    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" config:config error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::database-encryption[]
}
#endif

- (void) dontTestLogging {
    // tag::logging[]
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainReplicator];
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainQuery];
    // end::logging[]
}

- (void) dontTestEnableConsoleLogging {
    // tag::console-logging[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll; <i class="conum" data-value="1"></i><b>(1)</b>
    CBLDatabase.log.console.level = kCBLLogLevelVerbose; <i class="conum" data-value="2"></i><b>(2)</b>

    // end::console-logging[]

    // tag::console-logging-db[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll;

    // end::console-logging-db[]
}

- (void) dontTestFileLogging {
    // tag::file-logging[]
    NSString* tempFolder = [NSTemporaryDirectory() stringByAppendingPathComponent:@"cbllog"];
    CBLLogFileConfiguration* config = [[CBLLogFileConfiguration alloc] initWithDirectory:tempFolder]; <i class="conum" data-value="3"></i><b>(3)</b>
    config.maxRotateCount = 2; <i class="conum" data-value="4"></i><b>(4)</b>
    config.maxSize = 1024; <i class="conum" data-value="5"></i><b>(5)</b>
    config.usePlainText = YES; <i class="conum" data-value="6"></i><b>(6)</b>
    [CBLDatabase.log.file setConfig:config];
    [CBLDatabase.log.file setLevel: kCBLLogLevelInfo]; <i class="conum" data-value="7"></i><b>(7)</b>
    // end::file-logging[]
}

- (void) dontTestEnableCustomLogging {
    // tag::set-custom-logging[]
    [CBLDatabase.log setCustom:[[LogTestLogger alloc] initWithLogLevel: kCBLLogLevelWarning]];

    // end::set-custom-logging[]
}

- (void) dontTestLoadingPrebuilt {
    // tag::prebuilt-database[]
    // Note: Getting the path to a database is platform-specific.
    // For iOS you need to get the path from the main bundle.
    if (![CBLDatabase databaseExists:@"travel-sample" inDirectory:nil]) {
        NSError*error;
        NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@"travel-sample" ofType:@"cblite2"];
        if (![CBLDatabase copyFromPath:path toDatabase:@"travel-sample" withConfig:nil error:&amp;error]) {
            [NSException raise:NSInternalInconsistencyException
                        format:@"Could not load pre-built database: %@", error];
        }
    }
    // end::prebuilt-database[]
}

#pragma mark - Document

- (void) dontTestInitializer {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::initializer[]
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];
    [newTask setString:@"task" forKey:@"task"];
    [newTask setString:@"todo" forKey:@"owner"];
    [newTask setString:@"task" forKey:@"createdAt"];
    [database saveDocument:newTask error:&amp;error];
    // end::initializer[]
}

- (void) dontTestMutability {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];
    [database saveDocument:mutableDocument error:&amp;error];
    // end::update-document[]
}

- (void) dontTestTypedAcessors {
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];

    // tag::date-getter[]
    [newTask setValue:[NSDate date] forKey:@"createdAt"];
    NSDate *date = [newTask dateForKey:@"createdAt"];
    // end::date-getter[]

    NSLog(@"Date: %@", date);
}

- (void) dontTestBatchOperations {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::batch[]
    [database inBatch:&amp;error usingBlock:^{
        for (int i = 0; i &lt; 10; i++) {
            CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
            [doc setValue:@"user" forKey:@"type"];
            [doc setValue:[NSString stringWithFormat:@"user %d", i] forKey:@"name"];
            [doc setBoolean:NO forKey:@"admin"];
            [database saveDocument:doc error: &amp;error];
        }
    }];
    // end::batch[]
}

- (void) dontTestChangeListener {
    __weak CBLDatabase *database = self.db;

    // tag::document-listener[]
    [database addDocumentChangeListenerWithID: @"user.john" listener:^(CBLDocumentChange * change) {
        CBLDocument* document = [database documentWithID: change.documentID];
        NSLog(@"Status :: %@)", [document stringForKey: @"verified_account"]);
    }];
    // end::document-listener[]
}

- (void) dontTestDocumentExpiration {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::document-expiration[]
    // Purge the document one day from now
    NSDate* ttl = [[NSCalendar currentCalendar] dateByAddingUnit: NSCalendarUnitDay
                                                           value: 1
                                                          toDate: [NSDate date]
                                                         options: 0];
    [database setDocumentExpirationWithID:@"doc123" expiration:ttl error:&amp;error];

    // Reset expiration
    [database setDocumentExpirationWithID:@"doc1" expiration:nil error: &amp;error];

    // Query documents that will be expired in less than five minutes
    NSTimeInterval fiveMinutesFromNow = [[NSDate dateWithTimeIntervalSinceNow:60 * 5] timeIntervalSince1970];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression: [CBLQueryMeta id]]]
                                         from: [CBLQueryDataSource database: database]
                                        where: [[CBLQueryMeta expiration]
                                                lessThan: [CBLQueryExpression double: fiveMinutesFromNow]]];
    // end::document-expiration[]
    NSLog(@"%@", query);
}

- (void) dontTestBlob {
#if TARGET_OS_IPHONE
    NSError *error;
    CBLDatabase *database = self.db;
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::blob[]
    UIImage *appleImage = [UIImage imageNamed:@"avatar.jpg"];
    NSData *imageData = UIImageJPEGRepresentation(appleImage, 1.0);

    CBLBlob *blob = [[CBLBlob alloc] initWithContentType:@"image/jpeg" data:imageData];
    [newTask setBlob:blob forKey:@"avatar"];
    [database saveDocument:newTask error:&amp;error];

    CBLDocument *savedTask = [database documentWithID: @"task1"];
    CBLBlob *taskBlob = [savedTask blobForKey:@"avatar"];
    UIImage *taskImage = [UIImage imageWithData:taskBlob.content];
    // end::blob[]

    NSLog(@"%@", taskImage);
#endif
}

- (void) dontTest1xAttachment {
    CBLMutableDocument *document = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::1x-attachment[]
    CBLDictionary *attachments = [document dictionaryForKey:@"_attachments"];
    CBLBlob *avatar = [attachments blobForKey:@"avatar"];
    NSData *content = [avatar content];
    // end::1x-attachment[]

    NSLog(@"%@", content);
}

#pragma mark - Query

- (void) dontTestIndexing {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-index[]
    CBLValueIndexItem *type = [CBLValueIndexItem property:@"type"];
    CBLValueIndexItem *name = [CBLValueIndexItem property:@"name"];
    CBLIndex* index = [CBLIndexBuilder valueIndexWithItems:@[type, name]];
    [database createIndex:index withName:@"TypeNameIndex" error:&amp;error];
    // end::query-index[]
}

- (void) dontTestSelect {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-select-meta[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuery *query = [CBLQueryBuilder select:@[name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression value:@"user"]] andExpression:
                                               [[CBLQueryExpression property:@"admin"] equalTo:[CBLQueryExpression boolean:NO]]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"user name :: %@", [result stringAtIndex:0]);
    }
    // end::query-select-meta[]
}

- (void) dontTestSelectAll {
    CBLDatabase *database = self.db;

    // tag::query-select-all[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];
    // end::query-select-all[]

    NSLog(@"%@", query);
}

- (void) dontTestLiveQuery {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::live-query[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];

    // Adds a query change listener.
    // Changes will be posted on the main queue.
    id&lt;CBLListenerToken&gt; token = [query addChangeListener:^(CBLQueryChange * _Nonnull change) // &lt;.&gt;{
        for (CBLQueryResultSet *result in [change results]) {
            NSLog(@"%@", result);
            /* Update UI */
        }
    }];

    // Start live query.
    [query execute: &amp;error]; <i class="conum" data-value="8"></i><b>(8)</b>
    // end::live-query[]

    // tag::stop-live-query[]
    [query removeChangeListenerWithToken:token]; <i class="conum" data-value="9"></i><b>(9)</b>
    // end::stop-live-query[]
}

- (void) dontTestWhere {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-where[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:[CBLQueryLimit limit:[CBLQueryExpression integer:10]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        CBLDictionary *dict = [result valueForKey:@"travel-sample"];
        NSLog(@"document name :: %@", [dict stringForKey:@"name"]);
    }
    // end::query-where[]

    NSLog(@"%@", query);
}

- (void) dontTestQueryDeletedDocuments {
    CBLDatabase* database = self.db;

    // tag::query-deleted-documents[]
    // Query documents that have been deleted
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression:CBLQueryMeta.id]]
                                         from: [CBLQueryDataSource database:database]
                                        where: CBLQueryMeta.isDeleted];
    // end::query-deleted-documents[]
    NSLog(@"%@", query);
}

- (void) dontTestCollectionOperatorContains {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-contains[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuerySelectResult *likes = [CBLQuerySelectResult property:@"public_likes"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]];
    CBLQueryExpression *contains = [CBLQueryArrayFunction contains:[CBLQueryExpression property:@"public_likes"]
                                                             value:[CBLQueryExpression string:@"Armani Langworth"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name, likes]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: contains]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"public_likes :: %@", [[result arrayForKey:@"public_likes"] toArray]);
    }
    // end::query-collection-operator-contains[]
}

- (void) dontTestCollectionOperatorIn {
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-in[]
    NSArray *values = @[[CBLQueryExpression property:@"first"],
                       [CBLQueryExpression property:@"last"],
                       [CBLQueryExpression property:@"username"]];

    [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                       from:[CBLQueryDataSource database:database]
                      where:[[CBLQueryExpression string:@"Armani"] in:values]];
    // end::query-collection-operator-in[]
}

- (void) dontTestLikeOperator {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-like-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"royal engineers museum"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"name property :: %@", [result stringForKey:@"name"]);
    }
    // end::query-like-operator[]
}

- (void) dontTestWildCardMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"eng%e%"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-match[]

    NSLog(@"%@", query);
}

- (void) dontTestWildCardCharacterMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-character-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryExpression property:@"name"] like:[CBLQueryExpression string:@"eng____r"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-character-match[]

    NSLog(@"%@", query);
}

- (void) dontTestRegexMatch {
    CBLDatabase *database = self.db;

    // tag::query-regex-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *regex = [[CBLQueryExpression property:@"name"] regex:[CBLQueryExpression string:@"\\bEng.*e\\b"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: regex]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-regex-operator[]

    NSLog(@"%@", query);
}

- (void) dontTestJoin {
    CBLDatabase *database = self.db;

    // tag::query-join[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"name" from:@"airline"]];
    CBLQuerySelectResult *callsign = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"callsign" from:@"airline"]];
    CBLQuerySelectResult *dest = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"destinationairport" from:@"route"]];
    CBLQuerySelectResult *stops = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"stops" from:@"route"]];
    CBLQuerySelectResult *airline = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"airline" from:@"route"]];

    CBLQueryJoin *join = [CBLQueryJoin join:[CBLQueryDataSource database:database as:@"route"]
                                         on:[[CBLQueryMeta idFrom:@"airline"] equalTo:[CBLQueryExpression property:@"airlineid" from:@"route"]]];

    CBLQueryExpression *typeRoute = [[CBLQueryExpression property:@"type" from:@"route"] equalTo:[CBLQueryExpression string:@"route"]];
    CBLQueryExpression *typeAirline = [[CBLQueryExpression property:@"type" from:@"airline"] equalTo:[CBLQueryExpression string:@"airline"]];
    CBLQueryExpression *sourceRIX = [[CBLQueryExpression property:@"sourceairport" from:@"route"] equalTo:[CBLQueryExpression string:@"RIX"]];

    CBLQuery *query = [CBLQueryBuilder select:@[name, callsign, dest, stops, airline]
                                         from:[CBLQueryDataSource database:database as:@"airline"]
                                         join:@[join]
                                        where:[[typeRoute andExpression:typeAirline] andExpression:sourceRIX]];
    // end::query-join[]

    NSLog(@"%@", query);
}

- (void) dontTestGroupBy {
    CBLDatabase *database = self.db;

    // tag::query-groupby[]
    CBLQuerySelectResult *count = [CBLQuerySelectResult expression:[CBLQueryFunction count:[CBLQueryExpression all]]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *tz = [CBLQuerySelectResult property:@"tz"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"airport"]];
    CBLQueryExpression *geoAlt = [[CBLQueryExpression property:@"geo.alt"] greaterThanOrEqualTo:[CBLQueryExpression integer:300]];

    CBLQuery *query = [CBLQueryBuilder select:@[count, country, tz]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: geoAlt]
                                      groupBy:@[[CBLQueryExpression property:@"country"],
                                                [CBLQueryExpression property:@"tz"]]];
    // end::query-groupby[]

    NSLog(@"%@", query);
}

- (void) dontTestOrderBy {
    CBLDatabase *database = self.db;

    // tag::query-orderby[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *title = [CBLQuerySelectResult property:@"title"];

    CBLQuery *query = [CBLQueryBuilder select:@[id, title]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      orderBy:@[[[CBLQueryOrdering property:@"title"] descending]]];
    // end::query-orderby[]

    NSLog(@"%@", query);
}


- (void) dontTestExplainAll {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-all[]
    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[[CBLQueryExpression property:@"type"]
                   equalTo:[CBLQueryExpression string:@"university"]]
//            groupBy:@[[CBLQueryExpression property:@"country"]] <i class="conum" data-value="10"></i><b>(10)</b>
                          orderBy:@[[[CBLQueryOrdering property:@"title"] descending]] <i class="conum" data-value="11"></i><b>(11)</b>
       ];

    NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="12"></i><b>(12)</b>

      // end::query-explain-all[]
}
- (void) dontTestExplainLike {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-like[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"%hotel%"]];
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];
      NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="13"></i><b>(13)</b>

      // end::query-explain-like[]

}
- (void) dontTestExplainNoPfx {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-nopfx[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"hotel%"]]; <i class="conum" data-value="14"></i><b>(14)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-nopfx[]
}

- (void) dontTestExplainFunction {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-function[]
    CBLQueryExpression *type =
        [[CBLQueryFunction lower:[CBLQueryExpression property:@"type"]]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="15"></i><b>(15)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
                from:[CBLQueryDataSource database:database]
                where:[type andExpression: name]];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-function[]
}

- (void) dontTestExplainNoFunction {
    CBLDatabase *database = self.db;
    NSError *error;
      // tag::query-explain-nofunction[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="16"></i><b>(16)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

      // end::query-explain-nofunction[]

}



- (void) dontTestCreateFullTextIndex {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-index[]
    // Insert documents
    NSArray *tasks = @[@"buy groceries", @"play chess", @"book travels", @"buy museum tickets"];
    for (NSString *task in tasks) {
        CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
        [doc setString:@"task" forKey:@"type"];
        [doc setString:task forKey:@"name"];
        [database saveDocument:doc error:&amp;error];
    }

    // Create index
    CBLFullTextIndex *index = [CBLIndexBuilder fullTextIndexWithItems:@[[CBLFullTextIndexItem property:@"name"]]];
    index.ignoreAccents = NO;
    [database createIndex:index withName:@"nameFTSIndex" error:&amp;error];
    // end::fts-index[]
}

- (void) dontTestFullTextSearch {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-query[]
    CBLQueryExpression *where =
      [[CBLQueryFullTextExpression indexWithName:@"nameFTSIndex"] match:@"'buy'"];
    CBLQuery *query =
      [CBLQueryBuilder
        select:@[[CBLQuerySelectResult expression:[CBLQueryMeta id]]]
        from:[CBLQueryDataSource database:database]
        where:where];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"document id %@", [result stringAtIndex:0]);
    }
    // end::fts-query[]
}

#pragma mark - Replication

/* The `tag::replication[]` example is inlined in objc.adoc */

- (void) dontTestEnableReplicatorLogging {
    // tag::replication-logging[]
    // Replicator
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainReplicator];
    // Network
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainNetwork];
    // end::replication-logging[]
}

- (void) dontTestReplicationBasicAuthentication {
    CBLDatabase *database = self.db;
    // tag::basic-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::basic-authentication[]
}

- (void) dontTestReplicationSessionAuthentication {
    CBLDatabase *database = self.db;
    // tag::session-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLSessionAuthenticator alloc] initWithSessionID:@"904ac010862f37c8dd99015a33ab5a3565fd8447"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::session-authentication[]
}

- (void) dontTestReplicatorStatus {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-status[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
        }
    }];
    // end::replication-status[]
}


//  BEGIN PendingDocuments IB -- 11/Feb/21 --
//    public void testReplicationPendingDocs() throws URISyntaxException {
      // tag::replication-pendingdocuments[]

      CBLDatabase *database = self.db;
      NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
      CBLURLEndpoint *target =
        [[CBLURLEndpoint alloc] initWithURL: url];
      CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc]
          initWithDatabase:database
          target:target];

      config.replicatorType = kCBLReplicatorTypePush;

      // tag::replication-push-pendingdocumentids[]
      CBLReplicator *replicator =
        [[CBLReplicator alloc] initWithConfig:config];

      // Get list of pending doc IDs
      NSError* err = nil;
      NSSet *mydocids =
        [NSSet setWithSet:[replicator pendingDocumentIDs:&amp;err]]; <i class="conum" data-value="17"></i><b>(17)</b>

      // end::replication-push-pendingdocumentids[]

      if ([mydocids count] &gt; 0) {

        NSLog(@"There are %lu documents pending", (unsigned long)[mydocids count]);

        [replicator addChangeListener:^(CBLReplicatorChange *change) {

          NSLog(@"Replicator activity level is %u", change.status.activity);
          // iterate and report-on the pending doc IDs  in 'mydocids'
          for (thisid in mydocids) {

            // tag::replication-push-isdocumentpending[]
            NSError* err = nil;
            if (![replicator isDocumentPending: thisid error: &amp;err]) { <i class="conum" data-value="18"></i><b>(18)</b>
              NSLog(@"Doc ID %@ now pushed", thisid);
            }
            // end::replication-push-isdocumentpending[]
          }

        }];
        [replicator start];

      };

      // end::replication-pendingdocuments[]
    }
//  END PendingDocuments IB -- 11/Feb/21 --



- (void) dontTestReplicatorDocumentEvent {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::add-document-replication-listener[]
    id token = [replicator addDocumentReplicationListener:^(CBLDocumentReplication * _Nonnull replication) {
        NSLog(@"Replication type :: %@", replication.isPush ? @"Push" : @"Pull");
        for (CBLReplicatedDocument* document in replication.documents) {
            if (document.error == nil) {
                NSLog(@"Doc ID :: %@", document.id);
                if ((document.flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
                    NSLog(@"Successfully replicated a deleted document");
                }
            } else {
                // There was an error
            }
        }
    }];

    [replicator start];
    // end::add-document-replication-listener[]

    // tag::remove-document-replication-listener[]
    [replicator removeChangeListenerWithToken: token];
    // end::remove-document-replication-listener[]
}

- (void) dontTestCustomReplicationHeader {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *endpoint = [[CBLURLEndpoint alloc] initWithURL:url];

    // tag::replication-custom-header[]
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:endpoint];
    config.headers = @{@"CustomHeaderName" : @"Value"};
    // end::replication-custom-header[]
}

- (void) dontTestHandlingReplicationError {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-error-handling[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];
    // end::replication-error-handling[]
}

- (void) dontTestReplicationResetCheckpoint {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-reset-checkpoint[]
    [replicator resetCheckpoint];
    [replicator start];
    // end::replication-reset-checkpoint[]
}

- (void) dontTestReplicationPushFilter {
    CBLDatabase *database = self.db;

    // tag::replication-push-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pushFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ([[document stringForKey: @"type"] isEqualToString: @"draft"]) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-push-filter[]
}

- (void) dontTestReplicationPullFilter {
    CBLDatabase *database = self.db;

    // tag::replication-pull-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pullFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ((flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-pull-filter[]
}

//  Added 2/Feb/21 - Ian Bridge
    - void dontTestCustomRetryConfig {
        // tag::replication-retry-config[]
        id target =
          [[CBLURLEndpoint alloc] initWithURL: [NSURL URLWithString: @"ws://foo.cbl.com/db"]];

        CBLReplicatorConfiguration* config =
            [[CBLReplicatorConfiguration alloc] initWithDatabase: db target: target];
        config.type = kCBLReplicatorTypePush;
        config.continuous: YES;
        //  other config as required . . .

        // tag::replication-heartbeat[]
        config.heartbeat = 150; <i class="conum" data-value="19"></i><b>(19)</b>

        // end::replication-heartbeat[]
        // tag::replication-maxretries[]
        config.maxretries = 20; <i class="conum" data-value="20"></i><b>(20)</b>

        // end::replication-maxretries[]
        // tag::replication-maxretrywaittime[]
        config.maxretrywaittime = 600; <i class="conum" data-value="21"></i><b>(21)</b>

        // end::replication-maxretrywaittime[]
        //  other config as required . . .
        repl = [[CBLReplicator alloc] initWithConfig: config];

        // Cleanup:
        repl = nil;

        // end::replication-retry-config[]

    }


#ifdef COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseReplica {
    CBLDatabase *database = self.db;
    CBLDatabase *database2 = self.db;

    /* EE feature: code below might throw a compilation error
     if it's compiled against CBL Swift Community. */
    // tag::database-replica[]
    CBLDatabaseEndpoint *targetDatabase = [[CBLDatabaseEndpoint alloc] initWithDatabase:database2];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetDatabase];
    config.replicatorType = kCBLReplicatorTypePush;

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::database-replica[]
}
#endif

- (void) dontTestCertificatePinning {
    CBLDatabase *database = self.db;
    // Active - Example 4
    // tag::certificate-pinning[]
    // tag=p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                                                                       target:target];
    config.pinnedServerCertificate = (SecCertificateRef)CFAutorelease(certificate);

    // end=p2p-act-rep-config-cacert-pinned[]
    // end::certificate-pinning[]

    NSLog(@"%@", config);
}

- (NSData*) dataFromResource: (NSString*)file ofType: (NSString*)type {
    return [NSData data];
}

- (void) dontTestGettingStarted {
    CBLReplicator *_replicator;
    // tag::getting-started[]
    // Get the database (and create it if it doesnt exist).
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // Create a new document (i.e. a record) in the database.
    CBLMutableDocument *mutableDoc = [[CBLMutableDocument alloc] init];
    [mutableDoc setFloat:2.0 forKey:@"version"];
    [mutableDoc setString:@"SDK" forKey:@"type"];

    // Save it to the database.
    [database saveDocument:mutableDoc error:&amp;error];

    // Update a document.
    CBLMutableDocument *mutableDoc2 = [[database documentWithID:mutableDoc.id] toMutable];
    [mutableDoc2 setString:@"Swift" forKey:@"language"];
    [database saveDocument:mutableDoc2 error:&amp;error];

    CBLDocument *document = [database documentWithID:mutableDoc2.id];
    // Log the document ID (generated by the database)
    // and properties
    NSLog(@"Document ID :: %@", document.id);
    NSLog(@"Learning %@", [document stringForKey:@"language"]);

    // Create a query to fetch documents of type SDK.
    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"SDK"]];
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                          from:[CBLQueryDataSource database:database]
                                         where:type];

    // Run the query
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);

    // Create replicators to push and pull changes to and from the cloud.
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *targetEndpoint = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *replConfig = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetEndpoint];
    replConfig.replicatorType = kCBLReplicatorTypePushAndPull;

    // Add authentication.
    replConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    // Create replicator (make sure to add an instance or static variable named _replicator)
    _replicator = [[CBLReplicator alloc] initWithConfig:replConfig];

    // Listen to replicator change events.
    [_replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];

    // Start replication
    [_replicator start];
    // end::getting-started[]
}

- (void) dontTestPredictiveModel {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::register-model[]
    ImageClassifierModel* model = [[ImageClassifierModel alloc] init];
    [[CBLDatabase prediction] registerModel:model withName:@"ImageClassifier"];
    // end::register-model[]

    // tag::predictive-query-value-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input];

    CBLValueIndex* index = [CBLIndexBuilder valueIndexWithItems:@[[CBLValueIndexItem expression:[prediction property:@"label"]]]];
    [database createIndex:index withName:@"value-index-image-classifier" error:&amp;error];
    // end::predictive-query-value-index[]

    // tag::unregister-model[]
    [[CBLDatabase prediction] unregisterModelWithName:@"ImageClassifier"];
    // end::unregister-model[]
}

- (void) dontTestPredictiveIndex {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query-predictive-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary:@{@"photo":[CBLQueryExpression property:@"photo"]}];

    CBLPredictiveIndex* index = [CBLIndexBuilder predictiveIndexWithModel:@"ImageClassifier" input:input properties:nil];
    [database createIndex:index withName:@"predictive-index-image-classifier" error:&amp;error];
    // end::predictive-query-predictive-index[]
}

- (void) dontTestPredictiveQuery {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input]; <i class="conum" data-value="1"></i><b>(1)</b>

    CBLQueryExpression* condition = [[[prediction property:@"label"] equalTo:[CBLQueryExpression string:@"car"]]
                                     andExpression:[[prediction property:@"probablity"] greaterThanOrEqualTo:[CBLQueryExpression double:0.8]]];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult all]]
                                         from: [CBLQueryDataSource database:database]
                                        where: condition];

    // Run the query.
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);
    // end::predictive-query[]
}

- (void) dontTestCoreMLPredictiveModel {
    NSError *error;

    // tag::coreml-predictive-model[]
    // Load MLModel from `ImageClassifier.mlmodel`
    NSURL* modelURL = [[NSBundle mainBundle] URLForResource:@"ImageClassifier" withExtension:@"mlmodel"];
    NSURL* compiledModelURL = [MLModel compileModelAtURL:modelURL error:&amp;error];
    MLModel* model = [MLModel modelWithContentsOfURL:compiledModelURL error:&amp;error];
    CBLCoreMLPredictiveModel* predictiveModel = [[CBLCoreMLPredictiveModel alloc] initWithMLModel:model];

    // Register model
    [[CBLDatabase prediction] registerModel:predictiveModel withName:@"ImageClassifier"];
    // end::coreml-predictive-model[]
}

- (void) dontTestReplicatorConflictResolver {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::replication-conflict-resolver[]
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.conflictResolver = [[LocalWinConflictResolver alloc] init];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-conflict-resolver[]
}

- (void) dontTestSaveWithConflictHandler {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document-with-conflict-handler[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];

    [database saveDocument:mutableDocument
           conflictHandler:^BOOL(CBLMutableDocument *new, CBLDocument *current) {
               NSDictionary *currentDict = current.toDictionary;
               NSDictionary *newDict = new.toDictionary;

               NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:currentDict];
               [result addEntriesFromDictionary:newDict];
               [new setData: result];
               return YES;
           }
                     error: &amp;error];
    // end::update-document-with-conflict-handler[]
}

#pragma mark - URLListener

- (BOOL) isValidCredentials: (NSString*)u password: (NSString*)p { return YES; } // helper
- (void) dontTestInitListener {
    CBLDatabase *database = self.db;
    CBLURLEndpointListener* listener = nil;

    // tag::init-urllistener[]
    CBLURLEndpointListenerConfiguration* config;
    config = [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: database];
    config.tlsIdentity = nil; // Use with anonymous self signed cert
    config.authenticator =
        [[CBLListenerPasswordAuthenticator alloc]
            initWithBlock: ^BOOL(
                NSString * username,
                NSString * password)
                {
                if ([self isValidCredentials: username password:password]) {
                    return  YES;
                }
                return NO;
            }];

    listener = [[CBLURLEndpointListener alloc] initWithConfig: config];
    // end::init-urllistener[]
}

- (void) dontTestListenerStart {
    NSError* error = nil;
    CBLURLEndpointListener* listener = nil;

    // tag::start-urllistener[]
    BOOL success = [listener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }
    // end::start-urllistener[]
}

- (void) dontTestListenerStop {
    CBLURLEndpointListener* listener = nil;

    // tag::stop-urllistener[]
    [listener stop];
    // end::stop-urllistener[]
}

- (void) dontTestCreateSelfSignedCert {
    NSError* error = nil;
    CBLTLSIdentity* identity = nil;
    // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
    // Example-6
    // tag::create-self-signed-cert[]
    // tag::listener-config-tls-id-SelfSigned[]

    NSDictionary* attrs = @{ kCBLCertAttrCommonName: @"Couchbase Inc" };
    identity =
      [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
        label: @"Server-Cert-Label"
        error: &amp;error];
    // end::listener-config-tls-id-SelfSigned[]
    // end::create-self-signed-cert[]
}

- (void) dontTestListenerCertificateAuthenticatorRootCert {
    CBLURLEndpointListenerConfiguration* config;

    // Example 8-tab1
    // tag::listener-certificate-authenticator-root-urllistener[]
    // tag::listener-config-client-auth-root[]

    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef rootCertRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    config.authenticator = [[CBLListenerCertificateAuthenticator alloc]
                            initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];
    // end::listener-config-client-auth-root[]
    // end::listener-certificate-authenticator-root-urllistener[]
}

- (void) dontTestListenerCertificateAuthenticatorCallback {
    CBLURLEndpointListenerConfiguration* config;
    // Example 8-tab2
    // tag::listener-certificate-authenticator-callback-urllistener[]
    // tag::listener-config-client-auth-lambda[]

    CBLListenerCertificateAuthenticator* listenerAuth =
    [[CBLListenerCertificateAuthenticator alloc] initWithBlock: ^BOOL(NSArray *certs) {
        SecCertificateRef cert = (__bridge SecCertificateRef)(certs[0]);
        CFStringRef cnRef;
        OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
        if (status == errSecSuccess) {
            NSString* cn = (NSString*)CFBridgingRelease(cnRef);
            if ([self._allowlistedUsers containsObject: cn])
                return YES;
        }
        return NO;
    }];

    config.authenticator = listenerAuth;
    // end::listener-config-client-auth-lambda[]
    // end::listener-certificate-authenticator-callback-urllistener[]
}

@end

#pragma mark -

// Singleton Pattern
// &lt;doc&gt;
@interface DataManager : NSObject

@property (nonatomic, readonly) CBLDatabase *database;

+ (id)sharedInstance;

@end

@implementation DataManager

@synthesize database=_database;

+ (id)sharedInstance {
    static DataManager *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}

- (id)init {
    if (self = [super init]) {
        NSError *error;
        _database = [[CBLDatabase alloc] initWithName:@"dbname" error:&amp;error];
        if (!_database) {
            NSLog(@"Cannot open the database: %@", error);
            return nil;
        }
    }
    return self;
}

@end
// &lt;doc&gt;

// Peer-to-Peer Sample

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface ActivePeer: NSObject &lt;CBLMessageEndpointDelegate&gt;

@end

@interface ActivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation ActivePeer

- (instancetype) init {
    self = [super init];
    if (self) {
        // tag::message-endpoint[]
        CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"dbname" error: &amp;error];

        // The delegate must implement the `CBLMessageEndpointDelegate` protocol.
        NSString* id = @"";
        CBLMessageEndpoint *endpoint =
        [[CBLMessageEndpoint alloc] initWithUID:@"UID:123"
                                         target:id
                                   protocolType:kCBLProtocolTypeMessageStream
                                       delegate:self];
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc] initWithDatabase:database target: endpoint];

        // Create the replicator object.
        CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig: config];
        [replicator start];
        // end::message-endpoint-replicator[]
    }
    return self;
}

// tag::create-connection[]
- (id&lt;CBLMessageEndpointConnection&gt;)createConnectionForEndpoint:(CBLMessageEndpoint *)endpoint {
    return [[ActivePeerConnection alloc] init];
}
// end::create-connection[]

@end


@implementation ActivePeerConnection {
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)disconnect {
    // tag::active-replicator-close[]
    [_replicatorConnection close:nil];
    // end::active-replicator-close[]
}

// tag::active-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::active-peer-open[]

// tag::active-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::active-peer-send[]

- (void)receive:(NSData*)data {
    // tag::active-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::active-peer-receive[]
}

// tag::active-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::active-peer-close[]

@end

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface PassivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)startListener;
- (void)stopListener;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation PassivePeerConnection {
    CBLMessageEndpointListener *_messageEndpointListener;
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)startListener {
    // tag::listener[]
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error: &amp;error];

    CBLMessageEndpointListenerConfiguration *config =
    [[CBLMessageEndpointListenerConfiguration alloc] initWithDatabase:database
                                                         protocolType:kCBLProtocolTypeMessageStream];
    _messageEndpointListener = [[CBLMessageEndpointListener alloc] initWithConfig:config];
    // end::listener[]
}

- (void)stopListener {
    // tag::passive-stop-listener[]
    [_messageEndpointListener closeAll];
    // end::passive-stop-listener[]
}

- (void)acceptConnection {
    // tag::advertizer-accept[]
    PassivePeerConnection *connection = [[PassivePeerConnection alloc] init]; /* implements CBLMessageEndpointConnection */
    [_messageEndpointListener accept: connection];
    // end::advertizer-accept[]
}

- (void)disconnect {
    // tag::passive-replicator-close[]
    [_replicatorConnection close:nil];
    // end::passive-replicator-close[]
}

// tag::passive-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::passive-peer-open[]

// tag::passive-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::passive-peer-send[]

- (void)receive:(NSData*)data {
    // tag::passive-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::passive-peer-receive[]
}

// tag::passive-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::passive-peer-close[]
@end



// QUERY RESULT SET HANDLING EXAMPLES
- (void) dontTestQuerySyntaxJson {
    // tag::query-syntax-all[]
    NSError *error;

    CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

    CBLQuery *listQuery = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                             from:[CBLQueryDataSource database:db]]; <i class="conum" data-value="22"></i><b>(22)</b>

    // end::query-syntax-all[]


    // tag::query-access-all[]
        NSMutableArray* matches =
          [[NSMutableArray alloc] init];

        CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

        for (CBLQueryResult *result in resultset.allResults) { // access the resultSet.allResults

            NSDictionary *match = [result valueAtIndex: 0] ;
//             toDictionary];

            // Store dictionary in array
            [matches addObject: match];

            // Use dictionary values
            NSLog(@"id = %@", [match valueForKey:@"id"]);
            NSLog(@"name = %@", [match valueForKey:@"name"]);
            NSLog(@"type = %@", [match valueForKey:@"type"]);
            NSLog(@"city = %@", [match valueForKey:@"city"]);

        } // end for

    // end::query-access-all[]

    // tag::query-access-json[]
    NSMutableArray&lt;Hotel *&gt; *hotels = NSMutableArray.new;
    for (CBLQueryResult* result in [listQuery execute:&amp;error]) {

        // Get result as a JSON string

        NSString* thisJsonString =
                    [result toJSON]; <i class="conum" data-value="23"></i><b>(23)</b>

        // Get an native Obj-C object from the Json String
        NSDictionary *thisDictFromJSON =
                [NSJSONSerialization JSONObjectWithData:
                 [thisJsonString dataUsingEncoding: NSUTF8StringEncoding]
                       options: NSJSONReadingAllowFragments
                       error: &amp;error]; <i class="conum" data-value="24"></i><b>(24)</b>
        if (error) {
            NSLog(@"Error in serialization: %@",error);
            return;
        }


        // Populate a custom object from native dictionary
        Hotel *hotelFromJson = Hotel.new;

        hotelFromJson.id = thisDictFromJSON[@"id"];  <i class="conum" data-value="25"></i><b>(25)</b>
        hotelFromJson.name = thisDictFromJSON[@"name"];
        hotelFromJson.city = thisDictFromJSON[@"city"];
        hotelFromJson.country = thisDictFromJSON[@"country"];
        hotelFromJson.descriptive = thisDictFromJSON[@"description"];

        [hotels addObject:hotelFromJson];


        // Log generated Json and Native objects
        // For demo/example purposes
        NSLog(@"Json String %@", thisJsonString);
        NSLog(@"Native Object %@", thisDictFromJSON);
        NSLog(@"Custom Object: id: %@ name: %@ city: %@ country: %@ descriptive: %@", hotelFromJson.id, hotelFromJson.name, hotelFromJson.city, hotelFromJson.country, hotelFromJson.descriptive);

       }; // end for

    // end::query-access-json[]

} // end function




// tag::query-syntax-props[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

CBLQuerySelectResult *type = [CBLQuerySelectResult property:@"type"];

CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

CBLQuerySelectResult *city = [CBLQuerySelectResult property:@"city"];

*listQuery = [CBLQueryBuilder select:@[id, type, name, city]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="26"></i><b>(26)</b>

// end::query-syntax-props[]

// tag::query-access-props[]
    NSMutableArray* matches = [[NSMutableArray alloc] init]; // save to native array

    CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

    for (CBLQueryResult *result in resultset.allResults) { // all results

        [matches addObject: [result toDictionary]];

        NSLog(@"id = %@", [result stringForKey:@"id"]);
        NSLog(@"name = %@", [result stringForKey:@"name"]);
        NSLog(@"type = %@", [result stringForKey:@"type"]);
        NSLog(@"city = %@", [result stringForKey:@"city"]);

    } // end for

// end::query-access-props[]



// tag::query-syntax-count-only[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuerySelectResult *count =
  [CBLQuerySelectResult expression:[CBLQueryFunction count:   [CBLQueryExpression all]]];

*listQuery = [CBLQueryBuilder select:@[count]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="27"></i><b>(27)</b>

// end::query-syntax-count-only[]

// tag::query-access-count-only[]
CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisCount = [match intForKey:@"mycount"] <i class="conum" data-value="28"></i><b>(28)</b>

} // end for

// end::query-access-count-only[]


// tag::query-syntax-id[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

*listQuery = [CBLQueryBuilder select:@[id]
             from:[CBLQueryDataSource database:db]]

// end::query-syntax-id[]

// tag::query-access-id[]

CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisDocsId = [match stringForKey:@"id"] <i class="conum" data-value="29"></i><b>(29)</b>

  // Now you can get the document using its ID
  // for example using
  CBLMutableDocument* thisDoc =
    [thisDB documentWithID: thisDocsId]

} // end for

// end::query-access-id[]


// tag::query-syntax-pagination[]
int thisOffset = 0;
int thisLimit = 20;
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery* listQuery =
            [CBLQueryBuilder
                select: @[[CBLQuerySelectResult all]]
                from: [CBLQueryDataSource database: db]
                limit: [CBLQueryLimit
                            limit: [CBLQueryExpression integer: thisLimit]
                            offset: [CBLQueryExpression integer: thisOffset]]
            ];

// end::query-syntax-pagination[]



// PEER-to-PEER


// tag::listener-simple[]
CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database]; <i class="conum" data-value="30"></i><b>(30)</b>

thisConfig.authenticator =
  [[CBLListenerPasswordAuthenticator alloc]
    initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
      if ([self isValidCredentials: validUser password:validPassword]) {
          return  YES;
      }
      return NO;
  }]; <i class="conum" data-value="31"></i><b>(31)</b>

CBLURLEndpointListener* thisListener = nil;
thisListener =
  [[CBLURLEndpointListener alloc] initWithConfig: thisConfig]; <i class="conum" data-value="32"></i><b>(32)</b>

BOOL success = [thisListener startWithError: &amp;error];
if (!success) {
    NSLog(@"Cannot start the listener: %@", error);
} <i class="conum" data-value="33"></i><b>(33)</b>

// end::listener-simple[]

// tag::replicator-simple[]
NSURL *url =
  [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
CBLURLEndpoint *theListenerURL =
  [[CBLURLEndpoint alloc] initWithURL:url]; <i class="conum" data-value="34"></i><b>(34)</b>

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:theListenerURL]; <i class="conum" data-value="35"></i><b>(35)</b>

thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="36"></i><b>(36)</b>

thisConfig.authenticator =
  [[CBLBasicAuthenticator alloc]
    initWithUsername:@"valid.user"
      password:@"valid.password.string"]; <i class="conum" data-value="37"></i><b>(37)</b>


CBLReplicator *_thisReplicator;
_thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="38"></i><b>(38)</b>

[_thisReplicator start]; <i class="conum" data-value="39"></i><b>(39)</b>

// end::replicator-simple[]




//
// Stuff I adapted
//


import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class cMyPassListener {
  // tag::listener-initialize[]
  // tag::listener-config-db[]
  // Initialize the listener config <i class="conum" data-value="40"></i><b>(40)</b>
  CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database];

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.port =  55990; <i class="conum" data-value="41"></i><b>(41)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    NSString *thisURL = @"10.1.1.10";
    thisConfig.networkInterface = thisURL; <i class="conum" data-value="42"></i><b>(42)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.enableDeltaSync = true; <i class="conum" data-value="43"></i><b>(43)</b>

    // end::listener-config-delta-sync[]
    // Configure server security
    // tag::listener-config-tls-enable[]
    thisConfig.disableTLS  = false; <i class="conum" data-value="44"></i><b>(44)</b>

    // end::listener-config-tls-enable[]

    // tag::listener-config-tls-id-anon[]
    // Use an anonymous self-signed cert
    thisConfig.tlsIdentity = nil; <i class="conum" data-value="45"></i><b>(45)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure Client Security using an Authenticator
    // For example, Basic Authentication <i class="conum" data-value="46"></i><b>(46)</b>
    thisConfig.authenticator =
      [[CBLListenerPasswordAuthenticator alloc]
        initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
          if ([self isValidCredentials: validUser password:validPassword]) {
              return  YES;
          }
          return NO;
      }];

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // tag::listener-init[]
    // Initialize the listener <i class="conum" data-value="47"></i><b>(47)</b>
    CBLURLEndpointListener* thisListener = nil;
    thisListener =
      [[CBLURLEndpointListener alloc] initWithConfig: thisConfig];

    // end::listener-init[]
    // start the listener <i class="conum" data-value="48"></i><b>(48)</b>
    BOOL success = [thisListener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }

    // end::listener-start[]
// end::listener-initialize[]
  } // end of class

// tag::listener-stop[]
    [thisListener stop];

// end::listener-stop[]

  }
}


// Additional Snippets

// tag::listener-get-network-interfaces[]
// . . .  code snippet to be provided

// end::listener-get-network-interfaces[]

// tag::listener-get-url-list[]
NSError* error = nil;
CBLURLEndpointListenerConfiguration* config =
  [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: self.otherDB];
CBLURLEndpointListener* listener =
  [[CBLURLEndpointListener alloc] initWithConfig: config];

[listener startWithError: &amp;error];

NSLog(@"%@", listener.urls);

// end::listener-get-url-list[]

// tag::listener-local-db[]
// . . . preceding application logic . . .
fileprivate  var _allowlistedCommonNames:[[String:String]] = []
fileprivate var _thisListener:URLEndpointListener?
fileprivate var thisDB:Database?
// Include websockets listener initializer code
// func fMyPassListener() {
CBLDatabase *thisDB = self.db;
// end::listener-local-db[]

// tag::listener-config-tls-full[]
  // Configure server authentication
  // tag::listener-config-tls-disable[]
  thisConfig.disableTLS  = true; <i class="conum" data-value="49"></i><b>(49)</b>

  // end::listener-config-tls-disable[]

  // EXAMPLE 6
  // tag::listener-config-tls-id-full[]
  // tag::listener-config-tls-id-caCert[]
  // Use CA Cert
  // Create a TLSIdentity from a key-pair and
  // certificate in secure storage
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="50"></i><b>(50)</b>

    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    CBLTLSIdentity* thisIdentity =
      [CBLTLSIdentity importIdentityWithData: data
        password: @"123"
        label: @"couchbase-docs-cert"
        error: &amp;error]; <i class="conum" data-value="51"></i><b>(51)</b>

    config.tlsIdentity = thisIdentity; <i class="conum" data-value="52"></i><b>(52)</b>

  // end::listener-config-tls-id-caCert[]
  // tag::listener-config-tls-id-SelfSigned[]
  // Use a self-signed certificate
  NSDictionary* attrs =
    @{ kCBLCertAttrCommonName: @"Couchbase Inc" }; <i class="conum" data-value="53"></i><b>(53)</b>

  thisIdentity =
    [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
              label: @" couchbase-docs-cert"
              error: &amp;error]; <i class="conum" data-value="54"></i><b>(54)</b>

  // end::listener-config-tls-id-SelfSigned[]
      // tag::listener-config-tls-id-set[]
  // set the TLS Identity
  thisConfig.tlsIdentity = thisIdentity; <i class="conum" data-value="55"></i><b>(55)</b>

  // end::listener-config-tls-id-set[]
  // end::listener-config-tls-id-full[]
// end::listener-config-tls-full[]

// EXAMPLE 8
// tag::listener-config-client-auth-root[]
// Configure the client authenticator
NSURL *certURL =
  [[NSBundle mainBundle]
    URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="56"></i><b>(56)</b>
NSData *data =
  [[NSData alloc]
    initWithContentsOfURL: certURL];
SecCertificateRef rootCertRef =
  SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

thisConfig.authenticator =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];  <i class="conum" data-value="57"></i><b>(57)</b> <i class="conum" data-value="58"></i><b>(58)</b>

// end::listener-config-client-auth-root[]
// tag::listener-config-client-auth-lambda[]
// Authenticate self-signed cert
// using application logic
CBLListenerCertificateAuthenticator* thisListenerAuth =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithBlock: ^BOOL(NSArray *certs) {
      SecCertificateRef cert =
        (__bridge SecCertificateRef)(certs[0]); <i class="conum" data-value="59"></i><b>(59)</b>
      CFStringRef cnRef;
      OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
      if (status == errSecSuccess) {
          NSString* cn = (NSString*)CFBridgingRelease(cnRef);
          if ([self._allowlistedCommonNames containsObject: cn])
              return YES;
      }
      return NO;
  }];  <i class="conum" data-value="60"></i><b>(60)</b>

thisConfig.authenticator = thisListenerAuth; <i class="conum" data-value="61"></i><b>(61)</b>

// end::listener-config-client-auth-lambda[]







// tag::xlistener-config-tls-disable[]
thisConfig.disableTLS  = true

// end::xlistener-config-tls-disable[]

// tag::listener-config-tls-id-nil[]
thisConfig.tlsIdentity = nil

// end::listener-config-tls-id-nil[]


// tag::old-listener-config-delta-sync[]
thisConfig.enableDeltaSync = true

// end::old-listener-config-delta-sync[]


// tag::listener-status-check[]
NSUInteger totalConnections = thisListener.status.connectionCount;
NSUInteger activeConnections = thisListener.status.activeConnectionCount;

// end::listener-status-check[]


// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  let rootCertData = SecCertificateCopyData(cert) as Data
  let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
  // Listener:
  thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

// end::old-listener-config-client-auth-root[]
/

// tag::listener-config-client-auth-self-signed[]
thisConfig.authenticator = ListenerCertificateAuthenticator.init {
  (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedCommonNames.contains(["name": certCommonName! as String])) {
        return true
    }
    return false
}

// end::listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}

// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
thisConfig.port = tls ? wssPort : wsPort
thisConfig.disableTLS = !tls
thisConfig.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>

// end::p2p-ws-api-urlendpointlistener-constructor[]


// Active Peer Connection Snippets

//
//  my Other Bits.swift
//  doco-sync
//
//  Created by Ian Bridge on 19/06/2020.
//  Copyright  2020 Couchbase Inc. All rights reserved.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class myActPeerClass {

  func fMyActPeer() {
    // let validUser = "syncthisUser"
    // let validPassword = "sync9455"
    // let cert:SecCertificate?
    // let passivePeerEndpoint = "10.1.1.12:8920"
    // let passivePeerPort = "8920"
    // let passiveDbName = "userdb"
    // var actDb:Database?
    // var thisReplicator:Replicator?
    // var replicatorListener:ListenerToken?

    CBLReplicator *_thisReplicator;

    CBLListenerToken *_thisListenerToken;

    CBLDatabase *database
      = [[CBLDatabase alloc] initWithName:@"thisDB" error:&amp;error];
        if (!database) {
          NSLog(@"Cannot open the database: %@", error);
        };

    // tag::p2p-act-rep-func[]
    // tag::p2p-act-rep-initialize[]
    // Set listener DB endpoint
    NSURL *url = [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
    CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

    CBLReplicatorConfiguration *thisConfig
      = [[CBLReplicatorConfiguration alloc]
          initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="62"></i><b>(62)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config[]
    // tag::p2p-act-rep-config-type[]
    thisConfig.replicatorType = kCBLReplicatorTypePush;

    // end::p2p-act-rep-config-type[]
    // tag::autopurge-override[]
    // set auto-purge behavior (here we override default)
    thisConfig.enableAutoPurge = NO; <i class="conum" data-value="63"></i><b>(63)</b>

    // end::autopurge-override[]
    // tag::p2p-act-rep-config-cont[]
    thisConfig.continuous = YES;

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Authentication
    // Here - expect and accept self-signed certs
    thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="64"></i><b>(64)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Authentication
    // tag::p2p-act-rep-auth[]
    // Here set client to use basic authentication
    // Providing username and password credentials
    // If prompted for them by server
    thisConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"Our Username" password:@"Our Password"]; <i class="conum" data-value="65"></i><b>(65)</b>

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    thisConfig.conflictResolver = [[LocalWinConflictResolver alloc] <i class="conum" data-value="66"></i><b>(66)</b>

    // end::p2p-act-rep-config-conflict[]    //
    // end::p2p-act-rep-config[]
    // tag::p2p-act-rep-start-full[]
    // Apply configuration settings to the replicator
    _thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="67"></i><b>(67)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    // Optionally add a change listener <i class="conum" data-value="68"></i><b>(68)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    // Retain token for use in deletion
    id&lt;CBLListenerToken&gt; thisListenerToken
      = [thisReplicator addChangeListener:^(CBLReplicatorChange *thisChange) {
    // tag::p2p-act-rep-status[]
          if (thisChange.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
            } else {
            NSLog(@"Status: %d", thisChange.status.activity);
            };
    // end::p2p-act-rep-status[]
        }];
// end::p2p-act-rep-add-change-listener[]
// tag::p2p-act-rep-start[]
    // Run the replicator using the config settings
    [thisReplicator start]; <i class="conum" data-value="69"></i><b>(69)</b>

// end::p2p-act-rep-start[]
// end::p2p-act-rep-start-full[]
// end::p2p-act-rep-func[]
    }

    func mystopfunc() {
// tag::p2p-act-rep-stop[]
    // Remove the change listener
    [thisReplicator removeChangeListenerWithToken: thisListenerToken];

    // Stop the replicator
    [thisReplicator stop];
// end::p2p-act-rep-stop[]
}

// Additional Snippets from above
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA Certs
    thisConfig.acceptOnlySelfSignedServerCertificate = NO; <i class="conum" data-value="70"></i><b>(70)</b>

    // end::p2p-act-rep-config-cacert[]


    // tag::p2p-act-rep-config-pinnedcert[]
    // Return the remote pinned cert (the listener's cert)
    thisConfig.pinnedServerCertificate = thisCert; // Get listener cert if pinned

    // end::p2p-act-rep-config-pinnedcert[]







// tag::p2p-tlsid-manage-func[]
//
//  cMyGetCert.swift
//  doco-sync
//
//  Created by Ian Bridge on 20/06/2020.
//  Copyright  2020 Couchbase Inc. All rights reserved.
//

import Foundation
import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity


class cMyGetCert1{

    let kListenerCertLabel = "doco-sync-server"
    let kListenerCertKeyP12File = "listener-cert-pkey"
    let kListenerPinnedCertFile = "listener-pinned-cert"
    let kListenerCertKeyExportPassword = "couchbase"
    //var importedItems : NSArray
    let thisData : CFData?
    var items : CFArray?

    func fMyGetCert() -&gt;TLSIdentity? {
        var kcStatus = errSecSuccess // Zero
        let thisLabel : String? = "doco-sync-server"

        //var thisData : CFData?
        // tag::p2p-tlsid-tlsidentity-with-label[]
        // tag::p2p-tlsid-check-keychain[]
        // Check if Id exists in keychain and if so, use it
        CBLTLSIdentity* identity =
          [CBLTLSIdentity identityWithLabel: @"doco-sync-server" error: &amp;error]; <i class="conum" data-value="71"></i><b>(71)</b>

        // end::p2p-tlsid-check-keychain[]
        thisConfig.authenticator =
          [[CBLClientCertificateAuthenticator alloc] initWithIdentity: identity]; <i class="conum" data-value="72"></i><b>(72)</b>

        // end::p2p-tlsid-tlsidentity-with-label[]


// tag::p2p-tlsid-check-bundled[]
// CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let pathToCert = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
                let thisData = NSData(contentsOfFile: pathToCert)
            else
                {return nil}
// end::p2p-tlsid-check-bundled[]

// tag::p2p-tlsid-import-from-bundled[]
        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        kcStatus = SecPKCS12Import(thisData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;items)
            if kcStatus != errSecSuccess {
             print("failed to import data from provided with error :\(kcStatus) ")
             return nil
            }
        let importedItems = items! as NSArray
        let thisItem = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let thisSecId = thisItem[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var thisPrivateKey : SecKey?
        kcStatus = SecIdentityCopyPrivateKey(thisSecId, &amp;thisPrivateKey)
            if kcStatus != errSecSuccess {
                print("failed to import private key from provided with error :\(kcStatus) ")
                return nil
            }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let thisCertChain = thisItem[String(kSecImportItemCertChain)] as? [SecCertificate]

        // Return nil Id if errors in key or cert chain at this stage
        guard let pKey = thisPrivateKey, let pubCerts = thisCertChain else {
            return nil
        }
// end::p2p-tlsid-import-from-bundled[]

// tag::p2p-tlsid-store-in-keychain[]
// STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN

        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       pKey
        ]
        kcStatus = SecItemAdd(params as CFDictionary, nil)
            if kcStatus != errSecSuccess {
                print("Unable to store private key")
                return nil
            }
       // Store all Certs for Id in Keychain:
       var i = 0;
       for cert in thisCertChain! {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
                ]
            kcStatus = SecItemAdd(params as CFDictionary, nil)
                if kcStatus != errSecSuccess {
                    print("Unable to store certs")
                    return nil
                }
            i=i+1
        }
// end::p2p-tlsid-store-in-keychain[]

// tag::p2p-tlsid-return-id-from-keychain[]
// RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
do {
    return try TLSIdentity.identity(withIdentity: thisSecId, certs: [pubCerts[0]])
} catch {
    print("Error while loading self signed cert : \(error)")
    return nil
}
// end::p2p-tlsid-return-id-from-keychain[]
    } // fMyGetCert
} // cMyGetCert


// tag::p2p-tlsid-delete-id-from-keychain[]

[CBLTLSIdentity deleteIdentityWithLabel:thisSecId error: &amp;error];

// end::p2p-tlsid-delete-id-from-keychain[]



// end::p2p-tlsid-manage-func[]



// tag::p2p-act-rep-config-cacert-pinned-func[]
func fMyCaCertPinned() {
  // do {
  let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
  let targetEndpoint = URLEndpoint(url: tgtUrl)
  let actDb:Database?
  let config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint)
  // tag::p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate =
      SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url =
      [NSURL URLWithString:@"ws://localhost:4984/db"];

    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *thisConfig =
      [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                          target:target];
    thisConfig.pinnedServerCertificate =
      (SecCertificateRef)CFAutorelease(certificate);

    thisConfig.acceptOnlySelfSignedServerCertificate=false;

  // end::p2p-act-rep-config-cacert-pinned[]
  // end::p2p-act-rep-config-cacert-pinned-func[]
}



// For replications

// BEGIN -- snippets --
//    Purpose -- code samples for use in replication topic

// tag::sgw-repl-pull[]
@interface MyClass : NSObject
@property (nonatomic) CBLDatabase *database;
@property (nonatomic) CBLReplicator *replicator; <i class="conum" data-value="1"></i><b>(1)</b>
@end

@implementation MyClass
@synthesize database=_database;
@synthesize replicator=_replicator;

- (void) startReplication {
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"]; <i class="conum" data-value="2"></i><b>(2)</b>
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:_database
                                                                                       target:target];
    config.replicatorType = kCBLReplicatorTypePull;
    _replicator = [[CBLReplicator alloc] initWithConfig:config];
    [_replicator start];
}
@end

// end::sgw-repl-pull[]

// tag::sgw-repl-pull-callouts[]
&lt;1&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;2&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
You should now use `ws:`, or `wss:` for SSL/TLS connections.


// end::sgw-repl-pull-callouts[]

// tag::sgw-act-rep-initialize[]
// Set listener DB endpoint
NSURL *url = [NSURL URLWithString:@"ws://10.0.2.2.com:55990/travel-sample"];
CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="73"></i><b>(73)</b>

// end::sgw-act-rep-initialize[]
// END -- snippets --</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Store imported identity in keychain</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">//
//  SampleCodeTest.m
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#import &lt;UIKit/UIKit.h&gt;
#import &lt;CouchbaseLite/CouchbaseLite.h&gt;
#import &lt;CoreML/CoreML.h&gt;

// tag::predictive-model[]
// `myMLModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
@interface myMLModel : NSObject

+ (NSDictionary*)predictImage: (NSData*)data;

@end

@interface ImageClassifierModel : NSObject &lt;CBLPredictiveModel&gt;

- (nullable CBLDictionary*) predict: (CBLDictionary*)input;

@end

@implementation ImageClassifierModel

- (nullable CBLDictionary*) predict: (CBLDictionary*)input; {
    CBLBlob* blob = [input blobForKey:@"photo"];

    NSData* imageData = blob.content;
    // `myMLModel` is a fake implementation
    // this would be the implementation of the ml model you have chosen
    NSDictionary* modelOutput = [myMLModel predictImage:imageData];

    CBLMutableDictionary* output = [[CBLMutableDictionary alloc] initWithData: modelOutput];
    return output; <i class="conum" data-value="1"></i><b>(1)</b>
}

@end
// end::predictive-model[]

// to avoid link error
@implementation myMLModel
+ (NSDictionary*)predictImage: (NSData*)data { return [NSDictionary dictionary]; }
@end

// tag::custom-logging[]
@interface LogTestLogger : NSObject&lt;CBLLogger&gt;

// set the log level
@property (nonatomic) CBLLogLevel level;

@end

@implementation LogTestLogger

@synthesize level=_level;

- (void) logWithLevel: (CBLLogLevel)level domain: (CBLLogDomain)domain message: (NSString*)message {
    // handle the message, for example piping it to
    // a third party framework
}

@end

// end::custom-logging[]

// tag::local-win-conflict-resolver[]
@interface LocalWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation LocalWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.localDocument;
}

@end
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
@interface RemoteWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation RemoteWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.remoteDocument;
}

@end
// end::remote-win-conflict-resolver[]


// tag::merge-conflict-resolver[]
@interface MergeConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation MergeConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    NSDictionary *localDict = conflict.localDocument.toDictionary;
    NSDictionary *remoteDict = conflict.remoteDocument.toDictionary;

    NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:localDict];
    [result addEntriesFromDictionary:remoteDict];

    return [[CBLMutableDocument alloc] initWithID:conflict.documentID
                                             data:result];
}

@end
// end::merge-conflict-resolver[]

@interface SampleCodeTest : NSObject
@property(nonatomic) CBLDatabase* db;
@property(nonatomic) NSArray* _allowlistedUsers;
@end

@implementation SampleCodeTest

#pragma mark - Database

- (void) dontTestNewDatabase {
    // tag::new-database[]
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::new-database[]

    // tag::close-database[]
    tbd

    // end::close-database[]


}

#if COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseEncryption {
    // tag::database-encryption[]
    CBLDatabaseConfiguration *config = [[CBLDatabaseConfiguration alloc] init];
    config.encryptionKey = [[CBLEncryptionKey alloc] initWithPassword:@"secretpassword"];

    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" config:config error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::database-encryption[]
}
#endif

- (void) dontTestLogging {
    // tag::logging[]
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainReplicator];
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainQuery];
    // end::logging[]
}

- (void) dontTestEnableConsoleLogging {
    // tag::console-logging[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll; <i class="conum" data-value="1"></i><b>(1)</b>
    CBLDatabase.log.console.level = kCBLLogLevelVerbose; <i class="conum" data-value="2"></i><b>(2)</b>

    // end::console-logging[]

    // tag::console-logging-db[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll;

    // end::console-logging-db[]
}

- (void) dontTestFileLogging {
    // tag::file-logging[]
    NSString* tempFolder = [NSTemporaryDirectory() stringByAppendingPathComponent:@"cbllog"];
    CBLLogFileConfiguration* config = [[CBLLogFileConfiguration alloc] initWithDirectory:tempFolder]; <i class="conum" data-value="3"></i><b>(3)</b>
    config.maxRotateCount = 2; <i class="conum" data-value="4"></i><b>(4)</b>
    config.maxSize = 1024; <i class="conum" data-value="5"></i><b>(5)</b>
    config.usePlainText = YES; <i class="conum" data-value="6"></i><b>(6)</b>
    [CBLDatabase.log.file setConfig:config];
    [CBLDatabase.log.file setLevel: kCBLLogLevelInfo]; <i class="conum" data-value="7"></i><b>(7)</b>
    // end::file-logging[]
}

- (void) dontTestEnableCustomLogging {
    // tag::set-custom-logging[]
    [CBLDatabase.log setCustom:[[LogTestLogger alloc] initWithLogLevel: kCBLLogLevelWarning]];

    // end::set-custom-logging[]
}

- (void) dontTestLoadingPrebuilt {
    // tag::prebuilt-database[]
    // Note: Getting the path to a database is platform-specific.
    // For iOS you need to get the path from the main bundle.
    if (![CBLDatabase databaseExists:@"travel-sample" inDirectory:nil]) {
        NSError*error;
        NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@"travel-sample" ofType:@"cblite2"];
        if (![CBLDatabase copyFromPath:path toDatabase:@"travel-sample" withConfig:nil error:&amp;error]) {
            [NSException raise:NSInternalInconsistencyException
                        format:@"Could not load pre-built database: %@", error];
        }
    }
    // end::prebuilt-database[]
}

#pragma mark - Document

- (void) dontTestInitializer {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::initializer[]
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];
    [newTask setString:@"task" forKey:@"task"];
    [newTask setString:@"todo" forKey:@"owner"];
    [newTask setString:@"task" forKey:@"createdAt"];
    [database saveDocument:newTask error:&amp;error];
    // end::initializer[]
}

- (void) dontTestMutability {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];
    [database saveDocument:mutableDocument error:&amp;error];
    // end::update-document[]
}

- (void) dontTestTypedAcessors {
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];

    // tag::date-getter[]
    [newTask setValue:[NSDate date] forKey:@"createdAt"];
    NSDate *date = [newTask dateForKey:@"createdAt"];
    // end::date-getter[]

    NSLog(@"Date: %@", date);
}

- (void) dontTestBatchOperations {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::batch[]
    [database inBatch:&amp;error usingBlock:^{
        for (int i = 0; i &lt; 10; i++) {
            CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
            [doc setValue:@"user" forKey:@"type"];
            [doc setValue:[NSString stringWithFormat:@"user %d", i] forKey:@"name"];
            [doc setBoolean:NO forKey:@"admin"];
            [database saveDocument:doc error: &amp;error];
        }
    }];
    // end::batch[]
}

- (void) dontTestChangeListener {
    __weak CBLDatabase *database = self.db;

    // tag::document-listener[]
    [database addDocumentChangeListenerWithID: @"user.john" listener:^(CBLDocumentChange * change) {
        CBLDocument* document = [database documentWithID: change.documentID];
        NSLog(@"Status :: %@)", [document stringForKey: @"verified_account"]);
    }];
    // end::document-listener[]
}

- (void) dontTestDocumentExpiration {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::document-expiration[]
    // Purge the document one day from now
    NSDate* ttl = [[NSCalendar currentCalendar] dateByAddingUnit: NSCalendarUnitDay
                                                           value: 1
                                                          toDate: [NSDate date]
                                                         options: 0];
    [database setDocumentExpirationWithID:@"doc123" expiration:ttl error:&amp;error];

    // Reset expiration
    [database setDocumentExpirationWithID:@"doc1" expiration:nil error: &amp;error];

    // Query documents that will be expired in less than five minutes
    NSTimeInterval fiveMinutesFromNow = [[NSDate dateWithTimeIntervalSinceNow:60 * 5] timeIntervalSince1970];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression: [CBLQueryMeta id]]]
                                         from: [CBLQueryDataSource database: database]
                                        where: [[CBLQueryMeta expiration]
                                                lessThan: [CBLQueryExpression double: fiveMinutesFromNow]]];
    // end::document-expiration[]
    NSLog(@"%@", query);
}

- (void) dontTestBlob {
#if TARGET_OS_IPHONE
    NSError *error;
    CBLDatabase *database = self.db;
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::blob[]
    UIImage *appleImage = [UIImage imageNamed:@"avatar.jpg"];
    NSData *imageData = UIImageJPEGRepresentation(appleImage, 1.0);

    CBLBlob *blob = [[CBLBlob alloc] initWithContentType:@"image/jpeg" data:imageData];
    [newTask setBlob:blob forKey:@"avatar"];
    [database saveDocument:newTask error:&amp;error];

    CBLDocument *savedTask = [database documentWithID: @"task1"];
    CBLBlob *taskBlob = [savedTask blobForKey:@"avatar"];
    UIImage *taskImage = [UIImage imageWithData:taskBlob.content];
    // end::blob[]

    NSLog(@"%@", taskImage);
#endif
}

- (void) dontTest1xAttachment {
    CBLMutableDocument *document = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::1x-attachment[]
    CBLDictionary *attachments = [document dictionaryForKey:@"_attachments"];
    CBLBlob *avatar = [attachments blobForKey:@"avatar"];
    NSData *content = [avatar content];
    // end::1x-attachment[]

    NSLog(@"%@", content);
}

#pragma mark - Query

- (void) dontTestIndexing {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-index[]
    CBLValueIndexItem *type = [CBLValueIndexItem property:@"type"];
    CBLValueIndexItem *name = [CBLValueIndexItem property:@"name"];
    CBLIndex* index = [CBLIndexBuilder valueIndexWithItems:@[type, name]];
    [database createIndex:index withName:@"TypeNameIndex" error:&amp;error];
    // end::query-index[]
}

- (void) dontTestSelect {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-select-meta[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuery *query = [CBLQueryBuilder select:@[name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression value:@"user"]] andExpression:
                                               [[CBLQueryExpression property:@"admin"] equalTo:[CBLQueryExpression boolean:NO]]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"user name :: %@", [result stringAtIndex:0]);
    }
    // end::query-select-meta[]
}

- (void) dontTestSelectAll {
    CBLDatabase *database = self.db;

    // tag::query-select-all[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];
    // end::query-select-all[]

    NSLog(@"%@", query);
}

- (void) dontTestLiveQuery {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::live-query[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];

    // Adds a query change listener.
    // Changes will be posted on the main queue.
    id&lt;CBLListenerToken&gt; token = [query addChangeListener:^(CBLQueryChange * _Nonnull change) // &lt;.&gt;{
        for (CBLQueryResultSet *result in [change results]) {
            NSLog(@"%@", result);
            /* Update UI */
        }
    }];

    // Start live query.
    [query execute: &amp;error]; <i class="conum" data-value="8"></i><b>(8)</b>
    // end::live-query[]

    // tag::stop-live-query[]
    [query removeChangeListenerWithToken:token]; <i class="conum" data-value="9"></i><b>(9)</b>
    // end::stop-live-query[]
}

- (void) dontTestWhere {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-where[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:[CBLQueryLimit limit:[CBLQueryExpression integer:10]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        CBLDictionary *dict = [result valueForKey:@"travel-sample"];
        NSLog(@"document name :: %@", [dict stringForKey:@"name"]);
    }
    // end::query-where[]

    NSLog(@"%@", query);
}

- (void) dontTestQueryDeletedDocuments {
    CBLDatabase* database = self.db;

    // tag::query-deleted-documents[]
    // Query documents that have been deleted
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression:CBLQueryMeta.id]]
                                         from: [CBLQueryDataSource database:database]
                                        where: CBLQueryMeta.isDeleted];
    // end::query-deleted-documents[]
    NSLog(@"%@", query);
}

- (void) dontTestCollectionOperatorContains {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-contains[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuerySelectResult *likes = [CBLQuerySelectResult property:@"public_likes"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]];
    CBLQueryExpression *contains = [CBLQueryArrayFunction contains:[CBLQueryExpression property:@"public_likes"]
                                                             value:[CBLQueryExpression string:@"Armani Langworth"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name, likes]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: contains]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"public_likes :: %@", [[result arrayForKey:@"public_likes"] toArray]);
    }
    // end::query-collection-operator-contains[]
}

- (void) dontTestCollectionOperatorIn {
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-in[]
    NSArray *values = @[[CBLQueryExpression property:@"first"],
                       [CBLQueryExpression property:@"last"],
                       [CBLQueryExpression property:@"username"]];

    [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                       from:[CBLQueryDataSource database:database]
                      where:[[CBLQueryExpression string:@"Armani"] in:values]];
    // end::query-collection-operator-in[]
}

- (void) dontTestLikeOperator {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-like-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"royal engineers museum"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"name property :: %@", [result stringForKey:@"name"]);
    }
    // end::query-like-operator[]
}

- (void) dontTestWildCardMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"eng%e%"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-match[]

    NSLog(@"%@", query);
}

- (void) dontTestWildCardCharacterMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-character-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryExpression property:@"name"] like:[CBLQueryExpression string:@"eng____r"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-character-match[]

    NSLog(@"%@", query);
}

- (void) dontTestRegexMatch {
    CBLDatabase *database = self.db;

    // tag::query-regex-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *regex = [[CBLQueryExpression property:@"name"] regex:[CBLQueryExpression string:@"\\bEng.*e\\b"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: regex]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-regex-operator[]

    NSLog(@"%@", query);
}

- (void) dontTestJoin {
    CBLDatabase *database = self.db;

    // tag::query-join[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"name" from:@"airline"]];
    CBLQuerySelectResult *callsign = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"callsign" from:@"airline"]];
    CBLQuerySelectResult *dest = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"destinationairport" from:@"route"]];
    CBLQuerySelectResult *stops = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"stops" from:@"route"]];
    CBLQuerySelectResult *airline = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"airline" from:@"route"]];

    CBLQueryJoin *join = [CBLQueryJoin join:[CBLQueryDataSource database:database as:@"route"]
                                         on:[[CBLQueryMeta idFrom:@"airline"] equalTo:[CBLQueryExpression property:@"airlineid" from:@"route"]]];

    CBLQueryExpression *typeRoute = [[CBLQueryExpression property:@"type" from:@"route"] equalTo:[CBLQueryExpression string:@"route"]];
    CBLQueryExpression *typeAirline = [[CBLQueryExpression property:@"type" from:@"airline"] equalTo:[CBLQueryExpression string:@"airline"]];
    CBLQueryExpression *sourceRIX = [[CBLQueryExpression property:@"sourceairport" from:@"route"] equalTo:[CBLQueryExpression string:@"RIX"]];

    CBLQuery *query = [CBLQueryBuilder select:@[name, callsign, dest, stops, airline]
                                         from:[CBLQueryDataSource database:database as:@"airline"]
                                         join:@[join]
                                        where:[[typeRoute andExpression:typeAirline] andExpression:sourceRIX]];
    // end::query-join[]

    NSLog(@"%@", query);
}

- (void) dontTestGroupBy {
    CBLDatabase *database = self.db;

    // tag::query-groupby[]
    CBLQuerySelectResult *count = [CBLQuerySelectResult expression:[CBLQueryFunction count:[CBLQueryExpression all]]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *tz = [CBLQuerySelectResult property:@"tz"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"airport"]];
    CBLQueryExpression *geoAlt = [[CBLQueryExpression property:@"geo.alt"] greaterThanOrEqualTo:[CBLQueryExpression integer:300]];

    CBLQuery *query = [CBLQueryBuilder select:@[count, country, tz]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: geoAlt]
                                      groupBy:@[[CBLQueryExpression property:@"country"],
                                                [CBLQueryExpression property:@"tz"]]];
    // end::query-groupby[]

    NSLog(@"%@", query);
}

- (void) dontTestOrderBy {
    CBLDatabase *database = self.db;

    // tag::query-orderby[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *title = [CBLQuerySelectResult property:@"title"];

    CBLQuery *query = [CBLQueryBuilder select:@[id, title]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      orderBy:@[[[CBLQueryOrdering property:@"title"] descending]]];
    // end::query-orderby[]

    NSLog(@"%@", query);
}


- (void) dontTestExplainAll {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-all[]
    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[[CBLQueryExpression property:@"type"]
                   equalTo:[CBLQueryExpression string:@"university"]]
//            groupBy:@[[CBLQueryExpression property:@"country"]] <i class="conum" data-value="10"></i><b>(10)</b>
                          orderBy:@[[[CBLQueryOrdering property:@"title"] descending]] <i class="conum" data-value="11"></i><b>(11)</b>
       ];

    NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="12"></i><b>(12)</b>

      // end::query-explain-all[]
}
- (void) dontTestExplainLike {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-like[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"%hotel%"]];
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];
      NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="13"></i><b>(13)</b>

      // end::query-explain-like[]

}
- (void) dontTestExplainNoPfx {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-nopfx[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"hotel%"]]; <i class="conum" data-value="14"></i><b>(14)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-nopfx[]
}

- (void) dontTestExplainFunction {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-function[]
    CBLQueryExpression *type =
        [[CBLQueryFunction lower:[CBLQueryExpression property:@"type"]]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="15"></i><b>(15)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
                from:[CBLQueryDataSource database:database]
                where:[type andExpression: name]];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-function[]
}

- (void) dontTestExplainNoFunction {
    CBLDatabase *database = self.db;
    NSError *error;
      // tag::query-explain-nofunction[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="16"></i><b>(16)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

      // end::query-explain-nofunction[]

}



- (void) dontTestCreateFullTextIndex {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-index[]
    // Insert documents
    NSArray *tasks = @[@"buy groceries", @"play chess", @"book travels", @"buy museum tickets"];
    for (NSString *task in tasks) {
        CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
        [doc setString:@"task" forKey:@"type"];
        [doc setString:task forKey:@"name"];
        [database saveDocument:doc error:&amp;error];
    }

    // Create index
    CBLFullTextIndex *index = [CBLIndexBuilder fullTextIndexWithItems:@[[CBLFullTextIndexItem property:@"name"]]];
    index.ignoreAccents = NO;
    [database createIndex:index withName:@"nameFTSIndex" error:&amp;error];
    // end::fts-index[]
}

- (void) dontTestFullTextSearch {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-query[]
    CBLQueryExpression *where =
      [[CBLQueryFullTextExpression indexWithName:@"nameFTSIndex"] match:@"'buy'"];
    CBLQuery *query =
      [CBLQueryBuilder
        select:@[[CBLQuerySelectResult expression:[CBLQueryMeta id]]]
        from:[CBLQueryDataSource database:database]
        where:where];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"document id %@", [result stringAtIndex:0]);
    }
    // end::fts-query[]
}

#pragma mark - Replication

/* The `tag::replication[]` example is inlined in objc.adoc */

- (void) dontTestEnableReplicatorLogging {
    // tag::replication-logging[]
    // Replicator
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainReplicator];
    // Network
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainNetwork];
    // end::replication-logging[]
}

- (void) dontTestReplicationBasicAuthentication {
    CBLDatabase *database = self.db;
    // tag::basic-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::basic-authentication[]
}

- (void) dontTestReplicationSessionAuthentication {
    CBLDatabase *database = self.db;
    // tag::session-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLSessionAuthenticator alloc] initWithSessionID:@"904ac010862f37c8dd99015a33ab5a3565fd8447"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::session-authentication[]
}

- (void) dontTestReplicatorStatus {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-status[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
        }
    }];
    // end::replication-status[]
}


//  BEGIN PendingDocuments IB -- 11/Feb/21 --
//    public void testReplicationPendingDocs() throws URISyntaxException {
      // tag::replication-pendingdocuments[]

      CBLDatabase *database = self.db;
      NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
      CBLURLEndpoint *target =
        [[CBLURLEndpoint alloc] initWithURL: url];
      CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc]
          initWithDatabase:database
          target:target];

      config.replicatorType = kCBLReplicatorTypePush;

      // tag::replication-push-pendingdocumentids[]
      CBLReplicator *replicator =
        [[CBLReplicator alloc] initWithConfig:config];

      // Get list of pending doc IDs
      NSError* err = nil;
      NSSet *mydocids =
        [NSSet setWithSet:[replicator pendingDocumentIDs:&amp;err]]; <i class="conum" data-value="17"></i><b>(17)</b>

      // end::replication-push-pendingdocumentids[]

      if ([mydocids count] &gt; 0) {

        NSLog(@"There are %lu documents pending", (unsigned long)[mydocids count]);

        [replicator addChangeListener:^(CBLReplicatorChange *change) {

          NSLog(@"Replicator activity level is %u", change.status.activity);
          // iterate and report-on the pending doc IDs  in 'mydocids'
          for (thisid in mydocids) {

            // tag::replication-push-isdocumentpending[]
            NSError* err = nil;
            if (![replicator isDocumentPending: thisid error: &amp;err]) { <i class="conum" data-value="18"></i><b>(18)</b>
              NSLog(@"Doc ID %@ now pushed", thisid);
            }
            // end::replication-push-isdocumentpending[]
          }

        }];
        [replicator start];

      };

      // end::replication-pendingdocuments[]
    }
//  END PendingDocuments IB -- 11/Feb/21 --



- (void) dontTestReplicatorDocumentEvent {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::add-document-replication-listener[]
    id token = [replicator addDocumentReplicationListener:^(CBLDocumentReplication * _Nonnull replication) {
        NSLog(@"Replication type :: %@", replication.isPush ? @"Push" : @"Pull");
        for (CBLReplicatedDocument* document in replication.documents) {
            if (document.error == nil) {
                NSLog(@"Doc ID :: %@", document.id);
                if ((document.flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
                    NSLog(@"Successfully replicated a deleted document");
                }
            } else {
                // There was an error
            }
        }
    }];

    [replicator start];
    // end::add-document-replication-listener[]

    // tag::remove-document-replication-listener[]
    [replicator removeChangeListenerWithToken: token];
    // end::remove-document-replication-listener[]
}

- (void) dontTestCustomReplicationHeader {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *endpoint = [[CBLURLEndpoint alloc] initWithURL:url];

    // tag::replication-custom-header[]
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:endpoint];
    config.headers = @{@"CustomHeaderName" : @"Value"};
    // end::replication-custom-header[]
}

- (void) dontTestHandlingReplicationError {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-error-handling[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];
    // end::replication-error-handling[]
}

- (void) dontTestReplicationResetCheckpoint {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-reset-checkpoint[]
    [replicator resetCheckpoint];
    [replicator start];
    // end::replication-reset-checkpoint[]
}

- (void) dontTestReplicationPushFilter {
    CBLDatabase *database = self.db;

    // tag::replication-push-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pushFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ([[document stringForKey: @"type"] isEqualToString: @"draft"]) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-push-filter[]
}

- (void) dontTestReplicationPullFilter {
    CBLDatabase *database = self.db;

    // tag::replication-pull-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pullFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ((flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-pull-filter[]
}

//  Added 2/Feb/21 - Ian Bridge
    - void dontTestCustomRetryConfig {
        // tag::replication-retry-config[]
        id target =
          [[CBLURLEndpoint alloc] initWithURL: [NSURL URLWithString: @"ws://foo.cbl.com/db"]];

        CBLReplicatorConfiguration* config =
            [[CBLReplicatorConfiguration alloc] initWithDatabase: db target: target];
        config.type = kCBLReplicatorTypePush;
        config.continuous: YES;
        //  other config as required . . .

        // tag::replication-heartbeat[]
        config.heartbeat = 150; <i class="conum" data-value="19"></i><b>(19)</b>

        // end::replication-heartbeat[]
        // tag::replication-maxretries[]
        config.maxretries = 20; <i class="conum" data-value="20"></i><b>(20)</b>

        // end::replication-maxretries[]
        // tag::replication-maxretrywaittime[]
        config.maxretrywaittime = 600; <i class="conum" data-value="21"></i><b>(21)</b>

        // end::replication-maxretrywaittime[]
        //  other config as required . . .
        repl = [[CBLReplicator alloc] initWithConfig: config];

        // Cleanup:
        repl = nil;

        // end::replication-retry-config[]

    }


#ifdef COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseReplica {
    CBLDatabase *database = self.db;
    CBLDatabase *database2 = self.db;

    /* EE feature: code below might throw a compilation error
     if it's compiled against CBL Swift Community. */
    // tag::database-replica[]
    CBLDatabaseEndpoint *targetDatabase = [[CBLDatabaseEndpoint alloc] initWithDatabase:database2];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetDatabase];
    config.replicatorType = kCBLReplicatorTypePush;

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::database-replica[]
}
#endif

- (void) dontTestCertificatePinning {
    CBLDatabase *database = self.db;
    // Active - Example 4
    // tag::certificate-pinning[]
    // tag=p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                                                                       target:target];
    config.pinnedServerCertificate = (SecCertificateRef)CFAutorelease(certificate);

    // end=p2p-act-rep-config-cacert-pinned[]
    // end::certificate-pinning[]

    NSLog(@"%@", config);
}

- (NSData*) dataFromResource: (NSString*)file ofType: (NSString*)type {
    return [NSData data];
}

- (void) dontTestGettingStarted {
    CBLReplicator *_replicator;
    // tag::getting-started[]
    // Get the database (and create it if it doesnt exist).
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // Create a new document (i.e. a record) in the database.
    CBLMutableDocument *mutableDoc = [[CBLMutableDocument alloc] init];
    [mutableDoc setFloat:2.0 forKey:@"version"];
    [mutableDoc setString:@"SDK" forKey:@"type"];

    // Save it to the database.
    [database saveDocument:mutableDoc error:&amp;error];

    // Update a document.
    CBLMutableDocument *mutableDoc2 = [[database documentWithID:mutableDoc.id] toMutable];
    [mutableDoc2 setString:@"Swift" forKey:@"language"];
    [database saveDocument:mutableDoc2 error:&amp;error];

    CBLDocument *document = [database documentWithID:mutableDoc2.id];
    // Log the document ID (generated by the database)
    // and properties
    NSLog(@"Document ID :: %@", document.id);
    NSLog(@"Learning %@", [document stringForKey:@"language"]);

    // Create a query to fetch documents of type SDK.
    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"SDK"]];
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                          from:[CBLQueryDataSource database:database]
                                         where:type];

    // Run the query
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);

    // Create replicators to push and pull changes to and from the cloud.
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *targetEndpoint = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *replConfig = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetEndpoint];
    replConfig.replicatorType = kCBLReplicatorTypePushAndPull;

    // Add authentication.
    replConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    // Create replicator (make sure to add an instance or static variable named _replicator)
    _replicator = [[CBLReplicator alloc] initWithConfig:replConfig];

    // Listen to replicator change events.
    [_replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];

    // Start replication
    [_replicator start];
    // end::getting-started[]
}

- (void) dontTestPredictiveModel {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::register-model[]
    ImageClassifierModel* model = [[ImageClassifierModel alloc] init];
    [[CBLDatabase prediction] registerModel:model withName:@"ImageClassifier"];
    // end::register-model[]

    // tag::predictive-query-value-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input];

    CBLValueIndex* index = [CBLIndexBuilder valueIndexWithItems:@[[CBLValueIndexItem expression:[prediction property:@"label"]]]];
    [database createIndex:index withName:@"value-index-image-classifier" error:&amp;error];
    // end::predictive-query-value-index[]

    // tag::unregister-model[]
    [[CBLDatabase prediction] unregisterModelWithName:@"ImageClassifier"];
    // end::unregister-model[]
}

- (void) dontTestPredictiveIndex {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query-predictive-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary:@{@"photo":[CBLQueryExpression property:@"photo"]}];

    CBLPredictiveIndex* index = [CBLIndexBuilder predictiveIndexWithModel:@"ImageClassifier" input:input properties:nil];
    [database createIndex:index withName:@"predictive-index-image-classifier" error:&amp;error];
    // end::predictive-query-predictive-index[]
}

- (void) dontTestPredictiveQuery {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input]; <i class="conum" data-value="1"></i><b>(1)</b>

    CBLQueryExpression* condition = [[[prediction property:@"label"] equalTo:[CBLQueryExpression string:@"car"]]
                                     andExpression:[[prediction property:@"probablity"] greaterThanOrEqualTo:[CBLQueryExpression double:0.8]]];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult all]]
                                         from: [CBLQueryDataSource database:database]
                                        where: condition];

    // Run the query.
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);
    // end::predictive-query[]
}

- (void) dontTestCoreMLPredictiveModel {
    NSError *error;

    // tag::coreml-predictive-model[]
    // Load MLModel from `ImageClassifier.mlmodel`
    NSURL* modelURL = [[NSBundle mainBundle] URLForResource:@"ImageClassifier" withExtension:@"mlmodel"];
    NSURL* compiledModelURL = [MLModel compileModelAtURL:modelURL error:&amp;error];
    MLModel* model = [MLModel modelWithContentsOfURL:compiledModelURL error:&amp;error];
    CBLCoreMLPredictiveModel* predictiveModel = [[CBLCoreMLPredictiveModel alloc] initWithMLModel:model];

    // Register model
    [[CBLDatabase prediction] registerModel:predictiveModel withName:@"ImageClassifier"];
    // end::coreml-predictive-model[]
}

- (void) dontTestReplicatorConflictResolver {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::replication-conflict-resolver[]
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.conflictResolver = [[LocalWinConflictResolver alloc] init];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-conflict-resolver[]
}

- (void) dontTestSaveWithConflictHandler {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document-with-conflict-handler[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];

    [database saveDocument:mutableDocument
           conflictHandler:^BOOL(CBLMutableDocument *new, CBLDocument *current) {
               NSDictionary *currentDict = current.toDictionary;
               NSDictionary *newDict = new.toDictionary;

               NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:currentDict];
               [result addEntriesFromDictionary:newDict];
               [new setData: result];
               return YES;
           }
                     error: &amp;error];
    // end::update-document-with-conflict-handler[]
}

#pragma mark - URLListener

- (BOOL) isValidCredentials: (NSString*)u password: (NSString*)p { return YES; } // helper
- (void) dontTestInitListener {
    CBLDatabase *database = self.db;
    CBLURLEndpointListener* listener = nil;

    // tag::init-urllistener[]
    CBLURLEndpointListenerConfiguration* config;
    config = [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: database];
    config.tlsIdentity = nil; // Use with anonymous self signed cert
    config.authenticator =
        [[CBLListenerPasswordAuthenticator alloc]
            initWithBlock: ^BOOL(
                NSString * username,
                NSString * password)
                {
                if ([self isValidCredentials: username password:password]) {
                    return  YES;
                }
                return NO;
            }];

    listener = [[CBLURLEndpointListener alloc] initWithConfig: config];
    // end::init-urllistener[]
}

- (void) dontTestListenerStart {
    NSError* error = nil;
    CBLURLEndpointListener* listener = nil;

    // tag::start-urllistener[]
    BOOL success = [listener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }
    // end::start-urllistener[]
}

- (void) dontTestListenerStop {
    CBLURLEndpointListener* listener = nil;

    // tag::stop-urllistener[]
    [listener stop];
    // end::stop-urllistener[]
}

- (void) dontTestCreateSelfSignedCert {
    NSError* error = nil;
    CBLTLSIdentity* identity = nil;
    // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
    // Example-6
    // tag::create-self-signed-cert[]
    // tag::listener-config-tls-id-SelfSigned[]

    NSDictionary* attrs = @{ kCBLCertAttrCommonName: @"Couchbase Inc" };
    identity =
      [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
        label: @"Server-Cert-Label"
        error: &amp;error];
    // end::listener-config-tls-id-SelfSigned[]
    // end::create-self-signed-cert[]
}

- (void) dontTestListenerCertificateAuthenticatorRootCert {
    CBLURLEndpointListenerConfiguration* config;

    // Example 8-tab1
    // tag::listener-certificate-authenticator-root-urllistener[]
    // tag::listener-config-client-auth-root[]

    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef rootCertRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    config.authenticator = [[CBLListenerCertificateAuthenticator alloc]
                            initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];
    // end::listener-config-client-auth-root[]
    // end::listener-certificate-authenticator-root-urllistener[]
}

- (void) dontTestListenerCertificateAuthenticatorCallback {
    CBLURLEndpointListenerConfiguration* config;
    // Example 8-tab2
    // tag::listener-certificate-authenticator-callback-urllistener[]
    // tag::listener-config-client-auth-lambda[]

    CBLListenerCertificateAuthenticator* listenerAuth =
    [[CBLListenerCertificateAuthenticator alloc] initWithBlock: ^BOOL(NSArray *certs) {
        SecCertificateRef cert = (__bridge SecCertificateRef)(certs[0]);
        CFStringRef cnRef;
        OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
        if (status == errSecSuccess) {
            NSString* cn = (NSString*)CFBridgingRelease(cnRef);
            if ([self._allowlistedUsers containsObject: cn])
                return YES;
        }
        return NO;
    }];

    config.authenticator = listenerAuth;
    // end::listener-config-client-auth-lambda[]
    // end::listener-certificate-authenticator-callback-urllistener[]
}

@end

#pragma mark -

// Singleton Pattern
// &lt;doc&gt;
@interface DataManager : NSObject

@property (nonatomic, readonly) CBLDatabase *database;

+ (id)sharedInstance;

@end

@implementation DataManager

@synthesize database=_database;

+ (id)sharedInstance {
    static DataManager *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}

- (id)init {
    if (self = [super init]) {
        NSError *error;
        _database = [[CBLDatabase alloc] initWithName:@"dbname" error:&amp;error];
        if (!_database) {
            NSLog(@"Cannot open the database: %@", error);
            return nil;
        }
    }
    return self;
}

@end
// &lt;doc&gt;

// Peer-to-Peer Sample

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface ActivePeer: NSObject &lt;CBLMessageEndpointDelegate&gt;

@end

@interface ActivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation ActivePeer

- (instancetype) init {
    self = [super init];
    if (self) {
        // tag::message-endpoint[]
        CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"dbname" error: &amp;error];

        // The delegate must implement the `CBLMessageEndpointDelegate` protocol.
        NSString* id = @"";
        CBLMessageEndpoint *endpoint =
        [[CBLMessageEndpoint alloc] initWithUID:@"UID:123"
                                         target:id
                                   protocolType:kCBLProtocolTypeMessageStream
                                       delegate:self];
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc] initWithDatabase:database target: endpoint];

        // Create the replicator object.
        CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig: config];
        [replicator start];
        // end::message-endpoint-replicator[]
    }
    return self;
}

// tag::create-connection[]
- (id&lt;CBLMessageEndpointConnection&gt;)createConnectionForEndpoint:(CBLMessageEndpoint *)endpoint {
    return [[ActivePeerConnection alloc] init];
}
// end::create-connection[]

@end


@implementation ActivePeerConnection {
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)disconnect {
    // tag::active-replicator-close[]
    [_replicatorConnection close:nil];
    // end::active-replicator-close[]
}

// tag::active-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::active-peer-open[]

// tag::active-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::active-peer-send[]

- (void)receive:(NSData*)data {
    // tag::active-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::active-peer-receive[]
}

// tag::active-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::active-peer-close[]

@end

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface PassivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)startListener;
- (void)stopListener;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation PassivePeerConnection {
    CBLMessageEndpointListener *_messageEndpointListener;
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)startListener {
    // tag::listener[]
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error: &amp;error];

    CBLMessageEndpointListenerConfiguration *config =
    [[CBLMessageEndpointListenerConfiguration alloc] initWithDatabase:database
                                                         protocolType:kCBLProtocolTypeMessageStream];
    _messageEndpointListener = [[CBLMessageEndpointListener alloc] initWithConfig:config];
    // end::listener[]
}

- (void)stopListener {
    // tag::passive-stop-listener[]
    [_messageEndpointListener closeAll];
    // end::passive-stop-listener[]
}

- (void)acceptConnection {
    // tag::advertizer-accept[]
    PassivePeerConnection *connection = [[PassivePeerConnection alloc] init]; /* implements CBLMessageEndpointConnection */
    [_messageEndpointListener accept: connection];
    // end::advertizer-accept[]
}

- (void)disconnect {
    // tag::passive-replicator-close[]
    [_replicatorConnection close:nil];
    // end::passive-replicator-close[]
}

// tag::passive-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::passive-peer-open[]

// tag::passive-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::passive-peer-send[]

- (void)receive:(NSData*)data {
    // tag::passive-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::passive-peer-receive[]
}

// tag::passive-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::passive-peer-close[]
@end



// QUERY RESULT SET HANDLING EXAMPLES
- (void) dontTestQuerySyntaxJson {
    // tag::query-syntax-all[]
    NSError *error;

    CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

    CBLQuery *listQuery = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                             from:[CBLQueryDataSource database:db]]; <i class="conum" data-value="22"></i><b>(22)</b>

    // end::query-syntax-all[]


    // tag::query-access-all[]
        NSMutableArray* matches =
          [[NSMutableArray alloc] init];

        CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

        for (CBLQueryResult *result in resultset.allResults) { // access the resultSet.allResults

            NSDictionary *match = [result valueAtIndex: 0] ;
//             toDictionary];

            // Store dictionary in array
            [matches addObject: match];

            // Use dictionary values
            NSLog(@"id = %@", [match valueForKey:@"id"]);
            NSLog(@"name = %@", [match valueForKey:@"name"]);
            NSLog(@"type = %@", [match valueForKey:@"type"]);
            NSLog(@"city = %@", [match valueForKey:@"city"]);

        } // end for

    // end::query-access-all[]

    // tag::query-access-json[]
    NSMutableArray&lt;Hotel *&gt; *hotels = NSMutableArray.new;
    for (CBLQueryResult* result in [listQuery execute:&amp;error]) {

        // Get result as a JSON string

        NSString* thisJsonString =
                    [result toJSON]; <i class="conum" data-value="23"></i><b>(23)</b>

        // Get an native Obj-C object from the Json String
        NSDictionary *thisDictFromJSON =
                [NSJSONSerialization JSONObjectWithData:
                 [thisJsonString dataUsingEncoding: NSUTF8StringEncoding]
                       options: NSJSONReadingAllowFragments
                       error: &amp;error]; <i class="conum" data-value="24"></i><b>(24)</b>
        if (error) {
            NSLog(@"Error in serialization: %@",error);
            return;
        }


        // Populate a custom object from native dictionary
        Hotel *hotelFromJson = Hotel.new;

        hotelFromJson.id = thisDictFromJSON[@"id"];  <i class="conum" data-value="25"></i><b>(25)</b>
        hotelFromJson.name = thisDictFromJSON[@"name"];
        hotelFromJson.city = thisDictFromJSON[@"city"];
        hotelFromJson.country = thisDictFromJSON[@"country"];
        hotelFromJson.descriptive = thisDictFromJSON[@"description"];

        [hotels addObject:hotelFromJson];


        // Log generated Json and Native objects
        // For demo/example purposes
        NSLog(@"Json String %@", thisJsonString);
        NSLog(@"Native Object %@", thisDictFromJSON);
        NSLog(@"Custom Object: id: %@ name: %@ city: %@ country: %@ descriptive: %@", hotelFromJson.id, hotelFromJson.name, hotelFromJson.city, hotelFromJson.country, hotelFromJson.descriptive);

       }; // end for

    // end::query-access-json[]

} // end function




// tag::query-syntax-props[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

CBLQuerySelectResult *type = [CBLQuerySelectResult property:@"type"];

CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

CBLQuerySelectResult *city = [CBLQuerySelectResult property:@"city"];

*listQuery = [CBLQueryBuilder select:@[id, type, name, city]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="26"></i><b>(26)</b>

// end::query-syntax-props[]

// tag::query-access-props[]
    NSMutableArray* matches = [[NSMutableArray alloc] init]; // save to native array

    CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

    for (CBLQueryResult *result in resultset.allResults) { // all results

        [matches addObject: [result toDictionary]];

        NSLog(@"id = %@", [result stringForKey:@"id"]);
        NSLog(@"name = %@", [result stringForKey:@"name"]);
        NSLog(@"type = %@", [result stringForKey:@"type"]);
        NSLog(@"city = %@", [result stringForKey:@"city"]);

    } // end for

// end::query-access-props[]



// tag::query-syntax-count-only[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuerySelectResult *count =
  [CBLQuerySelectResult expression:[CBLQueryFunction count:   [CBLQueryExpression all]]];

*listQuery = [CBLQueryBuilder select:@[count]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="27"></i><b>(27)</b>

// end::query-syntax-count-only[]

// tag::query-access-count-only[]
CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisCount = [match intForKey:@"mycount"] <i class="conum" data-value="28"></i><b>(28)</b>

} // end for

// end::query-access-count-only[]


// tag::query-syntax-id[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

*listQuery = [CBLQueryBuilder select:@[id]
             from:[CBLQueryDataSource database:db]]

// end::query-syntax-id[]

// tag::query-access-id[]

CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisDocsId = [match stringForKey:@"id"] <i class="conum" data-value="29"></i><b>(29)</b>

  // Now you can get the document using its ID
  // for example using
  CBLMutableDocument* thisDoc =
    [thisDB documentWithID: thisDocsId]

} // end for

// end::query-access-id[]


// tag::query-syntax-pagination[]
int thisOffset = 0;
int thisLimit = 20;
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery* listQuery =
            [CBLQueryBuilder
                select: @[[CBLQuerySelectResult all]]
                from: [CBLQueryDataSource database: db]
                limit: [CBLQueryLimit
                            limit: [CBLQueryExpression integer: thisLimit]
                            offset: [CBLQueryExpression integer: thisOffset]]
            ];

// end::query-syntax-pagination[]



// PEER-to-PEER


// tag::listener-simple[]
CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database]; <i class="conum" data-value="30"></i><b>(30)</b>

thisConfig.authenticator =
  [[CBLListenerPasswordAuthenticator alloc]
    initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
      if ([self isValidCredentials: validUser password:validPassword]) {
          return  YES;
      }
      return NO;
  }]; <i class="conum" data-value="31"></i><b>(31)</b>

CBLURLEndpointListener* thisListener = nil;
thisListener =
  [[CBLURLEndpointListener alloc] initWithConfig: thisConfig]; <i class="conum" data-value="32"></i><b>(32)</b>

BOOL success = [thisListener startWithError: &amp;error];
if (!success) {
    NSLog(@"Cannot start the listener: %@", error);
} <i class="conum" data-value="33"></i><b>(33)</b>

// end::listener-simple[]

// tag::replicator-simple[]
NSURL *url =
  [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
CBLURLEndpoint *theListenerURL =
  [[CBLURLEndpoint alloc] initWithURL:url]; <i class="conum" data-value="34"></i><b>(34)</b>

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:theListenerURL]; <i class="conum" data-value="35"></i><b>(35)</b>

thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="36"></i><b>(36)</b>

thisConfig.authenticator =
  [[CBLBasicAuthenticator alloc]
    initWithUsername:@"valid.user"
      password:@"valid.password.string"]; <i class="conum" data-value="37"></i><b>(37)</b>


CBLReplicator *_thisReplicator;
_thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="38"></i><b>(38)</b>

[_thisReplicator start]; <i class="conum" data-value="39"></i><b>(39)</b>

// end::replicator-simple[]




//
// Stuff I adapted
//


import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class cMyPassListener {
  // tag::listener-initialize[]
  // tag::listener-config-db[]
  // Initialize the listener config <i class="conum" data-value="40"></i><b>(40)</b>
  CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database];

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.port =  55990; <i class="conum" data-value="41"></i><b>(41)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    NSString *thisURL = @"10.1.1.10";
    thisConfig.networkInterface = thisURL; <i class="conum" data-value="42"></i><b>(42)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.enableDeltaSync = true; <i class="conum" data-value="43"></i><b>(43)</b>

    // end::listener-config-delta-sync[]
    // Configure server security
    // tag::listener-config-tls-enable[]
    thisConfig.disableTLS  = false; <i class="conum" data-value="44"></i><b>(44)</b>

    // end::listener-config-tls-enable[]

    // tag::listener-config-tls-id-anon[]
    // Use an anonymous self-signed cert
    thisConfig.tlsIdentity = nil; <i class="conum" data-value="45"></i><b>(45)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure Client Security using an Authenticator
    // For example, Basic Authentication <i class="conum" data-value="46"></i><b>(46)</b>
    thisConfig.authenticator =
      [[CBLListenerPasswordAuthenticator alloc]
        initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
          if ([self isValidCredentials: validUser password:validPassword]) {
              return  YES;
          }
          return NO;
      }];

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // tag::listener-init[]
    // Initialize the listener <i class="conum" data-value="47"></i><b>(47)</b>
    CBLURLEndpointListener* thisListener = nil;
    thisListener =
      [[CBLURLEndpointListener alloc] initWithConfig: thisConfig];

    // end::listener-init[]
    // start the listener <i class="conum" data-value="48"></i><b>(48)</b>
    BOOL success = [thisListener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }

    // end::listener-start[]
// end::listener-initialize[]
  } // end of class

// tag::listener-stop[]
    [thisListener stop];

// end::listener-stop[]

  }
}


// Additional Snippets

// tag::listener-get-network-interfaces[]
// . . .  code snippet to be provided

// end::listener-get-network-interfaces[]

// tag::listener-get-url-list[]
NSError* error = nil;
CBLURLEndpointListenerConfiguration* config =
  [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: self.otherDB];
CBLURLEndpointListener* listener =
  [[CBLURLEndpointListener alloc] initWithConfig: config];

[listener startWithError: &amp;error];

NSLog(@"%@", listener.urls);

// end::listener-get-url-list[]

// tag::listener-local-db[]
// . . . preceding application logic . . .
fileprivate  var _allowlistedCommonNames:[[String:String]] = []
fileprivate var _thisListener:URLEndpointListener?
fileprivate var thisDB:Database?
// Include websockets listener initializer code
// func fMyPassListener() {
CBLDatabase *thisDB = self.db;
// end::listener-local-db[]

// tag::listener-config-tls-full[]
  // Configure server authentication
  // tag::listener-config-tls-disable[]
  thisConfig.disableTLS  = true; <i class="conum" data-value="49"></i><b>(49)</b>

  // end::listener-config-tls-disable[]

  // EXAMPLE 6
  // tag::listener-config-tls-id-full[]
  // tag::listener-config-tls-id-caCert[]
  // Use CA Cert
  // Create a TLSIdentity from a key-pair and
  // certificate in secure storage
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="50"></i><b>(50)</b>

    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    CBLTLSIdentity* thisIdentity =
      [CBLTLSIdentity importIdentityWithData: data
        password: @"123"
        label: @"couchbase-docs-cert"
        error: &amp;error]; <i class="conum" data-value="51"></i><b>(51)</b>

    config.tlsIdentity = thisIdentity; <i class="conum" data-value="52"></i><b>(52)</b>

  // end::listener-config-tls-id-caCert[]
  // tag::listener-config-tls-id-SelfSigned[]
  // Use a self-signed certificate
  NSDictionary* attrs =
    @{ kCBLCertAttrCommonName: @"Couchbase Inc" }; <i class="conum" data-value="53"></i><b>(53)</b>

  thisIdentity =
    [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
              label: @" couchbase-docs-cert"
              error: &amp;error]; <i class="conum" data-value="54"></i><b>(54)</b>

  // end::listener-config-tls-id-SelfSigned[]
      // tag::listener-config-tls-id-set[]
  // set the TLS Identity
  thisConfig.tlsIdentity = thisIdentity; <i class="conum" data-value="55"></i><b>(55)</b>

  // end::listener-config-tls-id-set[]
  // end::listener-config-tls-id-full[]
// end::listener-config-tls-full[]

// EXAMPLE 8
// tag::listener-config-client-auth-root[]
// Configure the client authenticator
NSURL *certURL =
  [[NSBundle mainBundle]
    URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="56"></i><b>(56)</b>
NSData *data =
  [[NSData alloc]
    initWithContentsOfURL: certURL];
SecCertificateRef rootCertRef =
  SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

thisConfig.authenticator =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];  <i class="conum" data-value="57"></i><b>(57)</b> <i class="conum" data-value="58"></i><b>(58)</b>

// end::listener-config-client-auth-root[]
// tag::listener-config-client-auth-lambda[]
// Authenticate self-signed cert
// using application logic
CBLListenerCertificateAuthenticator* thisListenerAuth =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithBlock: ^BOOL(NSArray *certs) {
      SecCertificateRef cert =
        (__bridge SecCertificateRef)(certs[0]); <i class="conum" data-value="59"></i><b>(59)</b>
      CFStringRef cnRef;
      OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
      if (status == errSecSuccess) {
          NSString* cn = (NSString*)CFBridgingRelease(cnRef);
          if ([self._allowlistedCommonNames containsObject: cn])
              return YES;
      }
      return NO;
  }];  <i class="conum" data-value="60"></i><b>(60)</b>

thisConfig.authenticator = thisListenerAuth; <i class="conum" data-value="61"></i><b>(61)</b>

// end::listener-config-client-auth-lambda[]







// tag::xlistener-config-tls-disable[]
thisConfig.disableTLS  = true

// end::xlistener-config-tls-disable[]

// tag::listener-config-tls-id-nil[]
thisConfig.tlsIdentity = nil

// end::listener-config-tls-id-nil[]


// tag::old-listener-config-delta-sync[]
thisConfig.enableDeltaSync = true

// end::old-listener-config-delta-sync[]


// tag::listener-status-check[]
NSUInteger totalConnections = thisListener.status.connectionCount;
NSUInteger activeConnections = thisListener.status.activeConnectionCount;

// end::listener-status-check[]


// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  let rootCertData = SecCertificateCopyData(cert) as Data
  let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
  // Listener:
  thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

// end::old-listener-config-client-auth-root[]
/

// tag::listener-config-client-auth-self-signed[]
thisConfig.authenticator = ListenerCertificateAuthenticator.init {
  (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedCommonNames.contains(["name": certCommonName! as String])) {
        return true
    }
    return false
}

// end::listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}

// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
thisConfig.port = tls ? wssPort : wsPort
thisConfig.disableTLS = !tls
thisConfig.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>

// end::p2p-ws-api-urlendpointlistener-constructor[]


// Active Peer Connection Snippets

//
//  my Other Bits.swift
//  doco-sync
//
//  Created by Ian Bridge on 19/06/2020.
//  Copyright  2020 Couchbase Inc. All rights reserved.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class myActPeerClass {

  func fMyActPeer() {
    // let validUser = "syncthisUser"
    // let validPassword = "sync9455"
    // let cert:SecCertificate?
    // let passivePeerEndpoint = "10.1.1.12:8920"
    // let passivePeerPort = "8920"
    // let passiveDbName = "userdb"
    // var actDb:Database?
    // var thisReplicator:Replicator?
    // var replicatorListener:ListenerToken?

    CBLReplicator *_thisReplicator;

    CBLListenerToken *_thisListenerToken;

    CBLDatabase *database
      = [[CBLDatabase alloc] initWithName:@"thisDB" error:&amp;error];
        if (!database) {
          NSLog(@"Cannot open the database: %@", error);
        };

    // tag::p2p-act-rep-func[]
    // tag::p2p-act-rep-initialize[]
    // Set listener DB endpoint
    NSURL *url = [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
    CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

    CBLReplicatorConfiguration *thisConfig
      = [[CBLReplicatorConfiguration alloc]
          initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="62"></i><b>(62)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config[]
    // tag::p2p-act-rep-config-type[]
    thisConfig.replicatorType = kCBLReplicatorTypePush;

    // end::p2p-act-rep-config-type[]
    // tag::autopurge-override[]
    // set auto-purge behavior (here we override default)
    thisConfig.enableAutoPurge = NO; <i class="conum" data-value="63"></i><b>(63)</b>

    // end::autopurge-override[]
    // tag::p2p-act-rep-config-cont[]
    thisConfig.continuous = YES;

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Authentication
    // Here - expect and accept self-signed certs
    thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="64"></i><b>(64)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Authentication
    // tag::p2p-act-rep-auth[]
    // Here set client to use basic authentication
    // Providing username and password credentials
    // If prompted for them by server
    thisConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"Our Username" password:@"Our Password"]; <i class="conum" data-value="65"></i><b>(65)</b>

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    thisConfig.conflictResolver = [[LocalWinConflictResolver alloc] <i class="conum" data-value="66"></i><b>(66)</b>

    // end::p2p-act-rep-config-conflict[]    //
    // end::p2p-act-rep-config[]
    // tag::p2p-act-rep-start-full[]
    // Apply configuration settings to the replicator
    _thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="67"></i><b>(67)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    // Optionally add a change listener <i class="conum" data-value="68"></i><b>(68)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    // Retain token for use in deletion
    id&lt;CBLListenerToken&gt; thisListenerToken
      = [thisReplicator addChangeListener:^(CBLReplicatorChange *thisChange) {
    // tag::p2p-act-rep-status[]
          if (thisChange.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
            } else {
            NSLog(@"Status: %d", thisChange.status.activity);
            };
    // end::p2p-act-rep-status[]
        }];
// end::p2p-act-rep-add-change-listener[]
// tag::p2p-act-rep-start[]
    // Run the replicator using the config settings
    [thisReplicator start]; <i class="conum" data-value="69"></i><b>(69)</b>

// end::p2p-act-rep-start[]
// end::p2p-act-rep-start-full[]
// end::p2p-act-rep-func[]
    }

    func mystopfunc() {
// tag::p2p-act-rep-stop[]
    // Remove the change listener
    [thisReplicator removeChangeListenerWithToken: thisListenerToken];

    // Stop the replicator
    [thisReplicator stop];
// end::p2p-act-rep-stop[]
}

// Additional Snippets from above
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA Certs
    thisConfig.acceptOnlySelfSignedServerCertificate = NO; <i class="conum" data-value="70"></i><b>(70)</b>

    // end::p2p-act-rep-config-cacert[]


    // tag::p2p-act-rep-config-pinnedcert[]
    // Return the remote pinned cert (the listener's cert)
    thisConfig.pinnedServerCertificate = thisCert; // Get listener cert if pinned

    // end::p2p-act-rep-config-pinnedcert[]







// tag::p2p-tlsid-manage-func[]
//
//  cMyGetCert.swift
//  doco-sync
//
//  Created by Ian Bridge on 20/06/2020.
//  Copyright  2020 Couchbase Inc. All rights reserved.
//

import Foundation
import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity


class cMyGetCert1{

    let kListenerCertLabel = "doco-sync-server"
    let kListenerCertKeyP12File = "listener-cert-pkey"
    let kListenerPinnedCertFile = "listener-pinned-cert"
    let kListenerCertKeyExportPassword = "couchbase"
    //var importedItems : NSArray
    let thisData : CFData?
    var items : CFArray?

    func fMyGetCert() -&gt;TLSIdentity? {
        var kcStatus = errSecSuccess // Zero
        let thisLabel : String? = "doco-sync-server"

        //var thisData : CFData?
        // tag::p2p-tlsid-tlsidentity-with-label[]
        // tag::p2p-tlsid-check-keychain[]
        // Check if Id exists in keychain and if so, use it
        CBLTLSIdentity* identity =
          [CBLTLSIdentity identityWithLabel: @"doco-sync-server" error: &amp;error]; <i class="conum" data-value="71"></i><b>(71)</b>

        // end::p2p-tlsid-check-keychain[]
        thisConfig.authenticator =
          [[CBLClientCertificateAuthenticator alloc] initWithIdentity: identity]; <i class="conum" data-value="72"></i><b>(72)</b>

        // end::p2p-tlsid-tlsidentity-with-label[]


// tag::p2p-tlsid-check-bundled[]
// CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let pathToCert = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
                let thisData = NSData(contentsOfFile: pathToCert)
            else
                {return nil}
// end::p2p-tlsid-check-bundled[]

// tag::p2p-tlsid-import-from-bundled[]
        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        kcStatus = SecPKCS12Import(thisData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;items)
            if kcStatus != errSecSuccess {
             print("failed to import data from provided with error :\(kcStatus) ")
             return nil
            }
        let importedItems = items! as NSArray
        let thisItem = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let thisSecId = thisItem[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var thisPrivateKey : SecKey?
        kcStatus = SecIdentityCopyPrivateKey(thisSecId, &amp;thisPrivateKey)
            if kcStatus != errSecSuccess {
                print("failed to import private key from provided with error :\(kcStatus) ")
                return nil
            }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let thisCertChain = thisItem[String(kSecImportItemCertChain)] as? [SecCertificate]

        // Return nil Id if errors in key or cert chain at this stage
        guard let pKey = thisPrivateKey, let pubCerts = thisCertChain else {
            return nil
        }
// end::p2p-tlsid-import-from-bundled[]

// tag::p2p-tlsid-store-in-keychain[]
// STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN

        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       pKey
        ]
        kcStatus = SecItemAdd(params as CFDictionary, nil)
            if kcStatus != errSecSuccess {
                print("Unable to store private key")
                return nil
            }
       // Store all Certs for Id in Keychain:
       var i = 0;
       for cert in thisCertChain! {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
                ]
            kcStatus = SecItemAdd(params as CFDictionary, nil)
                if kcStatus != errSecSuccess {
                    print("Unable to store certs")
                    return nil
                }
            i=i+1
        }
// end::p2p-tlsid-store-in-keychain[]

// tag::p2p-tlsid-return-id-from-keychain[]
// RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
do {
    return try TLSIdentity.identity(withIdentity: thisSecId, certs: [pubCerts[0]])
} catch {
    print("Error while loading self signed cert : \(error)")
    return nil
}
// end::p2p-tlsid-return-id-from-keychain[]
    } // fMyGetCert
} // cMyGetCert


// tag::p2p-tlsid-delete-id-from-keychain[]

[CBLTLSIdentity deleteIdentityWithLabel:thisSecId error: &amp;error];

// end::p2p-tlsid-delete-id-from-keychain[]



// end::p2p-tlsid-manage-func[]



// tag::p2p-act-rep-config-cacert-pinned-func[]
func fMyCaCertPinned() {
  // do {
  let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
  let targetEndpoint = URLEndpoint(url: tgtUrl)
  let actDb:Database?
  let config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint)
  // tag::p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate =
      SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url =
      [NSURL URLWithString:@"ws://localhost:4984/db"];

    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *thisConfig =
      [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                          target:target];
    thisConfig.pinnedServerCertificate =
      (SecCertificateRef)CFAutorelease(certificate);

    thisConfig.acceptOnlySelfSignedServerCertificate=false;

  // end::p2p-act-rep-config-cacert-pinned[]
  // end::p2p-act-rep-config-cacert-pinned-func[]
}



// For replications

// BEGIN -- snippets --
//    Purpose -- code samples for use in replication topic

// tag::sgw-repl-pull[]
@interface MyClass : NSObject
@property (nonatomic) CBLDatabase *database;
@property (nonatomic) CBLReplicator *replicator; <i class="conum" data-value="1"></i><b>(1)</b>
@end

@implementation MyClass
@synthesize database=_database;
@synthesize replicator=_replicator;

- (void) startReplication {
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"]; <i class="conum" data-value="2"></i><b>(2)</b>
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:_database
                                                                                       target:target];
    config.replicatorType = kCBLReplicatorTypePull;
    _replicator = [[CBLReplicator alloc] initWithConfig:config];
    [_replicator start];
}
@end

// end::sgw-repl-pull[]

// tag::sgw-repl-pull-callouts[]
&lt;1&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;2&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
You should now use `ws:`, or `wss:` for SSL/TLS connections.


// end::sgw-repl-pull-callouts[]

// tag::sgw-act-rep-initialize[]
// Set listener DB endpoint
NSURL *url = [NSURL URLWithString:@"ws://10.0.2.2.com:55990/travel-sample"];
CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="73"></i><b>(73)</b>

// end::sgw-act-rep-initialize[]
// END -- snippets --</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>Use keychain identity in config</p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">//
//  SampleCodeTest.m
//  CouchbaseLite
//
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

#import &lt;UIKit/UIKit.h&gt;
#import &lt;CouchbaseLite/CouchbaseLite.h&gt;
#import &lt;CoreML/CoreML.h&gt;

// tag::predictive-model[]
// `myMLModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
@interface myMLModel : NSObject

+ (NSDictionary*)predictImage: (NSData*)data;

@end

@interface ImageClassifierModel : NSObject &lt;CBLPredictiveModel&gt;

- (nullable CBLDictionary*) predict: (CBLDictionary*)input;

@end

@implementation ImageClassifierModel

- (nullable CBLDictionary*) predict: (CBLDictionary*)input; {
    CBLBlob* blob = [input blobForKey:@"photo"];

    NSData* imageData = blob.content;
    // `myMLModel` is a fake implementation
    // this would be the implementation of the ml model you have chosen
    NSDictionary* modelOutput = [myMLModel predictImage:imageData];

    CBLMutableDictionary* output = [[CBLMutableDictionary alloc] initWithData: modelOutput];
    return output; <i class="conum" data-value="1"></i><b>(1)</b>
}

@end
// end::predictive-model[]

// to avoid link error
@implementation myMLModel
+ (NSDictionary*)predictImage: (NSData*)data { return [NSDictionary dictionary]; }
@end

// tag::custom-logging[]
@interface LogTestLogger : NSObject&lt;CBLLogger&gt;

// set the log level
@property (nonatomic) CBLLogLevel level;

@end

@implementation LogTestLogger

@synthesize level=_level;

- (void) logWithLevel: (CBLLogLevel)level domain: (CBLLogDomain)domain message: (NSString*)message {
    // handle the message, for example piping it to
    // a third party framework
}

@end

// end::custom-logging[]

// tag::local-win-conflict-resolver[]
@interface LocalWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation LocalWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.localDocument;
}

@end
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
@interface RemoteWinConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation RemoteWinConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    return conflict.remoteDocument;
}

@end
// end::remote-win-conflict-resolver[]


// tag::merge-conflict-resolver[]
@interface MergeConflictResolver: NSObject&lt;CBLConflictResolver&gt;
@end

@implementation MergeConflictResolver
- (CBLDocument*) resolve: (CBLConflict*)conflict {
    NSDictionary *localDict = conflict.localDocument.toDictionary;
    NSDictionary *remoteDict = conflict.remoteDocument.toDictionary;

    NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:localDict];
    [result addEntriesFromDictionary:remoteDict];

    return [[CBLMutableDocument alloc] initWithID:conflict.documentID
                                             data:result];
}

@end
// end::merge-conflict-resolver[]

@interface SampleCodeTest : NSObject
@property(nonatomic) CBLDatabase* db;
@property(nonatomic) NSArray* _allowlistedUsers;
@end

@implementation SampleCodeTest

#pragma mark - Database

- (void) dontTestNewDatabase {
    // tag::new-database[]
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::new-database[]

    // tag::close-database[]
    tbd

    // end::close-database[]


}

#if COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseEncryption {
    // tag::database-encryption[]
    CBLDatabaseConfiguration *config = [[CBLDatabaseConfiguration alloc] init];
    config.encryptionKey = [[CBLEncryptionKey alloc] initWithPassword:@"secretpassword"];

    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"my-database" config:config error:&amp;error];
    if (!database) {
        NSLog(@"Cannot open the database: %@", error);
    }
    // end::database-encryption[]
}
#endif

- (void) dontTestLogging {
    // tag::logging[]
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainReplicator];
    [CBLDatabase setLogLevel: kCBLLogLevelVerbose domain: kCBLLogDomainQuery];
    // end::logging[]
}

- (void) dontTestEnableConsoleLogging {
    // tag::console-logging[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll; <i class="conum" data-value="1"></i><b>(1)</b>
    CBLDatabase.log.console.level = kCBLLogLevelVerbose; <i class="conum" data-value="2"></i><b>(2)</b>

    // end::console-logging[]

    // tag::console-logging-db[]
    CBLDatabase.log.console.domains = kCBLLogDomainAll;

    // end::console-logging-db[]
}

- (void) dontTestFileLogging {
    // tag::file-logging[]
    NSString* tempFolder = [NSTemporaryDirectory() stringByAppendingPathComponent:@"cbllog"];
    CBLLogFileConfiguration* config = [[CBLLogFileConfiguration alloc] initWithDirectory:tempFolder]; <i class="conum" data-value="3"></i><b>(3)</b>
    config.maxRotateCount = 2; <i class="conum" data-value="4"></i><b>(4)</b>
    config.maxSize = 1024; <i class="conum" data-value="5"></i><b>(5)</b>
    config.usePlainText = YES; <i class="conum" data-value="6"></i><b>(6)</b>
    [CBLDatabase.log.file setConfig:config];
    [CBLDatabase.log.file setLevel: kCBLLogLevelInfo]; <i class="conum" data-value="7"></i><b>(7)</b>
    // end::file-logging[]
}

- (void) dontTestEnableCustomLogging {
    // tag::set-custom-logging[]
    [CBLDatabase.log setCustom:[[LogTestLogger alloc] initWithLogLevel: kCBLLogLevelWarning]];

    // end::set-custom-logging[]
}

- (void) dontTestLoadingPrebuilt {
    // tag::prebuilt-database[]
    // Note: Getting the path to a database is platform-specific.
    // For iOS you need to get the path from the main bundle.
    if (![CBLDatabase databaseExists:@"travel-sample" inDirectory:nil]) {
        NSError*error;
        NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@"travel-sample" ofType:@"cblite2"];
        if (![CBLDatabase copyFromPath:path toDatabase:@"travel-sample" withConfig:nil error:&amp;error]) {
            [NSException raise:NSInternalInconsistencyException
                        format:@"Could not load pre-built database: %@", error];
        }
    }
    // end::prebuilt-database[]
}

#pragma mark - Document

- (void) dontTestInitializer {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::initializer[]
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];
    [newTask setString:@"task" forKey:@"task"];
    [newTask setString:@"todo" forKey:@"owner"];
    [newTask setString:@"task" forKey:@"createdAt"];
    [database saveDocument:newTask error:&amp;error];
    // end::initializer[]
}

- (void) dontTestMutability {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];
    [database saveDocument:mutableDocument error:&amp;error];
    // end::update-document[]
}

- (void) dontTestTypedAcessors {
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] init];

    // tag::date-getter[]
    [newTask setValue:[NSDate date] forKey:@"createdAt"];
    NSDate *date = [newTask dateForKey:@"createdAt"];
    // end::date-getter[]

    NSLog(@"Date: %@", date);
}

- (void) dontTestBatchOperations {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::batch[]
    [database inBatch:&amp;error usingBlock:^{
        for (int i = 0; i &lt; 10; i++) {
            CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
            [doc setValue:@"user" forKey:@"type"];
            [doc setValue:[NSString stringWithFormat:@"user %d", i] forKey:@"name"];
            [doc setBoolean:NO forKey:@"admin"];
            [database saveDocument:doc error: &amp;error];
        }
    }];
    // end::batch[]
}

- (void) dontTestChangeListener {
    __weak CBLDatabase *database = self.db;

    // tag::document-listener[]
    [database addDocumentChangeListenerWithID: @"user.john" listener:^(CBLDocumentChange * change) {
        CBLDocument* document = [database documentWithID: change.documentID];
        NSLog(@"Status :: %@)", [document stringForKey: @"verified_account"]);
    }];
    // end::document-listener[]
}

- (void) dontTestDocumentExpiration {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::document-expiration[]
    // Purge the document one day from now
    NSDate* ttl = [[NSCalendar currentCalendar] dateByAddingUnit: NSCalendarUnitDay
                                                           value: 1
                                                          toDate: [NSDate date]
                                                         options: 0];
    [database setDocumentExpirationWithID:@"doc123" expiration:ttl error:&amp;error];

    // Reset expiration
    [database setDocumentExpirationWithID:@"doc1" expiration:nil error: &amp;error];

    // Query documents that will be expired in less than five minutes
    NSTimeInterval fiveMinutesFromNow = [[NSDate dateWithTimeIntervalSinceNow:60 * 5] timeIntervalSince1970];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression: [CBLQueryMeta id]]]
                                         from: [CBLQueryDataSource database: database]
                                        where: [[CBLQueryMeta expiration]
                                                lessThan: [CBLQueryExpression double: fiveMinutesFromNow]]];
    // end::document-expiration[]
    NSLog(@"%@", query);
}

- (void) dontTestBlob {
#if TARGET_OS_IPHONE
    NSError *error;
    CBLDatabase *database = self.db;
    CBLMutableDocument *newTask = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::blob[]
    UIImage *appleImage = [UIImage imageNamed:@"avatar.jpg"];
    NSData *imageData = UIImageJPEGRepresentation(appleImage, 1.0);

    CBLBlob *blob = [[CBLBlob alloc] initWithContentType:@"image/jpeg" data:imageData];
    [newTask setBlob:blob forKey:@"avatar"];
    [database saveDocument:newTask error:&amp;error];

    CBLDocument *savedTask = [database documentWithID: @"task1"];
    CBLBlob *taskBlob = [savedTask blobForKey:@"avatar"];
    UIImage *taskImage = [UIImage imageWithData:taskBlob.content];
    // end::blob[]

    NSLog(@"%@", taskImage);
#endif
}

- (void) dontTest1xAttachment {
    CBLMutableDocument *document = [[CBLMutableDocument alloc] initWithID:@"task1"];

    // tag::1x-attachment[]
    CBLDictionary *attachments = [document dictionaryForKey:@"_attachments"];
    CBLBlob *avatar = [attachments blobForKey:@"avatar"];
    NSData *content = [avatar content];
    // end::1x-attachment[]

    NSLog(@"%@", content);
}

#pragma mark - Query

- (void) dontTestIndexing {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-index[]
    CBLValueIndexItem *type = [CBLValueIndexItem property:@"type"];
    CBLValueIndexItem *name = [CBLValueIndexItem property:@"name"];
    CBLIndex* index = [CBLIndexBuilder valueIndexWithItems:@[type, name]];
    [database createIndex:index withName:@"TypeNameIndex" error:&amp;error];
    // end::query-index[]
}

- (void) dontTestSelect {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-select-meta[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuery *query = [CBLQueryBuilder select:@[name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression value:@"user"]] andExpression:
                                               [[CBLQueryExpression property:@"admin"] equalTo:[CBLQueryExpression boolean:NO]]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"user name :: %@", [result stringAtIndex:0]);
    }
    // end::query-select-meta[]
}

- (void) dontTestSelectAll {
    CBLDatabase *database = self.db;

    // tag::query-select-all[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];
    // end::query-select-all[]

    NSLog(@"%@", query);
}

- (void) dontTestLiveQuery {
    NSError* error;
    CBLDatabase *database = self.db;

    // tag::live-query[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]];

    // Adds a query change listener.
    // Changes will be posted on the main queue.
    id&lt;CBLListenerToken&gt; token = [query addChangeListener:^(CBLQueryChange * _Nonnull change) // &lt;.&gt;{
        for (CBLQueryResultSet *result in [change results]) {
            NSLog(@"%@", result);
            /* Update UI */
        }
    }];

    // Start live query.
    [query execute: &amp;error]; <i class="conum" data-value="8"></i><b>(8)</b>
    // end::live-query[]

    // tag::stop-live-query[]
    [query removeChangeListenerWithToken:token]; <i class="conum" data-value="9"></i><b>(9)</b>
    // end::stop-live-query[]
}

- (void) dontTestWhere {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-where[]
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:[CBLQueryLimit limit:[CBLQueryExpression integer:10]]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        CBLDictionary *dict = [result valueForKey:@"travel-sample"];
        NSLog(@"document name :: %@", [dict stringForKey:@"name"]);
    }
    // end::query-where[]

    NSLog(@"%@", query);
}

- (void) dontTestQueryDeletedDocuments {
    CBLDatabase* database = self.db;

    // tag::query-deleted-documents[]
    // Query documents that have been deleted
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult expression:CBLQueryMeta.id]]
                                         from: [CBLQueryDataSource database:database]
                                        where: CBLQueryMeta.isDeleted];
    // end::query-deleted-documents[]
    NSLog(@"%@", query);
}

- (void) dontTestCollectionOperatorContains {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-contains[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];
    CBLQuerySelectResult *likes = [CBLQuerySelectResult property:@"public_likes"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]];
    CBLQueryExpression *contains = [CBLQueryArrayFunction contains:[CBLQueryExpression property:@"public_likes"]
                                                             value:[CBLQueryExpression string:@"Armani Langworth"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name, likes]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: contains]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"public_likes :: %@", [[result arrayForKey:@"public_likes"] toArray]);
    }
    // end::query-collection-operator-contains[]
}

- (void) dontTestCollectionOperatorIn {
    CBLDatabase *database = self.db;

    // tag::query-collection-operator-in[]
    NSArray *values = @[[CBLQueryExpression property:@"first"],
                       [CBLQueryExpression property:@"last"],
                       [CBLQueryExpression property:@"username"]];

    [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                       from:[CBLQueryDataSource database:database]
                      where:[[CBLQueryExpression string:@"Armani"] in:values]];
    // end::query-collection-operator-in[]
}

- (void) dontTestLikeOperator {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::query-like-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"royal engineers museum"]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"name property :: %@", [result stringForKey:@"name"]);
    }
    // end::query-like-operator[]
}

- (void) dontTestWildCardMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryFunction lower:[CBLQueryExpression property:@"name"]] like:[CBLQueryExpression string:@"eng%e%"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-match[]

    NSLog(@"%@", query);
}

- (void) dontTestWildCardCharacterMatch {
    CBLDatabase *database = self.db;

    // tag::query-like-operator-wildcard-character-match[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *like = [[CBLQueryExpression property:@"name"] like:[CBLQueryExpression string:@"eng____r"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, country, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: like]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-like-operator-wildcard-character-match[]

    NSLog(@"%@", query);
}

- (void) dontTestRegexMatch {
    CBLDatabase *database = self.db;

    // tag::query-regex-operator[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"landmark"]];
    CBLQueryExpression *regex = [[CBLQueryExpression property:@"name"] regex:[CBLQueryExpression string:@"\\bEng.*e\\b"]];

    CBLQueryLimit *limit = [CBLQueryLimit limit:[CBLQueryExpression integer:10]];

    CBLQuery *query = [CBLQueryBuilder select:@[id, name]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: regex]
                                      groupBy:nil having:nil orderBy:nil
                                        limit:limit];
    // end::query-regex-operator[]

    NSLog(@"%@", query);
}

- (void) dontTestJoin {
    CBLDatabase *database = self.db;

    // tag::query-join[]
    CBLQuerySelectResult *name = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"name" from:@"airline"]];
    CBLQuerySelectResult *callsign = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"callsign" from:@"airline"]];
    CBLQuerySelectResult *dest = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"destinationairport" from:@"route"]];
    CBLQuerySelectResult *stops = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"stops" from:@"route"]];
    CBLQuerySelectResult *airline = [CBLQuerySelectResult expression:[CBLQueryExpression property:@"airline" from:@"route"]];

    CBLQueryJoin *join = [CBLQueryJoin join:[CBLQueryDataSource database:database as:@"route"]
                                         on:[[CBLQueryMeta idFrom:@"airline"] equalTo:[CBLQueryExpression property:@"airlineid" from:@"route"]]];

    CBLQueryExpression *typeRoute = [[CBLQueryExpression property:@"type" from:@"route"] equalTo:[CBLQueryExpression string:@"route"]];
    CBLQueryExpression *typeAirline = [[CBLQueryExpression property:@"type" from:@"airline"] equalTo:[CBLQueryExpression string:@"airline"]];
    CBLQueryExpression *sourceRIX = [[CBLQueryExpression property:@"sourceairport" from:@"route"] equalTo:[CBLQueryExpression string:@"RIX"]];

    CBLQuery *query = [CBLQueryBuilder select:@[name, callsign, dest, stops, airline]
                                         from:[CBLQueryDataSource database:database as:@"airline"]
                                         join:@[join]
                                        where:[[typeRoute andExpression:typeAirline] andExpression:sourceRIX]];
    // end::query-join[]

    NSLog(@"%@", query);
}

- (void) dontTestGroupBy {
    CBLDatabase *database = self.db;

    // tag::query-groupby[]
    CBLQuerySelectResult *count = [CBLQuerySelectResult expression:[CBLQueryFunction count:[CBLQueryExpression all]]];
    CBLQuerySelectResult *country = [CBLQuerySelectResult property:@"country"];
    CBLQuerySelectResult *tz = [CBLQuerySelectResult property:@"tz"];

    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"airport"]];
    CBLQueryExpression *geoAlt = [[CBLQueryExpression property:@"geo.alt"] greaterThanOrEqualTo:[CBLQueryExpression integer:300]];

    CBLQuery *query = [CBLQueryBuilder select:@[count, country, tz]
                                         from:[CBLQueryDataSource database:database]
                                        where:[type andExpression: geoAlt]
                                      groupBy:@[[CBLQueryExpression property:@"country"],
                                                [CBLQueryExpression property:@"tz"]]];
    // end::query-groupby[]

    NSLog(@"%@", query);
}

- (void) dontTestOrderBy {
    CBLDatabase *database = self.db;

    // tag::query-orderby[]
    CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];
    CBLQuerySelectResult *title = [CBLQuerySelectResult property:@"title"];

    CBLQuery *query = [CBLQueryBuilder select:@[id, title]
                                         from:[CBLQueryDataSource database:database]
                                        where:[[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"hotel"]]
                                      orderBy:@[[[CBLQueryOrdering property:@"title"] descending]]];
    // end::query-orderby[]

    NSLog(@"%@", query);
}


- (void) dontTestExplainAll {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-all[]
    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[[CBLQueryExpression property:@"type"]
                   equalTo:[CBLQueryExpression string:@"university"]]
//            groupBy:@[[CBLQueryExpression property:@"country"]] <i class="conum" data-value="10"></i><b>(10)</b>
                          orderBy:@[[[CBLQueryOrdering property:@"title"] descending]] <i class="conum" data-value="11"></i><b>(11)</b>
       ];

    NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="12"></i><b>(12)</b>

      // end::query-explain-all[]
}
- (void) dontTestExplainLike {
    CBLDatabase *database = self.db;
    NSError *error;
    // tag::query-explain-like[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"%hotel%"]];
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];
      NSLog(@"%@", [query explain:&amp;error]); <i class="conum" data-value="13"></i><b>(13)</b>

      // end::query-explain-like[]

}
- (void) dontTestExplainNoPfx {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-nopfx[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            like:[CBLQueryExpression string:@"hotel%"]]; <i class="conum" data-value="14"></i><b>(14)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-nopfx[]
}

- (void) dontTestExplainFunction {
    CBLDatabase *database = self.db;
    NSError *error;

    // tag::query-explain-function[]
    CBLQueryExpression *type =
        [[CBLQueryFunction lower:[CBLQueryExpression property:@"type"]]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="15"></i><b>(15)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
                from:[CBLQueryDataSource database:database]
                where:[type andExpression: name]];

    NSLog(@"%@", [query explain:&amp;error]);

    // end::query-explain-function[]
}

- (void) dontTestExplainNoFunction {
    CBLDatabase *database = self.db;
    NSError *error;
      // tag::query-explain-nofunction[]
    CBLQueryExpression *type =
        [[CBLQueryExpression property:@"type"]
            equalTo:[CBLQueryExpression string:@"hotel"]]; <i class="conum" data-value="16"></i><b>(16)</b>
    CBLQueryExpression *name =
        [[CBLQueryExpression property:@"name"]
            like:[CBLQueryExpression string:@"%royal%"]];

    CBLQuery *query =
        [CBLQueryBuilder
            select:@[[CBLQuerySelectResult all]]
            from:[CBLQueryDataSource database:database]
            where:[type andExpression: name]
        ];

    NSLog(@"%@", [query explain:&amp;error]);

      // end::query-explain-nofunction[]

}



- (void) dontTestCreateFullTextIndex {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-index[]
    // Insert documents
    NSArray *tasks = @[@"buy groceries", @"play chess", @"book travels", @"buy museum tickets"];
    for (NSString *task in tasks) {
        CBLMutableDocument *doc = [[CBLMutableDocument alloc] init];
        [doc setString:@"task" forKey:@"type"];
        [doc setString:task forKey:@"name"];
        [database saveDocument:doc error:&amp;error];
    }

    // Create index
    CBLFullTextIndex *index = [CBLIndexBuilder fullTextIndexWithItems:@[[CBLFullTextIndexItem property:@"name"]]];
    index.ignoreAccents = NO;
    [database createIndex:index withName:@"nameFTSIndex" error:&amp;error];
    // end::fts-index[]
}

- (void) dontTestFullTextSearch {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::fts-query[]
    CBLQueryExpression *where =
      [[CBLQueryFullTextExpression indexWithName:@"nameFTSIndex"] match:@"'buy'"];
    CBLQuery *query =
      [CBLQueryBuilder
        select:@[[CBLQuerySelectResult expression:[CBLQueryMeta id]]]
        from:[CBLQueryDataSource database:database]
        where:where];

    NSEnumerator* rs = [query execute:&amp;error];
    for (CBLQueryResult *result in rs) {
        NSLog(@"document id %@", [result stringAtIndex:0]);
    }
    // end::fts-query[]
}

#pragma mark - Replication

/* The `tag::replication[]` example is inlined in objc.adoc */

- (void) dontTestEnableReplicatorLogging {
    // tag::replication-logging[]
    // Replicator
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainReplicator];
    // Network
    [CBLDatabase setLogLevel:kCBLLogLevelVerbose domain:kCBLLogDomainNetwork];
    // end::replication-logging[]
}

- (void) dontTestReplicationBasicAuthentication {
    CBLDatabase *database = self.db;
    // tag::basic-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::basic-authentication[]
}

- (void) dontTestReplicationSessionAuthentication {
    CBLDatabase *database = self.db;
    // tag::session-authentication[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.authenticator = [[CBLSessionAuthenticator alloc] initWithSessionID:@"904ac010862f37c8dd99015a33ab5a3565fd8447"];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::session-authentication[]
}

- (void) dontTestReplicatorStatus {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-status[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
        }
    }];
    // end::replication-status[]
}


//  BEGIN PendingDocuments IB -- 11/Feb/21 --
//    public void testReplicationPendingDocs() throws URISyntaxException {
      // tag::replication-pendingdocuments[]

      CBLDatabase *database = self.db;
      NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
      CBLURLEndpoint *target =
        [[CBLURLEndpoint alloc] initWithURL: url];
      CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc]
          initWithDatabase:database
          target:target];

      config.replicatorType = kCBLReplicatorTypePush;

      // tag::replication-push-pendingdocumentids[]
      CBLReplicator *replicator =
        [[CBLReplicator alloc] initWithConfig:config];

      // Get list of pending doc IDs
      NSError* err = nil;
      NSSet *mydocids =
        [NSSet setWithSet:[replicator pendingDocumentIDs:&amp;err]]; <i class="conum" data-value="17"></i><b>(17)</b>

      // end::replication-push-pendingdocumentids[]

      if ([mydocids count] &gt; 0) {

        NSLog(@"There are %lu documents pending", (unsigned long)[mydocids count]);

        [replicator addChangeListener:^(CBLReplicatorChange *change) {

          NSLog(@"Replicator activity level is %u", change.status.activity);
          // iterate and report-on the pending doc IDs  in 'mydocids'
          for (thisid in mydocids) {

            // tag::replication-push-isdocumentpending[]
            NSError* err = nil;
            if (![replicator isDocumentPending: thisid error: &amp;err]) { <i class="conum" data-value="18"></i><b>(18)</b>
              NSLog(@"Doc ID %@ now pushed", thisid);
            }
            // end::replication-push-isdocumentpending[]
          }

        }];
        [replicator start];

      };

      // end::replication-pendingdocuments[]
    }
//  END PendingDocuments IB -- 11/Feb/21 --



- (void) dontTestReplicatorDocumentEvent {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::add-document-replication-listener[]
    id token = [replicator addDocumentReplicationListener:^(CBLDocumentReplication * _Nonnull replication) {
        NSLog(@"Replication type :: %@", replication.isPush ? @"Push" : @"Pull");
        for (CBLReplicatedDocument* document in replication.documents) {
            if (document.error == nil) {
                NSLog(@"Doc ID :: %@", document.id);
                if ((document.flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
                    NSLog(@"Successfully replicated a deleted document");
                }
            } else {
                // There was an error
            }
        }
    }];

    [replicator start];
    // end::add-document-replication-listener[]

    // tag::remove-document-replication-listener[]
    [replicator removeChangeListenerWithToken: token];
    // end::remove-document-replication-listener[]
}

- (void) dontTestCustomReplicationHeader {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *endpoint = [[CBLURLEndpoint alloc] initWithURL:url];

    // tag::replication-custom-header[]
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:endpoint];
    config.headers = @{@"CustomHeaderName" : @"Value"};
    // end::replication-custom-header[]
}

- (void) dontTestHandlingReplicationError {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-error-handling[]
    [replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];
    // end::replication-error-handling[]
}

- (void) dontTestReplicationResetCheckpoint {
    CBLDatabase *database = self.db;
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];

    // tag::replication-reset-checkpoint[]
    [replicator resetCheckpoint];
    [replicator start];
    // end::replication-reset-checkpoint[]
}

- (void) dontTestReplicationPushFilter {
    CBLDatabase *database = self.db;

    // tag::replication-push-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pushFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ([[document stringForKey: @"type"] isEqualToString: @"draft"]) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-push-filter[]
}

- (void) dontTestReplicationPullFilter {
    CBLDatabase *database = self.db;

    // tag::replication-pull-filter[]
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.pullFilter = ^BOOL(CBLDocument * _Nonnull document, CBLDocumentFlags flags) { <i class="conum" data-value="1"></i><b>(1)</b>
        if ((flags &amp; kCBLDocumentFlagsDeleted) == kCBLDocumentFlagsDeleted) {
            return false;
        }
        return true;
    };

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-pull-filter[]
}

//  Added 2/Feb/21 - Ian Bridge
    - void dontTestCustomRetryConfig {
        // tag::replication-retry-config[]
        id target =
          [[CBLURLEndpoint alloc] initWithURL: [NSURL URLWithString: @"ws://foo.cbl.com/db"]];

        CBLReplicatorConfiguration* config =
            [[CBLReplicatorConfiguration alloc] initWithDatabase: db target: target];
        config.type = kCBLReplicatorTypePush;
        config.continuous: YES;
        //  other config as required . . .

        // tag::replication-heartbeat[]
        config.heartbeat = 150; <i class="conum" data-value="19"></i><b>(19)</b>

        // end::replication-heartbeat[]
        // tag::replication-maxretries[]
        config.maxretries = 20; <i class="conum" data-value="20"></i><b>(20)</b>

        // end::replication-maxretries[]
        // tag::replication-maxretrywaittime[]
        config.maxretrywaittime = 600; <i class="conum" data-value="21"></i><b>(21)</b>

        // end::replication-maxretrywaittime[]
        //  other config as required . . .
        repl = [[CBLReplicator alloc] initWithConfig: config];

        // Cleanup:
        repl = nil;

        // end::replication-retry-config[]

    }


#ifdef COUCHBASE_ENTERPRISE
- (void) dontTestDatabaseReplica {
    CBLDatabase *database = self.db;
    CBLDatabase *database2 = self.db;

    /* EE feature: code below might throw a compilation error
     if it's compiled against CBL Swift Community. */
    // tag::database-replica[]
    CBLDatabaseEndpoint *targetDatabase = [[CBLDatabaseEndpoint alloc] initWithDatabase:database2];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetDatabase];
    config.replicatorType = kCBLReplicatorTypePush;

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::database-replica[]
}
#endif

- (void) dontTestCertificatePinning {
    CBLDatabase *database = self.db;
    // Active - Example 4
    // tag::certificate-pinning[]
    // tag=p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                                                                       target:target];
    config.pinnedServerCertificate = (SecCertificateRef)CFAutorelease(certificate);

    // end=p2p-act-rep-config-cacert-pinned[]
    // end::certificate-pinning[]

    NSLog(@"%@", config);
}

- (NSData*) dataFromResource: (NSString*)file ofType: (NSString*)type {
    return [NSData data];
}

- (void) dontTestGettingStarted {
    CBLReplicator *_replicator;
    // tag::getting-started[]
    // Get the database (and create it if it doesnt exist).
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // Create a new document (i.e. a record) in the database.
    CBLMutableDocument *mutableDoc = [[CBLMutableDocument alloc] init];
    [mutableDoc setFloat:2.0 forKey:@"version"];
    [mutableDoc setString:@"SDK" forKey:@"type"];

    // Save it to the database.
    [database saveDocument:mutableDoc error:&amp;error];

    // Update a document.
    CBLMutableDocument *mutableDoc2 = [[database documentWithID:mutableDoc.id] toMutable];
    [mutableDoc2 setString:@"Swift" forKey:@"language"];
    [database saveDocument:mutableDoc2 error:&amp;error];

    CBLDocument *document = [database documentWithID:mutableDoc2.id];
    // Log the document ID (generated by the database)
    // and properties
    NSLog(@"Document ID :: %@", document.id);
    NSLog(@"Learning %@", [document stringForKey:@"language"]);

    // Create a query to fetch documents of type SDK.
    CBLQueryExpression *type = [[CBLQueryExpression property:@"type"] equalTo:[CBLQueryExpression string:@"SDK"]];
    CBLQuery *query = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                          from:[CBLQueryDataSource database:database]
                                         where:type];

    // Run the query
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);

    // Create replicators to push and pull changes to and from the cloud.
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *targetEndpoint = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *replConfig = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:targetEndpoint];
    replConfig.replicatorType = kCBLReplicatorTypePushAndPull;

    // Add authentication.
    replConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"john" password:@"pass"];

    // Create replicator (make sure to add an instance or static variable named _replicator)
    _replicator = [[CBLReplicator alloc] initWithConfig:replConfig];

    // Listen to replicator change events.
    [_replicator addChangeListener:^(CBLReplicatorChange *change) {
        if (change.status.error) {
            NSLog(@"Error code: %ld", change.status.error.code);
        }
    }];

    // Start replication
    [_replicator start];
    // end::getting-started[]
}

- (void) dontTestPredictiveModel {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::register-model[]
    ImageClassifierModel* model = [[ImageClassifierModel alloc] init];
    [[CBLDatabase prediction] registerModel:model withName:@"ImageClassifier"];
    // end::register-model[]

    // tag::predictive-query-value-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input];

    CBLValueIndex* index = [CBLIndexBuilder valueIndexWithItems:@[[CBLValueIndexItem expression:[prediction property:@"label"]]]];
    [database createIndex:index withName:@"value-index-image-classifier" error:&amp;error];
    // end::predictive-query-value-index[]

    // tag::unregister-model[]
    [[CBLDatabase prediction] unregisterModelWithName:@"ImageClassifier"];
    // end::unregister-model[]
}

- (void) dontTestPredictiveIndex {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query-predictive-index[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary:@{@"photo":[CBLQueryExpression property:@"photo"]}];

    CBLPredictiveIndex* index = [CBLIndexBuilder predictiveIndexWithModel:@"ImageClassifier" input:input properties:nil];
    [database createIndex:index withName:@"predictive-index-image-classifier" error:&amp;error];
    // end::predictive-query-predictive-index[]
}

- (void) dontTestPredictiveQuery {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::predictive-query[]
    CBLQueryExpression* input = [CBLQueryExpression dictionary: @{@"photo":[CBLQueryExpression property:@"photo"]}];
    CBLQueryPredictionFunction* prediction = [CBLQueryFunction predictionUsingModel:@"ImageClassifier" input:input]; <i class="conum" data-value="1"></i><b>(1)</b>

    CBLQueryExpression* condition = [[[prediction property:@"label"] equalTo:[CBLQueryExpression string:@"car"]]
                                     andExpression:[[prediction property:@"probablity"] greaterThanOrEqualTo:[CBLQueryExpression double:0.8]]];
    CBLQuery* query = [CBLQueryBuilder select: @[[CBLQuerySelectResult all]]
                                         from: [CBLQueryDataSource database:database]
                                        where: condition];

    // Run the query.
    CBLQueryResultSet *result = [query execute:&amp;error];
    NSLog(@"Number of rows :: %lu", (unsigned long)[[result allResults] count]);
    // end::predictive-query[]
}

- (void) dontTestCoreMLPredictiveModel {
    NSError *error;

    // tag::coreml-predictive-model[]
    // Load MLModel from `ImageClassifier.mlmodel`
    NSURL* modelURL = [[NSBundle mainBundle] URLForResource:@"ImageClassifier" withExtension:@"mlmodel"];
    NSURL* compiledModelURL = [MLModel compileModelAtURL:modelURL error:&amp;error];
    MLModel* model = [MLModel modelWithContentsOfURL:compiledModelURL error:&amp;error];
    CBLCoreMLPredictiveModel* predictiveModel = [[CBLCoreMLPredictiveModel alloc] initWithMLModel:model];

    // Register model
    [[CBLDatabase prediction] registerModel:predictiveModel withName:@"ImageClassifier"];
    // end::coreml-predictive-model[]
}

- (void) dontTestReplicatorConflictResolver {
    NSError *error;
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&amp;error];

    // tag::replication-conflict-resolver[]
    NSURL *url = [[NSURL alloc] initWithString:@"ws://localhost:4984/getting-started-db"];
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL:url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:database target:target];
    config.conflictResolver = [[LocalWinConflictResolver alloc] init];

    CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:config];
    [replicator start];
    // end::replication-conflict-resolver[]
}

- (void) dontTestSaveWithConflictHandler {
    NSError *error;
    CBLDatabase *database = self.db;

    // tag::update-document-with-conflict-handler[]
    CBLDocument *document = [database documentWithID:@"xyz"];
    CBLMutableDocument *mutableDocument = [document toMutable];
    [mutableDocument setString:@"apples" forKey:@"name"];

    [database saveDocument:mutableDocument
           conflictHandler:^BOOL(CBLMutableDocument *new, CBLDocument *current) {
               NSDictionary *currentDict = current.toDictionary;
               NSDictionary *newDict = new.toDictionary;

               NSMutableDictionary *result = [NSMutableDictionary dictionaryWithDictionary:currentDict];
               [result addEntriesFromDictionary:newDict];
               [new setData: result];
               return YES;
           }
                     error: &amp;error];
    // end::update-document-with-conflict-handler[]
}

#pragma mark - URLListener

- (BOOL) isValidCredentials: (NSString*)u password: (NSString*)p { return YES; } // helper
- (void) dontTestInitListener {
    CBLDatabase *database = self.db;
    CBLURLEndpointListener* listener = nil;

    // tag::init-urllistener[]
    CBLURLEndpointListenerConfiguration* config;
    config = [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: database];
    config.tlsIdentity = nil; // Use with anonymous self signed cert
    config.authenticator =
        [[CBLListenerPasswordAuthenticator alloc]
            initWithBlock: ^BOOL(
                NSString * username,
                NSString * password)
                {
                if ([self isValidCredentials: username password:password]) {
                    return  YES;
                }
                return NO;
            }];

    listener = [[CBLURLEndpointListener alloc] initWithConfig: config];
    // end::init-urllistener[]
}

- (void) dontTestListenerStart {
    NSError* error = nil;
    CBLURLEndpointListener* listener = nil;

    // tag::start-urllistener[]
    BOOL success = [listener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }
    // end::start-urllistener[]
}

- (void) dontTestListenerStop {
    CBLURLEndpointListener* listener = nil;

    // tag::stop-urllistener[]
    [listener stop];
    // end::stop-urllistener[]
}

- (void) dontTestCreateSelfSignedCert {
    NSError* error = nil;
    CBLTLSIdentity* identity = nil;
    // &lt;site-rooot&gt;/objc/advance/objc-p2psync-websocket-using-passive.html
    // Example-6
    // tag::create-self-signed-cert[]
    // tag::listener-config-tls-id-SelfSigned[]

    NSDictionary* attrs = @{ kCBLCertAttrCommonName: @"Couchbase Inc" };
    identity =
      [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
        label: @"Server-Cert-Label"
        error: &amp;error];
    // end::listener-config-tls-id-SelfSigned[]
    // end::create-self-signed-cert[]
}

- (void) dontTestListenerCertificateAuthenticatorRootCert {
    CBLURLEndpointListenerConfiguration* config;

    // Example 8-tab1
    // tag::listener-certificate-authenticator-root-urllistener[]
    // tag::listener-config-client-auth-root[]

    NSURL *certURL = [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data = [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef rootCertRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    config.authenticator = [[CBLListenerCertificateAuthenticator alloc]
                            initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];
    // end::listener-config-client-auth-root[]
    // end::listener-certificate-authenticator-root-urllistener[]
}

- (void) dontTestListenerCertificateAuthenticatorCallback {
    CBLURLEndpointListenerConfiguration* config;
    // Example 8-tab2
    // tag::listener-certificate-authenticator-callback-urllistener[]
    // tag::listener-config-client-auth-lambda[]

    CBLListenerCertificateAuthenticator* listenerAuth =
    [[CBLListenerCertificateAuthenticator alloc] initWithBlock: ^BOOL(NSArray *certs) {
        SecCertificateRef cert = (__bridge SecCertificateRef)(certs[0]);
        CFStringRef cnRef;
        OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
        if (status == errSecSuccess) {
            NSString* cn = (NSString*)CFBridgingRelease(cnRef);
            if ([self._allowlistedUsers containsObject: cn])
                return YES;
        }
        return NO;
    }];

    config.authenticator = listenerAuth;
    // end::listener-config-client-auth-lambda[]
    // end::listener-certificate-authenticator-callback-urllistener[]
}

@end

#pragma mark -

// Singleton Pattern
// &lt;doc&gt;
@interface DataManager : NSObject

@property (nonatomic, readonly) CBLDatabase *database;

+ (id)sharedInstance;

@end

@implementation DataManager

@synthesize database=_database;

+ (id)sharedInstance {
    static DataManager *sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}

- (id)init {
    if (self = [super init]) {
        NSError *error;
        _database = [[CBLDatabase alloc] initWithName:@"dbname" error:&amp;error];
        if (!_database) {
            NSLog(@"Cannot open the database: %@", error);
            return nil;
        }
    }
    return self;
}

@end
// &lt;doc&gt;

// Peer-to-Peer Sample

/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface ActivePeer: NSObject &lt;CBLMessageEndpointDelegate&gt;

@end

@interface ActivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation ActivePeer

- (instancetype) init {
    self = [super init];
    if (self) {
        // tag::message-endpoint[]
        CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"dbname" error: &amp;error];

        // The delegate must implement the `CBLMessageEndpointDelegate` protocol.
        NSString* id = @"";
        CBLMessageEndpoint *endpoint =
        [[CBLMessageEndpoint alloc] initWithUID:@"UID:123"
                                         target:id
                                   protocolType:kCBLProtocolTypeMessageStream
                                       delegate:self];
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        CBLReplicatorConfiguration *config =
        [[CBLReplicatorConfiguration alloc] initWithDatabase:database target: endpoint];

        // Create the replicator object.
        CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig: config];
        [replicator start];
        // end::message-endpoint-replicator[]
    }
    return self;
}

// tag::create-connection[]
- (id&lt;CBLMessageEndpointConnection&gt;)createConnectionForEndpoint:(CBLMessageEndpoint *)endpoint {
    return [[ActivePeerConnection alloc] init];
}
// end::create-connection[]

@end


@implementation ActivePeerConnection {
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)disconnect {
    // tag::active-replicator-close[]
    [_replicatorConnection close:nil];
    // end::active-replicator-close[]
}

// tag::active-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::active-peer-open[]

// tag::active-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::active-peer-send[]

- (void)receive:(NSData*)data {
    // tag::active-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::active-peer-receive[]
}

// tag::active-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::active-peer-close[]

@end

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ---------------  stubs for documentation  ----------------- */
/* ----------------------------------------------------------- */
@interface PassivePeerConnection: NSObject &lt;CBLMessageEndpointConnection&gt;
- (void)startListener;
- (void)stopListener;
- (void)disconnect;
- (void)receive:(NSData*)data;
@end

@implementation PassivePeerConnection {
    CBLMessageEndpointListener *_messageEndpointListener;
    id &lt;CBLReplicatorConnection&gt; _replicatorConnection;
}

- (void)startListener {
    // tag::listener[]
    CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error: &amp;error];

    CBLMessageEndpointListenerConfiguration *config =
    [[CBLMessageEndpointListenerConfiguration alloc] initWithDatabase:database
                                                         protocolType:kCBLProtocolTypeMessageStream];
    _messageEndpointListener = [[CBLMessageEndpointListener alloc] initWithConfig:config];
    // end::listener[]
}

- (void)stopListener {
    // tag::passive-stop-listener[]
    [_messageEndpointListener closeAll];
    // end::passive-stop-listener[]
}

- (void)acceptConnection {
    // tag::advertizer-accept[]
    PassivePeerConnection *connection = [[PassivePeerConnection alloc] init]; /* implements CBLMessageEndpointConnection */
    [_messageEndpointListener accept: connection];
    // end::advertizer-accept[]
}

- (void)disconnect {
    // tag::passive-replicator-close[]
    [_replicatorConnection close:nil];
    // end::passive-replicator-close[]
}

// tag::passive-peer-open[]
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id&lt;CBLReplicatorConnection&gt;)connection completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
// end::passive-peer-open[]

// tag::passive-peer-send[]
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError * _Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
// end::passive-peer-send[]

- (void)receive:(NSData*)data {
    // tag::passive-peer-receive[]
    CBLMessage *message = [CBLMessage fromData:data];
    [_replicatorConnection receive:message];
    // end::passive-peer-receive[]
}

// tag::passive-peer-close[]
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
// end::passive-peer-close[]
@end



// QUERY RESULT SET HANDLING EXAMPLES
- (void) dontTestQuerySyntaxJson {
    // tag::query-syntax-all[]
    NSError *error;

    CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

    CBLQuery *listQuery = [CBLQueryBuilder select:@[[CBLQuerySelectResult all]]
                                             from:[CBLQueryDataSource database:db]]; <i class="conum" data-value="22"></i><b>(22)</b>

    // end::query-syntax-all[]


    // tag::query-access-all[]
        NSMutableArray* matches =
          [[NSMutableArray alloc] init];

        CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

        for (CBLQueryResult *result in resultset.allResults) { // access the resultSet.allResults

            NSDictionary *match = [result valueAtIndex: 0] ;
//             toDictionary];

            // Store dictionary in array
            [matches addObject: match];

            // Use dictionary values
            NSLog(@"id = %@", [match valueForKey:@"id"]);
            NSLog(@"name = %@", [match valueForKey:@"name"]);
            NSLog(@"type = %@", [match valueForKey:@"type"]);
            NSLog(@"city = %@", [match valueForKey:@"city"]);

        } // end for

    // end::query-access-all[]

    // tag::query-access-json[]
    NSMutableArray&lt;Hotel *&gt; *hotels = NSMutableArray.new;
    for (CBLQueryResult* result in [listQuery execute:&amp;error]) {

        // Get result as a JSON string

        NSString* thisJsonString =
                    [result toJSON]; <i class="conum" data-value="23"></i><b>(23)</b>

        // Get an native Obj-C object from the Json String
        NSDictionary *thisDictFromJSON =
                [NSJSONSerialization JSONObjectWithData:
                 [thisJsonString dataUsingEncoding: NSUTF8StringEncoding]
                       options: NSJSONReadingAllowFragments
                       error: &amp;error]; <i class="conum" data-value="24"></i><b>(24)</b>
        if (error) {
            NSLog(@"Error in serialization: %@",error);
            return;
        }


        // Populate a custom object from native dictionary
        Hotel *hotelFromJson = Hotel.new;

        hotelFromJson.id = thisDictFromJSON[@"id"];  <i class="conum" data-value="25"></i><b>(25)</b>
        hotelFromJson.name = thisDictFromJSON[@"name"];
        hotelFromJson.city = thisDictFromJSON[@"city"];
        hotelFromJson.country = thisDictFromJSON[@"country"];
        hotelFromJson.descriptive = thisDictFromJSON[@"description"];

        [hotels addObject:hotelFromJson];


        // Log generated Json and Native objects
        // For demo/example purposes
        NSLog(@"Json String %@", thisJsonString);
        NSLog(@"Native Object %@", thisDictFromJSON);
        NSLog(@"Custom Object: id: %@ name: %@ city: %@ country: %@ descriptive: %@", hotelFromJson.id, hotelFromJson.name, hotelFromJson.city, hotelFromJson.country, hotelFromJson.descriptive);

       }; // end for

    // end::query-access-json[]

} // end function




// tag::query-syntax-props[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

CBLQuerySelectResult *type = [CBLQuerySelectResult property:@"type"];

CBLQuerySelectResult *name = [CBLQuerySelectResult property:@"name"];

CBLQuerySelectResult *city = [CBLQuerySelectResult property:@"city"];

*listQuery = [CBLQueryBuilder select:@[id, type, name, city]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="26"></i><b>(26)</b>

// end::query-syntax-props[]

// tag::query-access-props[]
    NSMutableArray* matches = [[NSMutableArray alloc] init]; // save to native array

    CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

    for (CBLQueryResult *result in resultset.allResults) { // all results

        [matches addObject: [result toDictionary]];

        NSLog(@"id = %@", [result stringForKey:@"id"]);
        NSLog(@"name = %@", [result stringForKey:@"name"]);
        NSLog(@"type = %@", [result stringForKey:@"type"]);
        NSLog(@"city = %@", [result stringForKey:@"city"]);

    } // end for

// end::query-access-props[]



// tag::query-syntax-count-only[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuerySelectResult *count =
  [CBLQuerySelectResult expression:[CBLQueryFunction count:   [CBLQueryExpression all]]];

*listQuery = [CBLQueryBuilder select:@[count]
             from:[CBLQueryDataSource database:db]] <i class="conum" data-value="27"></i><b>(27)</b>

// end::query-syntax-count-only[]

// tag::query-access-count-only[]
CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisCount = [match intForKey:@"mycount"] <i class="conum" data-value="28"></i><b>(28)</b>

} // end for

// end::query-access-count-only[]


// tag::query-syntax-id[]
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery *listQuery;

CBLQuerySelectResult *id = [CBLQuerySelectResult expression:[CBLQueryMeta id]];

*listQuery = [CBLQueryBuilder select:@[id]
             from:[CBLQueryDataSource database:db]]

// end::query-syntax-id[]

// tag::query-access-id[]

CBLDictionary *match;

CBLMutableArray* matches = [[CBLMutableArray alloc] init];

CBLQueryResultSet* resultset = [listQuery execute:&amp;error];

for (CBLQueryResult *result in resultset) {

  *match = [result toDictionary];

  *thisDocsId = [match stringForKey:@"id"] <i class="conum" data-value="29"></i><b>(29)</b>

  // Now you can get the document using its ID
  // for example using
  CBLMutableDocument* thisDoc =
    [thisDB documentWithID: thisDocsId]

} // end for

// end::query-access-id[]


// tag::query-syntax-pagination[]
int thisOffset = 0;
int thisLimit = 20;
CBLDatabase *db = [[CBLDatabase alloc] initWithName:@"hotels" error: &amp;error];

CBLQuery* listQuery =
            [CBLQueryBuilder
                select: @[[CBLQuerySelectResult all]]
                from: [CBLQueryDataSource database: db]
                limit: [CBLQueryLimit
                            limit: [CBLQueryExpression integer: thisLimit]
                            offset: [CBLQueryExpression integer: thisOffset]]
            ];

// end::query-syntax-pagination[]



// PEER-to-PEER


// tag::listener-simple[]
CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database]; <i class="conum" data-value="30"></i><b>(30)</b>

thisConfig.authenticator =
  [[CBLListenerPasswordAuthenticator alloc]
    initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
      if ([self isValidCredentials: validUser password:validPassword]) {
          return  YES;
      }
      return NO;
  }]; <i class="conum" data-value="31"></i><b>(31)</b>

CBLURLEndpointListener* thisListener = nil;
thisListener =
  [[CBLURLEndpointListener alloc] initWithConfig: thisConfig]; <i class="conum" data-value="32"></i><b>(32)</b>

BOOL success = [thisListener startWithError: &amp;error];
if (!success) {
    NSLog(@"Cannot start the listener: %@", error);
} <i class="conum" data-value="33"></i><b>(33)</b>

// end::listener-simple[]

// tag::replicator-simple[]
NSURL *url =
  [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
CBLURLEndpoint *theListenerURL =
  [[CBLURLEndpoint alloc] initWithURL:url]; <i class="conum" data-value="34"></i><b>(34)</b>

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:theListenerURL]; <i class="conum" data-value="35"></i><b>(35)</b>

thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="36"></i><b>(36)</b>

thisConfig.authenticator =
  [[CBLBasicAuthenticator alloc]
    initWithUsername:@"valid.user"
      password:@"valid.password.string"]; <i class="conum" data-value="37"></i><b>(37)</b>


CBLReplicator *_thisReplicator;
_thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="38"></i><b>(38)</b>

[_thisReplicator start]; <i class="conum" data-value="39"></i><b>(39)</b>

// end::replicator-simple[]




//
// Stuff I adapted
//


import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class cMyPassListener {
  // tag::listener-initialize[]
  // tag::listener-config-db[]
  // Initialize the listener config <i class="conum" data-value="40"></i><b>(40)</b>
  CBLURLEndpointListenerConfiguration* thisConfig;
  thisConfig =
    [[CBLURLEndpointListenerConfiguration alloc]
      initWithDatabase: database];

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.port =  55990; <i class="conum" data-value="41"></i><b>(41)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    NSString *thisURL = @"10.1.1.10";
    thisConfig.networkInterface = thisURL; <i class="conum" data-value="42"></i><b>(42)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.enableDeltaSync = true; <i class="conum" data-value="43"></i><b>(43)</b>

    // end::listener-config-delta-sync[]
    // Configure server security
    // tag::listener-config-tls-enable[]
    thisConfig.disableTLS  = false; <i class="conum" data-value="44"></i><b>(44)</b>

    // end::listener-config-tls-enable[]

    // tag::listener-config-tls-id-anon[]
    // Use an anonymous self-signed cert
    thisConfig.tlsIdentity = nil; <i class="conum" data-value="45"></i><b>(45)</b>

    // end::listener-config-tls-id-anon[]
    // tag::listener-config-client-auth-pwd[]
    // Configure Client Security using an Authenticator
    // For example, Basic Authentication <i class="conum" data-value="46"></i><b>(46)</b>
    thisConfig.authenticator =
      [[CBLListenerPasswordAuthenticator alloc]
        initWithBlock: ^BOOL(NSString * validUser, NSString * validPassword) {
          if ([self isValidCredentials: validUser password:validPassword]) {
              return  YES;
          }
          return NO;
      }];

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // tag::listener-init[]
    // Initialize the listener <i class="conum" data-value="47"></i><b>(47)</b>
    CBLURLEndpointListener* thisListener = nil;
    thisListener =
      [[CBLURLEndpointListener alloc] initWithConfig: thisConfig];

    // end::listener-init[]
    // start the listener <i class="conum" data-value="48"></i><b>(48)</b>
    BOOL success = [thisListener startWithError: &amp;error];
    if (!success) {
        NSLog(@"Cannot start the listener: %@", error);
    }

    // end::listener-start[]
// end::listener-initialize[]
  } // end of class

// tag::listener-stop[]
    [thisListener stop];

// end::listener-stop[]

  }
}


// Additional Snippets

// tag::listener-get-network-interfaces[]
// . . .  code snippet to be provided

// end::listener-get-network-interfaces[]

// tag::listener-get-url-list[]
NSError* error = nil;
CBLURLEndpointListenerConfiguration* config =
  [[CBLURLEndpointListenerConfiguration alloc] initWithDatabase: self.otherDB];
CBLURLEndpointListener* listener =
  [[CBLURLEndpointListener alloc] initWithConfig: config];

[listener startWithError: &amp;error];

NSLog(@"%@", listener.urls);

// end::listener-get-url-list[]

// tag::listener-local-db[]
// . . . preceding application logic . . .
fileprivate  var _allowlistedCommonNames:[[String:String]] = []
fileprivate var _thisListener:URLEndpointListener?
fileprivate var thisDB:Database?
// Include websockets listener initializer code
// func fMyPassListener() {
CBLDatabase *thisDB = self.db;
// end::listener-local-db[]

// tag::listener-config-tls-full[]
  // Configure server authentication
  // tag::listener-config-tls-disable[]
  thisConfig.disableTLS  = true; <i class="conum" data-value="49"></i><b>(49)</b>

  // end::listener-config-tls-disable[]

  // EXAMPLE 6
  // tag::listener-config-tls-id-full[]
  // tag::listener-config-tls-id-caCert[]
  // Use CA Cert
  // Create a TLSIdentity from a key-pair and
  // certificate in secure storage
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="50"></i><b>(50)</b>

    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    CBLTLSIdentity* thisIdentity =
      [CBLTLSIdentity importIdentityWithData: data
        password: @"123"
        label: @"couchbase-docs-cert"
        error: &amp;error]; <i class="conum" data-value="51"></i><b>(51)</b>

    config.tlsIdentity = thisIdentity; <i class="conum" data-value="52"></i><b>(52)</b>

  // end::listener-config-tls-id-caCert[]
  // tag::listener-config-tls-id-SelfSigned[]
  // Use a self-signed certificate
  NSDictionary* attrs =
    @{ kCBLCertAttrCommonName: @"Couchbase Inc" }; <i class="conum" data-value="53"></i><b>(53)</b>

  thisIdentity =
    [CBLTLSIdentity createIdentityForServer: YES /* isServer */
        attributes: attrs
        expiration: [NSDate dateWithTimeIntervalSinceNow: 86400]
              label: @" couchbase-docs-cert"
              error: &amp;error]; <i class="conum" data-value="54"></i><b>(54)</b>

  // end::listener-config-tls-id-SelfSigned[]
      // tag::listener-config-tls-id-set[]
  // set the TLS Identity
  thisConfig.tlsIdentity = thisIdentity; <i class="conum" data-value="55"></i><b>(55)</b>

  // end::listener-config-tls-id-set[]
  // end::listener-config-tls-id-full[]
// end::listener-config-tls-full[]

// EXAMPLE 8
// tag::listener-config-client-auth-root[]
// Configure the client authenticator
NSURL *certURL =
  [[NSBundle mainBundle]
    URLForResource: @"cert" withExtension: @"p12"]; <i class="conum" data-value="56"></i><b>(56)</b>
NSData *data =
  [[NSData alloc]
    initWithContentsOfURL: certURL];
SecCertificateRef rootCertRef =
  SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

thisConfig.authenticator =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithRootCerts: @[(id)CFBridgingRelease(rootCertRef)]];  <i class="conum" data-value="57"></i><b>(57)</b> <i class="conum" data-value="58"></i><b>(58)</b>

// end::listener-config-client-auth-root[]
// tag::listener-config-client-auth-lambda[]
// Authenticate self-signed cert
// using application logic
CBLListenerCertificateAuthenticator* thisListenerAuth =
  [[CBLListenerCertificateAuthenticator alloc]
    initWithBlock: ^BOOL(NSArray *certs) {
      SecCertificateRef cert =
        (__bridge SecCertificateRef)(certs[0]); <i class="conum" data-value="59"></i><b>(59)</b>
      CFStringRef cnRef;
      OSStatus status = SecCertificateCopyCommonName(cert, &amp;cnRef);
      if (status == errSecSuccess) {
          NSString* cn = (NSString*)CFBridgingRelease(cnRef);
          if ([self._allowlistedCommonNames containsObject: cn])
              return YES;
      }
      return NO;
  }];  <i class="conum" data-value="60"></i><b>(60)</b>

thisConfig.authenticator = thisListenerAuth; <i class="conum" data-value="61"></i><b>(61)</b>

// end::listener-config-client-auth-lambda[]







// tag::xlistener-config-tls-disable[]
thisConfig.disableTLS  = true

// end::xlistener-config-tls-disable[]

// tag::listener-config-tls-id-nil[]
thisConfig.tlsIdentity = nil

// end::listener-config-tls-id-nil[]


// tag::old-listener-config-delta-sync[]
thisConfig.enableDeltaSync = true

// end::old-listener-config-delta-sync[]


// tag::listener-status-check[]
NSUInteger totalConnections = thisListener.status.connectionCount;
NSUInteger activeConnections = thisListener.status.activeConnectionCount;

// end::listener-status-check[]


// tag::old-listener-config-client-auth-root[]
  // cert is a pre-populated object of type:SecCertificate representing a certificate
  let rootCertData = SecCertificateCopyData(cert) as Data
  let rootCert = SecCertificateCreateWithData(kCFAllocatorDefault, rootCertData as CFData)!
  // Listener:
  thisConfig.authenticator = ListenerCertificateAuthenticator.init (rootCerts: [rootCert])

// end::old-listener-config-client-auth-root[]
/

// tag::listener-config-client-auth-self-signed[]
thisConfig.authenticator = ListenerCertificateAuthenticator.init {
  (cert) -&gt; Bool in
    var cert:SecCertificate
    var certCommonName:CFString?
    let status=SecCertificateCopyCommonName(cert, &amp;certCommonName)
    if (self._allowlistedCommonNames.contains(["name": certCommonName! as String])) {
        return true
    }
    return false
}

// end::listener-config-client-auth-self-signed[]

// tag::p2p-ws-api-urlendpointlistener[]
public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
}

// end::p2p-ws-api-urlendpointlistener[]


// tag::p2p-ws-api-urlendpointlistener-constructor[]
let config = URLEndpointListenerConfiguration.init(database: self.oDB)
thisConfig.port = tls ? wssPort : wsPort
thisConfig.disableTLS = !tls
thisConfig.authenticator = auth
self.listener = URLEndpointListener.init(config: config) <i class="conum" data-value="1"></i><b>(1)</b>

// end::p2p-ws-api-urlendpointlistener-constructor[]


// Active Peer Connection Snippets

//
//  my Other Bits.swift
//  doco-sync
//
//  Created by Ian Bridge on 19/06/2020.
//  Copyright  2020 Couchbase Inc. All rights reserved.
//

import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity

class myActPeerClass {

  func fMyActPeer() {
    // let validUser = "syncthisUser"
    // let validPassword = "sync9455"
    // let cert:SecCertificate?
    // let passivePeerEndpoint = "10.1.1.12:8920"
    // let passivePeerPort = "8920"
    // let passiveDbName = "userdb"
    // var actDb:Database?
    // var thisReplicator:Replicator?
    // var replicatorListener:ListenerToken?

    CBLReplicator *_thisReplicator;

    CBLListenerToken *_thisListenerToken;

    CBLDatabase *database
      = [[CBLDatabase alloc] initWithName:@"thisDB" error:&amp;error];
        if (!database) {
          NSLog(@"Cannot open the database: %@", error);
        };

    // tag::p2p-act-rep-func[]
    // tag::p2p-act-rep-initialize[]
    // Set listener DB endpoint
    NSURL *url = [NSURL URLWithString:@"ws://listener.com:55990/otherDB"];
    CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

    CBLReplicatorConfiguration *thisConfig
      = [[CBLReplicatorConfiguration alloc]
          initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="62"></i><b>(62)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config[]
    // tag::p2p-act-rep-config-type[]
    thisConfig.replicatorType = kCBLReplicatorTypePush;

    // end::p2p-act-rep-config-type[]
    // tag::autopurge-override[]
    // set auto-purge behavior (here we override default)
    thisConfig.enableAutoPurge = NO; <i class="conum" data-value="63"></i><b>(63)</b>

    // end::autopurge-override[]
    // tag::p2p-act-rep-config-cont[]
    thisConfig.continuous = YES;

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Authentication
    // Here - expect and accept self-signed certs
    thisConfig.acceptOnlySelfSignedServerCertificate = YES; <i class="conum" data-value="64"></i><b>(64)</b>

    // end::p2p-act-rep-config-self-cert[]
    // Configure Client Authentication
    // tag::p2p-act-rep-auth[]
    // Here set client to use basic authentication
    // Providing username and password credentials
    // If prompted for them by server
    thisConfig.authenticator = [[CBLBasicAuthenticator alloc] initWithUsername:@"Our Username" password:@"Our Password"]; <i class="conum" data-value="65"></i><b>(65)</b>

    // end::p2p-act-rep-auth[]
    // end::p2p-act-rep-config-tls-full[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    thisConfig.conflictResolver = [[LocalWinConflictResolver alloc] <i class="conum" data-value="66"></i><b>(66)</b>

    // end::p2p-act-rep-config-conflict[]    //
    // end::p2p-act-rep-config[]
    // tag::p2p-act-rep-start-full[]
    // Apply configuration settings to the replicator
    _thisReplicator = [[CBLReplicator alloc] initWithConfig:thisConfig]; <i class="conum" data-value="67"></i><b>(67)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    // Optionally add a change listener <i class="conum" data-value="68"></i><b>(68)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    // Retain token for use in deletion
    id&lt;CBLListenerToken&gt; thisListenerToken
      = [thisReplicator addChangeListener:^(CBLReplicatorChange *thisChange) {
    // tag::p2p-act-rep-status[]
          if (thisChange.status.activity == kCBLReplicatorStopped) {
            NSLog(@"Replication stopped");
            } else {
            NSLog(@"Status: %d", thisChange.status.activity);
            };
    // end::p2p-act-rep-status[]
        }];
// end::p2p-act-rep-add-change-listener[]
// tag::p2p-act-rep-start[]
    // Run the replicator using the config settings
    [thisReplicator start]; <i class="conum" data-value="69"></i><b>(69)</b>

// end::p2p-act-rep-start[]
// end::p2p-act-rep-start-full[]
// end::p2p-act-rep-func[]
    }

    func mystopfunc() {
// tag::p2p-act-rep-stop[]
    // Remove the change listener
    [thisReplicator removeChangeListenerWithToken: thisListenerToken];

    // Stop the replicator
    [thisReplicator stop];
// end::p2p-act-rep-stop[]
}

// Additional Snippets from above
    // tag::p2p-act-rep-config-cacert[]
    // Configure Server Security -- only accept CA Certs
    thisConfig.acceptOnlySelfSignedServerCertificate = NO; <i class="conum" data-value="70"></i><b>(70)</b>

    // end::p2p-act-rep-config-cacert[]


    // tag::p2p-act-rep-config-pinnedcert[]
    // Return the remote pinned cert (the listener's cert)
    thisConfig.pinnedServerCertificate = thisCert; // Get listener cert if pinned

    // end::p2p-act-rep-config-pinnedcert[]







// tag::p2p-tlsid-manage-func[]
//
//  cMyGetCert.swift
//  doco-sync
//
//  Created by Ian Bridge on 20/06/2020.
//  Copyright  2020 Couchbase Inc. All rights reserved.
//

import Foundation
import Foundation
import CouchbaseLiteSwift
import MultipeerConnectivity


class cMyGetCert1{

    let kListenerCertLabel = "doco-sync-server"
    let kListenerCertKeyP12File = "listener-cert-pkey"
    let kListenerPinnedCertFile = "listener-pinned-cert"
    let kListenerCertKeyExportPassword = "couchbase"
    //var importedItems : NSArray
    let thisData : CFData?
    var items : CFArray?

    func fMyGetCert() -&gt;TLSIdentity? {
        var kcStatus = errSecSuccess // Zero
        let thisLabel : String? = "doco-sync-server"

        //var thisData : CFData?
        // tag::p2p-tlsid-tlsidentity-with-label[]
        // tag::p2p-tlsid-check-keychain[]
        // Check if Id exists in keychain and if so, use it
        CBLTLSIdentity* identity =
          [CBLTLSIdentity identityWithLabel: @"doco-sync-server" error: &amp;error]; <i class="conum" data-value="71"></i><b>(71)</b>

        // end::p2p-tlsid-check-keychain[]
        thisConfig.authenticator =
          [[CBLClientCertificateAuthenticator alloc] initWithIdentity: identity]; <i class="conum" data-value="72"></i><b>(72)</b>

        // end::p2p-tlsid-tlsidentity-with-label[]


// tag::p2p-tlsid-check-bundled[]
// CREATE IDENTITY FROM BUNDLED RESOURCE IF FOUND

        // Check for a resource bundle with required label to generate identity from
        // return nil identify if not found
        guard let pathToCert = Bundle.main.path(forResource: "doco-sync-server", ofType: "p12"),
                let thisData = NSData(contentsOfFile: pathToCert)
            else
                {return nil}
// end::p2p-tlsid-check-bundled[]

// tag::p2p-tlsid-import-from-bundled[]
        // Use SecPKCS12Import to import the contents (identities and certificates)
        // of the required resource bundle (PKCS #12 formatted blob).
        //
        // Set passphrase using kSecImportExportPassphrase.
        // This passphrase should correspond to what was specified when .p12 file was created
        kcStatus = SecPKCS12Import(thisData as CFData, [String(kSecImportExportPassphrase): "couchbase"] as CFDictionary, &amp;items)
            if kcStatus != errSecSuccess {
             print("failed to import data from provided with error :\(kcStatus) ")
             return nil
            }
        let importedItems = items! as NSArray
        let thisItem = importedItems[0] as! [String: Any]

        // Get SecIdentityRef representing the item's id
        let thisSecId = thisItem[String(kSecImportItemIdentity)]  as! SecIdentity

        // Get Id's Private Key, return nil id if fails
        var thisPrivateKey : SecKey?
        kcStatus = SecIdentityCopyPrivateKey(thisSecId, &amp;thisPrivateKey)
            if kcStatus != errSecSuccess {
                print("failed to import private key from provided with error :\(kcStatus) ")
                return nil
            }

        // Get all relevant certs [SecCertificate] from the ID's cert chain using kSecImportItemCertChain
        let thisCertChain = thisItem[String(kSecImportItemCertChain)] as? [SecCertificate]

        // Return nil Id if errors in key or cert chain at this stage
        guard let pKey = thisPrivateKey, let pubCerts = thisCertChain else {
            return nil
        }
// end::p2p-tlsid-import-from-bundled[]

// tag::p2p-tlsid-store-in-keychain[]
// STORE THE IDENTITY AND ITS CERT CHAIN IN THE KEYCHAIN

        // Store Private Key in Keychain
        let params: [String : Any] = [
            String(kSecClass):          kSecClassKey,
            String(kSecAttrKeyType):    kSecAttrKeyTypeRSA,
            String(kSecAttrKeyClass):   kSecAttrKeyClassPrivate,
            String(kSecValueRef):       pKey
        ]
        kcStatus = SecItemAdd(params as CFDictionary, nil)
            if kcStatus != errSecSuccess {
                print("Unable to store private key")
                return nil
            }
       // Store all Certs for Id in Keychain:
       var i = 0;
       for cert in thisCertChain! {
            let params: [String : Any] = [
                String(kSecClass):      kSecClassCertificate,
                String(kSecValueRef):   cert,
                String(kSecAttrLabel):  "doco-sync-server"
                ]
            kcStatus = SecItemAdd(params as CFDictionary, nil)
                if kcStatus != errSecSuccess {
                    print("Unable to store certs")
                    return nil
                }
            i=i+1
        }
// end::p2p-tlsid-store-in-keychain[]

// tag::p2p-tlsid-return-id-from-keychain[]
// RETURN A TLSIDENTITY FROM THE KEYCHAIN FOR USE IN CONFIGURING TLS COMMUNICATION
do {
    return try TLSIdentity.identity(withIdentity: thisSecId, certs: [pubCerts[0]])
} catch {
    print("Error while loading self signed cert : \(error)")
    return nil
}
// end::p2p-tlsid-return-id-from-keychain[]
    } // fMyGetCert
} // cMyGetCert


// tag::p2p-tlsid-delete-id-from-keychain[]

[CBLTLSIdentity deleteIdentityWithLabel:thisSecId error: &amp;error];

// end::p2p-tlsid-delete-id-from-keychain[]



// end::p2p-tlsid-manage-func[]



// tag::p2p-act-rep-config-cacert-pinned-func[]
func fMyCaCertPinned() {
  // do {
  let tgtUrl = URL(string: "wss://10.1.1.12:8092/actDb")!
  let targetEndpoint = URLEndpoint(url: tgtUrl)
  let actDb:Database?
  let config = ReplicatorConfiguration(database: actDb!, target: targetEndpoint)
  // tag::p2p-act-rep-config-cacert-pinned[]
    NSURL *certURL =
      [[NSBundle mainBundle] URLForResource: @"cert" withExtension: @"cer"];
    NSData *data =
      [[NSData alloc] initWithContentsOfURL: certURL];
    SecCertificateRef certificate =
      SecCertificateCreateWithData(NULL, (__bridge CFDataRef)data);

    NSURL *url =
      [NSURL URLWithString:@"ws://localhost:4984/db"];

    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];

    CBLReplicatorConfiguration *thisConfig =
      [[CBLReplicatorConfiguration alloc] initWithDatabase:database
                                          target:target];
    thisConfig.pinnedServerCertificate =
      (SecCertificateRef)CFAutorelease(certificate);

    thisConfig.acceptOnlySelfSignedServerCertificate=false;

  // end::p2p-act-rep-config-cacert-pinned[]
  // end::p2p-act-rep-config-cacert-pinned-func[]
}



// For replications

// BEGIN -- snippets --
//    Purpose -- code samples for use in replication topic

// tag::sgw-repl-pull[]
@interface MyClass : NSObject
@property (nonatomic) CBLDatabase *database;
@property (nonatomic) CBLReplicator *replicator; <i class="conum" data-value="1"></i><b>(1)</b>
@end

@implementation MyClass
@synthesize database=_database;
@synthesize replicator=_replicator;

- (void) startReplication {
    NSURL *url = [NSURL URLWithString:@"ws://localhost:4984/db"]; <i class="conum" data-value="2"></i><b>(2)</b>
    CBLURLEndpoint *target = [[CBLURLEndpoint alloc] initWithURL: url];
    CBLReplicatorConfiguration *config = [[CBLReplicatorConfiguration alloc] initWithDatabase:_database
                                                                                       target:target];
    config.replicatorType = kCBLReplicatorTypePull;
    _replicator = [[CBLReplicator alloc] initWithConfig:config];
    [_replicator start];
}
@end

// end::sgw-repl-pull[]

// tag::sgw-repl-pull-callouts[]
&lt;1&gt; A replication is an asynchronous operation.
To keep a reference to the `replicator` object, you can set it as an instance property.
&lt;2&gt; The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
You should now use `ws:`, or `wss:` for SSL/TLS connections.


// end::sgw-repl-pull-callouts[]

// tag::sgw-act-rep-initialize[]
// Set listener DB endpoint
NSURL *url = [NSURL URLWithString:@"ws://10.0.2.2.com:55990/travel-sample"];
CBLURLEndpoint *thisListener = [[CBLURLEndpoint alloc] initWithURL:url];

CBLReplicatorConfiguration *thisConfig
  = [[CBLReplicatorConfiguration alloc]
      initWithDatabase:thisDB target:thisListener]; <i class="conum" data-value="73"></i><b>(73)</b>

// end::sgw-act-rep-initialize[]
// END -- snippets --</code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="delete-tls-identity"><a class="anchor" href="#delete-tls-identity"></a>Delete TLS Identity</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-objc hljs" data-lang="objc" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/objc/examples/code_snippets/SampleCodeTest.m">
[CBLTLSIdentity deleteIdentityWithLabel:thisSecId error: &amp;error];</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="related-content"><a class="anchor" href="#related-content"></a>Related Content</h2>
<div class="sectionbody">
<div class="card-row three-column-row">
<div class="sect5 column">
<h6 id=""><a class="anchor" href="#"></a></h6>
<div class="ulist">
<div class="title">How to</div>
<ul>
<li>
<p><a href="p2psync-websocket-using-passive.html" class="page">Passive Peer</a></p>
</li>
<li>
<p><a href="p2psync-websocket-using-active.html" class="page">Active Peer</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-2"><a class="anchor" href="#-2"></a></h6>
<div class="ulist">
<div class="title">Concepts</div>
<ul>
<li>
<p><a href="p2psync-websocket.html" class="page">Peer-to-Peer Data Sync</a></p>
</li>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/{major}.{minor}/couchbase-lite-objc">API References</a>
.</p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-3"><a class="anchor" href="#-3"></a></h6>
<div class="paragraph">
<div class="title">Community Resources &#8230;&#8203;</div>
<p>Unresolved include directive in modules/ROOT/pages/_partials/_related-content.adoc - include::shared-mobile::partial$_related-content.adoc[]</p>
</div>
<div class="ulist">
<div class="title"></div>
<ul>
<li>
<p><a href="#tutorials:cbl-p2p-sync-websockets:swift/cbl-p2p-sync-websockets.adoc" class="page unresolved">Getting Started with Peer-to-Peer Synchronization</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="related-content-2"><a class="anchor" href="#related-content-2"></a>Related Content</h2>
<div class="sectionbody">
<div class="card-row three-column-row">
<div class="sect5 column">
<h6 id="-4"><a class="anchor" href="#-4"></a></h6>
<div class="ulist">
<div class="title">How to</div>
<ul>
<li>
<p><a href="p2psync-websocket-using-passive.html" class="page">Passive Peer</a></p>
</li>
<li>
<p><a href="p2psync-websocket-using-active.html" class="page">Active Peer</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-5"><a class="anchor" href="#-5"></a></h6>
<div class="ulist">
<div class="title">Concepts</div>
<ul>
<li>
<p><a href="p2psync-websocket.html" class="page">Peer-to-Peer Data Sync</a></p>
</li>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/{major}.{minor}/couchbase-lite-objc">API References</a>
.</p>
</li>
</ul>
</div>
</div>
<div class="sect5 column">
<h6 id="-6"><a class="anchor" href="#-6"></a></h6>
<div class="paragraph">
<div class="title">Community Resources &#8230;&#8203;</div>
<p>Unresolved include directive in modules/ROOT/pages/_partials/_related-content.adoc - include::shared-mobile::partial$_related-content.adoc[]</p>
</div>
<div class="ulist">
<div class="title"></div>
<ul>
<li>
<p><a href="#tutorials:cbl-p2p-sync-websockets:swift/cbl-p2p-sync-websockets.adoc" class="page unresolved">Getting Started with Peer-to-Peer Synchronization</a></p>
</li>
</ul>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Enterprise Edition only</div>
This an <a href="https://www.couchbase.com/products/editions">Enterprise Edition</a> feature.
Purchase the <em>Enterprise License</em>, which includes official <a href="https://www.couchbase.com/support-policy">Couchbase Support</a>, to use it in production (see the license and support <a href="https://www.couchbase.com/licensing-and-support-faq" class="bare">https://www.couchbase.com/licensing-and-support-faq</a>).
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase">
          </a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <svg  width="14" height="14" viewBox="0 0 32.1 26.1"> <path id="twitter" class="cls-1" d="M32,7.1a11.836,11.836,0,0,1-3.8,1,6.462,6.462,0,0,0,2.9-3.6,12.606,12.606,0,0,1-4.2,1.6A6.492,6.492,0,0,0,22.1,4a6.594,6.594,0,0,0-6.6,6.6,7.719,7.719,0,0,0,.2,1.5A18.458,18.458,0,0,1,2.2,5.2a6.294,6.294,0,0,0-.9,3.3A6.765,6.765,0,0,0,4.2,14a6.109,6.109,0,0,1-3-.8v.1a6.543,6.543,0,0,0,5.3,6.4,4.678,4.678,0,0,1-1.7.2,4.869,4.869,0,0,1-1.2-.1,6.679,6.679,0,0,0,6.1,4.6,12.917,12.917,0,0,1-8.2,2.8,9.151,9.151,0,0,1-1.6-.1,18.438,18.438,0,0,0,10.1,3c12.1,0,18.7-10,18.7-18.7v-.8A13.336,13.336,0,0,0,32,7.2Z" transform="translate(0.1 -4)"/></svg>
            <a href="https://twitter.com/couchbase" class="icon">
              Twitter
            </a>
          </li>
          <li>
          <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="linkedin" class="cls-1" d="M29,0H3A3.076,3.076,0,0,0,0,3V29a3.009,3.009,0,0,0,3,3H29a2.946,2.946,0,0,0,3-3V3A3.009,3.009,0,0,0,29,0ZM12,26H8V12h4ZM10,10a2,2,0,1,1,2-2A2.006,2.006,0,0,1,10,10ZM26,26H22V18a2,2,0,0,0-4,0v8H14V12h4v2.5c.8-1.1,2.1-2.5,3.5-2.5A4.736,4.736,0,0,1,26,17Z"/></svg>
              <a href="https://www.linkedin.com/company/couchbase" class="icon">
             Linkedin
            </a>
          </li>
          <li>
            <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="facebook" class="cls-1" d="M29,0H3A2.652,2.652,0,0,0,0,3V29a2.652,2.652,0,0,0,3,3H16V18H12V14h4V12a6.452,6.452,0,0,1,6-6h4v4H22a2.151,2.151,0,0,0-2,2v2h6l-1,4H20V32h9a2.652,2.652,0,0,0,3-3V3A2.652,2.652,0,0,0,29,0Z"/></svg>
            <a href="https://www.facebook.com/Couchbase" class="icon">
            Facebook
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <div class="footer-terms-copyright">
          <span> 2021 Couchbase, Inc. Couchbase, Couchbase Lite and the Couchbase logo are registered trademarks of Couchbase, Inc.</span>
      </div>
      <div class="footer-terms-links">
        <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
        <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
        <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
        <a href="https://www.couchbase.com/support-policy">Support Policy</a>
        <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
      </div>
    </div>
  </div>
</footer>
<script id="site-script" src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/fontawesome-icon-defs.js"></script>
<script async src="../../../_/js/vendor/fontawesome.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
</body>
</html>
