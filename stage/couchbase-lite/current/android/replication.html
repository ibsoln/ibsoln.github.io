<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Data Sync using Sync Gateway | Couchbase Docs</title>
<link rel="canonical" href="http://127.0.0.1:5000/couchbase-lite/current/android/replication.html">
<link rel="stylesheet" href="../../../_/css/site.css">
<script src="../../../_/js/vendor/jquery.js"></script>
<meta name="description" content="Couchbase Lite for Android -- Synchronizing data changes between local and remote databases using Sync Gateway">
<link rel="schema.dcterms" href="https://purl.org/dc/terms/">
<meta name="dcterms.subject" content="couchbase-lite">
<meta name="dcterms.identifier" content="3.0">
<meta name="page-url" content="/couchbase-lite/current/android/replication.html">
<meta name="generator" content="Antora 3.0.0-alpha.6">
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
</head>
<body class="article">
<header class="header fixed-top">
  <div class="header-top-row">
      <div class="container">
          <nav class="navbar navbar-expand-md flex-nowrap justify-content-between navbar-new-top">
              <ul class="navbar-brand-list">
                <li class="brand-logo">
                  <a class="navbar-brand" href="https://www.couchbase.com">
                    <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase" />
                  </a>
                </li>
                <li>
                  <a class="navbar-brand cb-documentation" href="https://docs.couchbase.com">
                    <img src="../../../_/img/cb-documentation.svg" alt="Couchbase Documentation" class="cb-docs" />
                    <img src="../../../_/img/cb-docs-hover.svg" alt="Couchbase Documentation" class="hide cb-hover-docs" />
                  </a>
                </li>
              </ul>
              <button class="navbar-burger" data-target="topbar-menu">
                <span></span>
                <span></span>
                <span></span>
              </button>

          </nav>
      </div>
  </div>
  <div class="header-bottom-row" id="topbar-menu">
    <div class="container">
        <nav  class="navbar navbar-new-bottom">

              <div class="navbar-collapse collapse" id="navbar2">
                <ul class="navbar-nav w-100 justify-content-start">
                  <li class="nav-item">
                    <a href="http://127.0.0.1:5000/home/index.html" class="nav-link">
                      <i class="fas fa-home"></i>
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/server.html">
                      Server
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/mobile.html">
                      Mobile
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/cloud.html">
                      Cloud
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/sdk.html">
                      SDKs
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../tutorials/index.html">
                      Tutorials
                      <span class="arrow">
                        <i class="fas fa-arrow-right"></i>
                      </span>
                    </a>
                  </li>
                </ul>
              </div>
              <div class="primary-action">
                <a href="https://cloud.couchbase.com/sign-up" class="free-trial-link" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Free Trial'});" >
                  <i class="fas fa-cloud"></i>
                  Free Trial
                </a>
                <a class="btn btn-primary try-btn"  onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Download'});" href="https://www.couchbase.com/downloads">
                  Downloads
                </a>
              </div>

        </nav>
    </div>
   </div>
</header>
<div class="body container">
<aside class="nav left-sidebar">
  <div class="nav-container">
<div class="components">
  <div class="components_group-title">
    <a href="../../../home/mobile.html">Mobile</a>
  </div>
  <ul class="components_list">
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Couchbase Lite</span>
        <select class="version_list">
          <option value="3.0" selected>3.0</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0">
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../index.html">Introduction</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../cbl-whatsnew.html">What&#8217;s New</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="quickstart.html">Android</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="dbreplica.html">Intra-device Data Sync</a>
  </span>
</li>
<li class="menu_list is-current-page" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link is-current-page" href="replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../clang/quickstart.html">C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../clang/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../clang/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/dbreplica.html">Intra-device Data Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../clang/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-c">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../clang/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/quickstart.html">C#.Net</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/dbreplica.html">Intra-device Data Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-net">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../csharp/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/quickstart.html">Java</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/dbreplica.html">Intra-device Data Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../java/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-java/index.html?">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../java/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/quickstart.html">Objective-C</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/dbreplica.html">Intra-device Data Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../objc/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-objc">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/troubleshooting-crashes.html">Decoding Crash Logs</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/compatibility.html">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/supported-os.html">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../objc/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/quickstart.html">Swift</a>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/gs-prereqs.html">Start Here!</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/gs-build.html">Build and Run</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/database.html">Databases</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/prebuilt-database.html">Pre-built Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/document.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/blob.html">Blobs</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Queries</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/querybuilder.html">QueryBuilder</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/querybuilder-n1ql.html">N1QL Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-resultsets.html">Query Resultsets</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-live.html">Live Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/query-troubleshooting.html">Query Troubleshooting</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/fts.html">Full Text Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/landing-replications.html">Data Sync</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/dbreplica.html">Intra-device Data Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/replication.html">Remote Sync Gateway</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../swift/p2psync-websocket.html">Peer-to-Peer</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-websocket-using-passive.html">Passive Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-websocket-using-active.html">Active Peer</a>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/p2psync-custom.html">Integrate Custom Listener</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/conflict.html">Handling Data Conflicts</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-swift">API&#160;References</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/dep-upgrade.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-logs.html">Using Logs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-queries.html">Troubleshooting Queries</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/troubleshooting-crashes.html">Decoding Crash Logs</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/releasenotes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:swift:compatibility.adoc">Compatibility</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#couchbase-lite:swift:supported-os.adoc">Supported OS</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../swift/refer-glossary.html">Glossary</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../javascript.html">JavaScript</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../javascript.html">JavaScript</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/introduction.html">Sync&#160;Gateway</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#sync-gateway::refer/config-properties.adoc">Configure</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin.html">REST API</a>
  </span>
</li>
</ul>
</li>
</ul>
      </div>
    </li>
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Sync Gateway</span>
        <select class="version_list">
          <option value="3.0" selected>3.0</option>
        </select>
      </div>
      <div class="version_items hide" data-version="3.0">
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/introduction.html">Introduction</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/whatsnew.html">What&#8217;s New</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Start Here!</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-prepare.html">Prepare</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-install.html">Install</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/get-started-verify-install.html">Verify</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/data-modeling.html">Data Modeling</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Configuration</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/configuration-schema-bootstrap.html">Bootstrap</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin-database.html">Database</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin-db-security.html">Database Security</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin-access-control.html">Access Control</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin-isgr.html">Inter-Sync&#160;Gateway Replication</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#sync-gateway::configuration-properties.adoc">Configuration <em><sup>(pre-3.0)</sup></em></a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">REST API</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-access.html">REST API Access</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api.html">Public REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-admin.html">Admin REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-metrics.html">Metrics REST API</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/rest-api-client-app.html">Use the REST API?</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Security</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-users.html">User Authentication</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/authentication-certs.html">TLS Certificate Authentication</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Access Control</span>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#sync-gateway::{access-control-concepts&amp;.adoc#8212;&amp;#8203;page}">Concepts</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{access-control-model&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/channels.html">Channels</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/roles.html">Roles</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/users.html">Users</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-function.html">Sync Function</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#sync-gateway::{sync-function-overview&amp;.adoc#8212;&amp;#8203;page}">Overview</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="2">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#sync-gateway::{sync-function-api&amp;.adoc#8212;&amp;#8203;page}">API Reference</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{sync-function-api-access-cmd&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{sync-function-api-channel-cmd&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{sync-function-api-expiry-cmd&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{sync-function-api-require-access-cmd&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{sync-function-api-require-admin-cmd&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{sync-function-api-require-role-cmd&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{sync-function-api-require-user-cmd&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{sync-function-api-role-cmd&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="3">
  <span class="menu_line">
    <span class="menu_title menu_text">{sync-function-api-throw-cmd&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="#sync-gateway::{access-control-how&amp;.adoc#8212;&amp;#8203;page}">How-To</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{access-control-how-create-users&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{access-control-how-create-roles&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{access-control-how-assign-users-to-roles&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{access-control-how-control-document-access&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{access-control-how-verify-access&#8212;&#8203;xref}</span>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{access-control-how-use-xattrs-for-access-grants&#8212;&#8203;xref}</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/auto-purge-channel-access-revocation.html">Auto-purge on Channel Access Revocation</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Sync</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-with-couchbase-server.html">Sync with Couchbase Server</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-using-app.html">Sync Using App</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Inter-Sync Gateway Replication</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-overview.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-run.html">Initialize</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-manage.html">Manage</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sync-inter-syncgateway-monitor.html">Monitor</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <span class="menu_title menu_text">{sgw-xref}sync-inter-syncgateway-conflict-resolution.adoc[Conflict Resolution]</span>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/revisions.html">Revisions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/what-are-tombstones.html">Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/managing-tombstones.html">Managing Tombstones</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/delta-sync.html">Delta Sync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/resync.html">Resync</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/import-filter.html">Import filter</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Manage</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-monitoring.html">Stats Monitoring</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Logging and Troubleshooting</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/logging.html">Logging</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/sgcollect-info.html">SGCollect Info</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/database-offline.html">Database Offline</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Deploy</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deployment.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/command-line-options.html">Command Line Options</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/load-balancer.html">Load Balancer</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/os-level-tuning.html">OS-level Tuning</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/webhooks.html">Webhooks</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/changes-feed.html">Changes Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/integrating-external-stores.html">External Stores</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/stats-prometheus.html">Prometheus Feed</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/indexing.html">Indexing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/setting-up-dr-cluster.html">Disaster Recovery</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/upgrading.html">Upgrade</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Use Kubernetes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/deploy-cluster-to-kubernetes.html">Deploy</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#operator::tutorial-sync-gateway-manage.adoc">Manage a Sync Gateway Cluster</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="#operator::tutorial-sync-gateway-clients.adoc">Expose Sync Gateway to Couchbase Lite clients</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-collections.html">Collections</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-eventing.html">Eventing</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-transactions.html">Transactions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/server-compatibility-xdcr.html">XDCR</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Product Notes</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/supported-environments.html">Supported Environments</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/compatibility.html">Compatibility Matrix</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Legacy Features</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sgreplicate-resolving-conflicts.html">SG-Replicate - Resolving Conflicts (depr)</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-sg-replicate.html">SG-Replicate</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/legacy-logging-pre2-1.html">Legacy Logging Pre2 1</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../../../sync-gateway/current/glossary.html">Glossary</a>
  </span>
</li>
</ul>
      </div>
    </li>
  </ul>
</div>
    <a href="#" class="menu-expand-toggle"><span>Navigation</span><i class="fas fa-times-circle"></i><i class="fas fa-chevron-circle-left"></i></a>
  </div>
</aside>
<aside class="toc sidebar">
  <div class="sidebar-box">
    <div class="tools" role="navigation">
<ul>
<li class="tool edit"><a href="file:///Users/ianbridge/CouchbaseDocs/bau/cbl/modules/android/pages/replication.adoc" title="Edit Page" target="_blank" rel="noopener">Edit on GitHub</a></li>
</ul>
</div>
    <div class="toc-menu"></div>
    <div class="is-this-helpful-box">
      <h4> Is this page helpful?</h4>
      <div class="btn-row">
        <a href="#" class="like-btn helpful-btn" id="yesBtn" data-page-rating="like" >
                <i class="far fa-thumbs-up"></i>
            Yes

            </a>
        <a href="#" class="dislike-btn helpful-btn" id="noBtn"  data-page-rating="dislike"> <i class="far fa-thumbs-down"></i> No</a>
      </div>
      <div class="any-feedback">
        <a href="#" class="btn any-feedback-btn" id="myCustomTrigger">Leave Additional Feedback? </a>
      </div>
      <div class="dialog-box" id="dialogBox">
        <form>
            <div class="form-group " id="additionalFeedbackBox">
              <textarea class="input-control feed-back-msg" rows="8" placeholder="Any Additonal Feedback?"></textarea>

              <div class="action-btn-row ">
                <a href="#" class="skip-btn" id="skipBtnMsg">Skip</a>
                  <button class="submit-btn btn blue-btn disabled" > Submit  </button>
                  <a href="#" class="info-btn"><i class="fas fa-info-circle"></i></a>
              </div>


            </div>

        </form>

      </div>
    </div>
  </div>

</aside>

<div class="feedback-modal modal-popup">
  <div class="modal-popup-dialogue">
    <div class="popup-header">
      <a href="#" class="close-popup"><i class="fa fa-times"></i></a>
    </div>
    <div class="popup-content">
      <p>
        Please use the form below to provide your feedback. Because your feedback is valuable to us,
         the information you submit in this form is recorded in our issue tracking system (JIRA), which is publicly available.
        You can track the status of your feedback using the ticket number displayed in the dialog once you submit the form.
      </p>
    </div>
  </div>
</div>

<main class="article" data-ceiling="topbar">
<div class="article-header">
<nav class="crumbs" aria-label="breadcrumbs">
<ul>
<li class="crumb"><a href="../index.html">Couchbase Lite</a></li>
<li class="crumb"><a href="quickstart.html">Android</a></li>
<li class="crumb"><a href="landing-replications.html">Data Sync</a></li>
<li class="crumb"><a href="replication.html">Remote Sync Gateway</a></li>
</ul>
</nav>
</div>
<article class="doc">
<div class="page-heading-title">
<h1 class="page">Data Sync using Sync Gateway</h1>
</div>
<div class="contributor-list-box">
<span class="last-commit-date" id="commitdate">    </span>
<ul id="contributorList"></ul>
<span  id="otherContributor"> + </span>
</div><div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
<div class="paragraph">
<p>Description&#8201;&#8212;&#8201;<em>Couchbase Lite for Android&#8201;&#8212;&#8201;Synchronizing data changes between local and remote databases using Sync Gateway</em><br>
Related Content&#8201;&#8212;&#8201;<a href="conflict.html" class="page">Handling Data Conflicts</a> | <a href="dbreplica.html" class="page">Intra-device Data Sync</a> | <a href="p2psync-websocket.html" class="page">Peer-to-Peer</a></p>
</div>
</blockquote>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="title">Android enablers</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Allow Unencrypted Network Traffic</dt>
<dd>
<p>To use cleartext, un-encrypted, network traffic (<code>http://</code> and-or <code>ws://</code>),  include <code>android:usesCleartextTraffic="true"</code> in the <code>application</code> element of the manifest as shown on <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted" target="_blank" rel="noopener">android.com</a>.<br>
<strong>This not recommended in production</strong>.</p>
</dd>
<dt class="hdlist1">Use Background Threads</dt>
<dd>
<p>As with any network or file I/O activity, CouchbaseLite activities should not be performed on the UI thread.
<strong>Always</strong> use a <strong>background</strong> thread.</p>
</dd>
</dl>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Code Snippets</div>
All code examples are indicative only.
They demonstrate the basic concepts and approaches to using a feature.
Use them as inspiration and adapt these examples to best practice when developing applications for your platform.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Couchbase Lite for Android provides API support for secure, bi-directional, synchronization of data changes between mobile applications and a central server database.
It does so by using a replicator to interact with Sync Gateway.
Simply put, the replicator is designed to send documents from a source to a target database.
In this case, between a local Couchbase Lite database and remote Sync Gateway database (server or cloud).</p>
</div>
<div class="paragraph">
<p>This content provides sample code and configuration examples covering the implementation of a replication using Sync Gateway.</p>
</div>
<div class="paragraph">
<p>Your application runs a replicator (also referred to here as a client), which  will initiate connection with a Sync Gateway (also referred to here as a server) and participate in the replication of database changes to bring both local and remote databases into sync.</p>
</div>
<div class="paragraph">
<p>Subsequent sections provide additional details and examples for the main configuration options.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="replication-protocol"><a class="anchor" href="#replication-protocol"></a>Replication Protocol</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="scheme"><a class="anchor" href="#scheme"></a>Scheme</h3>
<div class="paragraph">
<p>Couchbase Mobile uses a replication protocol based on WebSockets fof replication.
To use this protocol the replication URL should specify WebSockets as the URL scheme (see the <a href="#lbl-cfg-tgt">[lbl-cfg-tgt]</a> section below).</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Incompatibilities</dt>
<dd>
<p>Couchbase Lite&#8217;s replication protocol is <strong>incompatible</strong> with CouchDB-based databases.
And since Couchbase Lite 2.x+ only supports the new protocol, you will need to run a version of Sync Gateway that supports it&#8201;&#8212;&#8201;see: <a href="compatibility.html" class="page">Compatibility</a>.</p>
</dd>
<dt class="hdlist1">Legacy Compatibility</dt>
<dd>
<p>Clients using Couchbase Lite 1.x can continue to use <code>http</code> as the URL scheme.
Sync Gateway 2.x+ will automatically use:</p>
<div class="ulist">
<ul>
<li>
<p>The 1.x replication protocol when a Couchbase Lite 1.x client connects through <code>http://localhost:4984/db</code></p>
</li>
<li>
<p>The 2.0 replication protocol when a Couchbase Lite 2.0 client connects through <code>ws://localhost:4984/db</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>You can find further information in our blog: <a href="https://blog.couchbase.com/data-replication-couchbase-mobile/" target="_blank" rel="noopener">Introducing the Data Replication Protocol</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="lbl-repl-ord"><a class="anchor" href="#lbl-repl-ord"></a>Ordering</h3>
<div class="paragraph">
<p>To optimize for speed, the replication protocol doesn&#8217;t guarantee that documents will be received in a particular order.
So we don&#8217;t recommend to rely on that when using the replication or database change listeners for example.</p>
</div>
<div class="paragraph">
<p>Couchbase Lite <sup class="footnote" id="_footnote_fn2x6">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup> spins up multiple executors.
Unless mitigated, for example by using a custom executor, this policy can result in too many threads being spun up.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If no listeners are registered to listen to a replicator at the time of the most recent <code>start(. . .)</code>, then no subsequently registered listeners will receive notifications.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An executor manages a pool of threads and, perhaps, a queue in front of the executor, to handle the asynchronous callbacks.
Couchbase Lite API calls which are processed by an executor are listed below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">Query.addChangeListener
MessageEndpointListerner.addChangeListener
LiveQuery.addChangeListener
AbstractReplicator.addDocumentReplicationListener
AbstractReplicator.addChangeListener
Database.addChangeListener
Database.addDocumentChangeListener
Database.addDatabaseChangeListener
Database.addChangeListener</code></pre>
</div>
</div>
<div class="paragraph">
<p>Couchbase Lite <sup class="footnoteref">[<a class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup> sometimes uses its own internal executor to run asynchronous client code.
While this is fine for small tasks, larger tasks&#8201;&#8212;&#8201;those that take significant compute time, or that perform I/O&#8201;&#8212;&#8201;can block Couchbase processing.
If this happens your application will fail with a <code>RejectedExecutionException</code> and it may be necessary to create a separate executor on which to run the large tasks.</p>
</div>
<div class="paragraph">
<p>The following examples show how to specify a separate executor in the client code.
The client code executor can enforce an application policy for delivery ordering and the number of threads.</p>
</div>
<div class="paragraph">
<p><strong>Guaranteed Order Delivery</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * This version guarantees in order delivery and is parsimonious with space
 * The listener does not need to be thread safe (at least as far as this code is concerned).
 * It will run on only thread (the Executor's thread) and must return from a given call
 * before the next call commences.  Events may be delivered arbitrarily late, though,
 * depending on how long it takes the listener to run.
 */
public class InOrderExample {
    private static final ExecutorService IN_ORDER_EXEC = Executors.newSingleThreadExecutor();

    public Replicator runReplicator(Database db1, Database db2, ReplicatorChangeListener listener)
        throws CouchbaseLiteException {
        ReplicatorConfiguration config = new ReplicatorConfiguration(db1, new DatabaseEndpoint(db2));
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        Replicator repl = new Replicator(config);
        ListenerToken token = repl.addChangeListener(IN_ORDER_EXEC, listener::changed);

        repl.start();

        return repl;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Maximum Throughput</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">/**
 * This version maximizes throughput.  It will deliver change notifications as quickly
 * as CPU availability allows. It may deliver change notifications out of order.
 * Listeners must be thread safe because they may be called from multiple threads.
 * In fact, they must be re-entrant because a given listener may be running on mutiple threads
 * simultaneously.  In addition, when notifications swamp the processors, notifications awaiting
 * a processor will be queued as Threads, (instead of as Runnables) with accompanying memory
 * and GC impact.
 */
public class MaxThroughputExample {
    private static final ExecutorService MAX_THROUGHPUT_EXEC = Executors.newCachedThreadPool();

    public Replicator runReplicator(Database db1, Database db2, ReplicatorChangeListener listener)
        throws CouchbaseLiteException {
        ReplicatorConfiguration config = new ReplicatorConfiguration(db1, new DatabaseEndpoint(db2));
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        Replicator repl = new Replicator(config);
        ListenerToken token = repl.addChangeListener(MAX_THROUGHPUT_EXEC, listener::changed);

        repl.start();

        return repl;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Extreme Configurability</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">/**
 * This version demonstrates the extreme configurability of the CouchBase Lite replicator callback system.
 * It may deliver updates out of order and does require thread-safe and re-entrant listeners
 * (though it does correctly synchronizes tasks passed to it using a SynchronousQueue).
 * The thread pool executor shown here is configured for the sweet spot for number of threads per CPU.
 * In a real system, this single executor might be used by the entire application and be passed to
 * this module, thus establishing a reasonable app-wide threading policy.
 * In an emergency (Rejected Execution) it lazily creates a backup executor with an unbounded queue
 * in front of it.  It, thus, may deliver notifications late, as well as out of order.
 */
public class PolicyExample {
    private static final int CPUS = Runtime.getRuntime().availableProcessors();

    private static ThreadPoolExecutor BACKUP_EXEC;

    private static final RejectedExecutionHandler BACKUP_EXECUTION
        = new RejectedExecutionHandler() {
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            synchronized (this) {
                if (BACKUP_EXEC =  null) { BACKUP_EXEC = createBackupExecutor(); }
            }
            BACKUP_EXEC.execute(r);
        }
    };

    private static ThreadPoolExecutor createBackupExecutor() {
        ThreadPoolExecutor exec
            = new ThreadPoolExecutor(CPUS + 1, 2 * CPUS + 1, 30, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());
        exec.allowCoreThreadTimeOut(true);
        return exec;
    }

    private static final ThreadPoolExecutor STANDARD_EXEC
        = new ThreadPoolExecutor(CPUS + 1, 2 * CPUS + 1, 30, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());

    static { STANDARD_EXEC.setRejectedExecutionHandler(BACKUP_EXECUTION); }

    public Replicator runReplicator(Database db1, Database db2, ReplicatorChangeListener listener)
        throws CouchbaseLiteException {
        ReplicatorConfiguration config = new ReplicatorConfiguration(db1, new DatabaseEndpoint(db2));
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        Replicator repl = new Replicator(config);
        ListenerToken token = repl.addChangeListener(STANDARD_EXEC, listener::changed);

        repl.start();

        return repl;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration-summary"><a class="anchor" href="#configuration-summary"></a>Configuration Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You should configure and initialize a replicator for each Couchbase Lite database instance you want to sync.
<a href="#ex-simple-repl">Example 1</a> shows the configuration and initialization process.</p>
</div>
<div id="ex-simple-repl" class="exampleblock">
<div class="title">Example 1. Replication configuration and initialization</div>
<div class="content">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset1_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset1_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset1_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">// initialize the replicator configuration
val thisConfig = ReplicatorConfiguration(
    thisDB,
    URLEndpoint(URI("wss://listener.com:8954"))
) <i class="conum" data-value="1"></i><b>(1)</b>

// Set replicator type
thisConfig.setReplicatorType(
    ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL
)

// Configure Sync Mode
thisConfig.setContinuous(false) // default value

// Configure Server Authentication --
// only accept self-signed certs
thisConfig.setAcceptOnlySelfSignedServerCertificate(true) <i class="conum" data-value="2"></i><b>(2)</b>

// Configure the credentials the
// client will provide if prompted
val thisAuth: BasicAuthenticator <i class="conum" data-value="3"></i><b>(3)</b>
thisAuth = BasicAuthenticator("Our Username", "Our PasswordValue")
thisConfig.setAuthenticator(thisAuth)

/* Optionally set custom conflict resolver call back */thisConfig.setConflictResolver() <i class="conum" data-value="4"></i><b>(4)</b>

// Create replicator
// Consider holding a reference somewhere
// to prevent the Replicator from being GCed
val thisReplicator = Replicator(thisConfig) <i class="conum" data-value="5"></i><b>(5)</b>

// Optionally add a change listener <i class="conum" data-value="6"></i><b>(6)</b>
val thisListener: ListenerToken = addChangeListener { change -&gt;
    val err: CouchbaseLiteException = change.getStatus().getError()
    if (err != null) {
        Log.i(
            TAG,
            "Error code ::  " + err.getCode(),
            e
        )
    }
}

// Start replicator
thisReplicator.start(false) <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset1_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">// initialize the replicator configuration
final ReplicatorConfiguration thisConfig
   = new ReplicatorConfiguration(
      thisDB,
      URLEndpoint(URI("wss://listener.com:8954"))); <i class="conum" data-value="1"></i><b>(1)</b>

// Set replicator type
thisConfig.setReplicatorType(
  ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

// Configure Sync Mode
thisConfig.setContinuous(false); // default value

// Configure Server Authentication --
// only accept self-signed certs
thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="2"></i><b>(2)</b>

// Configure the credentials the
// client will provide if prompted
final BasicAuthenticator thisAuth
  = new BasicAuthenticator(
      "Our Username",
      "Our PasswordValue")); <i class="conum" data-value="3"></i><b>(3)</b>

thisConfig.setAuthenticator(thisAuth)

/* Optionally set custom conflict resolver call back */
thisConfig.setConflictResolver( /* define resolver function */); <i class="conum" data-value="4"></i><b>(4)</b>

// Create replicator
// Consider holding a reference somewhere
// to prevent the Replicator from being GCed
final Replicator thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="5"></i><b>(5)</b>

// Optionally add a change listener <i class="conum" data-value="6"></i><b>(6)</b>
ListenerToken thisListener =
  new thisReplicator.addChangeListener(change -&gt; {
    final CouchbaseLiteException err =
     change.getStatus().getError();
     if (err != null) {
       Log.i(TAG, "Error code ::  " + err.getCode(), e);
     }
  });

// Start replicator
thisReplicator.start(false); <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As with any network or file I/O activity, CouchbaseLite activities should not be performed on the UI thread.
<strong>Always</strong> use a <strong>background</strong> thread.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Notes on Example</strong></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Use the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/ReplicatorConfiguration.html">ReplicatorConfiguration</a> class&#8217;s constructor&#8201;&#8212;&#8201;<a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/ReplicatorConfiguration.html#ReplicatorConfiguration-com.couchbase.lite.Database-com.couchbase.lite.Endpoint-">ReplicatorConfiguration( database, endpoint)</a>&#8201;&#8212;&#8201;to initialize the replicator configuration with the local database&#8201;&#8212;&#8201;see also: <a href="#lbl-cfg-tgt">[lbl-cfg-tgt]</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Configure how the client will authenticate the server.
Here we say connect only to servers presenting a self-signed certificate.
By default, clients accept only servers presenting certificates that can be verified using the OS bundled Root CA Certificates&#8201;&#8212;&#8201;see: <a href="#lbl-svr-auth">[lbl-svr-auth]</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Configure the credentials the client will present to the server.
Here we say to provide <em>Basic Authentication</em> credentials. Other options are available&#8201;&#8212;&#8201;see: <a href="#lbl-client-auth">[lbl-client-auth]</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Configure how the replication should handle conflict resolution&#8201;&#8212;&#8201;see: <a href="conflict.html" class="page">Handling Data Conflicts</a> topic for mor on conflict resolution.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Initialize the replicator using your configuration object&#8201;&#8212;&#8201;see: <a href="#lbl-init-repl">[lbl-init-repl]</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Optionally, register an observer, which will notify you of changes to the replication status&#8201;&#8212;&#8201;see: <a href="#lbl-repl-mon">[lbl-repl-mon]</a></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Start the replicator &#8201;&#8212;&#8201;see: <a href="#lbl-repl-start">[lbl-repl-start]</a>.</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div id="lbl-cfg-repl" class="paragraph">
<p>== Configure</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">In this section</dt>
<dd>
<p><a href="#lbl-cfg-tgt">[lbl-cfg-tgt]</a>  |  <a href="#lbl-cfg-sync">[lbl-cfg-sync]</a>  |  <a href="#lbl-cfg-keep-alive">[lbl-cfg-keep-alive]</a>  |  <a href="#lbl-svr-auth">[lbl-svr-auth]</a>  | <a href="#lbl-client-auth">[lbl-client-auth]</a> | <a href="#lbl-repl-evnts">[lbl-repl-evnts]</a> |  <a href="#lbl-repl-hdrs">[lbl-repl-hdrs]</a> |  <a href="#lbl-repl-ckpt">[lbl-repl-ckpt]</a> |  <a href="#lbl-repl-fltrs">[lbl-repl-fltrs]</a> | <a href="#lbl-repl-chan">[lbl-repl-chan]</a> | <a href="#lbl-repl-delta">[lbl-repl-delta]</a></p>
</dd>
</dl>
</div>
<div id="lbl-cfg-tgt" class="paragraph">
<p>=== Configure Target</p>
</div>
<div class="paragraph">
<p>Use the
<a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/ReplicatorConfiguration.html">ReplicatorConfiguration</a> class and <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/ReplicatorConfiguration.html#ReplicatorConfiguration-com.couchbase.lite.Database-com.couchbase.lite.Endpoint-">ReplicatorConfiguration( database, endpoint)</a> constructor to initialize the replication configuration with local and remote database locations.</p>
</div>
<div class="paragraph">
<p>The constructor provides:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the name of the local database to be sync&#8217;d</p>
</li>
<li>
<p>the server&#8217;s URL (including the port number and the name of the remote database to sync with)</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>It is expected that the app will identify the IP address and URL and append the remote database name to the URL endpoint, producing for example: <code>wss://10.0.2.2:4984/travel-sample</code></p>
</div>
<div class="paragraph">
<p>The URL scheme for web socket URLs uses <code>ws:</code> (non-TLS) or <code>wss:</code> (SSL/TLS) prefixes.
To use cleartext, un-encrypted, network traffic (<code>http://</code> and-or <code>ws://</code>),  include <code>android:usesCleartextTraffic="true"</code> in the <code>application</code> element of the manifest as shown on <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted" target="_blank" rel="noopener">android.com</a>.<br>
<strong>This not recommended in production</strong>.</p>
</div>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset2_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset2_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset2_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import android.widget.Toast
import com.couchbase.code_snippets.TensorFlowModel
import com.couchbase.lite.ArrayFunction
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.Blob
import com.couchbase.lite.Conflict
import com.couchbase.lite.ConflictResolver
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.DatabaseConfiguration
import com.couchbase.lite.DatabaseEndpoint
import com.couchbase.lite.Dictionary
import com.couchbase.lite.Document
import com.couchbase.lite.DocumentFlag
import com.couchbase.lite.EncryptionKey
import com.couchbase.lite.Endpoint
import com.couchbase.lite.Expression
import com.couchbase.lite.FullTextExpression
import com.couchbase.lite.FullTextIndexItem
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.Join
import com.couchbase.lite.ListenerToken
import com.couchbase.lite.LogDomain
import com.couchbase.lite.LogFileConfiguration
import com.couchbase.lite.LogLevel
import com.couchbase.lite.Logger
import com.couchbase.lite.Message
import com.couchbase.lite.MessageEndpoint
import com.couchbase.lite.MessageEndpointConnection
import com.couchbase.lite.MessageEndpointDelegate
import com.couchbase.lite.MessageEndpointListener
import com.couchbase.lite.MessageEndpointListenerConfiguration
import com.couchbase.lite.MessagingCloseCompletion
import com.couchbase.lite.MessagingCompletion
import com.couchbase.lite.Meta
import com.couchbase.lite.MutableDictionary
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Ordering
import com.couchbase.lite.PredictionFunction
import com.couchbase.lite.PredictiveIndex
import com.couchbase.lite.PredictiveModel
import com.couchbase.lite.ProtocolType
import com.couchbase.lite.Query
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.ReplicatedDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConnection
import com.couchbase.lite.Result
import com.couchbase.lite.ResultSet
import com.couchbase.lite.SelectResult
import com.couchbase.lite.SessionAuthenticator
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.ValueIndex
import com.couchbase.lite.ValueIndexItem
import com.couchbase.lite.Where
import java.io.File
import java.io.IOException
import java.io.InputStream
import java.net.URI
import java.net.URISyntaxException
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.*

// tag::example-app[]
class Examples(private val context: Context) {
    private val database: Database? = null
    private var replicator: Replicator? = null

    //@Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {
        // tag::getting-started[]

        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        // Get the database (and create it if it doesnt exist).
        val config = DatabaseConfiguration()
        config.setDirectory(context.filesDir.absolutePath)
        val database = Database("getting-started", config)


        // Create a new document (i.e. a record) in the database.
        var mutableDoc: MutableDocument = MutableDocument()
            .setFloat("version", 2.0f)
            .setString("type", "SDK")

        // Save it to the database.
        database.save(mutableDoc)

        // Update a document.
        mutableDoc = database.getDocument(mutableDoc.getId()).toMutable()
        mutableDoc.setString("language", "Java")
        database.save(mutableDoc)
        val document: Document = database.getDocument(mutableDoc.getId())
        // Log the document ID (generated by the database) and properties
        Log.i(TAG, "Document ID :: " + document.getId())
        Log.i(TAG, "Learning " + document.getString("language"))

        // Create a query to fetch documents of type SDK.
        val query: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))
        val result: ResultSet = query.execute()
        Log.i(
            TAG,
            "Number of rows ::  " + result.allResults().size()
        )

        // Create replicators to push and pull changes to and from the cloud.
        val targetEndpoint: Endpoint =
            URLEndpoint(URI("ws://localhost:4984/getting-started-db"))
        val replConfig = ReplicatorConfiguration(database, targetEndpoint)
        replConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL)

        // Add authentication.
        replConfig.setAuthenticator(BasicAuthenticator("sync-gateway", "password"))

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        val replicator = Replicator(replConfig)

        // Listen to replicator change events.
        replicator.addChangeListener({ change -&gt;
            if (change.getStatus().getError() != null) {
                Log.i(
                    TAG,
                    "Error code ::  " + change.getStatus().getError().getCode()
                )
            }
        })

        // Start replication.
        replicator.start()

        // end::getting-started[]
        database.delete()
    }

    // end::example-app[]
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun test1xAttachments() {
        // if db exist, delete it
        deleteDB("android-sqlite", context.filesDir)
        ZipUtils.unzip(getAsset("replacedb/android140-sqlite.cblite2.zip"), context.filesDir)
        val db = Database("android-sqlite", DatabaseConfiguration())
        try {
            val doc: Document = db.getDocument("doc1")

            // For Validation
            val attachments: Dictionary = doc.getDictionary("_attachments")
            val blob: Blob = attachments.getBlob("attach1")
            val content: ByteArray = blob.getContent()
            // For Validation
            val attach =
                String.format(Locale.ENGLISH, "attach1").toByteArray()
            Arrays.equals(attach, content)
        } finally {
            // close db
            db.close()
            // if db exist, delete it
            deleteDB("android-sqlite", context.filesDir)
        }
        val document: Document = MutableDocument()

        // tag::1x-attachment[]
        val attachments: Dictionary = document.getDictionary("_attachments")
        val blob: Blob?
        blob = if (attachments != null) attachments.getBlob("avatar") else null
        val content: ByteArray?
        content = if (blob != null) blob.getContent() else null
        // end::1x-attachment[]
    }

    // ### Initializer
    fun testInitializer() {
        // tag::sdk-initializer[]
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)
        // end::sdk-initializer[]
    }

    // ### New Database
    @Throws(CouchbaseLiteException::class)
    fun testNewDatabase() {
        // tag::new-database[]
        val config = DatabaseConfiguration()
        config.setDirectory(context.filesDir.absolutePath) <i class="conum" data-value="1"></i><b>(1)</b>
        val database = Database("my-database", config)
        // end::new-database[]
        database.delete()
    }

    // ### Database Encryption
    @Throws(CouchbaseLiteException::class)
    fun testDatabaseEncryption() {
        // tag::database-encryption[]
        val config = DatabaseConfiguration()
        config.setEncryptionKey(EncryptionKey("PASSWORD"))
        val database = Database("mydb", config)
        // end::database-encryption[]
    }

    // ### Logging
    fun testLogging() {
        // tag::logging[]
        Database.setLogLevel(LogDomain.DATABASE, LogLevel.VERBOSE)
        Database.setLogLevel(LogDomain.QUERY, LogLevel.VERBOSE)
        // end::logging[]
    }

    fun testEnableCustomLogging() {
        // tag::set-custom-logging[]
        // this custom logger will never be asked to log an event
        // with a log level &lt; WARNING
        Database.log.setCustom(LogTestLogger(LogLevel.WARNING)) <i class="conum" data-value="2"></i><b>(2)</b>
        // end::set-custom-logging[]
    }

    // ### Console logging
    @Throws(CouchbaseLiteException::class)
    fun testConsoleLogging() {
        // tag::console-logging[]
        Database.log.getConsole().setDomain(LogDomain.ALL_DOMAINS) <i class="conum" data-value="3"></i><b>(3)</b>
        Database.log.getConsole().setLevel(LogLevel.VERBOSE) <i class="conum" data-value="4"></i><b>(4)</b>
        // end::console-logging[]
    }

    // ### File logging
    @Throws(CouchbaseLiteException::class)
    fun testFileLogging() {
        // tag::file-logging[]
        val path = context.cacheDir
        val LogCfg = LogFileConfiguration(path.toString()) <i class="conum" data-value="5"></i><b>(5)</b>
        LogCfg.setMaxSize(10240) <i class="conum" data-value="6"></i><b>(6)</b>
        LogCfg.setMaxRotateCount(5) <i class="conum" data-value="7"></i><b>(7)</b>
        LogCfg.setUsePlainText(false) <i class="conum" data-value="8"></i><b>(8)</b>
        Database.log.getFile().setConfig(LogCfg)
        Database.log.getFile().setLevel(LogLevel.INFO) <i class="conum" data-value="9"></i><b>(9)</b>
        // end::file-logging[]
    }

    fun writeConsoleLog() {
        // tag::write-console-logmsg[]
        Database.log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message")
        // end::write-console-logmsg[]
    }

    fun writeCustomLog() {
        // tag::write-custom-logmsg[]
        if (Database.log.Custom)
            Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message")
        // end::write-custom-logmsg[]
    }

    fun writeFileLog() {
        // tag::write-file-logmsg[]
        Database.log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message")
        // end::write-file-logmsg[]
    }

    // ### Loading a pre-built database
    @Throws(IOException::class)
    fun testPreBuiltDatabase() {
        // tag::prebuilt-database[]
        // Note: Getting the path to a database is platform-specific.
        // For Android you need to extract it from your
        // assets to a temporary directory and then pass that path to Database.copy()
        val configuration = DatabaseConfiguration()
        if (!Database.exists("travel-sample", context.filesDir)) {
            ZipUtils.unzip(getAsset("travel-sample.cblite2.zip"), context.filesDir)
            val path = File(context.filesDir, "travel-sample")
            try {
                Database.copy(path, "travel-sample", configuration)
            } catch (e: CouchbaseLiteException) {
                e.printStackTrace()
            }
        }
        // end::prebuilt-database[]
    }

    // helper methods
    // if db exist, delete it
    private fun deleteDB(name: String, dir: File) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            // sometimes, db is still in used, wait for a while. Maximum 3 sec
            for (i in 0..9) {
                try {
                    Database.delete(name, dir)
                    break
                } catch (ex: CouchbaseLiteException) {
                    try {
                        Thread.sleep(300)
                    } catch (ignore: InterruptedException) {
                    }
                }
            }
        }
    }

    // ### Initializers
    fun testInitializers() {
        // tag::initializer[]
        val newTask = MutableDocument()
        newTask.setString("type", "task")
        newTask.setString("owner", "todo")
        newTask.setDate("createdAt", Date())
        try {
            database.save(newTask)
        } catch (e: CouchbaseLiteException) {
            Log.e(TAG, e.toString())
        }
        // end::initializer[]
    }

    // ### Mutability
    fun testMutability() {
        try {
            database.save(MutableDocument("xyz"))
        } catch (ignore: CouchbaseLiteException) {
        }

        // tag::update-document[]
        val document: Document = database.getDocument("xyz")
        val mutableDocument: MutableDocument = document.toMutable()
        mutableDocument.setString("name", "apples")
        try {
            database.save(mutableDocument)
        } catch (e: CouchbaseLiteException) {
            Log.e(TAG, e.toString())
        }
        // end::update-document[]
    }

    // ### Typed Accessors
    fun testTypedAccessors() {
        val newTask = MutableDocument()

        // tag::date-getter[]
        newTask.setValue("createdAt", Date())
        val date: Date = newTask.getDate("createdAt")
        // end::date-getter[]
    }

    // ### Batch operations
    fun testBatchOperations() {
        // tag::batch[]
        try {
            database.inBatch({
                for (i in 0..9) {
                    val doc = MutableDocument()
                    doc.setValue("type", "user")
                    doc.setValue("name", "user $i")
                    doc.setBoolean("admin", false)
                    try {
                        database.save(doc)
                    } catch (e: CouchbaseLiteException) {
                        Log.e(TAG, e.toString())
                    }
                    Log.i(
                        TAG,
                        java.lang.String.format("saved user document %s", doc.getString("name"))
                    )
                }
            })
        } catch (e: CouchbaseLiteException) {
            Log.e(TAG, e.toString())
        }
        // end::batch[]
    }

    // ### Document Expiration
    @Throws(CouchbaseLiteException::class)
    fun DocumentExpiration() {
        // tag::document-expiration[]
        // Purge the document one day from now
        val ttl =
            Instant.now().plus(1, ChronoUnit.DAYS)
        database.setDocumentExpiration("doc123", Date(ttl.toEpochMilli()))

        // Reset expiration
        database.setDocumentExpiration("doc1", null)

        // Query documents that will be expired in less than five minutes
        val fiveMinutesFromNow =
            Instant.now().plus(5, ChronoUnit.MINUTES)
        val query: Query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.expiration.lessThan(Expression.doubleValue(fiveMinutesFromNow.toEpochMilli())))
        // end::document-expiration[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testDocumentChangeListener() {
        // tag::document-listener[]
        database.addDocumentChangeListener(
            "user.john",
            { change -&gt;
                val doc: Document = database.getDocument(change.getDocumentID())
                if (doc != null) {
                    Toast.makeText(
                        context,
                        "Status: " + doc.getString("verified_account"),
                        Toast.LENGTH_SHORT
                    ).show()
                }
            })
        // end::document-listener[]
    }

    // ### Blobs
    fun testBlobs() {
        val newTask = MutableDocument()

        // tag::blob[]
        val `is`: InputStream = getAsset("avatar.jpg") ?: return
        try {
            val blob = Blob("image/jpeg", `is`)
            newTask.setBlob("avatar", blob)
            database.save(newTask)
            val taskBlob: Blob = newTask.getBlob("avatar")
            val bytes: ByteArray = taskBlob.getContent()
        } catch (e: CouchbaseLiteException) {
            Log.e(TAG, e.toString())
        } finally {
            try {
                `is`.close()
            } catch (ignore: IOException) {
            }
        }
        // end::blob[]
    }

    // ### Indexing
    @Throws(CouchbaseLiteException::class)
    fun testIndexing() {
        // For Documentation
        run {
            // tag::query-index[]
            database.createIndex(
                "TypeNameIndex",
                IndexBuilder.valueIndex(
                    ValueIndexItem.property("type"),
                    ValueIndexItem.property("name")
                )
            )
            // end::query-index[]
        }
    }

    // ### SELECT statement
    fun testSelectStatement() {
        run {

            // tag::query-select-meta[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("type")
                )
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.expression(Meta.id))
            try {
                val rs: ResultSet = query.execute()
                for (result in rs) {
                    Log.i(
                        "Sample",
                        java.lang.String.format("hotel id -&gt; %s", result.getString("id"))
                    )
                    Log.i(
                        "Sample",
                        java.lang.String.format("hotel name -&gt; %s", result.getString("name"))
                    )
                }
            } catch (e: CouchbaseLiteException) {
                Log.e("Sample", e.getLocalizedMessage())
            }
        }
    }

    // META function
    @Throws(CouchbaseLiteException::class)
    fun testMetaFunction() {
        // For Documentation
        run {
            val query: Query = QueryBuilder
                .select(SelectResult.expression(Meta.id))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport")))
                .orderBy(Ordering.expression(Meta.id))
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.w(
                    "Sample",
                    java.lang.String.format("airport id -&gt; %s", result.getString("id"))
                )
                Log.w(
                    "Sample",
                    java.lang.String.format("airport id -&gt; %s", result.getString(0))
                )
            }
        }
    }

    // ### all(*)
    @Throws(CouchbaseLiteException::class)
    fun testSelectAll() {
        // For Documentation
        run {

            // tag::query-select-all[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
            // end::query-select-all[]

            // tag::live-query[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            val token: ListenerToken = query.addChangeListener({ change -&gt;
                for (result in change.getResults()) {
                    Log.d(TAG, "results: " + result.getKeys())
                    /* Update UI */
                }
            })

            // Start live query.
            query.execute() <i class="conum" data-value="1"></i><b>(1)</b>
            // end::live-query[]

            // tag::stop-live-query[]
            query.removeChangeListener(token)
            // end::stop-live-query[]
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format(
                        "hotel -&gt; %s",
                        result.getDictionary(DATABASE_NAME).toMap()
                    )
                )
            }
        }
    }

    // ###WHERE statement
    @Throws(CouchbaseLiteException::class)
    fun testWhereStatement() {
        // For Documentation
        run {

            // tag::query-where[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .limit(Expression.intValue(10))
            val rs: ResultSet = query.execute()
            for (result in rs) {
                val all: Dictionary = result.getDictionary(DATABASE_NAME)
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", all.getString("name"))
                )
                Log.i(
                    "Sample",
                    java.lang.String.format("type -&gt; %s", all.getString("type"))
                )
            }
            // end::query-where[]
        }
    }

    fun testQueryDeletedDocuments() {
        // tag::query-deleted-documents[]
        // Query documents that have been deleted
        val query: Where = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted)
        // end::query-deleted-documents[]
    }

    // ####Collection Operators
    @Throws(CouchbaseLiteException::class)
    fun testCollectionStatement() {
        // For Documentation
        run {

            // tag::query-collection-operator-contains[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("public_likes")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("hotel"))
                        .and(
                            ArrayFunction
                                .contains(
                                    Expression.property("public_likes"),
                                    Expression.string("Armani Langworth")
                                )
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format(
                        "public_likes -&gt; %s",
                        result.getArray("public_likes").toList()
                    )
                )
            }
            // end::query-collection-operator-contains[]
        }
    }

    // IN operator
    @Throws(CouchbaseLiteException::class)
    fun testInOperator() {
        // For Documentation
        run {

            // tag::query-collection-operator-in[]
            val values: Array&lt;Expression&gt; = arrayOf&lt;Expression&gt;(
                Expression.property("first"),
                Expression.property("last"),
                Expression.property("username")
            )
            val query: Query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.string("Armani").`in`(values))
            // end::query-collection-operator-in[]
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.w(
                    "Sample",
                    java.lang.String.format("%s", result.toMap().toString())
                )
            }
            // end::query-collection-operator-in[]
        }
    }

    // Pattern Matching
    @Throws(CouchbaseLiteException::class)
    fun testPatternMatching() {
        // For Documentation
        run {

            // tag::query-like-operator[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("landmark"))
                        .and(
                            Function.lower(Expression.property("name"))
                                .like(Function.Expression.string("royal engineers museum"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", result.getString("name"))
                )
            }
            // end::query-like-operator[]
        }
    }

    // ### Wildcard Match
    @Throws(CouchbaseLiteException::class)
    fun testWildcardMatch() {
        // For Documentation
        run {

            // tag::query-like-operator-wildcard-match[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("landmark"))
                        .and(
                            Function.lower(Expression.property("name"))
                                .like(Expression.string("eng%e%"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", result.getString("name"))
                )
            }
            // end::query-like-operator-wildcard-match[]
        }
    }

    // Wildcard Character Match
    @Throws(CouchbaseLiteException::class)
    fun testWildCharacterMatch() {
        // For Documentation
        run {

            // tag::query-like-operator-wildcard-character-match[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("landmark"))
                        .and(
                            Function.lower(Expression.property("name"))
                                .like(Expression.string("eng____r"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", result.getString("name"))
                )
            // end::query-like-operator-wildcard-character-match[]
            }
        }
    }

    // ### Regex Match
    @Throws(CouchbaseLiteException::class)
    fun testRegexMatch() {
        // For Documentation
        run {

            // tag::query-regex-operator[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("landmark"))
                        .and(
                            Function.lower(Expression.property("name"))
                                .regex(Expression.string("\\beng.*r\\b"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", result.getString("name"))
                )
            }
            // end::query-regex-operator[]
        }
    }

    // JOIN statement
    @Throws(CouchbaseLiteException::class)
    fun testJoinStatement() {
        // For Documentation
        run {

            // tag::query-join[]
            val query: Query = QueryBuilder.select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route"))
            )
                .from(DataSource.database(database).`as`("airline"))
                .join(
                    Join.join(DataSource.database(database).`as`("route"))
                        .on(
                            Meta.id.from("airline")
                                .equalTo(Expression.property("airlineid").from("route"))
                        )
                )
                .where(
                    Expression.property("type").from("route").equalTo(Expression.string("route"))
                        .and(
                            Expression.property("type").from("airline")
                                .equalTo(Expression.string("airline"))
                        )
                        .and(
                            Expression.property("sourceairport").from("route")
                                .equalTo(Expression.string("RIX"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.w(
                    "Sample",
                    java.lang.String.format("%s", result.toMap().toString())
                )
            }
            // end::query-join[]
        }
    }

    // ### GROUPBY statement
    @Throws(CouchbaseLiteException::class)
    fun testGroupByStatement() {
        // For Documentation
        run {

            // tag::query-groupby[]
            val query: Query = QueryBuilder.select(
                SelectResult.expression(Function.count(Expression.string("*"))),
                SelectResult.property("country"),
                SelectResult.property("tz")
            )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("airport"))
                        .and(
                            Expression.property("geo.alt")
                                .greaterThanOrEqualTo(Expression.intValue(300))
                        )
                )
                .groupBy(
                    Expression.property("country"),
                    Expression.property("tz")
                )
                .orderBy(Ordering.expression(Function.count(Expression.string("*"))).descending())
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format(
                        "There are %d airports on the %s timezone located in %s and above 300ft",
                        result.getInt("$1"),
                        result.getString("tz"),
                        result.getString("country")
                    )
                )
            }
            // end::query-groupby[]
        }
    }

    // ### ORDER BY statement
    @Throws(CouchbaseLiteException::class)
    fun testOrderByStatement() {
        // For Documentation
        run {

            // tag::query-orderby[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.property("name").ascending())
                .limit(Expression.intValue(10))
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i("Sample", java.lang.String.format("%s", result.toMap()))
            }
            // end::query-orderby[]
        }
    }

    // ### EXPLAIN statement
    @Throws(CouchbaseLiteException::class)
    fun testExplainStatement() {
        // For Documentation
        run {

            // tag::query-explain-all[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("university")))
                .groupBy(Expression.property("country"))
                .orderBy(Ordering.property("name").descending()) <i class="conum" data-value="10"></i><b>(10)</b>
            Log.i(query.explain()) <i class="conum" data-value="11"></i><b>(11)</b>
            // end::query-explain-all[]
            // tag::query-explain-like[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("%hotel%"))) <i class="conum" data-value="12"></i><b>(12)</b>
            Log.i(query.explain())
            // end::query-explain-like[]
            // tag::query-explain-nopfx[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="13"></i><b>(13)</b>
                        .and(Expression.property("name").like(Expression.string("%royal%")))
                )
            Log.i(query.explain())
            // end::query-explain-nopfx[]
            // tag::query-explain-function[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(
                    Function.lower(
                        Expression.property("type").equalTo(Expression.string("hotel"))
                    )
                ) <i class="conum" data-value="14"></i><b>(14)</b>
            Log.i(query.explain())
            // end::query-explain-function[]
            // tag::query-explain-nofunction[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))) <i class="conum" data-value="15"></i><b>(15)</b>
            Log.i(query.explain())
            // end::query-explain-nofunction[]
        }
    } // end query-explain
    // end::query-explain[]
    @Throws(CouchbaseLiteException::class)
    fun prepareIndex() {
        // tag::fts-index[]
        database.createIndex(
            "nameFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("name")).ignoreAccents(false)
        )
        // end::fts-index[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS() {
        // tag::fts-query[]
        val whereClause: Expression = FullTextExpression.index("nameFTSIndex").match("buy")
        val ftsQuery: Query = QueryBuilder.select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause)
        val ftsQueryResult: ResultSet = ftsQuery.execute()
        for (result in ftsQueryResult) {
            Log.i(
                TAG,
                java.lang.String.format("document properties %s", result.getString(0))
            )
        }
        // end::fts-query[]
    }

    /* The `tag::replication[]` example is inlined in java.adoc */
    fun testTroubleshooting() {
        // tag::replication-logging[]
        Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE)
        // end::replication-logging[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationBasicAuthentication() {
        // tag::basic-authentication[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setAuthenticator(BasicAuthenticator("username", "password"))

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()
        // end::basic-authentication[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationSessionAuthentication() {
        // tag::session-authentication[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setAuthenticator(SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447"))

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()
        // end::session-authentication[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationStatus() {
        val uri = URI("ws://localhost:4984/db")
        val endpoint: Endpoint = URLEndpoint(uri)
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)

        // tag::replication-status[]
        replicator.addChangeListener({ change -&gt;
            if (change.getStatus().getActivityLevel() === Replicator.ActivityLevel.STOPPED) {
                Log.i(TAG, "Replication stopped")
            }
        })
        // end::replication-status[]
    }

    internal inner class PendingDocsExample {
        private val database: Database? = null
        private var replicator: Replicator? = null

        //  BEGIN PendingDocuments IB -- 11/Feb/21 --
        @Throws(URISyntaxException::class, CouchbaseLiteException::class)
        fun testReplicationPendingDocs() {
            // nottag::replication-pendingdocuments[]
            // ... include other code as required
            //
            val endpoint: Endpoint = URLEndpoint(URI("ws://localhost:4984/db"))
            val config: ReplicatorConfiguration = ReplicatorConfiguration(database, endpoint)
                .setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH)
            // tag::replication-push-pendingdocumentids[]
            replicator = Replicator(config)
            val pendingDocs: Set&lt;String&gt; = replicator.getPendingDocumentIds() <i class="conum" data-value="16"></i><b>(16)</b>

            // end::replication-push-pendingdocumentids[]
            replicator.addChangeListener({ change -&gt;
                onStatusChanged(
                    pendingDocs,
                    change.getStatus()
                )
            })
            replicator.start()

            // ... include other code as required
            // notend::replication-pendingdocuments[]
        }

        //
        // tag::replication-pendingdocuments[]
        //
        private fun onStatusChanged(
            @NonNull pendingDocs: Set&lt;String&gt;,
            @NonNull status: Replicator.Status
        ) {
            // ... sample onStatusChanged function
            //
            Log.i(
                Companion.TAG,
                "Replicator activity level is " + status.getActivityLevel().toString()
            )

            // iterate and report-on previously
            // retrieved pending docids 'list'
            val itr = pendingDocs.iterator()
            while (itr.hasNext()) {
                val docId = itr.next()
                try {
                    // tag::replication-push-isdocumentpending[]
                    if (!replicator.isDocumentPending(docId)) {
                        continue
                    } <i class="conum" data-value="17"></i><b>(17)</b>
                    // end::replication-push-isdocumentpending[]
                    itr.remove()
                    Log.i(
                        Companion.TAG,
                        "Doc ID $docId has been pushed"
                    )
                } catch (e: CouchbaseLiteException) {
                    Log.w(
                        Companion.TAG,
                        "isDocumentPending failed",
                        e
                    )
                }
            }
        } // end::replication-pendingdocuments[]

        //  END PendingDocuments BM -- 19/Feb/21 --
        companion object {
            private const val TAG = "SCRATCH"
        }
    }

    @Throws(URISyntaxException::class)
    fun testHandlingNetworkErrors() {
        val endpoint: Endpoint = URLEndpoint(URI("ws://localhost:4984/db"))
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)

        // tag::replication-error-handling[]
        replicator.addChangeListener({ change -&gt;
            val error: CouchbaseLiteException = change.getStatus().getError()
            if (error != null) {
                Log.w(TAG, "Error code:: %d", error)
            }
        })
        replicator.start()
        // end::replication-error-handling[]
        replicator.stop()
    }

    @Throws(URISyntaxException::class)
    fun testReplicatorDocumentEvent() {
        val endpoint: Endpoint = URLEndpoint(URI("ws://localhost:4984/db"))
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)

        // tag::add-document-replication-listener[]
        val token: ListenerToken = replicator.addDocumentReplicationListener({ replication -&gt;
            if (replication.isPush()) Log.i(
                TAG,
                "Replication type: " + "Push"
            ) else Log.i(TAG, "Replication type: " + "Pull")
            for (document in replication.getDocuments()) {
                Log.i(TAG, "Doc ID: " + document.getID())
                val err: CouchbaseLiteException = document.getError()
                if (err != null) {
                    // There was an error
                    Log.e(TAG, "Error replicating document: ", err)
                    return@addDocumentReplicationListener
                }
                if (document.flags().contains(DocumentFlag.DocumentFlagsDeleted)) {
                    Log.i(
                        TAG,
                        "Successfully replicated a deleted document"
                    )
                }
            }
        })
        replicator.start()
        // end::add-document-replication-listener[]

        // tag::remove-document-replication-listener[]
        replicator.removeChangeListener(token)
        // end::remove-document-replication-listener[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationCustomHeader() {
        val uri = URI("ws://localhost:4984/db")
        val endpoint: Endpoint = URLEndpoint(uri)

        // tag::replication-custom-header[]
        val config = ReplicatorConfiguration(database, endpoint)
        val headers: MutableMap&lt;String, String&gt; =
            HashMap()
        headers["CustomHeaderName"] = "Value"
        config.setHeaders(headers)
        // end::replication-custom-header[]
    }

    // ### Certificate Pinning
    @Throws(URISyntaxException::class, IOException::class)
    fun testCertificatePinning() {
        val uri = URI("ws://localhost:4984/db")
        val endpoint: Endpoint = URLEndpoint(uri)
        val config = ReplicatorConfiguration(database, endpoint)

        // tag::certificate-pinning[]
        val `is`: InputStream = getAsset("cert.cer")
        val cert: ByteArray = IOUtils.toByteArray(`is`)
        if (`is` != null) {
            try {
                `is`.close()
            } catch (ignore: IOException) {
            }
        }
        config.setPinnedServerCertificate(cert)
        // end::certificate-pinning[]
    }

    // ### Reset replicator checkpoint
    @Throws(URISyntaxException::class)
    fun testReplicationResetCheckpoint() {
        val uri = URI("ws://localhost:4984/db")
        val endpoint: Endpoint = URLEndpoint(uri)
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()

        // tag::replication-reset-checkpoint[]
        replicator.resetCheckpoint()
        replicator.start()
        // end::replication-reset-checkpoint[]
        replicator.stop()
    }

    @Throws(URISyntaxException::class)
    fun testReplicationPushFilter() {
        // tag::replication-push-filter[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setPushFilter({ document, flags -&gt; flags.contains(DocumentFlag.DocumentFlagsDeleted) }) <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()
        // end::replication-push-filter[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationPullFilter() {
        // tag::replication-pull-filter[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setPullFilter({ document, flags -&gt; "draft" == document.getString("type") }) <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()
        // end::replication-pull-filter[]
    }

    @Throws(URISyntaxException::class)
    fun testCustomRetryConfig() {
        // tag::replication-retry-config[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)

        //  other config as required . . .
        // tag::replication-heartbeat-config[]
        config.setHeartbeat(150L) <i class="conum" data-value="18"></i><b>(18)</b>
        // end::replication-heartbeat-config[]
        // tag::replication-maxretries-config[]
        config.setMaxRetries(20L) <i class="conum" data-value="19"></i><b>(19)</b>
        // end::replication-maxretries-config[]
        // tag::replication-maxretrywaittime-config[]
        config.setMaxRetryWaitTime(600L) <i class="conum" data-value="20"></i><b>(20)</b>
        // end::replication-maxretrywaittime-config[]
        val repl = Replicator(config)

        // end::replication-retry-config[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testDatabaseReplica() {
        var config: DatabaseConfiguration? = DatabaseConfiguration()
        val database1 = Database("mydb", config)
        config = DatabaseConfiguration()
        val database2 = Database("db2", config)

        /* EE feature: code below might throw a compilation error
           if it's compiled against CBL Android Community. */
        // tag::database-replica[]
        val targetDatabase = DatabaseEndpoint(database2)
        val replicatorConfig =
            ReplicatorConfiguration(database1, targetDatabase)
        replicatorConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH)

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(replicatorConfig)
        replicator.start()
        // end::database-replica[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveModel() {
        val config = DatabaseConfiguration()
        val database = Database("mydb", config)

        // tag::register-model[]
        Database.prediction.registerModel("ImageClassifier", ImageClassifierModel())
        // end::register-model[]

        // tag::predictive-query-value-index[]
        val index: ValueIndex =
            IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")))
        database.createIndex("value-index-image-classifier", index)
        // end::predictive-query-value-index[]

        // tag::unregister-model[]
        Database.prediction.unregisterModel("ImageClassifier")
        // end::unregister-model[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveIndex() {
        val config = DatabaseConfiguration()
        val database = Database("mydb", config)

        // tag::predictive-query-predictive-index[]
        val inputMap: MutableMap&lt;String, Any&gt; =
            HashMap()
        inputMap["numbers"] = Expression.property("photo")
        val input: Expression = Expression.map(inputMap)
        val index: PredictiveIndex = IndexBuilder.predictiveIndex("ImageClassifier", input, null)
        database.createIndex("predictive-index-image-classifier", index)
        // end::predictive-query-predictive-index[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveQuery() {
        val config = DatabaseConfiguration()
        val database = Database("mydb", config)

        // tag::predictive-query[]
        val inputProperties: MutableMap&lt;String, Any&gt; =
            HashMap()
        inputProperties["photo"] = Expression.property("photo")
        val input: Expression = Expression.map(inputProperties)
        val prediction: PredictionFunction =
            PredictiveModel.predict("ImageClassifier", input) <i class="conum" data-value="1"></i><b>(1)</b>
        val query: Query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("label").equalTo(Expression.string("car"))
                    .and(
                        Expression.property("probability")
                            .greaterThanOrEqualTo(Expression.doubleValue(0.8))
                    )
            )

        // Run the query.
        val result: ResultSet = query.execute()
        Log.d(TAG, "Number of rows: " + result.allResults().size())
        // end::predictive-query[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationWithCustomConflictResolver() {
        // tag::replication-conflict-resolver[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setConflictResolver(LocalWinConflictResolver())
        val replication = Replicator(config)
        replication.start()
        // end::replication-conflict-resolver[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testSaveWithCustomConflictResolver() {
        // tag::update-document-with-conflict-handler[]
        val doc: Document = database.getDocument("xyz") ?: return
        val mutableDocument: MutableDocument = doc.toMutable()
        mutableDocument.setString("name", "apples")
        database.save(
            mutableDocument,
            { newDoc, curDoc -&gt;  <i class="conum" data-value="21"></i><b>(21)</b>
                if (curDoc == null) {
                    return@save false
                } <i class="conum" data-value="22"></i><b>(22)</b>
                val dataMap: MutableMap&lt;String, Any&gt; =
                    curDoc.toMap()
                dataMap.putAll(newDoc.toMap()) <i class="conum" data-value="23"></i><b>(23)</b>
                newDoc.setData(dataMap)
                true <i class="conum" data-value="24"></i><b>(24)</b>
            }) <i class="conum" data-value="25"></i><b>(25)</b>
        // end::update-document-with-conflict-handler[]
    }

    companion object {
        private const val TAG = "EXAMPLE"
        private const val DATABASE_NAME = "database"
    }

}

// tag::update-document-with-conflict-handler-callouts[]

&lt;.&gt; The conflict handler code is provided as a lambda.

&lt;.&gt; If the handler cannot resolve a conflict, it can return false.
In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.

&lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.

&lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).

&lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method
// end::update-document-with-conflict-handler-callouts[]


// tag::local-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
internal class LocalWinConflictResolver : ConflictResolver {
    fun resolve(conflict: Conflict): Document {
        return conflict.getLocalDocument()
    }
} // end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
internal class RemoteWinConflictResolver : ConflictResolver {
    fun resolve(conflict: Conflict): Document {
        return conflict.getRemoteDocument()
    }
} // end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
// Using replConfig.setConflictResolver(new MergeConflictResolver());
internal class MergeConflictResolver : ConflictResolver {
    fun resolve(conflict: Conflict): Document {
        val merge: MutableMap&lt;String, Any&gt; =
            conflict.getLocalDocument().toMap()
        merge.putAll(conflict.getRemoteDocument().toMap())
        return MutableDocument(conflict.getDocumentId(), merge)
    }
} // end::merge-conflict-resolver[]

/* ----------------------------------------------------------- */ /* ---------------------  ACTIVE SIDE  ----------------------- */ /* ----------------------------------------------------------- */
internal class BrowserSessionManager private constructor(private val context: Context) :
    MessageEndpointDelegate {
    private var replicator: Replicator? = null

    @Throws(CouchbaseLiteException::class)
    fun initCouchbase() {
        // tag::message-endpoint[]
        val databaseConfiguration = DatabaseConfiguration(context)
        val database = Database("mydb", databaseConfiguration)

        // The delegate must implement the `MessageEndpointDelegate` protocol.
        val messageEndpointTarget = MessageEndpoint(
            "UID:123",
            "active",
            ProtocolType.MESSAGE_STREAM,
            this
        )
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        val config =
            ReplicatorConfiguration(database, messageEndpointTarget)

        // Create the replicator object.
        replicator = Replicator(config)
        // Start the replication.
        replicator.start()
        // end::message-endpoint-replicator[]
    }

    // tag::create-connection[]
    /* implementation of MessageEndpointDelegate */
    @NonNull
    fun createConnection(@NonNull endpoint: MessageEndpoint?): MessageEndpointConnection {
        return ActivePeerConnection() /* implements MessageEndpointConnection */
    } // end::create-connection[]

}

internal class ActivePeerConnection : MessageEndpointConnection {
    private var replicatorConnection: ReplicatorConnection? = null
    fun disconnect() {
        // tag::active-replicator-close[]
        replicatorConnection.close(null)
        // end::active-replicator-close[]
    }

    // tag::active-peer-open[]
    /* implementation of MessageEndpointConnection */
    fun open(
        @NonNull connection: ReplicatorConnection?,
        @NonNull completion: MessagingCompletion
    ) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    // end::active-peer-open[]
    // tag::active-peer-close[]
    fun close(
        error: Exception?,
        @NonNull completion: MessagingCloseCompletion
    ) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete()
    }

    // end::active-peer-close[]
    // tag::active-peer-send[]
    /* implementation of MessageEndpointConnection */
    fun send(@NonNull message: Message?, @NonNull completion: MessagingCompletion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null)
    }

    // end::active-peer-send[]
    fun receive(message: Message?) {
        // tag::active-peer-receive[]
        replicatorConnection.receive(message)
        // end::active-peer-receive[]
    }
} /* ----------------------------------------------------------- */ /* ---------------------  PASSIVE SIDE  ---------------------- */ /* ----------------------------------------------------------- */

internal class PassivePeerConnection private constructor(private val context: Context) :
    MessageEndpointConnection {
    private var messageEndpointListener: MessageEndpointListener? = null
    private var replicatorConnection: ReplicatorConnection? = null

    @Throws(CouchbaseLiteException::class)
    fun startListener() {
        // tag::listener[]
        val databaseConfiguration = DatabaseConfiguration()
        val database = Database("mydb", databaseConfiguration)
        val listenerConfiguration =
            MessageEndpointListenerConfiguration(
                database,
                ProtocolType.MESSAGE_STREAM
            )
        messageEndpointListener = MessageEndpointListener(listenerConfiguration)
        // end::listener[]
    }

    fun stopListener() {
        // tag::passive-stop-listener[]
        messageEndpointListener.closeAll()
        // end::passive-stop-listener[]
    }

    fun accept() {
        // tag::advertizer-accept[]
        val connection = PassivePeerConnection(context) /* implements
        MessageEndpointConnection */
        messageEndpointListener.accept(connection)
        // end::advertizer-accept[]
    }

    fun disconnect() {
        // tag::passive-replicator-close[]
        replicatorConnection.close(null)
        // end::passive-replicator-close[]
    }

    // tag::passive-peer-open[]
    /* implementation of MessageEndpointConnection */
    fun open(
        @NonNull connection: ReplicatorConnection?,
        @NonNull completion: MessagingCompletion
    ) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    // end::passive-peer-open[]
    // tag::passive-peer-close[]
    /* implementation of MessageEndpointConnection */
    fun close(
        error: Exception?,
        @NonNull completion: MessagingCloseCompletion
    ) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete()
    }

    // end::passive-peer-close[]
    // tag::passive-peer-send[]
    /* implementation of MessageEndpointConnection */
    fun send(@NonNull message: Message?, @NonNull completion: MessagingCompletion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null)
    }

    // end::passive-peer-send[]
    fun receive(message: Message?) {
        // tag::passive-peer-receive[]
        replicatorConnection.receive(message)
        // end::passive-peer-receive[]
    }

} // tag::predictive-model[]

// `tensorFlowModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
internal class ImageClassifierModel : PredictiveModel {
    fun predict(@NonNull input: Dictionary): Dictionary? {
        val blob: Blob = input.getBlob("photo") ?: return null

        // `tensorFlowModel` is a fake implementation
        // this would be the implementation of the ml model you have chosen
        return MutableDictionary(TensorFlowModel.predictImage(blob.getContent())) <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

internal object TensorFlowModel {
    fun predictImage(data: ByteArray?): Map&lt;String, Any&gt;? {
        return null
    }
} // end::predictive-model[]

// tag::custom-logging[]
internal class LogTestLogger(@NonNull level: LogLevel) : Logger {
    @NonNull
    private val level: LogLevel

    @NonNull
    fun getLevel(): LogLevel {
        return level
    }

    fun log(
        @NonNull level: LogLevel?,
        @NonNull domain: LogDomain?,
        @NonNull message: String?
    ) {
        // this method will never be called if param level &lt; this.level
        // handle the message, for example piping it to a third party framework
    }

    init {
        this.level = level
    }
}

class CertAuthListener {
    companion object {
        private const val TAG = "PWD"
        private var CERT_ATTRIBUTES: Map&lt;String, String&gt;? = null

        init {
            val m: Map&lt;String, String&gt; =
                HashMap()
            com.couchbase.code_snippets.m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test")
            com.couchbase.code_snippets.m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase")
            com.couchbase.code_snippets.m.put(
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT,
                "Mobile"
            )
            com.couchbase.code_snippets.m.put(
                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS,
                "lite@couchbase.com"
            )
            CERT_ATTRIBUTES =
                Collections.unmodifiableMap(com.couchbase.code_snippets.m)
        }
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val serverIdentity: TLSIdentity = TLSIdentity.createIdentity(
            true,
            CERT_ATTRIBUTES,
            null,
            "server"
        )
        val clientIdentity: TLSIdentity = TLSIdentity.createIdentity(
            false,
            CERT_ATTRIBUTES,
            null,
            "client"
        )
        val uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts())
            ?: throw IOException("Failed to start the server")
        Thread(Runnable {
            try {
                startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb)
                Log.e(TAG, "Success!!")
                deleteIdentity("server")
                Log.e(TAG, "Alias deleted: server")
                deleteIdentity("client")
                Log.e(TAG, "Alias deleted: client")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }).start()
    }

    // start a client replicator
    @Throws(CertificateEncodingException::class, InterruptedException::class)
    fun startClient(
        @NonNull uri: URI?,
        @NonNull cert: Certificate,
        @NonNull clientIdentity: TLSIdentity,
        @NonNull db: Database?
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL)
        config.setContinuous(false)
        configureClientCerts(config, cert, clientIdentity)
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)
        repl.addChangeListener({ change -&gt;
            if (change.getStatus()
                    .getActivityLevel() === AbstractReplicator.ActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        })
        repl.start(false)
        completionLatch.await()
    }
    // tag::listener-config-auth-cert-full[]
    /**
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     *
     *
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    @Throws(CouchbaseLiteException::class)
    fun startServer(
        @NonNull db: Database?,
        @NonNull serverId: TLSIdentity?,
        @NonNull certs: List&lt;Certificate?&gt;?
    ): URI? {
        val config = URLEndpointListenerConfiguration(db)
        config.setPort(0) // this is the default
        config.setDisableTls(false)
        config.setTlsIdentity(serverId)
        config.setAuthenticator(ListenerCertificateAuthenticator(certs))
        val listener = URLEndpointListener(config)
        listener.start()
        val urls: List&lt;URI&gt; = listener.getUrls()
        return if (urls.isEmpty()) {
            null
        } else urls[0]
    }
    // end::listener-config-auth-cert-full[]
    // tag::listener-config-delete-cert-full[]
    /**
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    @Throws(
        KeyStoreException::class,
        CertificateException::class,
        NoSuchAlgorithmException::class,
        IOException::class
    )
    fun deleteIdentity(alias: String?) {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        keyStore.deleteEntry(alias) <i class="conum" data-value="26"></i><b>(26)</b>
    }
    // end::listener-config-delete-cert-full[]
    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /**
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     *
     *
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    @Throws(CertificateEncodingException::class)
    private fun configureClientCerts(
        config: ReplicatorConfiguration,
        @NonNull cert: Certificate,
        @NonNull clientIdentity: TLSIdentity
    ) {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(ClientCertificateAuthenticator(clientIdentity))

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded())
    }
    // notend::p2p-tlsid-tlsidentity-with-label[]
    /**
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     *
     *
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    @Throws(IOException::class)
    private fun readCertMaterialFromBundle(
        @NonNull context: Context,
        resId: Int
    ): ByteArray {
        val out = ByteArrayOutputStream()
        val `in` = context.resources.openRawResource(resId)
        val buf = ByteArray(1024)
        var n: Int
        while (`in`.read(buf).also { n = it } &gt;= 0) {
            out.write(buf, 0, n)
        }
        return out.toByteArray()
    }
}

class PasswordAuthListener {
    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray())
            ?: throw IOException("Failed to start the server")
        Thread(Runnable {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb)
                Log.e(TAG, "Success!!")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }).start()
    }

    // start a client replicator
    @Throws(InterruptedException::class)
    fun runClient(
        @NonNull uri: URI?,
        @NonNull username: String?,
        @NonNull password: CharArray?,
        @NonNull db: Database?
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL)
        config.setContinuous(false)
        config.setAuthenticator(BasicAuthenticator(username, password))
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)
        repl.addChangeListener({ change -&gt;
            if (change.getStatus()
                    .getActivityLevel() === AbstractReplicator.ActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        })
        repl.start(false)
        completionLatch.await()
    }
    // tag::listener-config-client-auth-pwd-full[]
    /**
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     *
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    fun startServer(
        @NonNull db: Database?,
        @NonNull username: String?,
        @NonNull password: CharArray?
    ): URI?

    companion object {
        private const val TAG = "PWD"
    }

    init {
        val config = URLEndpointListenerConfiguration(db)
        config.setPort(0) // this is the default
        config.setDisableTls(true)
        config.setAuthenticator(
            ListenerPasswordAuthenticator { validUser, pwd -&gt;
                username.equals(validUser) &amp;&amp; Arrays.equals(
                    validPassword,
                    pwd
                )
            }
        )
        val listener = URLEndpointListener(config)
        listener.start()
        val urls: List&lt;URI&gt; = listener.getUrls()
        return if (urls.isEmpty()) {
            null
        } else urls[0]
    }
    // end::listener-config-client-auth-pwd-full[]
}


class ExamplesP2p(private val context: Context) {
    private val database: Database? = null
    private var replicator: Replicator? = null

    //@Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {

        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        /* do some stuff here */
    }

    // PASSIVE PEER STUFF
    fun ibListenerSimple() {
        // tag::listener-simple[]
        val thisConfig =
            URLEndpointListenerConfiguration(thisDB) <i class="conum" data-value="27"></i><b>(27)</b>
        thisConfig.setAuthenticator(
            ListenerPasswordAuthenticator { username, password -&gt;
                username.equals("valid.User") &amp;&amp;
                        Arrays.equals(password, valid.password.string)
            }
        ) <i class="conum" data-value="28"></i><b>(28)</b>
        val thisListener = URLEndpointListener(thisConfig) <i class="conum" data-value="29"></i><b>(29)</b>
        thisListener.start() <i class="conum" data-value="30"></i><b>(30)</b>

        // end::listener-simple[]
    }

    fun ibReplicatorSimple() {
        // tag::replicator-simple[]
        var uri: URI? = null
        try {
            uri = URI("wss://10.0.2.2:4984/db")
        } catch (e: URISyntaxException) {
            e.printStackTrace()
        }
        val theListenerEndpoint: Endpoint = URLEndpoint(uri) <i class="conum" data-value="31"></i><b>(31)</b>
        val thisConfig =
            ReplicatorConfiguration(database, theListenerEndpoint) <i class="conum" data-value="32"></i><b>(32)</b>
        thisConfig.setAcceptOnlySelfSignedServerCertificate(true) <i class="conum" data-value="33"></i><b>(33)</b>
        val thisAuth = BasicAuthenticator(
            "valid.user",
            "valid.password.string"
        )
        thisConfig.setAuthenticator(thisAuth) <i class="conum" data-value="34"></i><b>(34)</b>
        replicator = Replicator(config) <i class="conum" data-value="35"></i><b>(35)</b>
        replicator.start() <i class="conum" data-value="36"></i><b>(36)</b>

        // end::replicator-simple[]
    }

    fun ibPassListener() {
// EXAMPLE 1
        // tag::listener-initialize[]
        // tag::listener-config-db[]
        // Initialize the listener config
        val thisConfig =
            URLEndpointListenerConfiguration(thisDB) <i class="conum" data-value="37"></i><b>(37)</b>

        // end::listener-config-db[]
        // tag::listener-config-port[]
        thisConfig.setPort(55990) <i class="conum" data-value="38"></i><b>(38)</b>

        // end::listener-config-port[]
        // tag::listener-config-netw-iface[]
        thisConfig.setNetworkInterface("10.1.1.10") <i class="conum" data-value="39"></i><b>(39)</b>

        // end::listener-config-netw-iface[]
        // tag::listener-config-delta-sync[]
        thisConfig.setEnableDeltaSync(false) <i class="conum" data-value="40"></i><b>(40)</b>

        // end::listener-config-delta-sync[]
        // tag::listener-config-tls-full[]
        // Configure server security
        // tag::listener-config-tls-enable[]
        thisConfig.setDisableTls(false) <i class="conum" data-value="41"></i><b>(41)</b>

        // end::listener-config-tls-enable[]
        // tag::listener-config-tls-id-anon[]
        // Use an Anonymous Self-Signed Cert
        thisConfig.setTlsIdentity(null) <i class="conum" data-value="42"></i><b>(42)</b>

        // end::listener-config-tls-id-anon[]

        // tag::listener-config-client-auth-pwd[]
        // Configure Client Security using an Authenticator
        // For example, Basic Authentication <i class="conum" data-value="43"></i><b>(43)</b>
        thisConfig.setAuthenticator(
            ListenerPasswordAuthenticator { validUser, validPassword -&gt;
                username.equals(validUser) &amp;&amp;
                        Arrays.equals(password, validPassword)
            }
        )

        // end::listener-config-client-auth-pwd[]
        // tag::listener-start[]
        // Initialize the listener
        val thisListener = URLEndpointListener(thisConfig) <i class="conum" data-value="44"></i><b>(44)</b>

        // Start the listener
        thisListener.start() <i class="conum" data-value="45"></i><b>(45)</b>

        // end::listener-start[]
        // end::listener-initialize[]
    }

    fun ibListenerGetNetworkInterfaces() {
        // tag::listener-get-network-interfaces[]
        val thisConfig =
            URLEndpointListenerConfiguration(database)
        val thisListener = URLEndpointListener(thisConfig)
        thisListener.start()
        Log.i(
            TAG,
            "URLS are " + thisListener.getUrls()
        )

        // end::listener-get-network-interfaces[]
    }

    fun ibListenerLocalDb() {
        // tag::listener-local-db[]
        // . . . preceding application logic . . .
        CouchbaseLite.init(context) <i class="conum" data-value="46"></i><b>(46)</b>
        val thisDB = Database("passivepeerdb")

        // end::listener-local-db[]
    }

    fun ibListenerConfigTlsDisable() {
        // tag::listener-config-tls-disable[]
        thisConfig.setDisableTls(true) <i class="conum" data-value="47"></i><b>(47)</b>

        // end::listener-config-tls-disable[]
    }

    fun ibListenerConfigTlsIdFull() {
        // tag::listener-config-tls-id-full[]
        // tag::listener-config-tls-id-caCert[]
        // Use CA Cert
        // Import a key pair into secure storage
        // Create a TLSIdentity from the imported key-pair
        val thisKeyPair: InputStream = FileInputStream()
        thisKeyPair.javaClass.getResourceAsStream("serverkeypair.p12") <i class="conum" data-value="48"></i><b>(48)</b>
        val thisIdentity: TLSIdentity = importIdentity(
            EXTERNAL_KEY_STORE_TYPE,  // KeyStore type, eg: "PKCS12"
            thisKeyPair,  // An InputStream from the keystore
            password,  // The keystore password
            EXTERNAL_KEY_ALIAS,  // The alias to be used (in external keystore)
            null,  // The key password
            "test-alias" // The alias for the imported key
        )

        // end::listener-config-tls-id-caCert[]

        // tag::listener-config-tls-id-set[]
        // Set the TLS Identity
        thisConfig.setTlsIdentity(thisIdentity) <i class="conum" data-value="49"></i><b>(49)</b>

        // end::listener-config-tls-id-set[]
// end::listener-config-tls-id-full[]
    }

    fun ibListenerConfigClientAuthRoot() {
// tag::listener-config-client-root-ca[]
        // tag::listener-config-client-auth-root[]
        // Configure the client authenticator
        // to validate using ROOT CA
        // thisClientID.certs is a list containing a client cert to accept
        // and any other certs needed to complete a chain between the client cert
        // and a CA
        val validId: TLSIdentity =
            TLSIdentity.getIdentity("Our Corporate Id")
                ?: throw IllegalStateException("Cannot find corporate id") // get the identity <i class="conum" data-value="50"></i><b>(50)</b>
        thisConfig.setTlsIdentity(validId)
        thisConfig.setAuthenticator(
            ListenerCertificateAuthenticator(validId.getCerts())
        ) <i class="conum" data-value="51"></i><b>(51)</b>
        // accept only clients signed by the corp cert
        val thisListener = URLEndpointListener(thisConfig)

        // end::listener-config-client-auth-root[]
// end::listener-config-client-root-ca[]
    }

    fun ibListenerConfigTlsDisable() {

        // tag::listener-config-tls-disable[]
        thisConfig.disableTLS(true)

        // end::listener-config-tls-disable[]
    }

    fun ibListenerStatusCheck() {
        // tag::listener-status-check[]
        val connectionCount: Int = thisListener.getStatus().getConnectionCount() <i class="conum" data-value="52"></i><b>(52)</b>
        val activeConnectionCount: Int =
            thisListener.getStatus().getActiveConnectionCount() <i class="conum" data-value="53"></i><b>(53)</b>

        // end::listener-status-check[]
    }

    fun ibListenerStop() {

        // tag::listener-stop[]
        thisListener.stop()

        // end::listener-stop[]
    }

    // ACTIVE PEER STUFF
    // Replication code
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testActPeerSync() {
        // tag::p2p-act-rep-func[]
        // tag::p2p-act-rep-initialize[]
        // initialize the replicator configuration
        val thisConfig = ReplicatorConfiguration(
            thisDB,
            URLEndpoint(URI("wss://listener.com:8954"))
        ) <i class="conum" data-value="54"></i><b>(54)</b>

        // end::p2p-act-rep-initialize[]
        // tag::p2p-act-rep-config-type[]
        // Set replicator type
        thisConfig.setReplicatorType(
            ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL
        )

        // end::p2p-act-rep-config-type[]
        // tag::p2p-act-rep-config-cont[]
        // Configure Sync Mode
        thisConfig.setContinuous(false) // default value

        // end::p2p-act-rep-config-cont[]
        // tag::p2p-act-rep-config-self-cert[]
        // Configure Server Authentication --
        // only accept self-signed certs
        thisConfig.setAcceptOnlySelfSignedServerCertificate(true) <i class="conum" data-value="55"></i><b>(55)</b>

        // end::p2p-act-rep-config-self-cert[]
        // tag::p2p-act-rep-auth[]
        // Configure the credentials the
        // client will provide if prompted
        val thisAuth: BasicAuthenticator <i class="conum" data-value="56"></i><b>(56)</b>
        thisAuth = BasicAuthenticator("Our Username", "Our PasswordValue")
        thisConfig.setAuthenticator(thisAuth)

        // end::p2p-act-rep-auth[]
        // tag::p2p-act-rep-config-conflict[]
        /* Optionally set custom conflict resolver call back */thisConfig.setConflictResolver() <i class="conum" data-value="57"></i><b>(57)</b>

        // end::p2p-act-rep-config-conflict[]
        // tag::p2p-act-rep-start-full[]
        // Create replicator
        // Consider holding a reference somewhere
        // to prevent the Replicator from being GCed
        val thisReplicator = Replicator(thisConfig) <i class="conum" data-value="58"></i><b>(58)</b>

        // tag::p2p-act-rep-add-change-listener[]
        // tag::p2p-act-rep-add-change-listener-label[]
        // Optionally add a change listener <i class="conum" data-value="59"></i><b>(59)</b>
        // end::p2p-act-rep-add-change-listener-label[]
        val thisListener: ListenerToken = addChangeListener { change -&gt;
            val err: CouchbaseLiteException = change.getStatus().getError()
            if (err != null) {
                Log.i(
                    TAG,
                    "Error code ::  " + err.getCode(),
                    e
                )
            }
        }

        // end::p2p-act-rep-add-change-listener[]
        // tag::p2p-act-rep-start[]
        // Start replicator
        thisReplicator.start(false) <i class="conum" data-value="60"></i><b>(60)</b>

        // end::p2p-act-rep-start[]
        // end::p2p-act-rep-start-full[]
        // end::p2p-act-rep-func[]         ***** End p2p-act-rep-func
    }

    fun ibReplicatorConfig() {
        // BEGIN additional snippets
        // tag::p2p-act-rep-config-tls-full[]
        // tag::p2p-act-rep-config-cacert[]
        // Configure Server Security
        // -- only accept CA attested certs
        thisConfig.setAcceptOnlySelfSignedServerCertificate(false) <i class="conum" data-value="61"></i><b>(61)</b>

        // end::p2p-act-rep-config-cacert[]
        // tag::p2p-act-rep-config-pinnedcert[]

        // Return the remote pinned cert (the listener's cert)
        val returnedCert: Byte =
            ByteArray(thisConfig.getPinnedCertificate()) // Get listener cert if pinned
        // end::p2p-act-rep-config-pinnedcert[]

        // end::p2p-act-rep-config-tls-full[]
        // tag::p2p-tlsid-tlsidentity-with-label[]
        // ... other replicator configuration
        // Provide a client certificate to the server for authentication
        val thisClientId: TLSIdentity = TLSIdentity.getIdentity("clientId")
            ?: throw IllegalStateException("Cannot find client id") <i class="conum" data-value="62"></i><b>(62)</b>
        thisConfig.setAuthenticator(ClientCertificateAuthenticator(thisClientId)) <i class="conum" data-value="63"></i><b>(63)</b>
        // ... other replicator configuration
        val thisReplicator = Replicator(thisConfig)

        // end::p2p-tlsid-tlsidentity-with-label[]
        // tag::p2p-act-rep-config-cacert-pinned[]

        // Use the pinned certificate from the byte array (cert)
        thisConfig.setPinnedServerCertificate(cert.getEncoded()) <i class="conum" data-value="64"></i><b>(64)</b>
        // end::p2p-act-rep-config-cacert-pinned[]
    }

    fun ibP2pReplicatorStatus() {
        // tag::p2p-act-rep-status[]
        Log.i(
            TAG, "The Replicator is currently " +
                    thisReplicator.getStatus().getActivityLevel()
        )
        Log.i(
            TAG,
            "The Replicator has processed $t"
        )
        if (thisReplicator.getStatus().getActivityLevel() ===
            Replicator.ActivityLevel.BUSY
        ) {
            Log.i(
                TAG,
                "Replication Processing"
            )
            Log.i(
                TAG, "It has completed " +
                        thisReplicator.getStatus().getProgess().getTotal().toString() +
                        " changes"
            )
        }
        // end::p2p-act-rep-status[]
    }

    fun ibP2pReplicatorStop() {
        // tag::p2p-act-rep-stop[]
        // Stop replication.
        thisReplicator.stop() <i class="conum" data-value="65"></i><b>(65)</b>
        // end::p2p-act-rep-stop[]
    }

    fun ibP2pListener() {
        CouchbaseLite.init(context)
        val thisDB = Database("passivepeerdb") <i class="conum" data-value="66"></i><b>(66)</b>
        // Initialize the listener config
        val thisConfig =
            URLEndpointListenerConfiguration(database)
        thisConfig.setPort(55990) /* &lt;.&gt;  Optional; defaults to auto */
        thisConfig.setDisableTls(false) /* &lt;.&gt;  Optional; defaults to false */
        thisConfig.setEnableDeltaSync(true) /* &lt;.&gt; Optional; defaults to false */

        // Configure the client authenticator (if using basic auth)
        val auth = ListenerPasswordAuthenticator(
            "username", "password"
        ) <i class="conum" data-value="67"></i><b>(67)</b>
        thisConfig.setAuthenticator(auth) <i class="conum" data-value="68"></i><b>(68)</b>

        // Initialize the listener
        val listener = URLEndpointListener(thisConfig) <i class="conum" data-value="69"></i><b>(69)</b>

        // Start the listener
        listener.start() <i class="conum" data-value="70"></i><b>(70)</b>


        // tag::createTlsIdentity[]

//        Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
//                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
//                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
//        );
        val thisIdentity: TLSIdentity = createIdentity(true, X509_ATTRIBUTES, null, "test-alias")

        // end::createTlsIdentity[]

        // tag::p2p-tlsid-store-in-keychain[]
        // end::p2p-tlsid-store-in-keychain[]


        // tag::deleteTlsIdentity[]
        // tag::p2p-tlsid-delete-id-from-keychain[]
        val thisAlias = "alias-to-delete"
        val thisKeyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        thisKeyStore.load(null)
        thisKeyStore.deleteEntry(thisAlias)

        // end::p2p-tlsid-delete-id-from-keychain[]
        // end::deleteTlsIdentity[]

        // tag::retrieveTlsIdentity[]
        // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label
        val thisIdentity: TLSIdentity = getIdentity("couchbase-docs-cert")
        // end::retrieveTlsIdentity[]
    }

    // tag::sgw-repl-pull[]
    fun ibRplicatorPull() {
        var database: Database
        var replicator: Replicator <i class="conum" data-value="71"></i><b>(71)</b>
        var uri: URI? = null
        try {
            uri = URI("wss://10.0.2.2:4984/db") <i class="conum" data-value="72"></i><b>(72)</b>
        } catch (e: URISyntaxException) {
            e.printStackTrace()
        }
        val endpoint: Endpoint = URLEndpoint(uri)
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        this.replicator = Replicator(config)
        this.replicator.start()
    }

    // end::sgw-repl-pull[]
    // tag::sgw-act-rep-initialize[]
    // initialize the replicator configuration
    val thisConfig: ReplicatorConfiguration = ReplicatorConfiguration(
        thisDB,
        URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))
    ) // &lt;.&gt; // end::sgw-act-rep-initialize[]

    /* C A L L O U T S

// Listener Callouts

  // tag::listener-callouts-full[]

    // tag::listener-start-callouts[]
    &lt;.&gt; Initialize the listener instance using the configuration settings.
    &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.

  // end::listener-start-callouts[]

  // tag::listener-status-check-callouts[]

  &lt;.&gt; `connectionCount` -- the total number of connections served by the listener
  &lt;.&gt; `activeConnectionCount` -- the number of active (BUSY) connections currently being served by the listener
  //
  // end::listener-status-check-callouts[]

    // end::listener-callouts-full[]


    // tag::p2p-act-rep-config-cacert-pinned-callouts[]
  &lt;.&gt; Configure the pinned certificate using data from the byte array `cert`
  // end::p2p-act-rep-config-cacert-pinned-callouts[]

  // tag::p2p-tlsid-tlsidentity-with-label-callouts[]
  &lt;.&gt; Attempt to get the identity from secure storage
  &lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity

  // end::p2p-tlsid-tlsidentity-with-label-callouts[]

  // tag::sgw-repl-pull-callouts[]
  &lt;.&gt; A replication is an asynchronous operation.
  To keep a reference to the `replicator` object, you can set it as an instance property.
  &lt;.&gt; The URL scheme for remote database URLs uses `ws:`, or `wss:` for SSL/TLS connections over wb sockets.
  In this example the hostname is `10.0.2.2` because the Android emulator runs in a VM that is generally accessible on `10.0.2.2` from the host machine (see https://developer.android.com/studio/run/emulator-networking[Android Emulator networking] documentation).
  +
  NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
  Although `wss:` protocol URLs are not affected, in order to use the `ws:` protocol, applications must target API 27 or lower, or must configure application network security as described https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted[here].

  // end::sgw-repl-pull-callouts[]
  */
}





    fun testQuerySyntaxAll() {

        // tag::query-syntax-all[]
//        try {
//            this_Db = new Database("hotels");
//        } catch (CouchbaseLiteException e) {
//            e.printStackTrace();
//        }
        val db = openOrCreateDatabaseForUser(currentUser)
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(db!!))
        // end::query-syntax-all[]

        // tag::query-access-all[]
        val hotels: HashMap&lt;String, Hotel&gt; = HashMap&lt;String, Hotel&gt;()
        try {
            for (result in listQuery.execute().allResults()) {
                // get the k-v pairs from the 'hotel' key's value into a dictionary
                val thisDocsProps = result.getDictionary(0) <i class="conum" data-value="73"></i><b>(73)</b>
                val thisDocsId = thisDocsProps!!.getString("id")
                val thisDocsName = thisDocsProps.getString("name")
                val thisDocsType = thisDocsProps.getString("type")
                val thisDocsCity = thisDocsProps.getString("city")

                // Alternatively, access results value dictionary directly
                val hotel = Hotel()
                hotel.id = result.getDictionary(0)!!.getString("id").toString() <i class="conum" data-value="74"></i><b>(74)</b>
                hotel.type = result.getDictionary(0)!!.getString("type").toString()
                hotel.name = result.getDictionary(0)!!.getString("name").toString()
                hotel.city = result.getDictionary(0)!!.getString("city").toString()
                hotel.country = result.getDictionary(0)!!.getString("country").toString()
                hotel.description = result.getDictionary(0)!!.getString("description").toString()
                hotels[hotel.id] = hotel
            }
        } catch (e: CouchbaseLiteException) {
            e.printStackTrace()
        }

        // end::query-access-all[]
    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun testQuerySyntaxJson() {
        val db = openOrCreateDatabaseForUser(currentUser)
        // tag::query-syntax-json[]
        // Example assumes Hotel class object defined elsewhere
//        Database db = null;
//        try {
//                db = new Database(dbName);
//        } catch (CouchbaseLiteException e) {
//            e.printStackTrace();
//        }

        // Build the query
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(db!!))

        // end::query-syntax-json[]

      // tag::query-access-json[]
        // Uses Jackson JSON processor
        val mapper = ObjectMapper();
        val hotels: ArrayList&lt;Hotel&gt; = ArrayList&lt;Hotel&gt;()

        for (result in listQuery.execute()) {

          // Get result as JSON string
          val thisJsonString1: String = result.toJSON() <i class="conum" data-value="75"></i><b>(75)</b>

          // Get Hashmap from JSON string
          val dictFromJSONstring =
              mapper.readValue(thisJsonString, HashMap::class.java) <i class="conum" data-value="76"></i><b>(76)</b>

          // Use created hashmap
          val hotelId = dictFromJSONstring["id"].toString() //
          val hotelType = dictFromJSONstring["type"].toString()
          val hotelname = dictFromJSONstring["name"].toString()


          // Get custom object from JSON strin
          val thisHotel =
              mapper.readValue(thisJsonString, Hotel::class.java) <i class="conum" data-value="77"></i><b>(77)</b>
          hotels.add(thisHotel)

      }
      // end::query-access-json[]
    }
    /* end func testQuerySyntaxJson */</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset2_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.support.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;
import com.example.docsnippet.Datastore;
import com.example.docsnippet.Hotel;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

// tag::example-app[]
public class docOnly_Examples {
  private static final String TAG = "EXAMPLE";

  private static final String DATABASE_NAME = "database";

  private final Context context;
  private Database database;
  private Replicator replicator;

  public docOnly_Examples(Context context) { this.context = context; }

  //@Test
  public void testGettingStarted() throws CouchbaseLiteException, URISyntaxException {
    // tag::getting-started[]

    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);

    // Get the database (and create it if it doesnt exist).
    DatabaseConfiguration config = new DatabaseConfiguration();

    config.setDirectory(context.getFilesDir().getAbsolutePath());

    Database database = new Database("getting-started", config);


    // Create a new document (i.e. a record) in the database.
    MutableDocument mutableDoc = new MutableDocument()
    .setFloat("version", 2.0F)
    .setString("type", "SDK");

    // Save it to the database.
    database.save(mutableDoc);

    // Update a document.
    mutableDoc = database.getDocument(mutableDoc.getId()).toMutable();
    mutableDoc.setString("language", "Java");
    database.save(mutableDoc);
    Document document = database.getDocument(mutableDoc.getId());
    // Log the document ID (generated by the database) and properties
    Log.i(TAG, "Document ID :: " + document.getId());
    Log.i(TAG, "Learning " + document.getString("language"));

    // Create a query to fetch documents of type SDK.
    Query query = QueryBuilder.select(SelectResult.all())
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("SDK")));
    ResultSet result = query.execute();
    Log.i(TAG, "Number of rows ::  " + result.allResults().size());

    // Create replicators to push and pull changes to and from the cloud.
    Endpoint targetEndpoint = new URLEndpoint(new URI("ws://localhost:4984/getting-started-db"));
    ReplicatorConfiguration replConfig = new ReplicatorConfiguration(database, targetEndpoint);
    replConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Add authentication.
    replConfig.setAuthenticator(new BasicAuthenticator("sync-gateway", "password"));

    // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
    Replicator replicator = new Replicator(replConfig);

    // Listen to replicator change events.
    replicator.addChangeListener(change -&gt; {
      if (change.getStatus().getError() != null) {
        Log.i(TAG, "Error code ::  " + change.getStatus().getError().getCode());
      }
    });

    // Start replication.
    replicator.start();

    // end::getting-started[]

    database.delete();
  }
  // end::example-app[]

  public void test1xAttachments() throws CouchbaseLiteException, IOException {
    // if db exist, delete it
    deleteDB("android-sqlite", context.getFilesDir());

    ZipUtils.unzip(getAsset("replacedb/android140-sqlite.cblite2.zip"), context.getFilesDir());

    Database db = new Database("android-sqlite", new DatabaseConfiguration());
    try {

      Document doc = db.getDocument("doc1");

      // For Validation
      Dictionary attachments = doc.getDictionary("_attachments");
      Blob blob = attachments.getBlob("attach1");
      byte[] content = blob.getContent();
      // For Validation

      byte[] attach = String.format(Locale.ENGLISH, "attach1").getBytes();
      Arrays.equals(attach, content);

    } finally {
      // close db
      db.close();
      // if db exist, delete it
      deleteDB("android-sqlite", context.getFilesDir());
    }

    Document document = new MutableDocument();

    // tag::1x-attachment[]
    Dictionary attachments = document.getDictionary("_attachments");
    Blob blob = attachments != null ? attachments.getBlob("avatar") : null;
    byte[] content = blob != null ? blob.getContent() : null;
    // end::1x-attachment[]
  }

  // ### Initializer
  public void testInitializer() {
    // tag::sdk-initializer[]
    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);
    // end::sdk-initializer[]
  }

  // ### New Database
  public void testNewDatabase() throws CouchbaseLiteException {
    // tag::new-database[]
    final DatabaseConfiguration config = new DatabaseConfiguration();
    config.setDirectory(context.getFilesDir().getAbsolutePath()); <i class="conum" data-value="1"></i><b>(1)</b>

    Database database = new Database("my-database", config);
    // end::new-database[]

    // tag::close-database[]
    database.close();

    // end::close-database[]

    database.delete();
  }

  // ### Database Encryption
  public void testDatabaseEncryption() throws CouchbaseLiteException {
    // tag::database-encryption[]
    DatabaseConfiguration config = new DatabaseConfiguration();
    config.setEncryptionKey(new EncryptionKey("PASSWORD"));
    Database database = new Database("mydb", config);
    // end::database-encryption[]
  }

  // ### Logging
  public void testLogging() {
    // tag::logging[]
    Database.setLogLevel(LogDomain.DATABASE, LogLevel.VERBOSE);
    Database.setLogLevel(LogDomain.QUERY, LogLevel.VERBOSE);
    // end::logging[]
    }

    public void testEnableCustomLogging() {
        // tag::set-custom-logging[]
        Database.log.setCustom(new LogTestLogger(LogLevel.WARNING)); <i class="conum" data-value="2"></i><b>(2)</b>
        // end::set-custom-logging[]
    }

    // ### Console logging
    public void testConsoleLogging() throws CouchbaseLiteException {
      // tag::console-logging[]
          Database.log.getConsole().setDomain(LogDomain.ALL_DOMAINS);  <i class="conum" data-value="3"></i><b>(3)</b>
          Database.log.getConsole().setLevel(LogLevel.VERBOSE); <i class="conum" data-value="4"></i><b>(4)</b>
      // end::console-logging[]
      // tag::console-logging-db[]
          Database.log.getConsole().setDomain(LogDomain.DATABASE);

      // end::console-logging-db[]
    }

    // ### File logging
    public void testFileLogging() throws CouchbaseLiteException {
        // tag::file-logging[]
        final File path = context.getCacheDir();

        LogFileConfiguration LogCfg =
          new LogFileConfiguration(path.toString()); <i class="conum" data-value="5"></i><b>(5)</b>
        LogCfg.setMaxSize(10240); <i class="conum" data-value="6"></i><b>(6)</b>
        LogCfg.setMaxRotateCount(5); <i class="conum" data-value="7"></i><b>(7)</b>
        LogCfg.setUsePlainText(false); <i class="conum" data-value="8"></i><b>(8)</b>
        Database.log.getFile().setConfig(LogCfg);
        Database.log.getFile().setLevel(LogLevel.INFO); <i class="conum" data-value="9"></i><b>(9)</b>
        // end::file-logging[]
    }

    public void writeConsoleLog()
    {
        // tag::write-console-logmsg[]
        Database.log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
        // end::write-console-logmsg[]
    }
    public void writeCustomLog()
    {
        // tag::write-custom-logmsg[]
        Database.log.Custom?.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
        // end::write-custom-logmsg[]
    }


    public void writeFileLog()
    {
        // tag::write-file-logmsg[]
        Database.log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
        // end::write-file-logmsg[]
    }




    // ### Loading a pre-built database
    public void testPreBuiltDatabase() throws IOException {
      // tag::prebuilt-database[]
      // Note: Getting the path to a database is platform-specific.
      // For Android you need to extract it from your
      // assets to a temporary directory and then pass that path to Database.copy()
      DatabaseConfiguration configuration = new DatabaseConfiguration();
      if (!Database.exists("travel-sample", context.getFilesDir())) {
            ZipUtils.unzip(getAsset("travel-sample.cblite2.zip"), context.getFilesDir());
            File path = new File(context.getFilesDir(), "travel-sample");
            try {
                Database.copy(path, "travel-sample", configuration);
            } catch (CouchbaseLiteException e) {
                e.printStackTrace();
            }
        }
        // end::prebuilt-database[]
    }

    // helper methods

    // if db exist, delete it
    private void deleteDB(String name, File dir) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            // sometimes, db is still in used, wait for a while. Maximum 3 sec
            for (int i = 0; i &lt; 10; i++) {
                try {
                    Database.delete(name, dir);
                    break;
                } catch (CouchbaseLiteException ex) {
                    try { Thread.sleep(300); }
                    catch (InterruptedException ignore) { }
                }
            }
        }
    }

    // ### Initializers
    public void testInitializers() {
        // tag::initializer[]
        MutableDocument newTask = new MutableDocument();
        newTask.setString("type", "task");
        newTask.setString("owner", "todo");
        newTask.setDate("createdAt", new Date());
        try {
            database.save(newTask);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
        // end::initializer[]
    }

    // ### Mutability
    public void testMutability() {
        try { database.save(new MutableDocument("xyz")); }
        catch (CouchbaseLiteException ignore) { }

        // tag::update-document[]
        Document document = database.getDocument("xyz");
        MutableDocument mutableDocument = document.toMutable();
        mutableDocument.setString("name", "apples");
        try {
            database.save(mutableDocument);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
        // end::update-document[]
    }

    // ### Typed Accessors
    public void testTypedAccessors() {
        MutableDocument newTask = new MutableDocument();

        // tag::date-getter[]
        newTask.setValue("createdAt", new Date());
        Date date = newTask.getDate("createdAt");
        // end::date-getter[]
    }

    // ### Batch operations
    public void testBatchOperations() {
        // tag::batch[]
        try {
            database.inBatch(() -&gt; {
                for (int i = 0; i &lt; 10; i++) {
                    MutableDocument doc = new MutableDocument();
                    doc.setValue("type", "user");
                    doc.setValue("name", "user " + i);
                    doc.setBoolean("admin", false);
                    try {
                        database.save(doc);
                    } catch (CouchbaseLiteException e) {
                        Log.e(TAG, e.toString());
                    }
                    Log.i(TAG, String.format("saved user document %s", doc.getString("name")));
                }
            });
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
        // end::batch[]
    }

    // ### Document Expiration
    public void DocumentExpiration() throws CouchbaseLiteException {
        // tag::document-expiration[]
        // Purge the document one day from now
        Instant ttl = Instant.now().plus(1, ChronoUnit.DAYS);
        database.setDocumentExpiration("doc123", new Date(ttl.toEpochMilli()));

        // Reset expiration
        database.setDocumentExpiration("doc1", null);

        // Query documents that will be expired in less than five minutes
        Instant fiveMinutesFromNow = Instant.now().plus(5, ChronoUnit.MINUTES);
        Query query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.expiration.lessThan(Expression.doubleValue(fiveMinutesFromNow.toEpochMilli())));
        // end::document-expiration[]
    }

    public void testDocumentChangeListener() throws CouchbaseLiteException {
        // tag::document-listener[]
        database.addDocumentChangeListener(
            "user.john",
            change -&gt; {
                Document doc = database.getDocument(change.getDocumentID());
                if (doc != null) {
                    Toast.makeText(context, "Status: " + doc.getString("verified_account"), Toast.LENGTH_SHORT).show();
                }
            });
        // end::document-listener[]
    }

    // ### Blobs
    public void testBlobs() {
        MutableDocument newTask = new MutableDocument();

        // tag::blob[]
        InputStream is = getAsset("avatar.jpg");
        if (is == null) { return; }
        try {
            Blob blob = new Blob("image/jpeg", is);
            newTask.setBlob("avatar", blob);
            database.save(newTask);

            Blob taskBlob = newTask.getBlob("avatar");
            byte[] bytes = taskBlob.getContent();
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        } finally {
            try { is.close(); }
            catch (IOException ignore) { }
        }
        // end::blob[]
    }

    // ### Indexing
    public void testIndexing() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-index[]
            database.createIndex(
                "TypeNameIndex",
                IndexBuilder.valueIndex(
                    ValueIndexItem.property("type"),
                    ValueIndexItem.property("name")));
            // end::query-index[]
        }
    }

    // ### SELECT statement
    public void testSelectStatement() {
        {
            // tag::query-select-meta[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("type"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.expression(Meta.id));

            try {
                ResultSet rs = query.execute();
                for (Result result : rs) {
                    Log.i("Sample", String.format("hotel id -&gt; %s", result.getString("id")));
                    Log.i("Sample", String.format("hotel name -&gt; %s", result.getString("name")));
                }
            } catch (CouchbaseLiteException e) {
                Log.e("Sample", e.getLocalizedMessage());
            }
            // end::query-select-meta[]
        }
    }

    // META function
    public void testMetaFunction() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.expression(Meta.id))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport")))
                .orderBy(Ordering.expression(Meta.id));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.w("Sample", String.format("airport id -&gt; %s", result.getString("id")));
                Log.w("Sample", String.format("airport id -&gt; %s", result.getString(0)));
            }
        }
    }

    // ### all(*)
    public void testSelectAll() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-select-all[]
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")));
            // end::query-select-all[]

            // tag::live-query[]
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database));

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            ListenerToken token = query.addChangeListener(change -&gt; { <i class="conum" data-value="10"></i><b>(10)</b>
                for (Result result : change.getResults()) {
                    Log.d(TAG, "results: " + result.getKeys());
                    /* Update UI */
                }
            });

            // Start live query.
            query.execute(); <i class="conum" data-value="11"></i><b>(11)</b>
            // end::live-query[]

            // tag::stop-live-query[]
            query.removeChangeListener(token); <i class="conum" data-value="12"></i><b>(12)</b>

            // end::stop-live-query[]

            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("hotel -&gt; %s", result.getDictionary(DATABASE_NAME).toMap()));
            }
        }
    }

    // ###WHERE statement
    public void testWhereStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-where[]
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .limit(Expression.intValue(10));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Dictionary all = result.getDictionary(DATABASE_NAME);
                Log.i("Sample", String.format("name -&gt; %s", all.getString("name")));
                Log.i("Sample", String.format("type -&gt; %s", all.getString("type")));
            }
            // end::query-where[]
        }
    }

    public void testQueryDeletedDocuments() {
        // tag::query-deleted-documents[]
        // Query documents that have been deleted
        Where query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted);
        // end::query-deleted-documents[]
    }


    // ####Collection Operators
    public void testCollectionStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-collection-operator-contains[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("public_likes"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction
                        .contains(Expression.property("public_likes"), Expression.string("Armani Langworth"))));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("public_likes -&gt; %s", result.getArray("public_likes").toList()));
            }
            // end::query-collection-operator-contains[]
        }
    }

    // IN operator
    public void testInOperator() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-collection-operator-in[]
            Expression[] values = new Expression[] {
                Expression.property("first"),
                Expression.property("last"),
                Expression.property("username")
            };

            Query query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.string("Armani").in(values));
            // end::query-collection-operator-in[]

            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // Pattern Matching
    public void testPatternMatching() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-like-operator[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Function.Expression.string("royal engineers museum")))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
            // end::query-like-operator[]
        }
    }

    // ### Wildcard Match
    public void testWildcardMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-like-operator-wildcard-match[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng%e%"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
            // end::query-like-operator-wildcard-match[]
        }
    }

    // Wildcard Character Match
    public void testWildCharacterMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-like-operator-wildcard-character-match[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng____r"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
            // end::query-like-operator-wildcard-character-match[]
        }
    }

    // ### Regex Match
    public void testRegexMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-regex-operator[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).regex(Expression.string("\\beng.*r\\b"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
            // end::query-regex-operator[]
        }
    }

    // JOIN statement
    public void testJoinStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-join[]
            Query query = QueryBuilder.select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route")))
                .from(DataSource.database(database).as("airline"))
                .join(Join.join(DataSource.database(database).as("route"))
                    .on(Meta.id.from("airline").equalTo(Expression.property("airlineid").from("route"))))
                .where(Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline").equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route").equalTo(Expression.string("RIX"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
            // end::query-join[]
        }
    }

    // ### GROUPBY statement
    public void testGroupByStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-groupby[]
            Query query = QueryBuilder.select(
                SelectResult.expression(Function.count(Expression.string("*"))),
                SelectResult.property("country"),
                SelectResult.property("tz"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300))))
                .groupBy(
                    Expression.property("country"),
                    Expression.property("tz"))
                .orderBy(Ordering.expression(Function.count(Expression.string("*"))).descending());
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format(
                        "There are %d airports on the %s timezone located in %s and above 300ft",
                        result.getInt("$1"),
                        result.getString("tz"),
                        result.getString("country")));
            }
            // end::query-groupby[]
        }
    }

    // ### ORDER BY statement
    public void testOrderByStatement() throws CouchbaseLiteException {
      // For Documentation
      {
        // tag::query-orderby[]
        Query query = QueryBuilder
        .select(
          SelectResult.expression(Meta.id),
          SelectResult.property("name"))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("hotel")))
          .orderBy(Ordering.property("name").ascending())
          .limit(Expression.intValue(10));
          ResultSet rs = query.execute();
          for (Result result : rs) { Log.i("Sample", String.format("%s", result.toMap())); }
          // end::query-orderby[]
        }
      }
      // ### EXPLAIN statement
      public void testExplainStatement() throws CouchbaseLiteException {
          // For Documentation
          {
              // tag::query-explain-all[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("university")))
                .groupBy(Expression.property("country"))
                .orderBy(Ordering.property("name").descending()); <i class="conum" data-value="13"></i><b>(13)</b>
              Log.i(query.explain()); <i class="conum" data-value="14"></i><b>(14)</b>
              // end::query-explain-all[]
              // tag::query-explain-like[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("%hotel%"))); <i class="conum" data-value="15"></i><b>(15)</b>
              Log.i(query.explain());
              // end::query-explain-like[]
              // tag::query-explain-nopfx[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="16"></i><b>(16)</b>
                  .and(Expression.property("name").like(Expression.string("%royal%"))));
              Log.i(query.explain());
              // end::query-explain-nopfx[]
              // tag::query-explain-function[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))); <i class="conum" data-value="17"></i><b>(17)</b>
              Log.i(query.explain());
              // end::query-explain-function[]
              // tag::query-explain-nofunction[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="18"></i><b>(18)</b>
              Log.i(query.explain());
              // end::query-explain-nofunction[]
          }
      }
      // end query-explain

    void prepareIndex() throws CouchbaseLiteException {
        // tag::fts-index[]
        database.createIndex(
            "nameFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("name")).ignoreAccents(false));
        // end::fts-index[]
    }

    public void testFTS() throws CouchbaseLiteException {
        // tag::fts-query[]
        Expression whereClause = FullTextExpression.index("nameFTSIndex").match("buy");
        Query ftsQuery = QueryBuilder.select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause);
        ResultSet ftsQueryResult = ftsQuery.execute();
        for (Result result : ftsQueryResult) {
            Log.i(
                TAG,
                String.format("document properties %s", result.getString(0)));
        }
        // end::fts-query[]
    }

    /* The `tag::replication[]` example is inlined in java.adoc */

    public void testTroubleshooting() {
        // tag::replication-logging[]
        Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE);
        // end::replication-logging[]
    }

    public void testReplicationBasicAuthentication() throws URISyntaxException {
        // tag::basic-authentication[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new BasicAuthenticator("username", "password"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
        // end::basic-authentication[]
    }

    public void testReplicationSessionAuthentication() throws URISyntaxException {
        // tag::session-authentication[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
        // end::session-authentication[]
    }

    public void testReplicationStatus() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        // tag::replication-status[]
        replicator.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == Replicator.ActivityLevel.STOPPED) {
                Log.i(TAG, "Replication stopped");
            }
          });
          // end::replication-status[]
        }

    //  BEGIN PendingDocuments BM -- 19/Feb/21 --
    import android.support.annotation.NonNull;
    import android.util.Log;

    import java.net.URI;
    import java.net.URISyntaxException;
    import java.util.Iterator;
    import java.util.Set;

    import com.couchbase.lite.CouchbaseLiteException;
    import com.couchbase.lite.Database;
    import com.couchbase.lite.Endpoint;
    import com.couchbase.lite.Replicator;
    import com.couchbase.lite.ReplicatorConfiguration;
    import com.couchbase.lite.URLEndpoint;

    class PendingDocsExample {
        private static final String TAG = "SCRATCH";

        private Database database;
        private Replicator replicator;

        //  BEGIN PendingDocuments IB -- 11/Feb/21 --
        public void testReplicationPendingDocs() throws URISyntaxException, CouchbaseLiteException {
            // nottag::replication-pendingdocuments[]
            // ... include other code as required
            //
            final Endpoint endpoint =
              new URLEndpoint(new URI("ws://localhost:4984/db"));

            final ReplicatorConfiguration config =
              new ReplicatorConfiguration(database, endpoint)
            .setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);
            // tag::replication-push-pendingdocumentids[]

            replicator = new Replicator(config);
            final Set&lt;String&gt; pendingDocs =
              replicator.getPendingDocumentIds(); <i class="conum" data-value="19"></i><b>(19)</b>

            // end::replication-push-pendingdocumentids[]

            replicator.addChangeListener(change -&gt; {
              onStatusChanged(pendingDocs, change.getStatus()); });

            replicator.start();

            // ... include other code as required
            // notend::replication-pendingdocuments[]
          }
        //
        // tag::replication-pendingdocuments[]
        //
        private void onStatusChanged(
          @NonNull final Set&lt;String&gt; pendingDocs,
          @NonNull final Replicator.Status status) {
          // ... sample onStatusChanged function
          //
          Log.i(TAG,
            "Replicator activity level is " + status.getActivityLevel().toString());

          // iterate and report-on previously
          // retrieved pending docids 'list'
          for (Iterator&lt;String&gt; itr = pendingDocs.iterator(); itr.hasNext(); ) {
            final String docId = itr.next();
            try {
              // tag::replication-push-isdocumentpending[]
              if (!replicator.isDocumentPending(docId)) { continue; } <i class="conum" data-value="20"></i><b>(20)</b>
              // end::replication-push-isdocumentpending[]

              itr.remove();
              Log.i(TAG, "Doc ID " + docId + " has been pushed");
            }
            catch (CouchbaseLiteException e) {
              Log.w(TAG, "isDocumentPending failed", e); }
          }
        }
        // end::replication-pendingdocuments[]
        //  END PendingDocuments BM -- 19/Feb/21 --
    }


    public void testHandlingNetworkErrors() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        // tag::replication-error-handling[]
        replicator.addChangeListener(change -&gt; {
            CouchbaseLiteException error = change.getStatus().getError();
            if (error != null) { Log.w(TAG, "Error code:: %d", error); }
        });
        replicator.start();
        // end::replication-error-handling[]

        replicator.stop();
    }

    public void testReplicatorDocumentEvent() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        // tag::add-document-replication-listener[]
        ListenerToken token = replicator.addDocumentReplicationListener(replication -&gt; {

            Log.i(TAG, "Replication type: " + ((replication.isPush()) ? "Push" : "Pull"));
            for (ReplicatedDocument document : replication.getDocuments()) {
                Log.i(TAG, "Doc ID: " + document.getID());

                CouchbaseLiteException err = document.getError();
                if (err != null) {
                    // There was an error
                    Log.e(TAG, "Error replicating document: ", err);
                    return;
                }

                if (document.flags().contains(DocumentFlag.DocumentFlagsDeleted)) {
                    Log.i(TAG, "Successfully replicated a deleted document");
                }
            }
        });

        replicator.start();
        // end::add-document-replication-listener[]

        // tag::remove-document-replication-listener[]
        replicator.removeChangeListener(token);
        // end::remove-document-replication-listener[]
    }

    public void testReplicationCustomHeader() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);

        // tag::replication-custom-header[]
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();
        headers.put("CustomHeaderName", "Value");
        config.setHeaders(headers);
        // end::replication-custom-header[]
    }

    // ### Certificate Pinning

    public void testCertificatePinning() throws URISyntaxException, IOException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);

        // tag::certificate-pinning[]
        InputStream is = getAsset("cert.cer");
        byte[] cert = IOUtils.toByteArray(is);
        if (is != null) {
            try { is.close(); }
            catch (IOException ignore) {}
        }

        config.setPinnedServerCertificate(cert);
        // end::certificate-pinning[]
    }

    // ### Reset replicator checkpoint
    public void testReplicationResetCheckpoint() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();

        // tag::replication-reset-checkpoint[]
        replicator.resetCheckpoint();
        replicator.start();
        // end::replication-reset-checkpoint[]

        replicator.stop();
    }

    public void testReplicationPushFilter() throws URISyntaxException {
        // tag::replication-push-filter[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPushFilter((document, flags) -&gt; flags.contains(DocumentFlag.DocumentFlagsDeleted)); <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
        // end::replication-push-filter[]
    }

    public void testReplicationPullFilter() throws URISyntaxException {
        // tag::replication-pull-filter[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPullFilter((document, flags) -&gt; "draft".equals(document.getString("type"))); <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
        // end::replication-pull-filter[]
    }

    public void testCustomRetryConfig() throws URISyntaxException {
    // tag::replication-retry-config[]
    URLEndpoint target =
    new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

    ReplicatorConfiguration config =
    new ReplicatorConfiguration(database, target);

    //  other config as required . . .
    // tag::replication-heartbeat-config[]
    config.setHeartbeat(150L); <i class="conum" data-value="21"></i><b>(21)</b>
    // end::replication-heartbeat-config[]
    // tag::replication-maxretries-config[]
    config.setMaxRetries(20L); <i class="conum" data-value="22"></i><b>(22)</b>
    // end::replication-maxretries-config[]
    // tag::replication-maxretrywaittime-config[]
    config.setMaxRetryWaitTime(600L); <i class="conum" data-value="23"></i><b>(23)</b>
    // end::replication-maxretrywaittime-config[]

    Replicator repl = new Replicator(config);

    // end::replication-retry-config[]
    }





    public void testDatabaseReplica() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database1 = new Database("mydb", config);

        config = new DatabaseConfiguration();
        Database database2 = new Database("db2", config);

        /* EE feature: code below might throw a compilation error
           if it's compiled against CBL Android Community. */
        // tag::database-replica[]
        DatabaseEndpoint targetDatabase = new DatabaseEndpoint(database2);
        ReplicatorConfiguration replicatorConfig = new ReplicatorConfiguration(database1, targetDatabase);
        replicatorConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(replicatorConfig);
        replicator.start();
        // end::database-replica[]
    }

    public void testPredictiveModel() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        // tag::register-model[]
        Database.prediction.registerModel("ImageClassifier", new ImageClassifierModel());
        // end::register-model[]

        // tag::predictive-query-value-index[]
        ValueIndex index = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")));
        database.createIndex("value-index-image-classifier", index);
        // end::predictive-query-value-index[]

        // tag::unregister-model[]
        Database.prediction.unregisterModel("ImageClassifier");
        // end::unregister-model[]
    }

    public void testPredictiveIndex() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        // tag::predictive-query-predictive-index[]
        Map&lt;String, Object&gt; inputMap = new HashMap&lt;&gt;();
        inputMap.put("numbers", Expression.property("photo"));
        Expression input = Expression.map(inputMap);

        PredictiveIndex index = IndexBuilder.predictiveIndex("ImageClassifier", input, null);
        database.createIndex("predictive-index-image-classifier", index);
        // end::predictive-query-predictive-index[]
    }

    public void testPredictiveQuery() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        // tag::predictive-query[]
        Map&lt;String, Object&gt; inputProperties = new HashMap&lt;&gt;();
        inputProperties.put("photo", Expression.property("photo"));
        Expression input = Expression.map(inputProperties);
        PredictionFunction prediction = PredictiveModel.predict("ImageClassifier", input); <i class="conum" data-value="1"></i><b>(1)</b>

        Query query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("label").equalTo(Expression.string("car"))
                .and(Expression.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))));

        // Run the query.
        ResultSet result = query.execute();
        Log.d(TAG, "Number of rows: " + result.allResults().size());
        // end::predictive-query[]
    }

    public void testReplicationWithCustomConflictResolver() throws URISyntaxException {
        // tag::replication-conflict-resolver[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setConflictResolver(new LocalWinConflictResolver());

        Replicator replication = new Replicator(config);
        replication.start();
        // end::replication-conflict-resolver[]
    }

    public void testSaveWithCustomConflictResolver() throws CouchbaseLiteException {
        // tag::update-document-with-conflict-handler[]
        Document doc = database.getDocument("xyz");
        if (doc == null) { return; }
        MutableDocument mutableDocument = doc.toMutable();
        mutableDocument.setString("name", "apples");

        database.save(
            mutableDocument,
            (newDoc, curDoc) -&gt; { <i class="conum" data-value="24"></i><b>(24)</b>
                if (curDoc == null) { return false; } <i class="conum" data-value="25"></i><b>(25)</b>
                Map&lt;String, Object&gt; dataMap = curDoc.toMap();
                dataMap.putAll(newDoc.toMap()); <i class="conum" data-value="26"></i><b>(26)</b>
                newDoc.setData(dataMap);
                return true; <i class="conum" data-value="27"></i><b>(27)</b>
            }); <i class="conum" data-value="28"></i><b>(28)</b>
        // end::update-document-with-conflict-handler[]
      }
    }

// tag::update-document-with-conflict-handler-callouts[]

&lt;.&gt; The conflict handler code is provided as a lambda.

&lt;.&gt; If the handler cannot resolve a conflict, it can return false.
In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.

&lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.

&lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).

&lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method
// end::update-document-with-conflict-handler-callouts[]

// tag::local-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
class LocalWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getLocalDocument();
    }
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
class RemoteWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getRemoteDocument();
    }
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
// Using replConfig.setConflictResolver(new MergeConflictResolver());
class MergeConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        Map&lt;String, Object&gt; merge = conflict.getLocalDocument().toMap();
        merge.putAll(conflict.getRemoteDocument().toMap());
        return new MutableDocument(conflict.getDocumentId(), merge);
    }
}
// end::merge-conflict-resolver[]


/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ----------------------------------------------------------- */

class BrowserSessionManager implements MessageEndpointDelegate {
    private final Context context;
    private Replicator replicator;

    private BrowserSessionManager(Context context) { this.context = context; }

    public void initCouchbase() throws CouchbaseLiteException {
        // tag::message-endpoint[]
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration(context);
        Database database = new Database("mydb", databaseConfiguration);

        // The delegate must implement the `MessageEndpointDelegate` protocol.
        MessageEndpoint messageEndpointTarget = new MessageEndpoint(
            "UID:123",
            "active",
            ProtocolType.MESSAGE_STREAM,
            this);
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, messageEndpointTarget);

        // Create the replicator object.
        replicator = new Replicator(config);
        // Start the replication.
        replicator.start();
        // end::message-endpoint-replicator[]
    }

    // tag::create-connection[]
    /* implementation of MessageEndpointDelegate */
    @NonNull
    @Override
    public MessageEndpointConnection createConnection(@NonNull MessageEndpoint endpoint) {
        return new ActivePeerConnection(); /* implements MessageEndpointConnection */
    }
    // end::create-connection[]
}

class ActivePeerConnection implements MessageEndpointConnection {

    private ReplicatorConnection replicatorConnection;

    public void disconnect() {
        // tag::active-replicator-close[]
        replicatorConnection.close(null);
        // end::active-replicator-close[]
    }

    // tag::active-peer-open[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }
    // end::active-peer-open[]

    // tag::active-peer-close[]
    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete();
    }
    // end::active-peer-close[]

    // tag::active-peer-send[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null);
    }
    // end::active-peer-send[]

    public void receive(Message message) {
        // tag::active-peer-receive[]
        replicatorConnection.receive(message);
        // end::active-peer-receive[]
    }

}

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ----------------------------------------------------------- */

class PassivePeerConnection implements MessageEndpointConnection {
    private final Context context;

    private MessageEndpointListener messageEndpointListener;
    private ReplicatorConnection replicatorConnection;

    private PassivePeerConnection(Context context) { this.context = context; }

    public void startListener() throws CouchbaseLiteException {
        // tag::listener[]
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration();
        Database database = new Database("mydb", databaseConfiguration);
        MessageEndpointListenerConfiguration listenerConfiguration = new MessageEndpointListenerConfiguration(
            database,
            ProtocolType.MESSAGE_STREAM);
        this.messageEndpointListener = new MessageEndpointListener(listenerConfiguration);
        // end::listener[]
    }

    public void stopListener() {
        // tag::passive-stop-listener[]
        messageEndpointListener.closeAll();
        // end::passive-stop-listener[]
    }

    public void accept() {
        // tag::advertizer-accept[]
        PassivePeerConnection connection = new PassivePeerConnection(context); /* implements
        MessageEndpointConnection */
        messageEndpointListener.accept(connection);
        // end::advertizer-accept[]
    }

    public void disconnect() {
        // tag::passive-replicator-close[]
        replicatorConnection.close(null);
        // end::passive-replicator-close[]
    }

    // tag::passive-peer-open[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }
    // end::passive-peer-open[]

    // tag::passive-peer-close[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete();
    }
    // end::passive-peer-close[]

    // tag::passive-peer-send[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null);
    }
    // end::passive-peer-send[]

    public void receive(Message message) {
        // tag::passive-peer-receive[]
        replicatorConnection.receive(message);
        // end::passive-peer-receive[]
    }
}

// tag::predictive-model[]
// `tensorFlowModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
class ImageClassifierModel implements PredictiveModel {
    @Override
    public Dictionary predict(@NonNull Dictionary input) {
        Blob blob = input.getBlob("photo");
        if (blob == null) { return null; }

        // `tensorFlowModel` is a fake implementation
        // this would be the implementation of the ml model you have chosen
        return new MutableDictionary(TensorFlowModel.predictImage(blob.getContent())); <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

class TensorFlowModel {
    public static Map&lt;String, Object&gt; predictImage(byte[] data) {
        return null;
    }
}
// end::predictive-model[]

// tag::custom-logging[]
class LogTestLogger implements Logger {
    @NonNull
    private final LogLevel level;

    public LogTestLogger(@NonNull LogLevel level) { this.level = level; }

    @NonNull
    @Override
    public LogLevel getLevel() { return level; }

    @Override
    public void log(@NonNull LogLevel level, @NonNull LogDomain domain, @NonNull String message) {
    }
}
// end::custom-logging[]




// tag::certAuthListener-full[]

//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "lite@couchbase.com");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread(() -&gt; {
            try {
                startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);
                Log.e(TAG, "Success!!");
                deleteIdentity("server");
                Log.e(TAG, "Alias deleted: server");
                deleteIdentity("client");
                Log.e(TAG, "Alias deleted: client");
            }
            catch (Exception e) { Log.e(TAG, "Failed!!", e); }
        }).start();
    }

    // start a client replicator
    public void startClient(
        @NonNull URI uri,
        @NonNull Certificate cert,
        @NonNull TLSIdentity clientIdentity,
        @NonNull Database db) throws CertificateEncodingException, InterruptedException {
        final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri));
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    // tag::listener-config-auth-cert-full[]
    /**
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(false);
      config.setTlsIdentity(serverId);
      config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

      final URLEndpointListener listener = new URLEndpointListener(config);
      listener.start();

      final List&lt;URI&gt; urls = listener.getUrls();
      if (urls.isEmpty()) { return null; }
      return urls.get(0);
    }
    // end::listener-config-auth-cert-full[]
    // tag::listener-config-delete-cert-full[]

    /**
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
    throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

      final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
      keyStore.load(null);

      keyStore.deleteEntry(alias); <i class="conum" data-value="29"></i><b>(29)</b>
    }
    // end::listener-config-delete-cert-full[]

    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /* Configure Client (active) side certificates
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    private void configureClientCerts(
      ReplicatorConfiguration config,
      @NonNull Certificate cert,
      @NonNull TLSIdentity clientIdentity)
      throws CertificateEncodingException {

        // Create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
      }
      // notend::p2p-tlsid-tlsidentity-with-label[]

    /**
     * Copy a cert from a resource bundle
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte buf[] = new byte[1024];
        int n;
        while ((n = in.read(buf)) &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}
// end::certAuthListener-full[]


// tag::passwordAuthListener-full[]

//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread(() -&gt; {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);
                Log.e(TAG, "Success!!");
            }
            catch (Exception e) { Log.e(TAG, "Failed!!", e); }
        }).start();
    }

    // start a client replicator
    public void runClient(
        @NonNull URI uri,
        @NonNull String username,
        @NonNull char[] password,
        @NonNull Database db) throws InterruptedException {
        final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri));
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    // tag::listener-config-client-auth-pwd-full[]
    /**
     *
     * Start a listener for db that accepts connections using exactly the passed username and password

     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password) <i class="conum" data-value="30"></i><b>(30)</b>
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(true);
      config.setAuthenticator(new ListenerPasswordAuthenticator(
        (validUser, pwd) -&gt; username.equals(validUser) &amp;&amp; Arrays.equals(validPassword, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
      }
      // end::listener-config-client-auth-pwd-full[]
    }


// end::passwordAuthListener-full[]




// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.support.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;

public class docOnly_ReplicationExamples {
  private static final String TAG = "EXAMPLE ACTIVE PEER";
  private static final String thisDBNAME = "local-database";
  private final Context context;
  // private Database database;
  // private Replicator replicator;

  public docOnly_ReplicationExamples(Context context) { this.context = context; }

  String user = "syncuser";
  String password = "sync9455";
  SecCertificate cert=null;
  String passivePeerEndpoint = "10.1.1.12:8920";
  String passivePeerPort = "8920";
  String passiveDbName = "userdb";
  Database thisDB;
  Replicator thisReplicator;
  ListenerToken replicatorListener;




// PASSIVE PEER STUFF
// Stuff I adapted
//
// BEGIN new stuff 90420temp cache
  private URLEndpointListener createListener() {
  final URLEndpointListenerConfiguration listenerConfig = new URLEndpointListenerConfiguration(db);

  listenerConfig.setDisableTls(false);

  listenerConfig.setEnableDeltaSync(true);

  listenerConfig.setTlsIdentity(null); // Use with anonymous self signed cert

  listenerConfig.setAuthenticator(new ListenerPasswordAuthenticator(this::isWhitelistedUser));

  return new URLEndpointListener(listenerConfig);
}

public void startListener(@NotNull URLEndpointListener listener) {
  executor.submit(() -&gt; {
      CouchbaseLiteException err = null;
      try { listener.start(); }
      catch (CouchbaseLiteException e) { err = e; }
      onStart(err);
  });
}

private void stopListener(@NotNull URLEndpointListener listener) {
  listener.stop();
}
// END new stuff 90420temp cache


private void ibListenerSimple() {
  // tag::listener-simple[]
  final URLEndpointListenerConfiguration thisConfig =
    new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="31"></i><b>(31)</b>

  thisConfig.setAuthenticator(
    new ListenerPasswordAuthenticator(
      (username, password) -&gt;
        username.equals("valid.User") &amp;&amp;
        Arrays.equals(password, valid.password.string)
      )
    ); <i class="conum" data-value="32"></i><b>(32)</b>

  final URLEndpointListener thisListener =
    new URLEndpointListener(thisConfig); <i class="conum" data-value="33"></i><b>(33)</b>

  thisListener.start(); <i class="conum" data-value="34"></i><b>(34)</b>

  // end::listener-simple[]
}

private void ibReplicatorSimple() {
  // tag::replicator-simple[]
  URI uri = null;
  try {
      uri = new URI("wss://10.0.2.2:4984/db");
  } catch (URISyntaxException e) {
      e.printStackTrace();
  }
  Endpoint theListenerEndpoint = new URLEndpoint(uri); <i class="conum" data-value="35"></i><b>(35)</b>

  ReplicatorConfiguration thisConfig =
    new ReplicatorConfiguration(database, theListenerEndpoint); <i class="conum" data-value="36"></i><b>(36)</b>

  thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="37"></i><b>(37)</b>

  final BasicAuthenticator thisAuth
  = new BasicAuthenticator(
      "valid.user",
      "valid.password.string");
  thisConfig.setAuthenticator(thisAuth) <i class="conum" data-value="38"></i><b>(38)</b>

  this.replicator = new Replicator(config); <i class="conum" data-value="39"></i><b>(39)</b>
  this.replicator.start(); <i class="conum" data-value="40"></i><b>(40)</b>

  // end::replicator-simple[]
}


private void ibPassListener() {
// EXAMPLE 1
    // tag::listener-initialize[]
    // tag::listener-config-db[]
    // Initialize the listener config
    final URLEndpointListenerConfiguration thisConfig
       = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="41"></i><b>(41)</b>

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.setPort(55990); <i class="conum" data-value="42"></i><b>(42)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    thisConfig.setNetworkInterface("10.1.1.10"); <i class="conum" data-value="43"></i><b>(43)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.setEnableDeltaSync(false); <i class="conum" data-value="44"></i><b>(44)</b>

    // end::listener-config-delta-sync[]
    // tag::listener-config-tls-full[]
    // Configure server security
    // tag::listener-config-tls-enable[]
    thisConfig.setDisableTls(false); <i class="conum" data-value="45"></i><b>(45)</b>

    // end::listener-config-tls-enable[]
    // tag::listener-config-tls-id-anon[]
    // Use an Anonymous Self-Signed Cert
    thisConfig.setTlsIdentity(null); <i class="conum" data-value="46"></i><b>(46)</b>

    // end::listener-config-tls-id-anon[]

    // tag::listener-config-client-auth-pwd[]
    // Configure Client Security using an Authenticator
    // For example, Basic Authentication <i class="conum" data-value="47"></i><b>(47)</b>
    thisConfig.setAuthenticator(new ListenerPasswordAuthenticator(
      (validUser, validPassword) -&gt;
        username.equals(validUser) &amp;&amp;
        Arrays.equals(password, validPassword)));

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // Initialize the listener
    final URLEndpointListener thisListener
      = new URLEndpointListener(thisConfig); <i class="conum" data-value="48"></i><b>(48)</b>

    // Start the listener
    thisListener.start(); <i class="conum" data-value="49"></i><b>(49)</b>

    // end::listener-start[]
    // end::listener-initialize[]
}

private void ibListenerGetNetworkInterfaces() {
  // tag::listener-get-network-interfaces[]
  final URLEndpointListenerConfiguration thisConfig =
    URLEndpointListenerConfiguration(database: self.oDB)
  final URLEndpointListener thisListener
    = new URLEndpointListener(thisConfig);
  thisListener.start()
  Log.i(TAG, "URLS are " + thisListener.getUrls());

  // end::listener-get-network-interfaces[]
}

private void ibListenerLocalDb() {
// tag::listener-local-db[]
// . . . preceding application logic . . .
CouchbaseLite.init(context); <i class="conum" data-value="50"></i><b>(50)</b>
Database thisDB = new Database("passivepeerdb");

// end::listener-local-db[]
}

private void ibListenerConfigTlsDisable() {
// tag::listener-config-tls-disable[]
thisConfig.setDisableTls(true); <i class="conum" data-value="51"></i><b>(51)</b>

// end::listener-config-tls-disable[]
}

private void ibListenerConfigTlsIdFull() {
// tag::listener-config-tls-id-full[]
  // tag::listener-config-tls-id-caCert[]
  // Use CA Cert
  // Import a key pair into secure storage
  // Create a TLSIdentity from the imported key-pair
  InputStream thisKeyPair = new FileInputStream();

  thisKeyPair.getClass().getResourceAsStream("serverkeypair.p12"); <i class="conum" data-value="52"></i><b>(52)</b>

  TLSIdentity thisIdentity = new TLSIdentity.importIdentity(
    EXTERNAL_KEY_STORE_TYPE,  // KeyStore type, eg: "PKCS12"
    thisKeyPair,              // An InputStream from the keystore
    password,                 // The keystore password
    EXTERNAL_KEY_ALIAS,       // The alias to be used (in external keystore)
    null,                     // The key password
    "test-alias"              // The alias for the imported key
    );

  // end::listener-config-tls-id-caCert[]

  // tag::listener-config-tls-id-SelfSigned[]
  // Use a self-signed certificate
  // Create a TLSIdentity for the server using convenience API.
  // System generates self-signed cert
  // Work-in-progress. Code snippet coming soon.
  private static final Map&lt;String, String&gt; CERT_ATTRIBUTES; <i class="conum" data-value="53"></i><b>(53)</b>
  static {
    final Map&lt;String, String&gt; thisMap = new HashMap&lt;&gt;();
    m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "Couchbase Demo");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
    m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "noreply@couchbase.com");
    CERT_ATTRIBUTES = Collections.unmodifiableMap(thisMap);
  }

  // Store the TLS identity in secure storage
  // under the label 'couchbase-docs-cert'
  TLSIdentity thisIdentity =
    new TLSIdentity.createIdentity(
      true,
      CERT_ATTRIBUTES,
      null,
      "couchbase-docs-cert"); <i class="conum" data-value="54"></i><b>(54)</b>

  // end::listener-config-tls-id-SelfSigned[]

  // tag::listener-config-tls-id-set[]
  // Set the TLS Identity
  thisConfig.setTlsIdentity(thisIdentity); <i class="conum" data-value="55"></i><b>(55)</b>

  // end::listener-config-tls-id-set[]
// end::listener-config-tls-id-full[]
}

private void ibListenerConfigClientAuthRoot() {
// tag::listener-config-client-root-ca[]
  // tag::listener-config-client-auth-root[]
  // Configure the client authenticator
  // to validate using ROOT CA
  // thisClientID.certs is a list containing a client cert to accept
  // and any other certs needed to complete a chain between the client cert
  // and a CA
  final TLSIdentity validId =
    TLSIdentity.getIdentity("Our Corporate Id");  // get the identity <i class="conum" data-value="56"></i><b>(56)</b>

  if (validId == null) { throw new IllegalStateException("Cannot find corporate id"); }

  thisConfig.setTlsIdentity(validId);

  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(validId.getCerts())); <i class="conum" data-value="57"></i><b>(57)</b> <i class="conum" data-value="58"></i><b>(58)</b>
    // accept only clients signed by the corp cert

  final URLEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

  // end::listener-config-client-auth-root[]
// end::listener-config-client-root-ca[]
}

private void ibListenerConfigClientAuthLambda() {
// tag::listener-config-client-auth-lambda[]
// Configure authentication using application logic
  final TLSIdentity thisCorpId = TLSIdentity.getIdentity("OurCorp"); <i class="conum" data-value="59"></i><b>(59)</b>
  if (thisCorpId == null) {
    throw new IllegalStateException("Cannot find corporate id"); }
  thisConfig.setTlsIdentity(thisCorpId);
  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(
      (thisCorpId.getCerts()) -&gt; {
      // use supplied logic that resolves to boolean
      // true=valid, false=invalid
      }
    )); <i class="conum" data-value="60"></i><b>(60)</b> <i class="conum" data-value="61"></i><b>(61)</b>
  final ULEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

  // end::listener-config-client-auth-lambda[]
}


private void ibListenerConfigTlsDisable() {

  // tag::listener-config-tls-disable[]
  thisConfig.disableTLS(true);

  // end::listener-config-tls-disable[]
}


private void ibListenerStatusCheck() {
  // tag::listener-status-check[]
  int connectionCount =
    thisListener.getStatus().getConnectionCount(); <i class="conum" data-value="62"></i><b>(62)</b>

  int activeConnectionCount =
    thisListener.getStatus().getActiveConnectionCount();  <i class="conum" data-value="63"></i><b>(63)</b>

  // end::listener-status-check[]
}

private void ibListenerStop() {

  // tag::listener-stop[]
  thisListener.stop();

  // end::listener-stop[]
}

// Listener Callouts
/*
  // tag::listener-callouts-full[]

    // tag::listener-start-callouts[]
    &lt;.&gt; Initialize the listener instance using the configuration settings.
    &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.

  // end::listener-start-callouts[]

  // tag::listener-status-check-callouts[]

  &lt;.&gt; `connectionCount` -- the total number of connections served by the listener
  &lt;.&gt; `activeConnectionCount` -- the number of active (BUSY) connections currently being served by the listener
  //
  // end::listener-status-check-callouts[]

// end::listener-callouts-full[]
*/
/* END CALLOUTS TEXT */


private void ibP2PUrlEndpointListener() {

// tag::p2p-ws-api-urlendpointlistener[]
  public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
    // end::p2p-ws-api-urlendpointlistener[]
  }
}



// ACTIVE PEER STUFF
// Replication code
//

  //@Test
  public void testActPeerSync() throws CouchbaseLiteException, URISyntaxException {
  // tag::p2p-act-rep-func[]
    // tag::p2p-act-rep-initialize[]
    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://listener.com:8954"))); <i class="conum" data-value="64"></i><b>(64)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config-type[]
    // Set replicator type
    thisConfig.setReplicatorType(
      ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // end::p2p-act-rep-config-type[]
    // tag::p2p-act-rep-config-cont[]
    // Configure Sync Mode
    thisConfig.setContinuous(false); // default value

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Authentication --
    // only accept self-signed certs
    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="65"></i><b>(65)</b>

    // end::p2p-act-rep-config-self-cert[]
    // tag::p2p-act-rep-auth[]
    // Configure the credentials the
    // client will provide if prompted
    final BasicAuthenticator thisAuth
      = new BasicAuthenticator(
          "Our Username",
          "Our PasswordValue")); <i class="conum" data-value="66"></i><b>(66)</b>

    thisConfig.setAuthenticator(thisAuth)

    // end::p2p-act-rep-auth[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    thisConfig.setConflictResolver( /* define resolver function */); <i class="conum" data-value="67"></i><b>(67)</b>

    // end::p2p-act-rep-config-conflict[]
    // tag::p2p-act-rep-start-full[]
    // Create replicator
    // Consider holding a reference somewhere
    // to prevent the Replicator from being GCed
    final Replicator thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="68"></i><b>(68)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    // Optionally add a change listener <i class="conum" data-value="69"></i><b>(69)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    ListenerToken thisListener =
      new thisReplicator.addChangeListener(change -&gt; {
        final CouchbaseLiteException err =
         change.getStatus().getError();
         if (err != null) {
           Log.i(TAG, "Error code ::  " + err.getCode(), e);
         }
      });

    // end::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-start[]
    // Start replicator
    thisReplicator.start(false); <i class="conum" data-value="70"></i><b>(70)</b>

    // end::p2p-act-rep-start[]
    // end::p2p-act-rep-start-full[]
    // end::p2p-act-rep-func[]         ***** End p2p-act-rep-func

  public void ibReplicatorConfig() {
  // BEGIN additional snippets
      // tag::p2p-act-rep-config-tls-full[]
      // tag::p2p-act-rep-config-cacert[]
      // Configure Server Security
      // -- only accept CA attested certs
      thisConfig.setAcceptOnlySelfSignedServerCertificate(false); <i class="conum" data-value="71"></i><b>(71)</b>

      // end::p2p-act-rep-config-cacert[]
      // tag::p2p-act-rep-config-pinnedcert[]

    // Return the remote pinned cert (the listener's cert)
    byte returnedCert
     = new byte(thisConfig.getPinnedCertificate()); // Get listener cert if pinned
    // end::p2p-act-rep-config-pinnedcert[]

    // end::p2p-act-rep-config-tls-full[]
    // tag::p2p-tlsid-tlsidentity-with-label[]
    // ... your other replicator configuration

    // Provide a client certificate to the server for authentication
    final TLSIdentity thisClientId = TLSIdentity.getIdentity("clientId"); <i class="conum" data-value="72"></i><b>(72)</b>

    if (thisClientId == null) { throw new IllegalStateException("Cannot find client id"); }

    thisConfig.setAuthenticator(new ClientCertificateAuthenticator(thisClientId)); <i class="conum" data-value="73"></i><b>(73)</b>

    // ... your other replicator configuration
    final thisReplicator= new Replicator(thisConfig);

    // end::p2p-tlsid-tlsidentity-with-label[]
    // tag::p2p-act-rep-config-cacert-pinned[]

    // Use the pinned certificate from the byte array (cert)
    thisConfig.setPinnedServerCertificate(cert.getEncoded()); <i class="conum" data-value="74"></i><b>(74)</b>
    // end::p2p-act-rep-config-cacert-pinned[]
}
// END additional snippets







// tag::p2p-act-rep-status[]

    Log.i(TAG, "The Replicator is currently " +
      thisReplicator.getStatus().getActivityLevel());

    Log.i(TAG, "The Replicator has processed " + t);

    if (thisReplicator.getStatus().getActivityLevel() ==
      Replicator.ActivityLevel.BUSY) {
        Log.i(TAG, "Replication Processing");
        Log.i(TAG, "It has completed " +
          thisReplicator.getStatus().getProgess().getTotal() +
          " changes");
      }
      // end::p2p-act-rep-status[]

      // tag::p2p-act-rep-stop[]
      // Stop replication.
      thisReplicator.stop(); <i class="conum" data-value="75"></i><b>(75)</b>
      // end::p2p-act-rep-stop[]


  CouchbaseLite.init(context);
  Database thisDB = new Database("passivepeerdb");  <i class="conum" data-value="76"></i><b>(76)</b>
  // Initialize the listener config
  final URLEndpointListenerConfiguration thisConfig = new URLEndpointListenerConfiguration(database);
  thisConfig.setPort(55990)           // &lt;.&gt; Optional; defaults to auto
  thisConfig.setDisableTls(false)     // &lt;.&gt; Optional; defaults to false
  thisConfig.setEnableDeltaSync(true) // &lt;.&gt; Optional; Defaults to false

  // Configure the client authenticator (if using basic auth)
  ListenerPasswordAuthenticator auth = new ListenerPasswordAuthenticator { "username", "password"}; <i class="conum" data-value="77"></i><b>(77)</b>
  thisConfig.setAuthenticator(auth); <i class="conum" data-value="78"></i><b>(78)</b>

  // Initialize the listener
  final URLEndpointListener listener = new URLEndpointListener( thisConfig ); <i class="conum" data-value="79"></i><b>(79)</b>

  // Start the listener
  listener.start(); <i class="conum" data-value="80"></i><b>(80)</b>



  // tag::createTlsIdentity[]

  Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
        )

  TLSIdentity thisIdentity = new TLSIdentity.createIdentity(true, X509_ATTRIBUTES, null, "test-alias");

  // end::createTlsIdentity[]

  // tag::p2p-tlsid-store-in-keychain[]
  // end::p2p-tlsid-store-in-keychain[]


  // tag::deleteTlsIdentity[]
  // tag::p2p-tlsid-delete-id-from-keychain[]
  String thisAlias = "alias-to-delete";
  final KeyStore thisKeyStore
    =  KeyStore.getInstance("AndroidKeyStore");
  thisKeyStore.load(null);
  thisKeyStore.deleteEntry(thisAlias);

  // end::p2p-tlsid-delete-id-from-keychain[]
  // end::deleteTlsIdentity[]

  // tag::retrieveTlsIdentity[]
  // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label

  TLSIdentity thisIdentity =
    new TLSIdentity.getIdentity("couchbase-docs-cert")
  // end::retrieveTlsIdentity[]


  // tag::sgw-repl-pull[]
  public void ibRplicatorPull() {
    Database database;
    Replicator replicator; <i class="conum" data-value="81"></i><b>(81)</b>

    URI uri = null;
    try {
        uri = new URI("wss://10.0.2.2:4984/db"); <i class="conum" data-value="82"></i><b>(82)</b>
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
    Endpoint endpoint = new URLEndpoint(uri);
    ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
    config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
    this.replicator = new Replicator(config);
    this.replicator.start();
  }
  // end::sgw-repl-pull[]

    // tag::sgw-act-rep-initialize[]
    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))); <i class="conum" data-value="83"></i><b>(83)</b>

    // end::sgw-act-rep-initialize[]


  /* C A L L O U T S

  // tag::p2p-act-rep-config-cacert-pinned-callouts[]
  &lt;.&gt; Configure the pinned certificate using data from the byte array `cert`
  // end::p2p-act-rep-config-cacert-pinned-callouts[]

  // tag::p2p-tlsid-tlsidentity-with-label-callouts[]
  &lt;.&gt; Attempt to get the identity from secure storage
  &lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity

  // end::p2p-tlsid-tlsidentity-with-label-callouts[]

  // tag::sgw-repl-pull-callouts[]
  &lt;.&gt; A replication is an asynchronous operation.
  To keep a reference to the `replicator` object, you can set it as an instance property.
  &lt;.&gt; The URL scheme for remote database URLs uses `ws:`, or `wss:` for SSL/TLS connections over wb sockets.
  In this example the hostname is `10.0.2.2` because the Android emulator runs in a VM that is generally accessible on `10.0.2.2` from the host machine (see https://developer.android.com/studio/run/emulator-networking[Android Emulator networking] documentation).
  +
  NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
  Although `wss:` protocol URLs are not affected, in order to use the `ws:` protocol, applications must target API 27 or lower, or must configure application network security as described https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted[here].

  // end::sgw-repl-pull-callouts[]
  */

}
/*

Snippets demonstrating use of resultsets

*/
package com.example.docsnippet;
        import android.app.Application.*;
        import android.content.Context;
        import android.content.Context.*;
        import java.lang.Object;
        import java.security.Key;
        import java.util.*;
        import com.couchbase.lite.*;
        import com.couchbase.lite.Dictionary;

public class TestQueries {

    // For Documentation

    Datastore ds = new Datastore();

    Database this_Db = ds.getDB();

    String dbName = this_Db.getName();

    HashMap&lt;String, Object&gt; hotels = new HashMap&lt;&gt;();

    Dictionary thisDocsProps;
    String thisDocsId;
    String thisDocsName;
    String thisDocsType;
    String thisDocsCity;



    static {
        init();
    }

    private static void init() {
    }



    public void testQuerySyntaxAll() throws CouchbaseLiteException {

        // tag::query-syntax-all[]
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

      Query listQuery = QueryBuilder.select(SelectResult.all())
              .from(DataSource.database(this_Db));
        // end::query-syntax-all[]

        // tag::query-access-all[]
        try {
            for (Result result : listQuery.execute().allResults()) {
                             // get the k-v pairs from the 'hotel' key's value into a dictionary
                thisDocsProps = result.getDictionary(0)); <i class="conum" data-value="84"></i><b>(84)</b>
                thisDocsId = thisDocsProps.getString("id");
                thisDocsName = thisDocsProps.getString("Name");
                thisDocsType = thisDocsProps.getString("Type");
                thisDocsCity = thisDocsProps.getString("City");

                // Alternatively, access results value dictionary directly
                final Hotel hotel = new Hotel();
                hotel.Id = result.getDictionary(0).getString("id"); <i class="conum" data-value="85"></i><b>(85)</b>
                hotel.Type = result.getDictionary(0).getString("Type");
                hotel.Name = result.getDictionary(0).getString("Name");
                hotel.City = result.getDictionary(0).getString("City");
                hotel.Country= result.getDictionary(0).getString("Country");
                hotel.Description = result.getDictionary(0).getString("Description");
                hotels.put(hotel.Id, hotel);

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }

        // end::query-access-all[]
      }

// tag::query-access-json[]
    // Uses Jackson JSON processor

    ArrayList&lt;Hotel&gt; hotels = new ArrayList&lt;Hotel&gt;();
    HashMap&lt;String, Object&gt; dictFromJSONstring;
    for (Result result : listQuery.execute()) {

      // Get result as JSON string
      String thisJsonString = result.toJSON(); <i class="conum" data-value="86"></i><b>(86)</b>

      // Get Java  Hashmap from JSON string
      HashMap&lt;String, Object&gt; dictFromJSONstring =
              mapper.readValue(thisJsonString, HashMap.class); <i class="conum" data-value="87"></i><b>(87)</b>


      // Use created hashmap
      String hotelId = dictFromJSONstring.get("id").toString();
      String hotelType = dictFromJSONstring.get("type").toString();
      String hotelname = dictFromJSONstring.get("name").toString();


      // Get custom object from JSON string
      Hotel thisHotel =
              mapper.readValue(thisJsonString, Hotel.class); <i class="conum" data-value="88"></i><b>(88)</b>
      hotels.add(thisHotel);

    }

  // end::query-access-json[]
            }


    public void testQuerySyntaxProps() throws CouchbaseLiteException {

        // tag::query-syntax-props[]
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        Query listQuery =
                QueryBuilder.select(SelectResult.expression(Meta.id),
                        SelectResult.property("name"),
                        SelectResult.property("Name"),
                        SelectResult.property("Type"),
                        SelectResult.property("City"))
                        .from(DataSource.database(this_Db));

        // end::query-syntax-props[]

        // tag::query-access-props[]

        try {
            for (Result result : listQuery.execute().allResults()) {

                // get data direct from result k-v pairs
                final Hotel hotel = new Hotel();
                hotel.Id = result.getString("id");
                hotel.Type = result.getString("Type");
                hotel.Name = result.getString("Name");
                hotel.City = result.getString("City");

                // Store created hotel object in a hashmap of hotels
                hotels.put(hotel.Id, hotel);

                // Get result k-v pairs into a 'dictionary' object
                Map &lt;String, Object&gt; thisDocsProps = result.toMap();
                thisDocsId =
                        thisDocsProps.getOrDefault("id",null).toString();
                thisDocsName =
                        thisDocsProps.getOrDefault("Name",null).toString();
                thisDocsType =
                        thisDocsProps.getOrDefault("Type",null).toString();
                thisDocsCity =
                        thisDocsProps.getOrDefault("City",null).toString();

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }

        // end::query-access-props[]
    }


    public void testQuerySyntaxCount() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      // tag::query-syntax-count-only[]
      Query listQuery = QueryBuilder.select(
              SelectResult.expression(Function.count(Expression.string("*"))).as("mycount")) <i class="conum" data-value="89"></i><b>(89)</b>
              .from(DataSource.database(this_Db));

      // end::query-syntax-count-only[]


        // tag::query-access-count-only[]
        try {
            for (Result result : listQuery.execute()) {

                // Retrieve count using key 'mycount'
                Integer altDocId = result.getInt("mycount");

                // Alternatively, use the index
                Integer orDocId = result.getInt(0);
            }
            // Or even miss out the for-loop altogether
            Integer resultCount = listQuery.execute().next().getInt("mycount");

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }
        // end::query-access-count-only[]
    }


    public void testQuerySyntaxId() throws CouchbaseLiteException {
      // tag::query-syntax-id[]
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id).as("metaID"))
                      .from(DataSource.database(this_Db));

      // end::query-syntax-id[]


        // tag::query-access-id[]

        try {
            for (Result result : listQuery.execute().allResults()) {

                // get the ID form the result's k-v pair array
                thisDocsId = result.getString("metaID"); <i class="conum" data-value="90"></i><b>(90)</b>

                // Get document from DB using retrieved ID
                Document thisDoc = this_Db.getDocument(thisDocsId);

                // Process document as required
                thisDocsName = thisDoc.getString("Name");

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }

        // end::query-access-id[]

    }


    // tag::query-syntax-pagination-all[]
    public void testQueryPagination() throws CouchbaseLiteException {


        // tag::query-syntax-pagination[]
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        int thisOffset = 0;
        int thisLimit = 20;

        Query listQuery =
                QueryBuilder
                        .select(SelectResult.all())
                        .from(DataSource.database(this_Db))
                        .limit(Expression.intValue(thisLimit),
                                  Expression.intValue(thisOffset)); <i class="conum" data-value="91"></i><b>(91)</b>

        // end::query-syntax-pagination[]

    }

    // end::query-syntax-pagination-all[]



} // class</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note use of the <code>wss://</code> prefix to ensure TLS encryption (strongly recommended in production)</td>
</tr>
</table>
</div>
<div id="lbl-cfg-sync" class="paragraph">
<p>=== Sync Mode</p>
</div>
<div class="paragraph">
<p>Here we define the direction and type of replication we want to initiate.</p>
</div>
<div class="paragraph">
<p>We use <code><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/ReplicatorConfiguration.html">ReplicatorConfiguration</a></code> class&#8217;s <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/ReplicatorConfiguration.html#setReplicatorType-com.couchbase.lite.AbstractReplicatorConfiguration.ReplicatorType-">replicatorType</a> and
<code><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/ReplicatorConfiguration.html#setContinuous-boolean-">continuous</a></code> parameters, to tell the replicator:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The direction of the replication:
<code><strong>PUSH_AND_PULL</strong></code>; <code>PULL</code>; <code>PUSH</code></p>
</li>
<li>
<p>The type of replication, that is:</p>
<div class="ulist">
<ul>
<li>
<p>Continuous&#8201;&#8212;&#8201;remaining active indefinitely to replicate changed documents (<code>continuous=true</code>).</p>
</li>
<li>
<p>Ad-hoc&#8201;&#8212;&#8201;a one-shot replication of changed documents (<code>continuous=false</code>).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset3_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset3_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset3_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">// Set replicator type
thisConfig.setReplicatorType(
    ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL
)

// Configure Sync Mode
thisConfig.setContinuous(false) // default value</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset3_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">// Set replicator type
thisConfig.setReplicatorType(
  ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

// Configure Sync Mode
thisConfig.setContinuous(false); // default value</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="lbl-cfg-keep-alive" class="paragraph">
<p>=== Retry Configuration</p>
</div>
<div class="paragraph">
<p>Couchbase Lite for Android&#8217;s replication retry logic assures a resilient connection.</p>
</div>
<div class="paragraph">
<p>The replicator minimizes the chance and impact of dropped connections by maintaining a heartbeat; essentially pinging the Sync Gateway at a configurable interval to ensure the connection remains alive.</p>
</div>
<div class="paragraph">
<p>In the event it detects a transient error, the replicator will attempt to reconnect, stopping only when the connection is re-established, or the number of retries exceeds the retry limit (9 times for a single-shot replication and unlimited for a continuous replication).</p>
</div>
<div class="paragraph">
<p>On each retry the interval between attempts is increased exponentially (exponential backoff) up to the maximum wait time limit (5 minutes).</p>
</div>
<div class="paragraph">
<p>The REST API provides configurable control over this replication retry logic using a set of configiurable properties&#8201;&#8212;&#8201;see: <a href="#tbl-repl-retry">Table 1</a>.</p>
</div>
<table id="tbl-repl-retry" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Replication Retry Configuration Properties</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 30%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Property</p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock">Use cases</p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock">Description</p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicatorConfiguration.html#setHeartbeat-long-">setHeartbeat()</a></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Reduce to detect connection errors sooner</p>
</li>
<li>
<p>Align to load-balancer or proxy <code>keep-alive</code> interval&#8201;&#8212;&#8201;see Sync Gateway&#8217;s topic <a href="../../../sync-gateway/current/load-balancer.html#websocket-connection" class="page">Load Balancer - Keep Alive</a></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The interval (in seconds) between the heartbeat pulses.</p>
</div>
<div class="paragraph">
<p>Default: The replicator pings the Sync Gateway every 300 seconds.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicatorConfiguration.html#setMaxRetries-int-">setMaxRetries()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Change this to limit or extend the number of retry attempts.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The maximum number of retry attempts</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set this to zero (0) to prevent any retry attempt</p>
</li>
<li>
<p>The retry attempt count is reset when the replicator is able to connect and replicate</p>
</li>
<li>
<p>Default values are:</p>
<div class="ulist">
<ul>
<li>
<p>Single-shot replication = 9;</p>
</li>
<li>
<p>Continuous replication = maximum integer value</p>
</li>
</ul>
</div>
</li>
<li>
<p>Negative values generate a Couchbase exception <code>InvalidArgumentException</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicatorConfiguration.html#setMaxRetryWaitTime-long-">setMaxRetryWaitTime()</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Change this to adjust the interval between retries.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The maximum interval between retry attempts</p>
</div>
<div class="paragraph">
<p>Whilst you can configure the <strong>maximum permitted</strong> wait time,  each individual interval is calculated by the replicator&#8217;s exponential backoff algorithm and is not configurable.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Default value: 300 seconds (5 minutes)</p>
</li>
<li>
<p>Zero or negative values generate a Couchbase exception, <code>InvalidArgumentException</code>.</p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When necessary you can adjust any or all of those configurable values&#8201;&#8212;&#8201;see: <a href="#ex-repl-retry">[ex-repl-retry]</a> for how to do this.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset4_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset4_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset4_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
val config = ReplicatorConfiguration(database, target)

//  other config as required . . .
config.setHeartbeat(150L) <i class="conum" data-value="1"></i><b>(1)</b>
config.setMaxRetries(20L) <i class="conum" data-value="2"></i><b>(2)</b>
config.setMaxRetryWaitTime(600L) <i class="conum" data-value="3"></i><b>(3)</b>
val repl = Replicator(config)</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset4_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">URLEndpoint target =
new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

ReplicatorConfiguration config =
new ReplicatorConfiguration(database, target);

//  other config as required . . .
config.setHeartbeat(150L); <i class="conum" data-value="1"></i><b>(1)</b>
config.setMaxRetries(20L); <i class="conum" data-value="2"></i><b>(2)</b>
config.setMaxRetryWaitTime(600L); <i class="conum" data-value="3"></i><b>(3)</b>

Replicator repl = new Replicator(config);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Here we use <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicatorConfiguration.html#setHeartbeat-long-">setHeartbeat()</a> to set the required interval (in seconds) between the heartbeat pulses</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here we use <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicatorConfiguration.html#setMaxRetries-int-">setMaxRetries()</a> to set the required number of retry attempts</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here we use <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicatorConfiguration.html#setMaxRetryWaitTime-long-">setMaxRetryWaitTime()</a> to set the required interval between retry attempts.</td>
</tr>
</table>
</div>
<div id="lbl-svr-auth" class="paragraph">
<p>=== Server Authentication</p>
</div>
<div class="paragraph">
<p>Define the credentials your app (the client) is expecting to receive from the Sync Gateway (the server) in order to ensure it is prepared to continue with the sync.</p>
</div>
<div class="paragraph">
<p>Note that the client cannot authenticate the server if TLS is turned off.
When TLS is enabled (Sync Gateway&#8217;s default) the client <em>must</em> authenticate the server.
If the server cannot provide acceptable credentials then the connection will fail.</p>
</div>
<div class="paragraph">
<p>Use <code><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/ReplicatorConfiguration.html">ReplicatorConfiguration</a></code> properties <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/ReplicatorConfiguration.html#setAcceptOnlySelfSignedServerCertificate-boolean-">setAcceptOnlySelfSignedServerCertificate</a> and <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/ReplicatorConfiguration.html#setPinnedServerCertificate-byte:A-">setPinnedServerCertificate</a>, to tell the replicator how to verify server-supplied TLS server certificates.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If there is a pinned certificate, nothing else matters, the server cert must <strong>exactly</strong> match the pinned certificate.</p>
</li>
<li>
<p>If there are no pinned certs and <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/ReplicatorConfiguration.html#setAcceptOnlySelfSignedServerCertificate-boolean-">setAcceptOnlySelfSignedServerCertificate</a> is <code>true</code> then any self-signed certificate is accepted.  Certificates that are not self signed are rejected, no matter who signed them.</p>
</li>
<li>
<p>If there are no pinned certificates and <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/ReplicatorConfiguration.html#setAcceptOnlySelfSignedServerCertificate-boolean-">setAcceptOnlySelfSignedServerCertificate</a> is <code>false</code> (default), the client validates the servers certificates against the system CA certificates.  The server must supply a chain of certificates whose root is signed by one of the certificates in the system CA bundle.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset5_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset5_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset5_kotlin">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset6_ca-cert"></a>CA Cert</p>
</li>
<li>
<p><a id="tabset6_self-signed-cert"></a>Self Signed Cert</p>
</li>
<li>
<p><a id="tabset6_pinned-certificate"></a>Pinned Certificate</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset6_ca-cert">
<div class="paragraph">
<p>Set the client to expect and accept only CA attested certificates.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">// Configure Server Security
// -- only accept CA attested certs
thisConfig.setAcceptOnlySelfSignedServerCertificate(false) <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the default.
Only certificate chains with roots signed by a trusted CA are allowed.
Self signed certificates are not allowed.</td>
</tr>
</table>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset6_self-signed-cert">
<div class="paragraph">
<p>Set the client to expect and accept only self-signed certificates</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">// Configure Server Authentication --
// only accept self-signed certs
thisConfig.setAcceptOnlySelfSignedServerCertificate(true) <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set this to <code>true</code> to accept any self signed cert.
Any certificates that are not self-signed are rejected.</td>
</tr>
</table>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset6_pinned-certificate">
<div class="paragraph">
<p>Set the client to expect and accept only a pinned certificate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt#L2258-L2260">
// Use the pinned certificate from the byte array (cert)
thisConfig.setPinnedServerCertificate(cert.getEncoded()) <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configure the pinned certificate using data from the byte array <code>cert</code></td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset5_java">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset7_ca-cert"></a>CA Cert</p>
</li>
<li>
<p><a id="tabset7_self-signed-cert"></a>Self Signed Cert</p>
</li>
<li>
<p><a id="tabset7_pinned-certificate"></a>Pinned Certificate</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset7_ca-cert">
<div class="paragraph">
<p>Set the client to expect and accept only CA attested certificates.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">// Configure Server Security
// -- only accept CA attested certs
thisConfig.setAcceptOnlySelfSignedServerCertificate(false); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the default.
Only certificate chains with roots signed by a trusted CA are allowed.
Self signed certificates are not allowed.</td>
</tr>
</table>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset7_self-signed-cert">
<div class="paragraph">
<p>Set the client to expect and accept only self-signed certificates</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">// Configure Server Authentication --
// only accept self-signed certs
thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set this to <code>true</code> to accept any self signed cert.
Any certificates that are not self-signed are rejected.</td>
</tr>
</table>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset7_pinned-certificate">
<div class="paragraph">
<p>Set the client to expect and accept only a pinned certificate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java">// Use the pinned certificate from the byte array (cert)
thisConfig.setPinnedServerCertificate(cert.getEncoded()); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configure the pinned certificate using data from the byte array <code>cert</code></td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>This all assumes that you have configured the Sync Gateway to provide the appropriate SSL certificates, and have included the appropriate certificate in your app bundle&#8201;&#8212;&#8201;for more on this see: <a href="#lbl-cert-pinning">[lbl-cert-pinning]</a>.</p>
</div>
<div id="lbl-client-auth" class="paragraph">
<p>=== Client Authentication</p>
</div>
<div class="paragraph">
<p>By default, Sync Gateway does not enable authentication.
This is to make it easier to get up and running with synchronization.
You can enable authentication with the following properties in the configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "databases": {
    "mydatabase": {
      "users": {
        "GUEST": {"disabled": true}
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To authenticate with Sync Gateway, an associated user must first be created.
Sync Gateway users can be created through the <a href="../../../sync-gateway/current/rest-api-admin.html#/user/post__db___user_" class="page"><code>POST /{tkn-db}/_user</code></a> endpoint on the Admin REST API.
Provided that the user exists on Sync Gateway, there are two ways to authenticate from a Couchbase Lite client: Basic Authentication or Session Authentication.</p>
</div>
<div class="paragraph">
<p>==== Basic Authentication</p>
</div>
<div class="paragraph">
<p>You can provide a user name and password to the basic authenticator class method.
Under the hood, the replicator will send the credentials in the first request to retrieve a <code>SyncGatewaySession</code> cookie and use it for all subsequent requests during the replication.
This is the recommended way of using basic authentication.
<a href="#ex-base-auth">[ex-base-auth]</a> shows how to initiate a one-shot replication as the user <strong>username</strong> with the password <strong>password</strong>.</p>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset8_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset8_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset8_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import android.widget.Toast
import com.couchbase.code_snippets.TensorFlowModel
import com.couchbase.lite.ArrayFunction
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.Blob
import com.couchbase.lite.Conflict
import com.couchbase.lite.ConflictResolver
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.DatabaseConfiguration
import com.couchbase.lite.DatabaseEndpoint
import com.couchbase.lite.Dictionary
import com.couchbase.lite.Document
import com.couchbase.lite.DocumentFlag
import com.couchbase.lite.EncryptionKey
import com.couchbase.lite.Endpoint
import com.couchbase.lite.Expression
import com.couchbase.lite.FullTextExpression
import com.couchbase.lite.FullTextIndexItem
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.Join
import com.couchbase.lite.ListenerToken
import com.couchbase.lite.LogDomain
import com.couchbase.lite.LogFileConfiguration
import com.couchbase.lite.LogLevel
import com.couchbase.lite.Logger
import com.couchbase.lite.Message
import com.couchbase.lite.MessageEndpoint
import com.couchbase.lite.MessageEndpointConnection
import com.couchbase.lite.MessageEndpointDelegate
import com.couchbase.lite.MessageEndpointListener
import com.couchbase.lite.MessageEndpointListenerConfiguration
import com.couchbase.lite.MessagingCloseCompletion
import com.couchbase.lite.MessagingCompletion
import com.couchbase.lite.Meta
import com.couchbase.lite.MutableDictionary
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Ordering
import com.couchbase.lite.PredictionFunction
import com.couchbase.lite.PredictiveIndex
import com.couchbase.lite.PredictiveModel
import com.couchbase.lite.ProtocolType
import com.couchbase.lite.Query
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.ReplicatedDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConnection
import com.couchbase.lite.Result
import com.couchbase.lite.ResultSet
import com.couchbase.lite.SelectResult
import com.couchbase.lite.SessionAuthenticator
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.ValueIndex
import com.couchbase.lite.ValueIndexItem
import com.couchbase.lite.Where
import java.io.File
import java.io.IOException
import java.io.InputStream
import java.net.URI
import java.net.URISyntaxException
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.*

// tag::example-app[]
class Examples(private val context: Context) {
    private val database: Database? = null
    private var replicator: Replicator? = null

    //@Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {
        // tag::getting-started[]

        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        // Get the database (and create it if it doesnt exist).
        val config = DatabaseConfiguration()
        config.setDirectory(context.filesDir.absolutePath)
        val database = Database("getting-started", config)


        // Create a new document (i.e. a record) in the database.
        var mutableDoc: MutableDocument = MutableDocument()
            .setFloat("version", 2.0f)
            .setString("type", "SDK")

        // Save it to the database.
        database.save(mutableDoc)

        // Update a document.
        mutableDoc = database.getDocument(mutableDoc.getId()).toMutable()
        mutableDoc.setString("language", "Java")
        database.save(mutableDoc)
        val document: Document = database.getDocument(mutableDoc.getId())
        // Log the document ID (generated by the database) and properties
        Log.i(TAG, "Document ID :: " + document.getId())
        Log.i(TAG, "Learning " + document.getString("language"))

        // Create a query to fetch documents of type SDK.
        val query: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))
        val result: ResultSet = query.execute()
        Log.i(
            TAG,
            "Number of rows ::  " + result.allResults().size()
        )

        // Create replicators to push and pull changes to and from the cloud.
        val targetEndpoint: Endpoint =
            URLEndpoint(URI("ws://localhost:4984/getting-started-db"))
        val replConfig = ReplicatorConfiguration(database, targetEndpoint)
        replConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL)

        // Add authentication.
        replConfig.setAuthenticator(BasicAuthenticator("sync-gateway", "password"))

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        val replicator = Replicator(replConfig)

        // Listen to replicator change events.
        replicator.addChangeListener({ change -&gt;
            if (change.getStatus().getError() != null) {
                Log.i(
                    TAG,
                    "Error code ::  " + change.getStatus().getError().getCode()
                )
            }
        })

        // Start replication.
        replicator.start()

        // end::getting-started[]
        database.delete()
    }

    // end::example-app[]
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun test1xAttachments() {
        // if db exist, delete it
        deleteDB("android-sqlite", context.filesDir)
        ZipUtils.unzip(getAsset("replacedb/android140-sqlite.cblite2.zip"), context.filesDir)
        val db = Database("android-sqlite", DatabaseConfiguration())
        try {
            val doc: Document = db.getDocument("doc1")

            // For Validation
            val attachments: Dictionary = doc.getDictionary("_attachments")
            val blob: Blob = attachments.getBlob("attach1")
            val content: ByteArray = blob.getContent()
            // For Validation
            val attach =
                String.format(Locale.ENGLISH, "attach1").toByteArray()
            Arrays.equals(attach, content)
        } finally {
            // close db
            db.close()
            // if db exist, delete it
            deleteDB("android-sqlite", context.filesDir)
        }
        val document: Document = MutableDocument()

        // tag::1x-attachment[]
        val attachments: Dictionary = document.getDictionary("_attachments")
        val blob: Blob?
        blob = if (attachments != null) attachments.getBlob("avatar") else null
        val content: ByteArray?
        content = if (blob != null) blob.getContent() else null
        // end::1x-attachment[]
    }

    // ### Initializer
    fun testInitializer() {
        // tag::sdk-initializer[]
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)
        // end::sdk-initializer[]
    }

    // ### New Database
    @Throws(CouchbaseLiteException::class)
    fun testNewDatabase() {
        // tag::new-database[]
        val config = DatabaseConfiguration()
        config.setDirectory(context.filesDir.absolutePath) <i class="conum" data-value="1"></i><b>(1)</b>
        val database = Database("my-database", config)
        // end::new-database[]
        database.delete()
    }

    // ### Database Encryption
    @Throws(CouchbaseLiteException::class)
    fun testDatabaseEncryption() {
        // tag::database-encryption[]
        val config = DatabaseConfiguration()
        config.setEncryptionKey(EncryptionKey("PASSWORD"))
        val database = Database("mydb", config)
        // end::database-encryption[]
    }

    // ### Logging
    fun testLogging() {
        // tag::logging[]
        Database.setLogLevel(LogDomain.DATABASE, LogLevel.VERBOSE)
        Database.setLogLevel(LogDomain.QUERY, LogLevel.VERBOSE)
        // end::logging[]
    }

    fun testEnableCustomLogging() {
        // tag::set-custom-logging[]
        // this custom logger will never be asked to log an event
        // with a log level &lt; WARNING
        Database.log.setCustom(LogTestLogger(LogLevel.WARNING)) <i class="conum" data-value="2"></i><b>(2)</b>
        // end::set-custom-logging[]
    }

    // ### Console logging
    @Throws(CouchbaseLiteException::class)
    fun testConsoleLogging() {
        // tag::console-logging[]
        Database.log.getConsole().setDomain(LogDomain.ALL_DOMAINS) <i class="conum" data-value="3"></i><b>(3)</b>
        Database.log.getConsole().setLevel(LogLevel.VERBOSE) <i class="conum" data-value="4"></i><b>(4)</b>
        // end::console-logging[]
    }

    // ### File logging
    @Throws(CouchbaseLiteException::class)
    fun testFileLogging() {
        // tag::file-logging[]
        val path = context.cacheDir
        val LogCfg = LogFileConfiguration(path.toString()) <i class="conum" data-value="5"></i><b>(5)</b>
        LogCfg.setMaxSize(10240) <i class="conum" data-value="6"></i><b>(6)</b>
        LogCfg.setMaxRotateCount(5) <i class="conum" data-value="7"></i><b>(7)</b>
        LogCfg.setUsePlainText(false) <i class="conum" data-value="8"></i><b>(8)</b>
        Database.log.getFile().setConfig(LogCfg)
        Database.log.getFile().setLevel(LogLevel.INFO) <i class="conum" data-value="9"></i><b>(9)</b>
        // end::file-logging[]
    }

    fun writeConsoleLog() {
        // tag::write-console-logmsg[]
        Database.log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message")
        // end::write-console-logmsg[]
    }

    fun writeCustomLog() {
        // tag::write-custom-logmsg[]
        if (Database.log.Custom)
            Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message")
        // end::write-custom-logmsg[]
    }

    fun writeFileLog() {
        // tag::write-file-logmsg[]
        Database.log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message")
        // end::write-file-logmsg[]
    }

    // ### Loading a pre-built database
    @Throws(IOException::class)
    fun testPreBuiltDatabase() {
        // tag::prebuilt-database[]
        // Note: Getting the path to a database is platform-specific.
        // For Android you need to extract it from your
        // assets to a temporary directory and then pass that path to Database.copy()
        val configuration = DatabaseConfiguration()
        if (!Database.exists("travel-sample", context.filesDir)) {
            ZipUtils.unzip(getAsset("travel-sample.cblite2.zip"), context.filesDir)
            val path = File(context.filesDir, "travel-sample")
            try {
                Database.copy(path, "travel-sample", configuration)
            } catch (e: CouchbaseLiteException) {
                e.printStackTrace()
            }
        }
        // end::prebuilt-database[]
    }

    // helper methods
    // if db exist, delete it
    private fun deleteDB(name: String, dir: File) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            // sometimes, db is still in used, wait for a while. Maximum 3 sec
            for (i in 0..9) {
                try {
                    Database.delete(name, dir)
                    break
                } catch (ex: CouchbaseLiteException) {
                    try {
                        Thread.sleep(300)
                    } catch (ignore: InterruptedException) {
                    }
                }
            }
        }
    }

    // ### Initializers
    fun testInitializers() {
        // tag::initializer[]
        val newTask = MutableDocument()
        newTask.setString("type", "task")
        newTask.setString("owner", "todo")
        newTask.setDate("createdAt", Date())
        try {
            database.save(newTask)
        } catch (e: CouchbaseLiteException) {
            Log.e(TAG, e.toString())
        }
        // end::initializer[]
    }

    // ### Mutability
    fun testMutability() {
        try {
            database.save(MutableDocument("xyz"))
        } catch (ignore: CouchbaseLiteException) {
        }

        // tag::update-document[]
        val document: Document = database.getDocument("xyz")
        val mutableDocument: MutableDocument = document.toMutable()
        mutableDocument.setString("name", "apples")
        try {
            database.save(mutableDocument)
        } catch (e: CouchbaseLiteException) {
            Log.e(TAG, e.toString())
        }
        // end::update-document[]
    }

    // ### Typed Accessors
    fun testTypedAccessors() {
        val newTask = MutableDocument()

        // tag::date-getter[]
        newTask.setValue("createdAt", Date())
        val date: Date = newTask.getDate("createdAt")
        // end::date-getter[]
    }

    // ### Batch operations
    fun testBatchOperations() {
        // tag::batch[]
        try {
            database.inBatch({
                for (i in 0..9) {
                    val doc = MutableDocument()
                    doc.setValue("type", "user")
                    doc.setValue("name", "user $i")
                    doc.setBoolean("admin", false)
                    try {
                        database.save(doc)
                    } catch (e: CouchbaseLiteException) {
                        Log.e(TAG, e.toString())
                    }
                    Log.i(
                        TAG,
                        java.lang.String.format("saved user document %s", doc.getString("name"))
                    )
                }
            })
        } catch (e: CouchbaseLiteException) {
            Log.e(TAG, e.toString())
        }
        // end::batch[]
    }

    // ### Document Expiration
    @Throws(CouchbaseLiteException::class)
    fun DocumentExpiration() {
        // tag::document-expiration[]
        // Purge the document one day from now
        val ttl =
            Instant.now().plus(1, ChronoUnit.DAYS)
        database.setDocumentExpiration("doc123", Date(ttl.toEpochMilli()))

        // Reset expiration
        database.setDocumentExpiration("doc1", null)

        // Query documents that will be expired in less than five minutes
        val fiveMinutesFromNow =
            Instant.now().plus(5, ChronoUnit.MINUTES)
        val query: Query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.expiration.lessThan(Expression.doubleValue(fiveMinutesFromNow.toEpochMilli())))
        // end::document-expiration[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testDocumentChangeListener() {
        // tag::document-listener[]
        database.addDocumentChangeListener(
            "user.john",
            { change -&gt;
                val doc: Document = database.getDocument(change.getDocumentID())
                if (doc != null) {
                    Toast.makeText(
                        context,
                        "Status: " + doc.getString("verified_account"),
                        Toast.LENGTH_SHORT
                    ).show()
                }
            })
        // end::document-listener[]
    }

    // ### Blobs
    fun testBlobs() {
        val newTask = MutableDocument()

        // tag::blob[]
        val `is`: InputStream = getAsset("avatar.jpg") ?: return
        try {
            val blob = Blob("image/jpeg", `is`)
            newTask.setBlob("avatar", blob)
            database.save(newTask)
            val taskBlob: Blob = newTask.getBlob("avatar")
            val bytes: ByteArray = taskBlob.getContent()
        } catch (e: CouchbaseLiteException) {
            Log.e(TAG, e.toString())
        } finally {
            try {
                `is`.close()
            } catch (ignore: IOException) {
            }
        }
        // end::blob[]
    }

    // ### Indexing
    @Throws(CouchbaseLiteException::class)
    fun testIndexing() {
        // For Documentation
        run {
            // tag::query-index[]
            database.createIndex(
                "TypeNameIndex",
                IndexBuilder.valueIndex(
                    ValueIndexItem.property("type"),
                    ValueIndexItem.property("name")
                )
            )
            // end::query-index[]
        }
    }

    // ### SELECT statement
    fun testSelectStatement() {
        run {

            // tag::query-select-meta[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("type")
                )
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.expression(Meta.id))
            try {
                val rs: ResultSet = query.execute()
                for (result in rs) {
                    Log.i(
                        "Sample",
                        java.lang.String.format("hotel id -&gt; %s", result.getString("id"))
                    )
                    Log.i(
                        "Sample",
                        java.lang.String.format("hotel name -&gt; %s", result.getString("name"))
                    )
                }
            } catch (e: CouchbaseLiteException) {
                Log.e("Sample", e.getLocalizedMessage())
            }
        }
    }

    // META function
    @Throws(CouchbaseLiteException::class)
    fun testMetaFunction() {
        // For Documentation
        run {
            val query: Query = QueryBuilder
                .select(SelectResult.expression(Meta.id))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport")))
                .orderBy(Ordering.expression(Meta.id))
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.w(
                    "Sample",
                    java.lang.String.format("airport id -&gt; %s", result.getString("id"))
                )
                Log.w(
                    "Sample",
                    java.lang.String.format("airport id -&gt; %s", result.getString(0))
                )
            }
        }
    }

    // ### all(*)
    @Throws(CouchbaseLiteException::class)
    fun testSelectAll() {
        // For Documentation
        run {

            // tag::query-select-all[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
            // end::query-select-all[]

            // tag::live-query[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            val token: ListenerToken = query.addChangeListener({ change -&gt;
                for (result in change.getResults()) {
                    Log.d(TAG, "results: " + result.getKeys())
                    /* Update UI */
                }
            })

            // Start live query.
            query.execute() <i class="conum" data-value="1"></i><b>(1)</b>
            // end::live-query[]

            // tag::stop-live-query[]
            query.removeChangeListener(token)
            // end::stop-live-query[]
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format(
                        "hotel -&gt; %s",
                        result.getDictionary(DATABASE_NAME).toMap()
                    )
                )
            }
        }
    }

    // ###WHERE statement
    @Throws(CouchbaseLiteException::class)
    fun testWhereStatement() {
        // For Documentation
        run {

            // tag::query-where[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .limit(Expression.intValue(10))
            val rs: ResultSet = query.execute()
            for (result in rs) {
                val all: Dictionary = result.getDictionary(DATABASE_NAME)
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", all.getString("name"))
                )
                Log.i(
                    "Sample",
                    java.lang.String.format("type -&gt; %s", all.getString("type"))
                )
            }
            // end::query-where[]
        }
    }

    fun testQueryDeletedDocuments() {
        // tag::query-deleted-documents[]
        // Query documents that have been deleted
        val query: Where = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted)
        // end::query-deleted-documents[]
    }

    // ####Collection Operators
    @Throws(CouchbaseLiteException::class)
    fun testCollectionStatement() {
        // For Documentation
        run {

            // tag::query-collection-operator-contains[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("public_likes")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("hotel"))
                        .and(
                            ArrayFunction
                                .contains(
                                    Expression.property("public_likes"),
                                    Expression.string("Armani Langworth")
                                )
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format(
                        "public_likes -&gt; %s",
                        result.getArray("public_likes").toList()
                    )
                )
            }
            // end::query-collection-operator-contains[]
        }
    }

    // IN operator
    @Throws(CouchbaseLiteException::class)
    fun testInOperator() {
        // For Documentation
        run {

            // tag::query-collection-operator-in[]
            val values: Array&lt;Expression&gt; = arrayOf&lt;Expression&gt;(
                Expression.property("first"),
                Expression.property("last"),
                Expression.property("username")
            )
            val query: Query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.string("Armani").`in`(values))
            // end::query-collection-operator-in[]
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.w(
                    "Sample",
                    java.lang.String.format("%s", result.toMap().toString())
                )
            }
            // end::query-collection-operator-in[]
        }
    }

    // Pattern Matching
    @Throws(CouchbaseLiteException::class)
    fun testPatternMatching() {
        // For Documentation
        run {

            // tag::query-like-operator[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("landmark"))
                        .and(
                            Function.lower(Expression.property("name"))
                                .like(Function.Expression.string("royal engineers museum"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", result.getString("name"))
                )
            }
            // end::query-like-operator[]
        }
    }

    // ### Wildcard Match
    @Throws(CouchbaseLiteException::class)
    fun testWildcardMatch() {
        // For Documentation
        run {

            // tag::query-like-operator-wildcard-match[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("landmark"))
                        .and(
                            Function.lower(Expression.property("name"))
                                .like(Expression.string("eng%e%"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", result.getString("name"))
                )
            }
            // end::query-like-operator-wildcard-match[]
        }
    }

    // Wildcard Character Match
    @Throws(CouchbaseLiteException::class)
    fun testWildCharacterMatch() {
        // For Documentation
        run {

            // tag::query-like-operator-wildcard-character-match[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("landmark"))
                        .and(
                            Function.lower(Expression.property("name"))
                                .like(Expression.string("eng____r"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", result.getString("name"))
                )
            // end::query-like-operator-wildcard-character-match[]
            }
        }
    }

    // ### Regex Match
    @Throws(CouchbaseLiteException::class)
    fun testRegexMatch() {
        // For Documentation
        run {

            // tag::query-regex-operator[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("landmark"))
                        .and(
                            Function.lower(Expression.property("name"))
                                .regex(Expression.string("\\beng.*r\\b"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", result.getString("name"))
                )
            }
            // end::query-regex-operator[]
        }
    }

    // JOIN statement
    @Throws(CouchbaseLiteException::class)
    fun testJoinStatement() {
        // For Documentation
        run {

            // tag::query-join[]
            val query: Query = QueryBuilder.select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route"))
            )
                .from(DataSource.database(database).`as`("airline"))
                .join(
                    Join.join(DataSource.database(database).`as`("route"))
                        .on(
                            Meta.id.from("airline")
                                .equalTo(Expression.property("airlineid").from("route"))
                        )
                )
                .where(
                    Expression.property("type").from("route").equalTo(Expression.string("route"))
                        .and(
                            Expression.property("type").from("airline")
                                .equalTo(Expression.string("airline"))
                        )
                        .and(
                            Expression.property("sourceairport").from("route")
                                .equalTo(Expression.string("RIX"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.w(
                    "Sample",
                    java.lang.String.format("%s", result.toMap().toString())
                )
            }
            // end::query-join[]
        }
    }

    // ### GROUPBY statement
    @Throws(CouchbaseLiteException::class)
    fun testGroupByStatement() {
        // For Documentation
        run {

            // tag::query-groupby[]
            val query: Query = QueryBuilder.select(
                SelectResult.expression(Function.count(Expression.string("*"))),
                SelectResult.property("country"),
                SelectResult.property("tz")
            )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("airport"))
                        .and(
                            Expression.property("geo.alt")
                                .greaterThanOrEqualTo(Expression.intValue(300))
                        )
                )
                .groupBy(
                    Expression.property("country"),
                    Expression.property("tz")
                )
                .orderBy(Ordering.expression(Function.count(Expression.string("*"))).descending())
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format(
                        "There are %d airports on the %s timezone located in %s and above 300ft",
                        result.getInt("$1"),
                        result.getString("tz"),
                        result.getString("country")
                    )
                )
            }
            // end::query-groupby[]
        }
    }

    // ### ORDER BY statement
    @Throws(CouchbaseLiteException::class)
    fun testOrderByStatement() {
        // For Documentation
        run {

            // tag::query-orderby[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.property("name").ascending())
                .limit(Expression.intValue(10))
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i("Sample", java.lang.String.format("%s", result.toMap()))
            }
            // end::query-orderby[]
        }
    }

    // ### EXPLAIN statement
    @Throws(CouchbaseLiteException::class)
    fun testExplainStatement() {
        // For Documentation
        run {

            // tag::query-explain-all[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("university")))
                .groupBy(Expression.property("country"))
                .orderBy(Ordering.property("name").descending()) <i class="conum" data-value="10"></i><b>(10)</b>
            Log.i(query.explain()) <i class="conum" data-value="11"></i><b>(11)</b>
            // end::query-explain-all[]
            // tag::query-explain-like[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("%hotel%"))) <i class="conum" data-value="12"></i><b>(12)</b>
            Log.i(query.explain())
            // end::query-explain-like[]
            // tag::query-explain-nopfx[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="13"></i><b>(13)</b>
                        .and(Expression.property("name").like(Expression.string("%royal%")))
                )
            Log.i(query.explain())
            // end::query-explain-nopfx[]
            // tag::query-explain-function[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(
                    Function.lower(
                        Expression.property("type").equalTo(Expression.string("hotel"))
                    )
                ) <i class="conum" data-value="14"></i><b>(14)</b>
            Log.i(query.explain())
            // end::query-explain-function[]
            // tag::query-explain-nofunction[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))) <i class="conum" data-value="15"></i><b>(15)</b>
            Log.i(query.explain())
            // end::query-explain-nofunction[]
        }
    } // end query-explain
    // end::query-explain[]
    @Throws(CouchbaseLiteException::class)
    fun prepareIndex() {
        // tag::fts-index[]
        database.createIndex(
            "nameFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("name")).ignoreAccents(false)
        )
        // end::fts-index[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS() {
        // tag::fts-query[]
        val whereClause: Expression = FullTextExpression.index("nameFTSIndex").match("buy")
        val ftsQuery: Query = QueryBuilder.select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause)
        val ftsQueryResult: ResultSet = ftsQuery.execute()
        for (result in ftsQueryResult) {
            Log.i(
                TAG,
                java.lang.String.format("document properties %s", result.getString(0))
            )
        }
        // end::fts-query[]
    }

    /* The `tag::replication[]` example is inlined in java.adoc */
    fun testTroubleshooting() {
        // tag::replication-logging[]
        Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE)
        // end::replication-logging[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationBasicAuthentication() {
        // tag::basic-authentication[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setAuthenticator(BasicAuthenticator("username", "password"))

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()
        // end::basic-authentication[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationSessionAuthentication() {
        // tag::session-authentication[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setAuthenticator(SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447"))

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()
        // end::session-authentication[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationStatus() {
        val uri = URI("ws://localhost:4984/db")
        val endpoint: Endpoint = URLEndpoint(uri)
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)

        // tag::replication-status[]
        replicator.addChangeListener({ change -&gt;
            if (change.getStatus().getActivityLevel() === Replicator.ActivityLevel.STOPPED) {
                Log.i(TAG, "Replication stopped")
            }
        })
        // end::replication-status[]
    }

    internal inner class PendingDocsExample {
        private val database: Database? = null
        private var replicator: Replicator? = null

        //  BEGIN PendingDocuments IB -- 11/Feb/21 --
        @Throws(URISyntaxException::class, CouchbaseLiteException::class)
        fun testReplicationPendingDocs() {
            // nottag::replication-pendingdocuments[]
            // ... include other code as required
            //
            val endpoint: Endpoint = URLEndpoint(URI("ws://localhost:4984/db"))
            val config: ReplicatorConfiguration = ReplicatorConfiguration(database, endpoint)
                .setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH)
            // tag::replication-push-pendingdocumentids[]
            replicator = Replicator(config)
            val pendingDocs: Set&lt;String&gt; = replicator.getPendingDocumentIds() <i class="conum" data-value="16"></i><b>(16)</b>

            // end::replication-push-pendingdocumentids[]
            replicator.addChangeListener({ change -&gt;
                onStatusChanged(
                    pendingDocs,
                    change.getStatus()
                )
            })
            replicator.start()

            // ... include other code as required
            // notend::replication-pendingdocuments[]
        }

        //
        // tag::replication-pendingdocuments[]
        //
        private fun onStatusChanged(
            @NonNull pendingDocs: Set&lt;String&gt;,
            @NonNull status: Replicator.Status
        ) {
            // ... sample onStatusChanged function
            //
            Log.i(
                Companion.TAG,
                "Replicator activity level is " + status.getActivityLevel().toString()
            )

            // iterate and report-on previously
            // retrieved pending docids 'list'
            val itr = pendingDocs.iterator()
            while (itr.hasNext()) {
                val docId = itr.next()
                try {
                    // tag::replication-push-isdocumentpending[]
                    if (!replicator.isDocumentPending(docId)) {
                        continue
                    } <i class="conum" data-value="17"></i><b>(17)</b>
                    // end::replication-push-isdocumentpending[]
                    itr.remove()
                    Log.i(
                        Companion.TAG,
                        "Doc ID $docId has been pushed"
                    )
                } catch (e: CouchbaseLiteException) {
                    Log.w(
                        Companion.TAG,
                        "isDocumentPending failed",
                        e
                    )
                }
            }
        } // end::replication-pendingdocuments[]

        //  END PendingDocuments BM -- 19/Feb/21 --
        companion object {
            private const val TAG = "SCRATCH"
        }
    }

    @Throws(URISyntaxException::class)
    fun testHandlingNetworkErrors() {
        val endpoint: Endpoint = URLEndpoint(URI("ws://localhost:4984/db"))
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)

        // tag::replication-error-handling[]
        replicator.addChangeListener({ change -&gt;
            val error: CouchbaseLiteException = change.getStatus().getError()
            if (error != null) {
                Log.w(TAG, "Error code:: %d", error)
            }
        })
        replicator.start()
        // end::replication-error-handling[]
        replicator.stop()
    }

    @Throws(URISyntaxException::class)
    fun testReplicatorDocumentEvent() {
        val endpoint: Endpoint = URLEndpoint(URI("ws://localhost:4984/db"))
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)

        // tag::add-document-replication-listener[]
        val token: ListenerToken = replicator.addDocumentReplicationListener({ replication -&gt;
            if (replication.isPush()) Log.i(
                TAG,
                "Replication type: " + "Push"
            ) else Log.i(TAG, "Replication type: " + "Pull")
            for (document in replication.getDocuments()) {
                Log.i(TAG, "Doc ID: " + document.getID())
                val err: CouchbaseLiteException = document.getError()
                if (err != null) {
                    // There was an error
                    Log.e(TAG, "Error replicating document: ", err)
                    return@addDocumentReplicationListener
                }
                if (document.flags().contains(DocumentFlag.DocumentFlagsDeleted)) {
                    Log.i(
                        TAG,
                        "Successfully replicated a deleted document"
                    )
                }
            }
        })
        replicator.start()
        // end::add-document-replication-listener[]

        // tag::remove-document-replication-listener[]
        replicator.removeChangeListener(token)
        // end::remove-document-replication-listener[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationCustomHeader() {
        val uri = URI("ws://localhost:4984/db")
        val endpoint: Endpoint = URLEndpoint(uri)

        // tag::replication-custom-header[]
        val config = ReplicatorConfiguration(database, endpoint)
        val headers: MutableMap&lt;String, String&gt; =
            HashMap()
        headers["CustomHeaderName"] = "Value"
        config.setHeaders(headers)
        // end::replication-custom-header[]
    }

    // ### Certificate Pinning
    @Throws(URISyntaxException::class, IOException::class)
    fun testCertificatePinning() {
        val uri = URI("ws://localhost:4984/db")
        val endpoint: Endpoint = URLEndpoint(uri)
        val config = ReplicatorConfiguration(database, endpoint)

        // tag::certificate-pinning[]
        val `is`: InputStream = getAsset("cert.cer")
        val cert: ByteArray = IOUtils.toByteArray(`is`)
        if (`is` != null) {
            try {
                `is`.close()
            } catch (ignore: IOException) {
            }
        }
        config.setPinnedServerCertificate(cert)
        // end::certificate-pinning[]
    }

    // ### Reset replicator checkpoint
    @Throws(URISyntaxException::class)
    fun testReplicationResetCheckpoint() {
        val uri = URI("ws://localhost:4984/db")
        val endpoint: Endpoint = URLEndpoint(uri)
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()

        // tag::replication-reset-checkpoint[]
        replicator.resetCheckpoint()
        replicator.start()
        // end::replication-reset-checkpoint[]
        replicator.stop()
    }

    @Throws(URISyntaxException::class)
    fun testReplicationPushFilter() {
        // tag::replication-push-filter[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setPushFilter({ document, flags -&gt; flags.contains(DocumentFlag.DocumentFlagsDeleted) }) <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()
        // end::replication-push-filter[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationPullFilter() {
        // tag::replication-pull-filter[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setPullFilter({ document, flags -&gt; "draft" == document.getString("type") }) <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()
        // end::replication-pull-filter[]
    }

    @Throws(URISyntaxException::class)
    fun testCustomRetryConfig() {
        // tag::replication-retry-config[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)

        //  other config as required . . .
        // tag::replication-heartbeat-config[]
        config.setHeartbeat(150L) <i class="conum" data-value="18"></i><b>(18)</b>
        // end::replication-heartbeat-config[]
        // tag::replication-maxretries-config[]
        config.setMaxRetries(20L) <i class="conum" data-value="19"></i><b>(19)</b>
        // end::replication-maxretries-config[]
        // tag::replication-maxretrywaittime-config[]
        config.setMaxRetryWaitTime(600L) <i class="conum" data-value="20"></i><b>(20)</b>
        // end::replication-maxretrywaittime-config[]
        val repl = Replicator(config)

        // end::replication-retry-config[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testDatabaseReplica() {
        var config: DatabaseConfiguration? = DatabaseConfiguration()
        val database1 = Database("mydb", config)
        config = DatabaseConfiguration()
        val database2 = Database("db2", config)

        /* EE feature: code below might throw a compilation error
           if it's compiled against CBL Android Community. */
        // tag::database-replica[]
        val targetDatabase = DatabaseEndpoint(database2)
        val replicatorConfig =
            ReplicatorConfiguration(database1, targetDatabase)
        replicatorConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH)

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(replicatorConfig)
        replicator.start()
        // end::database-replica[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveModel() {
        val config = DatabaseConfiguration()
        val database = Database("mydb", config)

        // tag::register-model[]
        Database.prediction.registerModel("ImageClassifier", ImageClassifierModel())
        // end::register-model[]

        // tag::predictive-query-value-index[]
        val index: ValueIndex =
            IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")))
        database.createIndex("value-index-image-classifier", index)
        // end::predictive-query-value-index[]

        // tag::unregister-model[]
        Database.prediction.unregisterModel("ImageClassifier")
        // end::unregister-model[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveIndex() {
        val config = DatabaseConfiguration()
        val database = Database("mydb", config)

        // tag::predictive-query-predictive-index[]
        val inputMap: MutableMap&lt;String, Any&gt; =
            HashMap()
        inputMap["numbers"] = Expression.property("photo")
        val input: Expression = Expression.map(inputMap)
        val index: PredictiveIndex = IndexBuilder.predictiveIndex("ImageClassifier", input, null)
        database.createIndex("predictive-index-image-classifier", index)
        // end::predictive-query-predictive-index[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveQuery() {
        val config = DatabaseConfiguration()
        val database = Database("mydb", config)

        // tag::predictive-query[]
        val inputProperties: MutableMap&lt;String, Any&gt; =
            HashMap()
        inputProperties["photo"] = Expression.property("photo")
        val input: Expression = Expression.map(inputProperties)
        val prediction: PredictionFunction =
            PredictiveModel.predict("ImageClassifier", input) <i class="conum" data-value="1"></i><b>(1)</b>
        val query: Query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("label").equalTo(Expression.string("car"))
                    .and(
                        Expression.property("probability")
                            .greaterThanOrEqualTo(Expression.doubleValue(0.8))
                    )
            )

        // Run the query.
        val result: ResultSet = query.execute()
        Log.d(TAG, "Number of rows: " + result.allResults().size())
        // end::predictive-query[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationWithCustomConflictResolver() {
        // tag::replication-conflict-resolver[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setConflictResolver(LocalWinConflictResolver())
        val replication = Replicator(config)
        replication.start()
        // end::replication-conflict-resolver[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testSaveWithCustomConflictResolver() {
        // tag::update-document-with-conflict-handler[]
        val doc: Document = database.getDocument("xyz") ?: return
        val mutableDocument: MutableDocument = doc.toMutable()
        mutableDocument.setString("name", "apples")
        database.save(
            mutableDocument,
            { newDoc, curDoc -&gt;  <i class="conum" data-value="21"></i><b>(21)</b>
                if (curDoc == null) {
                    return@save false
                } <i class="conum" data-value="22"></i><b>(22)</b>
                val dataMap: MutableMap&lt;String, Any&gt; =
                    curDoc.toMap()
                dataMap.putAll(newDoc.toMap()) <i class="conum" data-value="23"></i><b>(23)</b>
                newDoc.setData(dataMap)
                true <i class="conum" data-value="24"></i><b>(24)</b>
            }) <i class="conum" data-value="25"></i><b>(25)</b>
        // end::update-document-with-conflict-handler[]
    }

    companion object {
        private const val TAG = "EXAMPLE"
        private const val DATABASE_NAME = "database"
    }

}

// tag::update-document-with-conflict-handler-callouts[]

&lt;.&gt; The conflict handler code is provided as a lambda.

&lt;.&gt; If the handler cannot resolve a conflict, it can return false.
In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.

&lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.

&lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).

&lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method
// end::update-document-with-conflict-handler-callouts[]


// tag::local-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
internal class LocalWinConflictResolver : ConflictResolver {
    fun resolve(conflict: Conflict): Document {
        return conflict.getLocalDocument()
    }
} // end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
internal class RemoteWinConflictResolver : ConflictResolver {
    fun resolve(conflict: Conflict): Document {
        return conflict.getRemoteDocument()
    }
} // end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
// Using replConfig.setConflictResolver(new MergeConflictResolver());
internal class MergeConflictResolver : ConflictResolver {
    fun resolve(conflict: Conflict): Document {
        val merge: MutableMap&lt;String, Any&gt; =
            conflict.getLocalDocument().toMap()
        merge.putAll(conflict.getRemoteDocument().toMap())
        return MutableDocument(conflict.getDocumentId(), merge)
    }
} // end::merge-conflict-resolver[]

/* ----------------------------------------------------------- */ /* ---------------------  ACTIVE SIDE  ----------------------- */ /* ----------------------------------------------------------- */
internal class BrowserSessionManager private constructor(private val context: Context) :
    MessageEndpointDelegate {
    private var replicator: Replicator? = null

    @Throws(CouchbaseLiteException::class)
    fun initCouchbase() {
        // tag::message-endpoint[]
        val databaseConfiguration = DatabaseConfiguration(context)
        val database = Database("mydb", databaseConfiguration)

        // The delegate must implement the `MessageEndpointDelegate` protocol.
        val messageEndpointTarget = MessageEndpoint(
            "UID:123",
            "active",
            ProtocolType.MESSAGE_STREAM,
            this
        )
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        val config =
            ReplicatorConfiguration(database, messageEndpointTarget)

        // Create the replicator object.
        replicator = Replicator(config)
        // Start the replication.
        replicator.start()
        // end::message-endpoint-replicator[]
    }

    // tag::create-connection[]
    /* implementation of MessageEndpointDelegate */
    @NonNull
    fun createConnection(@NonNull endpoint: MessageEndpoint?): MessageEndpointConnection {
        return ActivePeerConnection() /* implements MessageEndpointConnection */
    } // end::create-connection[]

}

internal class ActivePeerConnection : MessageEndpointConnection {
    private var replicatorConnection: ReplicatorConnection? = null
    fun disconnect() {
        // tag::active-replicator-close[]
        replicatorConnection.close(null)
        // end::active-replicator-close[]
    }

    // tag::active-peer-open[]
    /* implementation of MessageEndpointConnection */
    fun open(
        @NonNull connection: ReplicatorConnection?,
        @NonNull completion: MessagingCompletion
    ) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    // end::active-peer-open[]
    // tag::active-peer-close[]
    fun close(
        error: Exception?,
        @NonNull completion: MessagingCloseCompletion
    ) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete()
    }

    // end::active-peer-close[]
    // tag::active-peer-send[]
    /* implementation of MessageEndpointConnection */
    fun send(@NonNull message: Message?, @NonNull completion: MessagingCompletion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null)
    }

    // end::active-peer-send[]
    fun receive(message: Message?) {
        // tag::active-peer-receive[]
        replicatorConnection.receive(message)
        // end::active-peer-receive[]
    }
} /* ----------------------------------------------------------- */ /* ---------------------  PASSIVE SIDE  ---------------------- */ /* ----------------------------------------------------------- */

internal class PassivePeerConnection private constructor(private val context: Context) :
    MessageEndpointConnection {
    private var messageEndpointListener: MessageEndpointListener? = null
    private var replicatorConnection: ReplicatorConnection? = null

    @Throws(CouchbaseLiteException::class)
    fun startListener() {
        // tag::listener[]
        val databaseConfiguration = DatabaseConfiguration()
        val database = Database("mydb", databaseConfiguration)
        val listenerConfiguration =
            MessageEndpointListenerConfiguration(
                database,
                ProtocolType.MESSAGE_STREAM
            )
        messageEndpointListener = MessageEndpointListener(listenerConfiguration)
        // end::listener[]
    }

    fun stopListener() {
        // tag::passive-stop-listener[]
        messageEndpointListener.closeAll()
        // end::passive-stop-listener[]
    }

    fun accept() {
        // tag::advertizer-accept[]
        val connection = PassivePeerConnection(context) /* implements
        MessageEndpointConnection */
        messageEndpointListener.accept(connection)
        // end::advertizer-accept[]
    }

    fun disconnect() {
        // tag::passive-replicator-close[]
        replicatorConnection.close(null)
        // end::passive-replicator-close[]
    }

    // tag::passive-peer-open[]
    /* implementation of MessageEndpointConnection */
    fun open(
        @NonNull connection: ReplicatorConnection?,
        @NonNull completion: MessagingCompletion
    ) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    // end::passive-peer-open[]
    // tag::passive-peer-close[]
    /* implementation of MessageEndpointConnection */
    fun close(
        error: Exception?,
        @NonNull completion: MessagingCloseCompletion
    ) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete()
    }

    // end::passive-peer-close[]
    // tag::passive-peer-send[]
    /* implementation of MessageEndpointConnection */
    fun send(@NonNull message: Message?, @NonNull completion: MessagingCompletion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null)
    }

    // end::passive-peer-send[]
    fun receive(message: Message?) {
        // tag::passive-peer-receive[]
        replicatorConnection.receive(message)
        // end::passive-peer-receive[]
    }

} // tag::predictive-model[]

// `tensorFlowModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
internal class ImageClassifierModel : PredictiveModel {
    fun predict(@NonNull input: Dictionary): Dictionary? {
        val blob: Blob = input.getBlob("photo") ?: return null

        // `tensorFlowModel` is a fake implementation
        // this would be the implementation of the ml model you have chosen
        return MutableDictionary(TensorFlowModel.predictImage(blob.getContent())) <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

internal object TensorFlowModel {
    fun predictImage(data: ByteArray?): Map&lt;String, Any&gt;? {
        return null
    }
} // end::predictive-model[]

// tag::custom-logging[]
internal class LogTestLogger(@NonNull level: LogLevel) : Logger {
    @NonNull
    private val level: LogLevel

    @NonNull
    fun getLevel(): LogLevel {
        return level
    }

    fun log(
        @NonNull level: LogLevel?,
        @NonNull domain: LogDomain?,
        @NonNull message: String?
    ) {
        // this method will never be called if param level &lt; this.level
        // handle the message, for example piping it to a third party framework
    }

    init {
        this.level = level
    }
}

class CertAuthListener {
    companion object {
        private const val TAG = "PWD"
        private var CERT_ATTRIBUTES: Map&lt;String, String&gt;? = null

        init {
            val m: Map&lt;String, String&gt; =
                HashMap()
            com.couchbase.code_snippets.m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test")
            com.couchbase.code_snippets.m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase")
            com.couchbase.code_snippets.m.put(
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT,
                "Mobile"
            )
            com.couchbase.code_snippets.m.put(
                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS,
                "lite@couchbase.com"
            )
            CERT_ATTRIBUTES =
                Collections.unmodifiableMap(com.couchbase.code_snippets.m)
        }
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val serverIdentity: TLSIdentity = TLSIdentity.createIdentity(
            true,
            CERT_ATTRIBUTES,
            null,
            "server"
        )
        val clientIdentity: TLSIdentity = TLSIdentity.createIdentity(
            false,
            CERT_ATTRIBUTES,
            null,
            "client"
        )
        val uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts())
            ?: throw IOException("Failed to start the server")
        Thread(Runnable {
            try {
                startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb)
                Log.e(TAG, "Success!!")
                deleteIdentity("server")
                Log.e(TAG, "Alias deleted: server")
                deleteIdentity("client")
                Log.e(TAG, "Alias deleted: client")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }).start()
    }

    // start a client replicator
    @Throws(CertificateEncodingException::class, InterruptedException::class)
    fun startClient(
        @NonNull uri: URI?,
        @NonNull cert: Certificate,
        @NonNull clientIdentity: TLSIdentity,
        @NonNull db: Database?
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL)
        config.setContinuous(false)
        configureClientCerts(config, cert, clientIdentity)
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)
        repl.addChangeListener({ change -&gt;
            if (change.getStatus()
                    .getActivityLevel() === AbstractReplicator.ActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        })
        repl.start(false)
        completionLatch.await()
    }
    // tag::listener-config-auth-cert-full[]
    /**
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     *
     *
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    @Throws(CouchbaseLiteException::class)
    fun startServer(
        @NonNull db: Database?,
        @NonNull serverId: TLSIdentity?,
        @NonNull certs: List&lt;Certificate?&gt;?
    ): URI? {
        val config = URLEndpointListenerConfiguration(db)
        config.setPort(0) // this is the default
        config.setDisableTls(false)
        config.setTlsIdentity(serverId)
        config.setAuthenticator(ListenerCertificateAuthenticator(certs))
        val listener = URLEndpointListener(config)
        listener.start()
        val urls: List&lt;URI&gt; = listener.getUrls()
        return if (urls.isEmpty()) {
            null
        } else urls[0]
    }
    // end::listener-config-auth-cert-full[]
    // tag::listener-config-delete-cert-full[]
    /**
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    @Throws(
        KeyStoreException::class,
        CertificateException::class,
        NoSuchAlgorithmException::class,
        IOException::class
    )
    fun deleteIdentity(alias: String?) {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        keyStore.deleteEntry(alias) <i class="conum" data-value="26"></i><b>(26)</b>
    }
    // end::listener-config-delete-cert-full[]
    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /**
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     *
     *
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    @Throws(CertificateEncodingException::class)
    private fun configureClientCerts(
        config: ReplicatorConfiguration,
        @NonNull cert: Certificate,
        @NonNull clientIdentity: TLSIdentity
    ) {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(ClientCertificateAuthenticator(clientIdentity))

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded())
    }
    // notend::p2p-tlsid-tlsidentity-with-label[]
    /**
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     *
     *
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    @Throws(IOException::class)
    private fun readCertMaterialFromBundle(
        @NonNull context: Context,
        resId: Int
    ): ByteArray {
        val out = ByteArrayOutputStream()
        val `in` = context.resources.openRawResource(resId)
        val buf = ByteArray(1024)
        var n: Int
        while (`in`.read(buf).also { n = it } &gt;= 0) {
            out.write(buf, 0, n)
        }
        return out.toByteArray()
    }
}

class PasswordAuthListener {
    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray())
            ?: throw IOException("Failed to start the server")
        Thread(Runnable {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb)
                Log.e(TAG, "Success!!")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }).start()
    }

    // start a client replicator
    @Throws(InterruptedException::class)
    fun runClient(
        @NonNull uri: URI?,
        @NonNull username: String?,
        @NonNull password: CharArray?,
        @NonNull db: Database?
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL)
        config.setContinuous(false)
        config.setAuthenticator(BasicAuthenticator(username, password))
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)
        repl.addChangeListener({ change -&gt;
            if (change.getStatus()
                    .getActivityLevel() === AbstractReplicator.ActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        })
        repl.start(false)
        completionLatch.await()
    }
    // tag::listener-config-client-auth-pwd-full[]
    /**
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     *
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    fun startServer(
        @NonNull db: Database?,
        @NonNull username: String?,
        @NonNull password: CharArray?
    ): URI?

    companion object {
        private const val TAG = "PWD"
    }

    init {
        val config = URLEndpointListenerConfiguration(db)
        config.setPort(0) // this is the default
        config.setDisableTls(true)
        config.setAuthenticator(
            ListenerPasswordAuthenticator { validUser, pwd -&gt;
                username.equals(validUser) &amp;&amp; Arrays.equals(
                    validPassword,
                    pwd
                )
            }
        )
        val listener = URLEndpointListener(config)
        listener.start()
        val urls: List&lt;URI&gt; = listener.getUrls()
        return if (urls.isEmpty()) {
            null
        } else urls[0]
    }
    // end::listener-config-client-auth-pwd-full[]
}


class ExamplesP2p(private val context: Context) {
    private val database: Database? = null
    private var replicator: Replicator? = null

    //@Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {

        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        /* do some stuff here */
    }

    // PASSIVE PEER STUFF
    fun ibListenerSimple() {
        // tag::listener-simple[]
        val thisConfig =
            URLEndpointListenerConfiguration(thisDB) <i class="conum" data-value="27"></i><b>(27)</b>
        thisConfig.setAuthenticator(
            ListenerPasswordAuthenticator { username, password -&gt;
                username.equals("valid.User") &amp;&amp;
                        Arrays.equals(password, valid.password.string)
            }
        ) <i class="conum" data-value="28"></i><b>(28)</b>
        val thisListener = URLEndpointListener(thisConfig) <i class="conum" data-value="29"></i><b>(29)</b>
        thisListener.start() <i class="conum" data-value="30"></i><b>(30)</b>

        // end::listener-simple[]
    }

    fun ibReplicatorSimple() {
        // tag::replicator-simple[]
        var uri: URI? = null
        try {
            uri = URI("wss://10.0.2.2:4984/db")
        } catch (e: URISyntaxException) {
            e.printStackTrace()
        }
        val theListenerEndpoint: Endpoint = URLEndpoint(uri) <i class="conum" data-value="31"></i><b>(31)</b>
        val thisConfig =
            ReplicatorConfiguration(database, theListenerEndpoint) <i class="conum" data-value="32"></i><b>(32)</b>
        thisConfig.setAcceptOnlySelfSignedServerCertificate(true) <i class="conum" data-value="33"></i><b>(33)</b>
        val thisAuth = BasicAuthenticator(
            "valid.user",
            "valid.password.string"
        )
        thisConfig.setAuthenticator(thisAuth) <i class="conum" data-value="34"></i><b>(34)</b>
        replicator = Replicator(config) <i class="conum" data-value="35"></i><b>(35)</b>
        replicator.start() <i class="conum" data-value="36"></i><b>(36)</b>

        // end::replicator-simple[]
    }

    fun ibPassListener() {
// EXAMPLE 1
        // tag::listener-initialize[]
        // tag::listener-config-db[]
        // Initialize the listener config
        val thisConfig =
            URLEndpointListenerConfiguration(thisDB) <i class="conum" data-value="37"></i><b>(37)</b>

        // end::listener-config-db[]
        // tag::listener-config-port[]
        thisConfig.setPort(55990) <i class="conum" data-value="38"></i><b>(38)</b>

        // end::listener-config-port[]
        // tag::listener-config-netw-iface[]
        thisConfig.setNetworkInterface("10.1.1.10") <i class="conum" data-value="39"></i><b>(39)</b>

        // end::listener-config-netw-iface[]
        // tag::listener-config-delta-sync[]
        thisConfig.setEnableDeltaSync(false) <i class="conum" data-value="40"></i><b>(40)</b>

        // end::listener-config-delta-sync[]
        // tag::listener-config-tls-full[]
        // Configure server security
        // tag::listener-config-tls-enable[]
        thisConfig.setDisableTls(false) <i class="conum" data-value="41"></i><b>(41)</b>

        // end::listener-config-tls-enable[]
        // tag::listener-config-tls-id-anon[]
        // Use an Anonymous Self-Signed Cert
        thisConfig.setTlsIdentity(null) <i class="conum" data-value="42"></i><b>(42)</b>

        // end::listener-config-tls-id-anon[]

        // tag::listener-config-client-auth-pwd[]
        // Configure Client Security using an Authenticator
        // For example, Basic Authentication <i class="conum" data-value="43"></i><b>(43)</b>
        thisConfig.setAuthenticator(
            ListenerPasswordAuthenticator { validUser, validPassword -&gt;
                username.equals(validUser) &amp;&amp;
                        Arrays.equals(password, validPassword)
            }
        )

        // end::listener-config-client-auth-pwd[]
        // tag::listener-start[]
        // Initialize the listener
        val thisListener = URLEndpointListener(thisConfig) <i class="conum" data-value="44"></i><b>(44)</b>

        // Start the listener
        thisListener.start() <i class="conum" data-value="45"></i><b>(45)</b>

        // end::listener-start[]
        // end::listener-initialize[]
    }

    fun ibListenerGetNetworkInterfaces() {
        // tag::listener-get-network-interfaces[]
        val thisConfig =
            URLEndpointListenerConfiguration(database)
        val thisListener = URLEndpointListener(thisConfig)
        thisListener.start()
        Log.i(
            TAG,
            "URLS are " + thisListener.getUrls()
        )

        // end::listener-get-network-interfaces[]
    }

    fun ibListenerLocalDb() {
        // tag::listener-local-db[]
        // . . . preceding application logic . . .
        CouchbaseLite.init(context) <i class="conum" data-value="46"></i><b>(46)</b>
        val thisDB = Database("passivepeerdb")

        // end::listener-local-db[]
    }

    fun ibListenerConfigTlsDisable() {
        // tag::listener-config-tls-disable[]
        thisConfig.setDisableTls(true) <i class="conum" data-value="47"></i><b>(47)</b>

        // end::listener-config-tls-disable[]
    }

    fun ibListenerConfigTlsIdFull() {
        // tag::listener-config-tls-id-full[]
        // tag::listener-config-tls-id-caCert[]
        // Use CA Cert
        // Import a key pair into secure storage
        // Create a TLSIdentity from the imported key-pair
        val thisKeyPair: InputStream = FileInputStream()
        thisKeyPair.javaClass.getResourceAsStream("serverkeypair.p12") <i class="conum" data-value="48"></i><b>(48)</b>
        val thisIdentity: TLSIdentity = importIdentity(
            EXTERNAL_KEY_STORE_TYPE,  // KeyStore type, eg: "PKCS12"
            thisKeyPair,  // An InputStream from the keystore
            password,  // The keystore password
            EXTERNAL_KEY_ALIAS,  // The alias to be used (in external keystore)
            null,  // The key password
            "test-alias" // The alias for the imported key
        )

        // end::listener-config-tls-id-caCert[]

        // tag::listener-config-tls-id-set[]
        // Set the TLS Identity
        thisConfig.setTlsIdentity(thisIdentity) <i class="conum" data-value="49"></i><b>(49)</b>

        // end::listener-config-tls-id-set[]
// end::listener-config-tls-id-full[]
    }

    fun ibListenerConfigClientAuthRoot() {
// tag::listener-config-client-root-ca[]
        // tag::listener-config-client-auth-root[]
        // Configure the client authenticator
        // to validate using ROOT CA
        // thisClientID.certs is a list containing a client cert to accept
        // and any other certs needed to complete a chain between the client cert
        // and a CA
        val validId: TLSIdentity =
            TLSIdentity.getIdentity("Our Corporate Id")
                ?: throw IllegalStateException("Cannot find corporate id") // get the identity <i class="conum" data-value="50"></i><b>(50)</b>
        thisConfig.setTlsIdentity(validId)
        thisConfig.setAuthenticator(
            ListenerCertificateAuthenticator(validId.getCerts())
        ) <i class="conum" data-value="51"></i><b>(51)</b>
        // accept only clients signed by the corp cert
        val thisListener = URLEndpointListener(thisConfig)

        // end::listener-config-client-auth-root[]
// end::listener-config-client-root-ca[]
    }

    fun ibListenerConfigTlsDisable() {

        // tag::listener-config-tls-disable[]
        thisConfig.disableTLS(true)

        // end::listener-config-tls-disable[]
    }

    fun ibListenerStatusCheck() {
        // tag::listener-status-check[]
        val connectionCount: Int = thisListener.getStatus().getConnectionCount() <i class="conum" data-value="52"></i><b>(52)</b>
        val activeConnectionCount: Int =
            thisListener.getStatus().getActiveConnectionCount() <i class="conum" data-value="53"></i><b>(53)</b>

        // end::listener-status-check[]
    }

    fun ibListenerStop() {

        // tag::listener-stop[]
        thisListener.stop()

        // end::listener-stop[]
    }

    // ACTIVE PEER STUFF
    // Replication code
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testActPeerSync() {
        // tag::p2p-act-rep-func[]
        // tag::p2p-act-rep-initialize[]
        // initialize the replicator configuration
        val thisConfig = ReplicatorConfiguration(
            thisDB,
            URLEndpoint(URI("wss://listener.com:8954"))
        ) <i class="conum" data-value="54"></i><b>(54)</b>

        // end::p2p-act-rep-initialize[]
        // tag::p2p-act-rep-config-type[]
        // Set replicator type
        thisConfig.setReplicatorType(
            ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL
        )

        // end::p2p-act-rep-config-type[]
        // tag::p2p-act-rep-config-cont[]
        // Configure Sync Mode
        thisConfig.setContinuous(false) // default value

        // end::p2p-act-rep-config-cont[]
        // tag::p2p-act-rep-config-self-cert[]
        // Configure Server Authentication --
        // only accept self-signed certs
        thisConfig.setAcceptOnlySelfSignedServerCertificate(true) <i class="conum" data-value="55"></i><b>(55)</b>

        // end::p2p-act-rep-config-self-cert[]
        // tag::p2p-act-rep-auth[]
        // Configure the credentials the
        // client will provide if prompted
        val thisAuth: BasicAuthenticator <i class="conum" data-value="56"></i><b>(56)</b>
        thisAuth = BasicAuthenticator("Our Username", "Our PasswordValue")
        thisConfig.setAuthenticator(thisAuth)

        // end::p2p-act-rep-auth[]
        // tag::p2p-act-rep-config-conflict[]
        /* Optionally set custom conflict resolver call back */thisConfig.setConflictResolver() <i class="conum" data-value="57"></i><b>(57)</b>

        // end::p2p-act-rep-config-conflict[]
        // tag::p2p-act-rep-start-full[]
        // Create replicator
        // Consider holding a reference somewhere
        // to prevent the Replicator from being GCed
        val thisReplicator = Replicator(thisConfig) <i class="conum" data-value="58"></i><b>(58)</b>

        // tag::p2p-act-rep-add-change-listener[]
        // tag::p2p-act-rep-add-change-listener-label[]
        // Optionally add a change listener <i class="conum" data-value="59"></i><b>(59)</b>
        // end::p2p-act-rep-add-change-listener-label[]
        val thisListener: ListenerToken = addChangeListener { change -&gt;
            val err: CouchbaseLiteException = change.getStatus().getError()
            if (err != null) {
                Log.i(
                    TAG,
                    "Error code ::  " + err.getCode(),
                    e
                )
            }
        }

        // end::p2p-act-rep-add-change-listener[]
        // tag::p2p-act-rep-start[]
        // Start replicator
        thisReplicator.start(false) <i class="conum" data-value="60"></i><b>(60)</b>

        // end::p2p-act-rep-start[]
        // end::p2p-act-rep-start-full[]
        // end::p2p-act-rep-func[]         ***** End p2p-act-rep-func
    }

    fun ibReplicatorConfig() {
        // BEGIN additional snippets
        // tag::p2p-act-rep-config-tls-full[]
        // tag::p2p-act-rep-config-cacert[]
        // Configure Server Security
        // -- only accept CA attested certs
        thisConfig.setAcceptOnlySelfSignedServerCertificate(false) <i class="conum" data-value="61"></i><b>(61)</b>

        // end::p2p-act-rep-config-cacert[]
        // tag::p2p-act-rep-config-pinnedcert[]

        // Return the remote pinned cert (the listener's cert)
        val returnedCert: Byte =
            ByteArray(thisConfig.getPinnedCertificate()) // Get listener cert if pinned
        // end::p2p-act-rep-config-pinnedcert[]

        // end::p2p-act-rep-config-tls-full[]
        // tag::p2p-tlsid-tlsidentity-with-label[]
        // ... other replicator configuration
        // Provide a client certificate to the server for authentication
        val thisClientId: TLSIdentity = TLSIdentity.getIdentity("clientId")
            ?: throw IllegalStateException("Cannot find client id") <i class="conum" data-value="62"></i><b>(62)</b>
        thisConfig.setAuthenticator(ClientCertificateAuthenticator(thisClientId)) <i class="conum" data-value="63"></i><b>(63)</b>
        // ... other replicator configuration
        val thisReplicator = Replicator(thisConfig)

        // end::p2p-tlsid-tlsidentity-with-label[]
        // tag::p2p-act-rep-config-cacert-pinned[]

        // Use the pinned certificate from the byte array (cert)
        thisConfig.setPinnedServerCertificate(cert.getEncoded()) <i class="conum" data-value="64"></i><b>(64)</b>
        // end::p2p-act-rep-config-cacert-pinned[]
    }

    fun ibP2pReplicatorStatus() {
        // tag::p2p-act-rep-status[]
        Log.i(
            TAG, "The Replicator is currently " +
                    thisReplicator.getStatus().getActivityLevel()
        )
        Log.i(
            TAG,
            "The Replicator has processed $t"
        )
        if (thisReplicator.getStatus().getActivityLevel() ===
            Replicator.ActivityLevel.BUSY
        ) {
            Log.i(
                TAG,
                "Replication Processing"
            )
            Log.i(
                TAG, "It has completed " +
                        thisReplicator.getStatus().getProgess().getTotal().toString() +
                        " changes"
            )
        }
        // end::p2p-act-rep-status[]
    }

    fun ibP2pReplicatorStop() {
        // tag::p2p-act-rep-stop[]
        // Stop replication.
        thisReplicator.stop() <i class="conum" data-value="65"></i><b>(65)</b>
        // end::p2p-act-rep-stop[]
    }

    fun ibP2pListener() {
        CouchbaseLite.init(context)
        val thisDB = Database("passivepeerdb") <i class="conum" data-value="66"></i><b>(66)</b>
        // Initialize the listener config
        val thisConfig =
            URLEndpointListenerConfiguration(database)
        thisConfig.setPort(55990) /* &lt;.&gt;  Optional; defaults to auto */
        thisConfig.setDisableTls(false) /* &lt;.&gt;  Optional; defaults to false */
        thisConfig.setEnableDeltaSync(true) /* &lt;.&gt; Optional; defaults to false */

        // Configure the client authenticator (if using basic auth)
        val auth = ListenerPasswordAuthenticator(
            "username", "password"
        ) <i class="conum" data-value="67"></i><b>(67)</b>
        thisConfig.setAuthenticator(auth) <i class="conum" data-value="68"></i><b>(68)</b>

        // Initialize the listener
        val listener = URLEndpointListener(thisConfig) <i class="conum" data-value="69"></i><b>(69)</b>

        // Start the listener
        listener.start() <i class="conum" data-value="70"></i><b>(70)</b>


        // tag::createTlsIdentity[]

//        Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
//                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
//                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
//        );
        val thisIdentity: TLSIdentity = createIdentity(true, X509_ATTRIBUTES, null, "test-alias")

        // end::createTlsIdentity[]

        // tag::p2p-tlsid-store-in-keychain[]
        // end::p2p-tlsid-store-in-keychain[]


        // tag::deleteTlsIdentity[]
        // tag::p2p-tlsid-delete-id-from-keychain[]
        val thisAlias = "alias-to-delete"
        val thisKeyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        thisKeyStore.load(null)
        thisKeyStore.deleteEntry(thisAlias)

        // end::p2p-tlsid-delete-id-from-keychain[]
        // end::deleteTlsIdentity[]

        // tag::retrieveTlsIdentity[]
        // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label
        val thisIdentity: TLSIdentity = getIdentity("couchbase-docs-cert")
        // end::retrieveTlsIdentity[]
    }

    // tag::sgw-repl-pull[]
    fun ibRplicatorPull() {
        var database: Database
        var replicator: Replicator <i class="conum" data-value="71"></i><b>(71)</b>
        var uri: URI? = null
        try {
            uri = URI("wss://10.0.2.2:4984/db") <i class="conum" data-value="72"></i><b>(72)</b>
        } catch (e: URISyntaxException) {
            e.printStackTrace()
        }
        val endpoint: Endpoint = URLEndpoint(uri)
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        this.replicator = Replicator(config)
        this.replicator.start()
    }

    // end::sgw-repl-pull[]
    // tag::sgw-act-rep-initialize[]
    // initialize the replicator configuration
    val thisConfig: ReplicatorConfiguration = ReplicatorConfiguration(
        thisDB,
        URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))
    ) // &lt;.&gt; // end::sgw-act-rep-initialize[]

    /* C A L L O U T S

// Listener Callouts

  // tag::listener-callouts-full[]

    // tag::listener-start-callouts[]
    &lt;.&gt; Initialize the listener instance using the configuration settings.
    &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.

  // end::listener-start-callouts[]

  // tag::listener-status-check-callouts[]

  &lt;.&gt; `connectionCount` -- the total number of connections served by the listener
  &lt;.&gt; `activeConnectionCount` -- the number of active (BUSY) connections currently being served by the listener
  //
  // end::listener-status-check-callouts[]

    // end::listener-callouts-full[]


    // tag::p2p-act-rep-config-cacert-pinned-callouts[]
  &lt;.&gt; Configure the pinned certificate using data from the byte array `cert`
  // end::p2p-act-rep-config-cacert-pinned-callouts[]

  // tag::p2p-tlsid-tlsidentity-with-label-callouts[]
  &lt;.&gt; Attempt to get the identity from secure storage
  &lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity

  // end::p2p-tlsid-tlsidentity-with-label-callouts[]

  // tag::sgw-repl-pull-callouts[]
  &lt;.&gt; A replication is an asynchronous operation.
  To keep a reference to the `replicator` object, you can set it as an instance property.
  &lt;.&gt; The URL scheme for remote database URLs uses `ws:`, or `wss:` for SSL/TLS connections over wb sockets.
  In this example the hostname is `10.0.2.2` because the Android emulator runs in a VM that is generally accessible on `10.0.2.2` from the host machine (see https://developer.android.com/studio/run/emulator-networking[Android Emulator networking] documentation).
  +
  NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
  Although `wss:` protocol URLs are not affected, in order to use the `ws:` protocol, applications must target API 27 or lower, or must configure application network security as described https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted[here].

  // end::sgw-repl-pull-callouts[]
  */
}





    fun testQuerySyntaxAll() {

        // tag::query-syntax-all[]
//        try {
//            this_Db = new Database("hotels");
//        } catch (CouchbaseLiteException e) {
//            e.printStackTrace();
//        }
        val db = openOrCreateDatabaseForUser(currentUser)
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(db!!))
        // end::query-syntax-all[]

        // tag::query-access-all[]
        val hotels: HashMap&lt;String, Hotel&gt; = HashMap&lt;String, Hotel&gt;()
        try {
            for (result in listQuery.execute().allResults()) {
                // get the k-v pairs from the 'hotel' key's value into a dictionary
                val thisDocsProps = result.getDictionary(0) <i class="conum" data-value="73"></i><b>(73)</b>
                val thisDocsId = thisDocsProps!!.getString("id")
                val thisDocsName = thisDocsProps.getString("name")
                val thisDocsType = thisDocsProps.getString("type")
                val thisDocsCity = thisDocsProps.getString("city")

                // Alternatively, access results value dictionary directly
                val hotel = Hotel()
                hotel.id = result.getDictionary(0)!!.getString("id").toString() <i class="conum" data-value="74"></i><b>(74)</b>
                hotel.type = result.getDictionary(0)!!.getString("type").toString()
                hotel.name = result.getDictionary(0)!!.getString("name").toString()
                hotel.city = result.getDictionary(0)!!.getString("city").toString()
                hotel.country = result.getDictionary(0)!!.getString("country").toString()
                hotel.description = result.getDictionary(0)!!.getString("description").toString()
                hotels[hotel.id] = hotel
            }
        } catch (e: CouchbaseLiteException) {
            e.printStackTrace()
        }

        // end::query-access-all[]
    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun testQuerySyntaxJson() {
        val db = openOrCreateDatabaseForUser(currentUser)
        // tag::query-syntax-json[]
        // Example assumes Hotel class object defined elsewhere
//        Database db = null;
//        try {
//                db = new Database(dbName);
//        } catch (CouchbaseLiteException e) {
//            e.printStackTrace();
//        }

        // Build the query
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(db!!))

        // end::query-syntax-json[]

      // tag::query-access-json[]
        // Uses Jackson JSON processor
        val mapper = ObjectMapper();
        val hotels: ArrayList&lt;Hotel&gt; = ArrayList&lt;Hotel&gt;()

        for (result in listQuery.execute()) {

          // Get result as JSON string
          val thisJsonString1: String = result.toJSON() <i class="conum" data-value="75"></i><b>(75)</b>

          // Get Hashmap from JSON string
          val dictFromJSONstring =
              mapper.readValue(thisJsonString, HashMap::class.java) <i class="conum" data-value="76"></i><b>(76)</b>

          // Use created hashmap
          val hotelId = dictFromJSONstring["id"].toString() //
          val hotelType = dictFromJSONstring["type"].toString()
          val hotelname = dictFromJSONstring["name"].toString()


          // Get custom object from JSON strin
          val thisHotel =
              mapper.readValue(thisJsonString, Hotel::class.java) <i class="conum" data-value="77"></i><b>(77)</b>
          hotels.add(thisHotel)

      }
      // end::query-access-json[]
    }
    /* end func testQuerySyntaxJson */</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset8_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.support.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;
import com.example.docsnippet.Datastore;
import com.example.docsnippet.Hotel;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

// tag::example-app[]
public class docOnly_Examples {
  private static final String TAG = "EXAMPLE";

  private static final String DATABASE_NAME = "database";

  private final Context context;
  private Database database;
  private Replicator replicator;

  public docOnly_Examples(Context context) { this.context = context; }

  //@Test
  public void testGettingStarted() throws CouchbaseLiteException, URISyntaxException {
    // tag::getting-started[]

    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);

    // Get the database (and create it if it doesnt exist).
    DatabaseConfiguration config = new DatabaseConfiguration();

    config.setDirectory(context.getFilesDir().getAbsolutePath());

    Database database = new Database("getting-started", config);


    // Create a new document (i.e. a record) in the database.
    MutableDocument mutableDoc = new MutableDocument()
    .setFloat("version", 2.0F)
    .setString("type", "SDK");

    // Save it to the database.
    database.save(mutableDoc);

    // Update a document.
    mutableDoc = database.getDocument(mutableDoc.getId()).toMutable();
    mutableDoc.setString("language", "Java");
    database.save(mutableDoc);
    Document document = database.getDocument(mutableDoc.getId());
    // Log the document ID (generated by the database) and properties
    Log.i(TAG, "Document ID :: " + document.getId());
    Log.i(TAG, "Learning " + document.getString("language"));

    // Create a query to fetch documents of type SDK.
    Query query = QueryBuilder.select(SelectResult.all())
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("SDK")));
    ResultSet result = query.execute();
    Log.i(TAG, "Number of rows ::  " + result.allResults().size());

    // Create replicators to push and pull changes to and from the cloud.
    Endpoint targetEndpoint = new URLEndpoint(new URI("ws://localhost:4984/getting-started-db"));
    ReplicatorConfiguration replConfig = new ReplicatorConfiguration(database, targetEndpoint);
    replConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Add authentication.
    replConfig.setAuthenticator(new BasicAuthenticator("sync-gateway", "password"));

    // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
    Replicator replicator = new Replicator(replConfig);

    // Listen to replicator change events.
    replicator.addChangeListener(change -&gt; {
      if (change.getStatus().getError() != null) {
        Log.i(TAG, "Error code ::  " + change.getStatus().getError().getCode());
      }
    });

    // Start replication.
    replicator.start();

    // end::getting-started[]

    database.delete();
  }
  // end::example-app[]

  public void test1xAttachments() throws CouchbaseLiteException, IOException {
    // if db exist, delete it
    deleteDB("android-sqlite", context.getFilesDir());

    ZipUtils.unzip(getAsset("replacedb/android140-sqlite.cblite2.zip"), context.getFilesDir());

    Database db = new Database("android-sqlite", new DatabaseConfiguration());
    try {

      Document doc = db.getDocument("doc1");

      // For Validation
      Dictionary attachments = doc.getDictionary("_attachments");
      Blob blob = attachments.getBlob("attach1");
      byte[] content = blob.getContent();
      // For Validation

      byte[] attach = String.format(Locale.ENGLISH, "attach1").getBytes();
      Arrays.equals(attach, content);

    } finally {
      // close db
      db.close();
      // if db exist, delete it
      deleteDB("android-sqlite", context.getFilesDir());
    }

    Document document = new MutableDocument();

    // tag::1x-attachment[]
    Dictionary attachments = document.getDictionary("_attachments");
    Blob blob = attachments != null ? attachments.getBlob("avatar") : null;
    byte[] content = blob != null ? blob.getContent() : null;
    // end::1x-attachment[]
  }

  // ### Initializer
  public void testInitializer() {
    // tag::sdk-initializer[]
    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);
    // end::sdk-initializer[]
  }

  // ### New Database
  public void testNewDatabase() throws CouchbaseLiteException {
    // tag::new-database[]
    final DatabaseConfiguration config = new DatabaseConfiguration();
    config.setDirectory(context.getFilesDir().getAbsolutePath()); <i class="conum" data-value="1"></i><b>(1)</b>

    Database database = new Database("my-database", config);
    // end::new-database[]

    // tag::close-database[]
    database.close();

    // end::close-database[]

    database.delete();
  }

  // ### Database Encryption
  public void testDatabaseEncryption() throws CouchbaseLiteException {
    // tag::database-encryption[]
    DatabaseConfiguration config = new DatabaseConfiguration();
    config.setEncryptionKey(new EncryptionKey("PASSWORD"));
    Database database = new Database("mydb", config);
    // end::database-encryption[]
  }

  // ### Logging
  public void testLogging() {
    // tag::logging[]
    Database.setLogLevel(LogDomain.DATABASE, LogLevel.VERBOSE);
    Database.setLogLevel(LogDomain.QUERY, LogLevel.VERBOSE);
    // end::logging[]
    }

    public void testEnableCustomLogging() {
        // tag::set-custom-logging[]
        Database.log.setCustom(new LogTestLogger(LogLevel.WARNING)); <i class="conum" data-value="2"></i><b>(2)</b>
        // end::set-custom-logging[]
    }

    // ### Console logging
    public void testConsoleLogging() throws CouchbaseLiteException {
      // tag::console-logging[]
          Database.log.getConsole().setDomain(LogDomain.ALL_DOMAINS);  <i class="conum" data-value="3"></i><b>(3)</b>
          Database.log.getConsole().setLevel(LogLevel.VERBOSE); <i class="conum" data-value="4"></i><b>(4)</b>
      // end::console-logging[]
      // tag::console-logging-db[]
          Database.log.getConsole().setDomain(LogDomain.DATABASE);

      // end::console-logging-db[]
    }

    // ### File logging
    public void testFileLogging() throws CouchbaseLiteException {
        // tag::file-logging[]
        final File path = context.getCacheDir();

        LogFileConfiguration LogCfg =
          new LogFileConfiguration(path.toString()); <i class="conum" data-value="5"></i><b>(5)</b>
        LogCfg.setMaxSize(10240); <i class="conum" data-value="6"></i><b>(6)</b>
        LogCfg.setMaxRotateCount(5); <i class="conum" data-value="7"></i><b>(7)</b>
        LogCfg.setUsePlainText(false); <i class="conum" data-value="8"></i><b>(8)</b>
        Database.log.getFile().setConfig(LogCfg);
        Database.log.getFile().setLevel(LogLevel.INFO); <i class="conum" data-value="9"></i><b>(9)</b>
        // end::file-logging[]
    }

    public void writeConsoleLog()
    {
        // tag::write-console-logmsg[]
        Database.log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
        // end::write-console-logmsg[]
    }
    public void writeCustomLog()
    {
        // tag::write-custom-logmsg[]
        Database.log.Custom?.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
        // end::write-custom-logmsg[]
    }


    public void writeFileLog()
    {
        // tag::write-file-logmsg[]
        Database.log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
        // end::write-file-logmsg[]
    }




    // ### Loading a pre-built database
    public void testPreBuiltDatabase() throws IOException {
      // tag::prebuilt-database[]
      // Note: Getting the path to a database is platform-specific.
      // For Android you need to extract it from your
      // assets to a temporary directory and then pass that path to Database.copy()
      DatabaseConfiguration configuration = new DatabaseConfiguration();
      if (!Database.exists("travel-sample", context.getFilesDir())) {
            ZipUtils.unzip(getAsset("travel-sample.cblite2.zip"), context.getFilesDir());
            File path = new File(context.getFilesDir(), "travel-sample");
            try {
                Database.copy(path, "travel-sample", configuration);
            } catch (CouchbaseLiteException e) {
                e.printStackTrace();
            }
        }
        // end::prebuilt-database[]
    }

    // helper methods

    // if db exist, delete it
    private void deleteDB(String name, File dir) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            // sometimes, db is still in used, wait for a while. Maximum 3 sec
            for (int i = 0; i &lt; 10; i++) {
                try {
                    Database.delete(name, dir);
                    break;
                } catch (CouchbaseLiteException ex) {
                    try { Thread.sleep(300); }
                    catch (InterruptedException ignore) { }
                }
            }
        }
    }

    // ### Initializers
    public void testInitializers() {
        // tag::initializer[]
        MutableDocument newTask = new MutableDocument();
        newTask.setString("type", "task");
        newTask.setString("owner", "todo");
        newTask.setDate("createdAt", new Date());
        try {
            database.save(newTask);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
        // end::initializer[]
    }

    // ### Mutability
    public void testMutability() {
        try { database.save(new MutableDocument("xyz")); }
        catch (CouchbaseLiteException ignore) { }

        // tag::update-document[]
        Document document = database.getDocument("xyz");
        MutableDocument mutableDocument = document.toMutable();
        mutableDocument.setString("name", "apples");
        try {
            database.save(mutableDocument);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
        // end::update-document[]
    }

    // ### Typed Accessors
    public void testTypedAccessors() {
        MutableDocument newTask = new MutableDocument();

        // tag::date-getter[]
        newTask.setValue("createdAt", new Date());
        Date date = newTask.getDate("createdAt");
        // end::date-getter[]
    }

    // ### Batch operations
    public void testBatchOperations() {
        // tag::batch[]
        try {
            database.inBatch(() -&gt; {
                for (int i = 0; i &lt; 10; i++) {
                    MutableDocument doc = new MutableDocument();
                    doc.setValue("type", "user");
                    doc.setValue("name", "user " + i);
                    doc.setBoolean("admin", false);
                    try {
                        database.save(doc);
                    } catch (CouchbaseLiteException e) {
                        Log.e(TAG, e.toString());
                    }
                    Log.i(TAG, String.format("saved user document %s", doc.getString("name")));
                }
            });
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
        // end::batch[]
    }

    // ### Document Expiration
    public void DocumentExpiration() throws CouchbaseLiteException {
        // tag::document-expiration[]
        // Purge the document one day from now
        Instant ttl = Instant.now().plus(1, ChronoUnit.DAYS);
        database.setDocumentExpiration("doc123", new Date(ttl.toEpochMilli()));

        // Reset expiration
        database.setDocumentExpiration("doc1", null);

        // Query documents that will be expired in less than five minutes
        Instant fiveMinutesFromNow = Instant.now().plus(5, ChronoUnit.MINUTES);
        Query query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.expiration.lessThan(Expression.doubleValue(fiveMinutesFromNow.toEpochMilli())));
        // end::document-expiration[]
    }

    public void testDocumentChangeListener() throws CouchbaseLiteException {
        // tag::document-listener[]
        database.addDocumentChangeListener(
            "user.john",
            change -&gt; {
                Document doc = database.getDocument(change.getDocumentID());
                if (doc != null) {
                    Toast.makeText(context, "Status: " + doc.getString("verified_account"), Toast.LENGTH_SHORT).show();
                }
            });
        // end::document-listener[]
    }

    // ### Blobs
    public void testBlobs() {
        MutableDocument newTask = new MutableDocument();

        // tag::blob[]
        InputStream is = getAsset("avatar.jpg");
        if (is == null) { return; }
        try {
            Blob blob = new Blob("image/jpeg", is);
            newTask.setBlob("avatar", blob);
            database.save(newTask);

            Blob taskBlob = newTask.getBlob("avatar");
            byte[] bytes = taskBlob.getContent();
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        } finally {
            try { is.close(); }
            catch (IOException ignore) { }
        }
        // end::blob[]
    }

    // ### Indexing
    public void testIndexing() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-index[]
            database.createIndex(
                "TypeNameIndex",
                IndexBuilder.valueIndex(
                    ValueIndexItem.property("type"),
                    ValueIndexItem.property("name")));
            // end::query-index[]
        }
    }

    // ### SELECT statement
    public void testSelectStatement() {
        {
            // tag::query-select-meta[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("type"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.expression(Meta.id));

            try {
                ResultSet rs = query.execute();
                for (Result result : rs) {
                    Log.i("Sample", String.format("hotel id -&gt; %s", result.getString("id")));
                    Log.i("Sample", String.format("hotel name -&gt; %s", result.getString("name")));
                }
            } catch (CouchbaseLiteException e) {
                Log.e("Sample", e.getLocalizedMessage());
            }
            // end::query-select-meta[]
        }
    }

    // META function
    public void testMetaFunction() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.expression(Meta.id))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport")))
                .orderBy(Ordering.expression(Meta.id));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.w("Sample", String.format("airport id -&gt; %s", result.getString("id")));
                Log.w("Sample", String.format("airport id -&gt; %s", result.getString(0)));
            }
        }
    }

    // ### all(*)
    public void testSelectAll() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-select-all[]
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")));
            // end::query-select-all[]

            // tag::live-query[]
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database));

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            ListenerToken token = query.addChangeListener(change -&gt; { <i class="conum" data-value="10"></i><b>(10)</b>
                for (Result result : change.getResults()) {
                    Log.d(TAG, "results: " + result.getKeys());
                    /* Update UI */
                }
            });

            // Start live query.
            query.execute(); <i class="conum" data-value="11"></i><b>(11)</b>
            // end::live-query[]

            // tag::stop-live-query[]
            query.removeChangeListener(token); <i class="conum" data-value="12"></i><b>(12)</b>

            // end::stop-live-query[]

            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("hotel -&gt; %s", result.getDictionary(DATABASE_NAME).toMap()));
            }
        }
    }

    // ###WHERE statement
    public void testWhereStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-where[]
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .limit(Expression.intValue(10));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Dictionary all = result.getDictionary(DATABASE_NAME);
                Log.i("Sample", String.format("name -&gt; %s", all.getString("name")));
                Log.i("Sample", String.format("type -&gt; %s", all.getString("type")));
            }
            // end::query-where[]
        }
    }

    public void testQueryDeletedDocuments() {
        // tag::query-deleted-documents[]
        // Query documents that have been deleted
        Where query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted);
        // end::query-deleted-documents[]
    }


    // ####Collection Operators
    public void testCollectionStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-collection-operator-contains[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("public_likes"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction
                        .contains(Expression.property("public_likes"), Expression.string("Armani Langworth"))));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("public_likes -&gt; %s", result.getArray("public_likes").toList()));
            }
            // end::query-collection-operator-contains[]
        }
    }

    // IN operator
    public void testInOperator() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-collection-operator-in[]
            Expression[] values = new Expression[] {
                Expression.property("first"),
                Expression.property("last"),
                Expression.property("username")
            };

            Query query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.string("Armani").in(values));
            // end::query-collection-operator-in[]

            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // Pattern Matching
    public void testPatternMatching() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-like-operator[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Function.Expression.string("royal engineers museum")))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
            // end::query-like-operator[]
        }
    }

    // ### Wildcard Match
    public void testWildcardMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-like-operator-wildcard-match[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng%e%"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
            // end::query-like-operator-wildcard-match[]
        }
    }

    // Wildcard Character Match
    public void testWildCharacterMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-like-operator-wildcard-character-match[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng____r"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
            // end::query-like-operator-wildcard-character-match[]
        }
    }

    // ### Regex Match
    public void testRegexMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-regex-operator[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).regex(Expression.string("\\beng.*r\\b"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
            // end::query-regex-operator[]
        }
    }

    // JOIN statement
    public void testJoinStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-join[]
            Query query = QueryBuilder.select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route")))
                .from(DataSource.database(database).as("airline"))
                .join(Join.join(DataSource.database(database).as("route"))
                    .on(Meta.id.from("airline").equalTo(Expression.property("airlineid").from("route"))))
                .where(Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline").equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route").equalTo(Expression.string("RIX"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
            // end::query-join[]
        }
    }

    // ### GROUPBY statement
    public void testGroupByStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-groupby[]
            Query query = QueryBuilder.select(
                SelectResult.expression(Function.count(Expression.string("*"))),
                SelectResult.property("country"),
                SelectResult.property("tz"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300))))
                .groupBy(
                    Expression.property("country"),
                    Expression.property("tz"))
                .orderBy(Ordering.expression(Function.count(Expression.string("*"))).descending());
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format(
                        "There are %d airports on the %s timezone located in %s and above 300ft",
                        result.getInt("$1"),
                        result.getString("tz"),
                        result.getString("country")));
            }
            // end::query-groupby[]
        }
    }

    // ### ORDER BY statement
    public void testOrderByStatement() throws CouchbaseLiteException {
      // For Documentation
      {
        // tag::query-orderby[]
        Query query = QueryBuilder
        .select(
          SelectResult.expression(Meta.id),
          SelectResult.property("name"))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("hotel")))
          .orderBy(Ordering.property("name").ascending())
          .limit(Expression.intValue(10));
          ResultSet rs = query.execute();
          for (Result result : rs) { Log.i("Sample", String.format("%s", result.toMap())); }
          // end::query-orderby[]
        }
      }
      // ### EXPLAIN statement
      public void testExplainStatement() throws CouchbaseLiteException {
          // For Documentation
          {
              // tag::query-explain-all[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("university")))
                .groupBy(Expression.property("country"))
                .orderBy(Ordering.property("name").descending()); <i class="conum" data-value="13"></i><b>(13)</b>
              Log.i(query.explain()); <i class="conum" data-value="14"></i><b>(14)</b>
              // end::query-explain-all[]
              // tag::query-explain-like[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("%hotel%"))); <i class="conum" data-value="15"></i><b>(15)</b>
              Log.i(query.explain());
              // end::query-explain-like[]
              // tag::query-explain-nopfx[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="16"></i><b>(16)</b>
                  .and(Expression.property("name").like(Expression.string("%royal%"))));
              Log.i(query.explain());
              // end::query-explain-nopfx[]
              // tag::query-explain-function[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))); <i class="conum" data-value="17"></i><b>(17)</b>
              Log.i(query.explain());
              // end::query-explain-function[]
              // tag::query-explain-nofunction[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="18"></i><b>(18)</b>
              Log.i(query.explain());
              // end::query-explain-nofunction[]
          }
      }
      // end query-explain

    void prepareIndex() throws CouchbaseLiteException {
        // tag::fts-index[]
        database.createIndex(
            "nameFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("name")).ignoreAccents(false));
        // end::fts-index[]
    }

    public void testFTS() throws CouchbaseLiteException {
        // tag::fts-query[]
        Expression whereClause = FullTextExpression.index("nameFTSIndex").match("buy");
        Query ftsQuery = QueryBuilder.select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause);
        ResultSet ftsQueryResult = ftsQuery.execute();
        for (Result result : ftsQueryResult) {
            Log.i(
                TAG,
                String.format("document properties %s", result.getString(0)));
        }
        // end::fts-query[]
    }

    /* The `tag::replication[]` example is inlined in java.adoc */

    public void testTroubleshooting() {
        // tag::replication-logging[]
        Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE);
        // end::replication-logging[]
    }

    public void testReplicationBasicAuthentication() throws URISyntaxException {
        // tag::basic-authentication[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new BasicAuthenticator("username", "password"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
        // end::basic-authentication[]
    }

    public void testReplicationSessionAuthentication() throws URISyntaxException {
        // tag::session-authentication[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
        // end::session-authentication[]
    }

    public void testReplicationStatus() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        // tag::replication-status[]
        replicator.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == Replicator.ActivityLevel.STOPPED) {
                Log.i(TAG, "Replication stopped");
            }
          });
          // end::replication-status[]
        }

    //  BEGIN PendingDocuments BM -- 19/Feb/21 --
    import android.support.annotation.NonNull;
    import android.util.Log;

    import java.net.URI;
    import java.net.URISyntaxException;
    import java.util.Iterator;
    import java.util.Set;

    import com.couchbase.lite.CouchbaseLiteException;
    import com.couchbase.lite.Database;
    import com.couchbase.lite.Endpoint;
    import com.couchbase.lite.Replicator;
    import com.couchbase.lite.ReplicatorConfiguration;
    import com.couchbase.lite.URLEndpoint;

    class PendingDocsExample {
        private static final String TAG = "SCRATCH";

        private Database database;
        private Replicator replicator;

        //  BEGIN PendingDocuments IB -- 11/Feb/21 --
        public void testReplicationPendingDocs() throws URISyntaxException, CouchbaseLiteException {
            // nottag::replication-pendingdocuments[]
            // ... include other code as required
            //
            final Endpoint endpoint =
              new URLEndpoint(new URI("ws://localhost:4984/db"));

            final ReplicatorConfiguration config =
              new ReplicatorConfiguration(database, endpoint)
            .setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);
            // tag::replication-push-pendingdocumentids[]

            replicator = new Replicator(config);
            final Set&lt;String&gt; pendingDocs =
              replicator.getPendingDocumentIds(); <i class="conum" data-value="19"></i><b>(19)</b>

            // end::replication-push-pendingdocumentids[]

            replicator.addChangeListener(change -&gt; {
              onStatusChanged(pendingDocs, change.getStatus()); });

            replicator.start();

            // ... include other code as required
            // notend::replication-pendingdocuments[]
          }
        //
        // tag::replication-pendingdocuments[]
        //
        private void onStatusChanged(
          @NonNull final Set&lt;String&gt; pendingDocs,
          @NonNull final Replicator.Status status) {
          // ... sample onStatusChanged function
          //
          Log.i(TAG,
            "Replicator activity level is " + status.getActivityLevel().toString());

          // iterate and report-on previously
          // retrieved pending docids 'list'
          for (Iterator&lt;String&gt; itr = pendingDocs.iterator(); itr.hasNext(); ) {
            final String docId = itr.next();
            try {
              // tag::replication-push-isdocumentpending[]
              if (!replicator.isDocumentPending(docId)) { continue; } <i class="conum" data-value="20"></i><b>(20)</b>
              // end::replication-push-isdocumentpending[]

              itr.remove();
              Log.i(TAG, "Doc ID " + docId + " has been pushed");
            }
            catch (CouchbaseLiteException e) {
              Log.w(TAG, "isDocumentPending failed", e); }
          }
        }
        // end::replication-pendingdocuments[]
        //  END PendingDocuments BM -- 19/Feb/21 --
    }


    public void testHandlingNetworkErrors() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        // tag::replication-error-handling[]
        replicator.addChangeListener(change -&gt; {
            CouchbaseLiteException error = change.getStatus().getError();
            if (error != null) { Log.w(TAG, "Error code:: %d", error); }
        });
        replicator.start();
        // end::replication-error-handling[]

        replicator.stop();
    }

    public void testReplicatorDocumentEvent() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        // tag::add-document-replication-listener[]
        ListenerToken token = replicator.addDocumentReplicationListener(replication -&gt; {

            Log.i(TAG, "Replication type: " + ((replication.isPush()) ? "Push" : "Pull"));
            for (ReplicatedDocument document : replication.getDocuments()) {
                Log.i(TAG, "Doc ID: " + document.getID());

                CouchbaseLiteException err = document.getError();
                if (err != null) {
                    // There was an error
                    Log.e(TAG, "Error replicating document: ", err);
                    return;
                }

                if (document.flags().contains(DocumentFlag.DocumentFlagsDeleted)) {
                    Log.i(TAG, "Successfully replicated a deleted document");
                }
            }
        });

        replicator.start();
        // end::add-document-replication-listener[]

        // tag::remove-document-replication-listener[]
        replicator.removeChangeListener(token);
        // end::remove-document-replication-listener[]
    }

    public void testReplicationCustomHeader() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);

        // tag::replication-custom-header[]
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();
        headers.put("CustomHeaderName", "Value");
        config.setHeaders(headers);
        // end::replication-custom-header[]
    }

    // ### Certificate Pinning

    public void testCertificatePinning() throws URISyntaxException, IOException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);

        // tag::certificate-pinning[]
        InputStream is = getAsset("cert.cer");
        byte[] cert = IOUtils.toByteArray(is);
        if (is != null) {
            try { is.close(); }
            catch (IOException ignore) {}
        }

        config.setPinnedServerCertificate(cert);
        // end::certificate-pinning[]
    }

    // ### Reset replicator checkpoint
    public void testReplicationResetCheckpoint() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();

        // tag::replication-reset-checkpoint[]
        replicator.resetCheckpoint();
        replicator.start();
        // end::replication-reset-checkpoint[]

        replicator.stop();
    }

    public void testReplicationPushFilter() throws URISyntaxException {
        // tag::replication-push-filter[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPushFilter((document, flags) -&gt; flags.contains(DocumentFlag.DocumentFlagsDeleted)); <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
        // end::replication-push-filter[]
    }

    public void testReplicationPullFilter() throws URISyntaxException {
        // tag::replication-pull-filter[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPullFilter((document, flags) -&gt; "draft".equals(document.getString("type"))); <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
        // end::replication-pull-filter[]
    }

    public void testCustomRetryConfig() throws URISyntaxException {
    // tag::replication-retry-config[]
    URLEndpoint target =
    new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

    ReplicatorConfiguration config =
    new ReplicatorConfiguration(database, target);

    //  other config as required . . .
    // tag::replication-heartbeat-config[]
    config.setHeartbeat(150L); <i class="conum" data-value="21"></i><b>(21)</b>
    // end::replication-heartbeat-config[]
    // tag::replication-maxretries-config[]
    config.setMaxRetries(20L); <i class="conum" data-value="22"></i><b>(22)</b>
    // end::replication-maxretries-config[]
    // tag::replication-maxretrywaittime-config[]
    config.setMaxRetryWaitTime(600L); <i class="conum" data-value="23"></i><b>(23)</b>
    // end::replication-maxretrywaittime-config[]

    Replicator repl = new Replicator(config);

    // end::replication-retry-config[]
    }





    public void testDatabaseReplica() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database1 = new Database("mydb", config);

        config = new DatabaseConfiguration();
        Database database2 = new Database("db2", config);

        /* EE feature: code below might throw a compilation error
           if it's compiled against CBL Android Community. */
        // tag::database-replica[]
        DatabaseEndpoint targetDatabase = new DatabaseEndpoint(database2);
        ReplicatorConfiguration replicatorConfig = new ReplicatorConfiguration(database1, targetDatabase);
        replicatorConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(replicatorConfig);
        replicator.start();
        // end::database-replica[]
    }

    public void testPredictiveModel() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        // tag::register-model[]
        Database.prediction.registerModel("ImageClassifier", new ImageClassifierModel());
        // end::register-model[]

        // tag::predictive-query-value-index[]
        ValueIndex index = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")));
        database.createIndex("value-index-image-classifier", index);
        // end::predictive-query-value-index[]

        // tag::unregister-model[]
        Database.prediction.unregisterModel("ImageClassifier");
        // end::unregister-model[]
    }

    public void testPredictiveIndex() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        // tag::predictive-query-predictive-index[]
        Map&lt;String, Object&gt; inputMap = new HashMap&lt;&gt;();
        inputMap.put("numbers", Expression.property("photo"));
        Expression input = Expression.map(inputMap);

        PredictiveIndex index = IndexBuilder.predictiveIndex("ImageClassifier", input, null);
        database.createIndex("predictive-index-image-classifier", index);
        // end::predictive-query-predictive-index[]
    }

    public void testPredictiveQuery() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        // tag::predictive-query[]
        Map&lt;String, Object&gt; inputProperties = new HashMap&lt;&gt;();
        inputProperties.put("photo", Expression.property("photo"));
        Expression input = Expression.map(inputProperties);
        PredictionFunction prediction = PredictiveModel.predict("ImageClassifier", input); <i class="conum" data-value="1"></i><b>(1)</b>

        Query query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("label").equalTo(Expression.string("car"))
                .and(Expression.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))));

        // Run the query.
        ResultSet result = query.execute();
        Log.d(TAG, "Number of rows: " + result.allResults().size());
        // end::predictive-query[]
    }

    public void testReplicationWithCustomConflictResolver() throws URISyntaxException {
        // tag::replication-conflict-resolver[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setConflictResolver(new LocalWinConflictResolver());

        Replicator replication = new Replicator(config);
        replication.start();
        // end::replication-conflict-resolver[]
    }

    public void testSaveWithCustomConflictResolver() throws CouchbaseLiteException {
        // tag::update-document-with-conflict-handler[]
        Document doc = database.getDocument("xyz");
        if (doc == null) { return; }
        MutableDocument mutableDocument = doc.toMutable();
        mutableDocument.setString("name", "apples");

        database.save(
            mutableDocument,
            (newDoc, curDoc) -&gt; { <i class="conum" data-value="24"></i><b>(24)</b>
                if (curDoc == null) { return false; } <i class="conum" data-value="25"></i><b>(25)</b>
                Map&lt;String, Object&gt; dataMap = curDoc.toMap();
                dataMap.putAll(newDoc.toMap()); <i class="conum" data-value="26"></i><b>(26)</b>
                newDoc.setData(dataMap);
                return true; <i class="conum" data-value="27"></i><b>(27)</b>
            }); <i class="conum" data-value="28"></i><b>(28)</b>
        // end::update-document-with-conflict-handler[]
      }
    }

// tag::update-document-with-conflict-handler-callouts[]

&lt;.&gt; The conflict handler code is provided as a lambda.

&lt;.&gt; If the handler cannot resolve a conflict, it can return false.
In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.

&lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.

&lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).

&lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method
// end::update-document-with-conflict-handler-callouts[]

// tag::local-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
class LocalWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getLocalDocument();
    }
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
class RemoteWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getRemoteDocument();
    }
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
// Using replConfig.setConflictResolver(new MergeConflictResolver());
class MergeConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        Map&lt;String, Object&gt; merge = conflict.getLocalDocument().toMap();
        merge.putAll(conflict.getRemoteDocument().toMap());
        return new MutableDocument(conflict.getDocumentId(), merge);
    }
}
// end::merge-conflict-resolver[]


/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ----------------------------------------------------------- */

class BrowserSessionManager implements MessageEndpointDelegate {
    private final Context context;
    private Replicator replicator;

    private BrowserSessionManager(Context context) { this.context = context; }

    public void initCouchbase() throws CouchbaseLiteException {
        // tag::message-endpoint[]
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration(context);
        Database database = new Database("mydb", databaseConfiguration);

        // The delegate must implement the `MessageEndpointDelegate` protocol.
        MessageEndpoint messageEndpointTarget = new MessageEndpoint(
            "UID:123",
            "active",
            ProtocolType.MESSAGE_STREAM,
            this);
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, messageEndpointTarget);

        // Create the replicator object.
        replicator = new Replicator(config);
        // Start the replication.
        replicator.start();
        // end::message-endpoint-replicator[]
    }

    // tag::create-connection[]
    /* implementation of MessageEndpointDelegate */
    @NonNull
    @Override
    public MessageEndpointConnection createConnection(@NonNull MessageEndpoint endpoint) {
        return new ActivePeerConnection(); /* implements MessageEndpointConnection */
    }
    // end::create-connection[]
}

class ActivePeerConnection implements MessageEndpointConnection {

    private ReplicatorConnection replicatorConnection;

    public void disconnect() {
        // tag::active-replicator-close[]
        replicatorConnection.close(null);
        // end::active-replicator-close[]
    }

    // tag::active-peer-open[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }
    // end::active-peer-open[]

    // tag::active-peer-close[]
    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete();
    }
    // end::active-peer-close[]

    // tag::active-peer-send[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null);
    }
    // end::active-peer-send[]

    public void receive(Message message) {
        // tag::active-peer-receive[]
        replicatorConnection.receive(message);
        // end::active-peer-receive[]
    }

}

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ----------------------------------------------------------- */

class PassivePeerConnection implements MessageEndpointConnection {
    private final Context context;

    private MessageEndpointListener messageEndpointListener;
    private ReplicatorConnection replicatorConnection;

    private PassivePeerConnection(Context context) { this.context = context; }

    public void startListener() throws CouchbaseLiteException {
        // tag::listener[]
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration();
        Database database = new Database("mydb", databaseConfiguration);
        MessageEndpointListenerConfiguration listenerConfiguration = new MessageEndpointListenerConfiguration(
            database,
            ProtocolType.MESSAGE_STREAM);
        this.messageEndpointListener = new MessageEndpointListener(listenerConfiguration);
        // end::listener[]
    }

    public void stopListener() {
        // tag::passive-stop-listener[]
        messageEndpointListener.closeAll();
        // end::passive-stop-listener[]
    }

    public void accept() {
        // tag::advertizer-accept[]
        PassivePeerConnection connection = new PassivePeerConnection(context); /* implements
        MessageEndpointConnection */
        messageEndpointListener.accept(connection);
        // end::advertizer-accept[]
    }

    public void disconnect() {
        // tag::passive-replicator-close[]
        replicatorConnection.close(null);
        // end::passive-replicator-close[]
    }

    // tag::passive-peer-open[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }
    // end::passive-peer-open[]

    // tag::passive-peer-close[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete();
    }
    // end::passive-peer-close[]

    // tag::passive-peer-send[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null);
    }
    // end::passive-peer-send[]

    public void receive(Message message) {
        // tag::passive-peer-receive[]
        replicatorConnection.receive(message);
        // end::passive-peer-receive[]
    }
}

// tag::predictive-model[]
// `tensorFlowModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
class ImageClassifierModel implements PredictiveModel {
    @Override
    public Dictionary predict(@NonNull Dictionary input) {
        Blob blob = input.getBlob("photo");
        if (blob == null) { return null; }

        // `tensorFlowModel` is a fake implementation
        // this would be the implementation of the ml model you have chosen
        return new MutableDictionary(TensorFlowModel.predictImage(blob.getContent())); <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

class TensorFlowModel {
    public static Map&lt;String, Object&gt; predictImage(byte[] data) {
        return null;
    }
}
// end::predictive-model[]

// tag::custom-logging[]
class LogTestLogger implements Logger {
    @NonNull
    private final LogLevel level;

    public LogTestLogger(@NonNull LogLevel level) { this.level = level; }

    @NonNull
    @Override
    public LogLevel getLevel() { return level; }

    @Override
    public void log(@NonNull LogLevel level, @NonNull LogDomain domain, @NonNull String message) {
    }
}
// end::custom-logging[]




// tag::certAuthListener-full[]

//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "lite@couchbase.com");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread(() -&gt; {
            try {
                startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);
                Log.e(TAG, "Success!!");
                deleteIdentity("server");
                Log.e(TAG, "Alias deleted: server");
                deleteIdentity("client");
                Log.e(TAG, "Alias deleted: client");
            }
            catch (Exception e) { Log.e(TAG, "Failed!!", e); }
        }).start();
    }

    // start a client replicator
    public void startClient(
        @NonNull URI uri,
        @NonNull Certificate cert,
        @NonNull TLSIdentity clientIdentity,
        @NonNull Database db) throws CertificateEncodingException, InterruptedException {
        final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri));
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    // tag::listener-config-auth-cert-full[]
    /**
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(false);
      config.setTlsIdentity(serverId);
      config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

      final URLEndpointListener listener = new URLEndpointListener(config);
      listener.start();

      final List&lt;URI&gt; urls = listener.getUrls();
      if (urls.isEmpty()) { return null; }
      return urls.get(0);
    }
    // end::listener-config-auth-cert-full[]
    // tag::listener-config-delete-cert-full[]

    /**
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
    throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

      final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
      keyStore.load(null);

      keyStore.deleteEntry(alias); <i class="conum" data-value="29"></i><b>(29)</b>
    }
    // end::listener-config-delete-cert-full[]

    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /* Configure Client (active) side certificates
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    private void configureClientCerts(
      ReplicatorConfiguration config,
      @NonNull Certificate cert,
      @NonNull TLSIdentity clientIdentity)
      throws CertificateEncodingException {

        // Create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
      }
      // notend::p2p-tlsid-tlsidentity-with-label[]

    /**
     * Copy a cert from a resource bundle
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte buf[] = new byte[1024];
        int n;
        while ((n = in.read(buf)) &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}
// end::certAuthListener-full[]


// tag::passwordAuthListener-full[]

//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread(() -&gt; {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);
                Log.e(TAG, "Success!!");
            }
            catch (Exception e) { Log.e(TAG, "Failed!!", e); }
        }).start();
    }

    // start a client replicator
    public void runClient(
        @NonNull URI uri,
        @NonNull String username,
        @NonNull char[] password,
        @NonNull Database db) throws InterruptedException {
        final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri));
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    // tag::listener-config-client-auth-pwd-full[]
    /**
     *
     * Start a listener for db that accepts connections using exactly the passed username and password

     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password) <i class="conum" data-value="30"></i><b>(30)</b>
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(true);
      config.setAuthenticator(new ListenerPasswordAuthenticator(
        (validUser, pwd) -&gt; username.equals(validUser) &amp;&amp; Arrays.equals(validPassword, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
      }
      // end::listener-config-client-auth-pwd-full[]
    }


// end::passwordAuthListener-full[]




// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.support.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;

public class docOnly_ReplicationExamples {
  private static final String TAG = "EXAMPLE ACTIVE PEER";
  private static final String thisDBNAME = "local-database";
  private final Context context;
  // private Database database;
  // private Replicator replicator;

  public docOnly_ReplicationExamples(Context context) { this.context = context; }

  String user = "syncuser";
  String password = "sync9455";
  SecCertificate cert=null;
  String passivePeerEndpoint = "10.1.1.12:8920";
  String passivePeerPort = "8920";
  String passiveDbName = "userdb";
  Database thisDB;
  Replicator thisReplicator;
  ListenerToken replicatorListener;




// PASSIVE PEER STUFF
// Stuff I adapted
//
// BEGIN new stuff 90420temp cache
  private URLEndpointListener createListener() {
  final URLEndpointListenerConfiguration listenerConfig = new URLEndpointListenerConfiguration(db);

  listenerConfig.setDisableTls(false);

  listenerConfig.setEnableDeltaSync(true);

  listenerConfig.setTlsIdentity(null); // Use with anonymous self signed cert

  listenerConfig.setAuthenticator(new ListenerPasswordAuthenticator(this::isWhitelistedUser));

  return new URLEndpointListener(listenerConfig);
}

public void startListener(@NotNull URLEndpointListener listener) {
  executor.submit(() -&gt; {
      CouchbaseLiteException err = null;
      try { listener.start(); }
      catch (CouchbaseLiteException e) { err = e; }
      onStart(err);
  });
}

private void stopListener(@NotNull URLEndpointListener listener) {
  listener.stop();
}
// END new stuff 90420temp cache


private void ibListenerSimple() {
  // tag::listener-simple[]
  final URLEndpointListenerConfiguration thisConfig =
    new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="31"></i><b>(31)</b>

  thisConfig.setAuthenticator(
    new ListenerPasswordAuthenticator(
      (username, password) -&gt;
        username.equals("valid.User") &amp;&amp;
        Arrays.equals(password, valid.password.string)
      )
    ); <i class="conum" data-value="32"></i><b>(32)</b>

  final URLEndpointListener thisListener =
    new URLEndpointListener(thisConfig); <i class="conum" data-value="33"></i><b>(33)</b>

  thisListener.start(); <i class="conum" data-value="34"></i><b>(34)</b>

  // end::listener-simple[]
}

private void ibReplicatorSimple() {
  // tag::replicator-simple[]
  URI uri = null;
  try {
      uri = new URI("wss://10.0.2.2:4984/db");
  } catch (URISyntaxException e) {
      e.printStackTrace();
  }
  Endpoint theListenerEndpoint = new URLEndpoint(uri); <i class="conum" data-value="35"></i><b>(35)</b>

  ReplicatorConfiguration thisConfig =
    new ReplicatorConfiguration(database, theListenerEndpoint); <i class="conum" data-value="36"></i><b>(36)</b>

  thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="37"></i><b>(37)</b>

  final BasicAuthenticator thisAuth
  = new BasicAuthenticator(
      "valid.user",
      "valid.password.string");
  thisConfig.setAuthenticator(thisAuth) <i class="conum" data-value="38"></i><b>(38)</b>

  this.replicator = new Replicator(config); <i class="conum" data-value="39"></i><b>(39)</b>
  this.replicator.start(); <i class="conum" data-value="40"></i><b>(40)</b>

  // end::replicator-simple[]
}


private void ibPassListener() {
// EXAMPLE 1
    // tag::listener-initialize[]
    // tag::listener-config-db[]
    // Initialize the listener config
    final URLEndpointListenerConfiguration thisConfig
       = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="41"></i><b>(41)</b>

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.setPort(55990); <i class="conum" data-value="42"></i><b>(42)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    thisConfig.setNetworkInterface("10.1.1.10"); <i class="conum" data-value="43"></i><b>(43)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.setEnableDeltaSync(false); <i class="conum" data-value="44"></i><b>(44)</b>

    // end::listener-config-delta-sync[]
    // tag::listener-config-tls-full[]
    // Configure server security
    // tag::listener-config-tls-enable[]
    thisConfig.setDisableTls(false); <i class="conum" data-value="45"></i><b>(45)</b>

    // end::listener-config-tls-enable[]
    // tag::listener-config-tls-id-anon[]
    // Use an Anonymous Self-Signed Cert
    thisConfig.setTlsIdentity(null); <i class="conum" data-value="46"></i><b>(46)</b>

    // end::listener-config-tls-id-anon[]

    // tag::listener-config-client-auth-pwd[]
    // Configure Client Security using an Authenticator
    // For example, Basic Authentication <i class="conum" data-value="47"></i><b>(47)</b>
    thisConfig.setAuthenticator(new ListenerPasswordAuthenticator(
      (validUser, validPassword) -&gt;
        username.equals(validUser) &amp;&amp;
        Arrays.equals(password, validPassword)));

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // Initialize the listener
    final URLEndpointListener thisListener
      = new URLEndpointListener(thisConfig); <i class="conum" data-value="48"></i><b>(48)</b>

    // Start the listener
    thisListener.start(); <i class="conum" data-value="49"></i><b>(49)</b>

    // end::listener-start[]
    // end::listener-initialize[]
}

private void ibListenerGetNetworkInterfaces() {
  // tag::listener-get-network-interfaces[]
  final URLEndpointListenerConfiguration thisConfig =
    URLEndpointListenerConfiguration(database: self.oDB)
  final URLEndpointListener thisListener
    = new URLEndpointListener(thisConfig);
  thisListener.start()
  Log.i(TAG, "URLS are " + thisListener.getUrls());

  // end::listener-get-network-interfaces[]
}

private void ibListenerLocalDb() {
// tag::listener-local-db[]
// . . . preceding application logic . . .
CouchbaseLite.init(context); <i class="conum" data-value="50"></i><b>(50)</b>
Database thisDB = new Database("passivepeerdb");

// end::listener-local-db[]
}

private void ibListenerConfigTlsDisable() {
// tag::listener-config-tls-disable[]
thisConfig.setDisableTls(true); <i class="conum" data-value="51"></i><b>(51)</b>

// end::listener-config-tls-disable[]
}

private void ibListenerConfigTlsIdFull() {
// tag::listener-config-tls-id-full[]
  // tag::listener-config-tls-id-caCert[]
  // Use CA Cert
  // Import a key pair into secure storage
  // Create a TLSIdentity from the imported key-pair
  InputStream thisKeyPair = new FileInputStream();

  thisKeyPair.getClass().getResourceAsStream("serverkeypair.p12"); <i class="conum" data-value="52"></i><b>(52)</b>

  TLSIdentity thisIdentity = new TLSIdentity.importIdentity(
    EXTERNAL_KEY_STORE_TYPE,  // KeyStore type, eg: "PKCS12"
    thisKeyPair,              // An InputStream from the keystore
    password,                 // The keystore password
    EXTERNAL_KEY_ALIAS,       // The alias to be used (in external keystore)
    null,                     // The key password
    "test-alias"              // The alias for the imported key
    );

  // end::listener-config-tls-id-caCert[]

  // tag::listener-config-tls-id-SelfSigned[]
  // Use a self-signed certificate
  // Create a TLSIdentity for the server using convenience API.
  // System generates self-signed cert
  // Work-in-progress. Code snippet coming soon.
  private static final Map&lt;String, String&gt; CERT_ATTRIBUTES; <i class="conum" data-value="53"></i><b>(53)</b>
  static {
    final Map&lt;String, String&gt; thisMap = new HashMap&lt;&gt;();
    m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "Couchbase Demo");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
    m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "noreply@couchbase.com");
    CERT_ATTRIBUTES = Collections.unmodifiableMap(thisMap);
  }

  // Store the TLS identity in secure storage
  // under the label 'couchbase-docs-cert'
  TLSIdentity thisIdentity =
    new TLSIdentity.createIdentity(
      true,
      CERT_ATTRIBUTES,
      null,
      "couchbase-docs-cert"); <i class="conum" data-value="54"></i><b>(54)</b>

  // end::listener-config-tls-id-SelfSigned[]

  // tag::listener-config-tls-id-set[]
  // Set the TLS Identity
  thisConfig.setTlsIdentity(thisIdentity); <i class="conum" data-value="55"></i><b>(55)</b>

  // end::listener-config-tls-id-set[]
// end::listener-config-tls-id-full[]
}

private void ibListenerConfigClientAuthRoot() {
// tag::listener-config-client-root-ca[]
  // tag::listener-config-client-auth-root[]
  // Configure the client authenticator
  // to validate using ROOT CA
  // thisClientID.certs is a list containing a client cert to accept
  // and any other certs needed to complete a chain between the client cert
  // and a CA
  final TLSIdentity validId =
    TLSIdentity.getIdentity("Our Corporate Id");  // get the identity <i class="conum" data-value="56"></i><b>(56)</b>

  if (validId == null) { throw new IllegalStateException("Cannot find corporate id"); }

  thisConfig.setTlsIdentity(validId);

  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(validId.getCerts())); <i class="conum" data-value="57"></i><b>(57)</b> <i class="conum" data-value="58"></i><b>(58)</b>
    // accept only clients signed by the corp cert

  final URLEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

  // end::listener-config-client-auth-root[]
// end::listener-config-client-root-ca[]
}

private void ibListenerConfigClientAuthLambda() {
// tag::listener-config-client-auth-lambda[]
// Configure authentication using application logic
  final TLSIdentity thisCorpId = TLSIdentity.getIdentity("OurCorp"); <i class="conum" data-value="59"></i><b>(59)</b>
  if (thisCorpId == null) {
    throw new IllegalStateException("Cannot find corporate id"); }
  thisConfig.setTlsIdentity(thisCorpId);
  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(
      (thisCorpId.getCerts()) -&gt; {
      // use supplied logic that resolves to boolean
      // true=valid, false=invalid
      }
    )); <i class="conum" data-value="60"></i><b>(60)</b> <i class="conum" data-value="61"></i><b>(61)</b>
  final ULEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

  // end::listener-config-client-auth-lambda[]
}


private void ibListenerConfigTlsDisable() {

  // tag::listener-config-tls-disable[]
  thisConfig.disableTLS(true);

  // end::listener-config-tls-disable[]
}


private void ibListenerStatusCheck() {
  // tag::listener-status-check[]
  int connectionCount =
    thisListener.getStatus().getConnectionCount(); <i class="conum" data-value="62"></i><b>(62)</b>

  int activeConnectionCount =
    thisListener.getStatus().getActiveConnectionCount();  <i class="conum" data-value="63"></i><b>(63)</b>

  // end::listener-status-check[]
}

private void ibListenerStop() {

  // tag::listener-stop[]
  thisListener.stop();

  // end::listener-stop[]
}

// Listener Callouts
/*
  // tag::listener-callouts-full[]

    // tag::listener-start-callouts[]
    &lt;.&gt; Initialize the listener instance using the configuration settings.
    &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.

  // end::listener-start-callouts[]

  // tag::listener-status-check-callouts[]

  &lt;.&gt; `connectionCount` -- the total number of connections served by the listener
  &lt;.&gt; `activeConnectionCount` -- the number of active (BUSY) connections currently being served by the listener
  //
  // end::listener-status-check-callouts[]

// end::listener-callouts-full[]
*/
/* END CALLOUTS TEXT */


private void ibP2PUrlEndpointListener() {

// tag::p2p-ws-api-urlendpointlistener[]
  public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
    // end::p2p-ws-api-urlendpointlistener[]
  }
}



// ACTIVE PEER STUFF
// Replication code
//

  //@Test
  public void testActPeerSync() throws CouchbaseLiteException, URISyntaxException {
  // tag::p2p-act-rep-func[]
    // tag::p2p-act-rep-initialize[]
    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://listener.com:8954"))); <i class="conum" data-value="64"></i><b>(64)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config-type[]
    // Set replicator type
    thisConfig.setReplicatorType(
      ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // end::p2p-act-rep-config-type[]
    // tag::p2p-act-rep-config-cont[]
    // Configure Sync Mode
    thisConfig.setContinuous(false); // default value

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Authentication --
    // only accept self-signed certs
    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="65"></i><b>(65)</b>

    // end::p2p-act-rep-config-self-cert[]
    // tag::p2p-act-rep-auth[]
    // Configure the credentials the
    // client will provide if prompted
    final BasicAuthenticator thisAuth
      = new BasicAuthenticator(
          "Our Username",
          "Our PasswordValue")); <i class="conum" data-value="66"></i><b>(66)</b>

    thisConfig.setAuthenticator(thisAuth)

    // end::p2p-act-rep-auth[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    thisConfig.setConflictResolver( /* define resolver function */); <i class="conum" data-value="67"></i><b>(67)</b>

    // end::p2p-act-rep-config-conflict[]
    // tag::p2p-act-rep-start-full[]
    // Create replicator
    // Consider holding a reference somewhere
    // to prevent the Replicator from being GCed
    final Replicator thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="68"></i><b>(68)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    // Optionally add a change listener <i class="conum" data-value="69"></i><b>(69)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    ListenerToken thisListener =
      new thisReplicator.addChangeListener(change -&gt; {
        final CouchbaseLiteException err =
         change.getStatus().getError();
         if (err != null) {
           Log.i(TAG, "Error code ::  " + err.getCode(), e);
         }
      });

    // end::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-start[]
    // Start replicator
    thisReplicator.start(false); <i class="conum" data-value="70"></i><b>(70)</b>

    // end::p2p-act-rep-start[]
    // end::p2p-act-rep-start-full[]
    // end::p2p-act-rep-func[]         ***** End p2p-act-rep-func

  public void ibReplicatorConfig() {
  // BEGIN additional snippets
      // tag::p2p-act-rep-config-tls-full[]
      // tag::p2p-act-rep-config-cacert[]
      // Configure Server Security
      // -- only accept CA attested certs
      thisConfig.setAcceptOnlySelfSignedServerCertificate(false); <i class="conum" data-value="71"></i><b>(71)</b>

      // end::p2p-act-rep-config-cacert[]
      // tag::p2p-act-rep-config-pinnedcert[]

    // Return the remote pinned cert (the listener's cert)
    byte returnedCert
     = new byte(thisConfig.getPinnedCertificate()); // Get listener cert if pinned
    // end::p2p-act-rep-config-pinnedcert[]

    // end::p2p-act-rep-config-tls-full[]
    // tag::p2p-tlsid-tlsidentity-with-label[]
    // ... your other replicator configuration

    // Provide a client certificate to the server for authentication
    final TLSIdentity thisClientId = TLSIdentity.getIdentity("clientId"); <i class="conum" data-value="72"></i><b>(72)</b>

    if (thisClientId == null) { throw new IllegalStateException("Cannot find client id"); }

    thisConfig.setAuthenticator(new ClientCertificateAuthenticator(thisClientId)); <i class="conum" data-value="73"></i><b>(73)</b>

    // ... your other replicator configuration
    final thisReplicator= new Replicator(thisConfig);

    // end::p2p-tlsid-tlsidentity-with-label[]
    // tag::p2p-act-rep-config-cacert-pinned[]

    // Use the pinned certificate from the byte array (cert)
    thisConfig.setPinnedServerCertificate(cert.getEncoded()); <i class="conum" data-value="74"></i><b>(74)</b>
    // end::p2p-act-rep-config-cacert-pinned[]
}
// END additional snippets







// tag::p2p-act-rep-status[]

    Log.i(TAG, "The Replicator is currently " +
      thisReplicator.getStatus().getActivityLevel());

    Log.i(TAG, "The Replicator has processed " + t);

    if (thisReplicator.getStatus().getActivityLevel() ==
      Replicator.ActivityLevel.BUSY) {
        Log.i(TAG, "Replication Processing");
        Log.i(TAG, "It has completed " +
          thisReplicator.getStatus().getProgess().getTotal() +
          " changes");
      }
      // end::p2p-act-rep-status[]

      // tag::p2p-act-rep-stop[]
      // Stop replication.
      thisReplicator.stop(); <i class="conum" data-value="75"></i><b>(75)</b>
      // end::p2p-act-rep-stop[]


  CouchbaseLite.init(context);
  Database thisDB = new Database("passivepeerdb");  <i class="conum" data-value="76"></i><b>(76)</b>
  // Initialize the listener config
  final URLEndpointListenerConfiguration thisConfig = new URLEndpointListenerConfiguration(database);
  thisConfig.setPort(55990)           // &lt;.&gt; Optional; defaults to auto
  thisConfig.setDisableTls(false)     // &lt;.&gt; Optional; defaults to false
  thisConfig.setEnableDeltaSync(true) // &lt;.&gt; Optional; Defaults to false

  // Configure the client authenticator (if using basic auth)
  ListenerPasswordAuthenticator auth = new ListenerPasswordAuthenticator { "username", "password"}; <i class="conum" data-value="77"></i><b>(77)</b>
  thisConfig.setAuthenticator(auth); <i class="conum" data-value="78"></i><b>(78)</b>

  // Initialize the listener
  final URLEndpointListener listener = new URLEndpointListener( thisConfig ); <i class="conum" data-value="79"></i><b>(79)</b>

  // Start the listener
  listener.start(); <i class="conum" data-value="80"></i><b>(80)</b>



  // tag::createTlsIdentity[]

  Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
        )

  TLSIdentity thisIdentity = new TLSIdentity.createIdentity(true, X509_ATTRIBUTES, null, "test-alias");

  // end::createTlsIdentity[]

  // tag::p2p-tlsid-store-in-keychain[]
  // end::p2p-tlsid-store-in-keychain[]


  // tag::deleteTlsIdentity[]
  // tag::p2p-tlsid-delete-id-from-keychain[]
  String thisAlias = "alias-to-delete";
  final KeyStore thisKeyStore
    =  KeyStore.getInstance("AndroidKeyStore");
  thisKeyStore.load(null);
  thisKeyStore.deleteEntry(thisAlias);

  // end::p2p-tlsid-delete-id-from-keychain[]
  // end::deleteTlsIdentity[]

  // tag::retrieveTlsIdentity[]
  // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label

  TLSIdentity thisIdentity =
    new TLSIdentity.getIdentity("couchbase-docs-cert")
  // end::retrieveTlsIdentity[]


  // tag::sgw-repl-pull[]
  public void ibRplicatorPull() {
    Database database;
    Replicator replicator; <i class="conum" data-value="81"></i><b>(81)</b>

    URI uri = null;
    try {
        uri = new URI("wss://10.0.2.2:4984/db"); <i class="conum" data-value="82"></i><b>(82)</b>
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
    Endpoint endpoint = new URLEndpoint(uri);
    ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
    config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
    this.replicator = new Replicator(config);
    this.replicator.start();
  }
  // end::sgw-repl-pull[]

    // tag::sgw-act-rep-initialize[]
    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))); <i class="conum" data-value="83"></i><b>(83)</b>

    // end::sgw-act-rep-initialize[]


  /* C A L L O U T S

  // tag::p2p-act-rep-config-cacert-pinned-callouts[]
  &lt;.&gt; Configure the pinned certificate using data from the byte array `cert`
  // end::p2p-act-rep-config-cacert-pinned-callouts[]

  // tag::p2p-tlsid-tlsidentity-with-label-callouts[]
  &lt;.&gt; Attempt to get the identity from secure storage
  &lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity

  // end::p2p-tlsid-tlsidentity-with-label-callouts[]

  // tag::sgw-repl-pull-callouts[]
  &lt;.&gt; A replication is an asynchronous operation.
  To keep a reference to the `replicator` object, you can set it as an instance property.
  &lt;.&gt; The URL scheme for remote database URLs uses `ws:`, or `wss:` for SSL/TLS connections over wb sockets.
  In this example the hostname is `10.0.2.2` because the Android emulator runs in a VM that is generally accessible on `10.0.2.2` from the host machine (see https://developer.android.com/studio/run/emulator-networking[Android Emulator networking] documentation).
  +
  NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
  Although `wss:` protocol URLs are not affected, in order to use the `ws:` protocol, applications must target API 27 or lower, or must configure application network security as described https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted[here].

  // end::sgw-repl-pull-callouts[]
  */

}
/*

Snippets demonstrating use of resultsets

*/
package com.example.docsnippet;
        import android.app.Application.*;
        import android.content.Context;
        import android.content.Context.*;
        import java.lang.Object;
        import java.security.Key;
        import java.util.*;
        import com.couchbase.lite.*;
        import com.couchbase.lite.Dictionary;

public class TestQueries {

    // For Documentation

    Datastore ds = new Datastore();

    Database this_Db = ds.getDB();

    String dbName = this_Db.getName();

    HashMap&lt;String, Object&gt; hotels = new HashMap&lt;&gt;();

    Dictionary thisDocsProps;
    String thisDocsId;
    String thisDocsName;
    String thisDocsType;
    String thisDocsCity;



    static {
        init();
    }

    private static void init() {
    }



    public void testQuerySyntaxAll() throws CouchbaseLiteException {

        // tag::query-syntax-all[]
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

      Query listQuery = QueryBuilder.select(SelectResult.all())
              .from(DataSource.database(this_Db));
        // end::query-syntax-all[]

        // tag::query-access-all[]
        try {
            for (Result result : listQuery.execute().allResults()) {
                             // get the k-v pairs from the 'hotel' key's value into a dictionary
                thisDocsProps = result.getDictionary(0)); <i class="conum" data-value="84"></i><b>(84)</b>
                thisDocsId = thisDocsProps.getString("id");
                thisDocsName = thisDocsProps.getString("Name");
                thisDocsType = thisDocsProps.getString("Type");
                thisDocsCity = thisDocsProps.getString("City");

                // Alternatively, access results value dictionary directly
                final Hotel hotel = new Hotel();
                hotel.Id = result.getDictionary(0).getString("id"); <i class="conum" data-value="85"></i><b>(85)</b>
                hotel.Type = result.getDictionary(0).getString("Type");
                hotel.Name = result.getDictionary(0).getString("Name");
                hotel.City = result.getDictionary(0).getString("City");
                hotel.Country= result.getDictionary(0).getString("Country");
                hotel.Description = result.getDictionary(0).getString("Description");
                hotels.put(hotel.Id, hotel);

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }

        // end::query-access-all[]
      }

// tag::query-access-json[]
    // Uses Jackson JSON processor

    ArrayList&lt;Hotel&gt; hotels = new ArrayList&lt;Hotel&gt;();
    HashMap&lt;String, Object&gt; dictFromJSONstring;
    for (Result result : listQuery.execute()) {

      // Get result as JSON string
      String thisJsonString = result.toJSON(); <i class="conum" data-value="86"></i><b>(86)</b>

      // Get Java  Hashmap from JSON string
      HashMap&lt;String, Object&gt; dictFromJSONstring =
              mapper.readValue(thisJsonString, HashMap.class); <i class="conum" data-value="87"></i><b>(87)</b>


      // Use created hashmap
      String hotelId = dictFromJSONstring.get("id").toString();
      String hotelType = dictFromJSONstring.get("type").toString();
      String hotelname = dictFromJSONstring.get("name").toString();


      // Get custom object from JSON string
      Hotel thisHotel =
              mapper.readValue(thisJsonString, Hotel.class); <i class="conum" data-value="88"></i><b>(88)</b>
      hotels.add(thisHotel);

    }

  // end::query-access-json[]
            }


    public void testQuerySyntaxProps() throws CouchbaseLiteException {

        // tag::query-syntax-props[]
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        Query listQuery =
                QueryBuilder.select(SelectResult.expression(Meta.id),
                        SelectResult.property("name"),
                        SelectResult.property("Name"),
                        SelectResult.property("Type"),
                        SelectResult.property("City"))
                        .from(DataSource.database(this_Db));

        // end::query-syntax-props[]

        // tag::query-access-props[]

        try {
            for (Result result : listQuery.execute().allResults()) {

                // get data direct from result k-v pairs
                final Hotel hotel = new Hotel();
                hotel.Id = result.getString("id");
                hotel.Type = result.getString("Type");
                hotel.Name = result.getString("Name");
                hotel.City = result.getString("City");

                // Store created hotel object in a hashmap of hotels
                hotels.put(hotel.Id, hotel);

                // Get result k-v pairs into a 'dictionary' object
                Map &lt;String, Object&gt; thisDocsProps = result.toMap();
                thisDocsId =
                        thisDocsProps.getOrDefault("id",null).toString();
                thisDocsName =
                        thisDocsProps.getOrDefault("Name",null).toString();
                thisDocsType =
                        thisDocsProps.getOrDefault("Type",null).toString();
                thisDocsCity =
                        thisDocsProps.getOrDefault("City",null).toString();

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }

        // end::query-access-props[]
    }


    public void testQuerySyntaxCount() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      // tag::query-syntax-count-only[]
      Query listQuery = QueryBuilder.select(
              SelectResult.expression(Function.count(Expression.string("*"))).as("mycount")) <i class="conum" data-value="89"></i><b>(89)</b>
              .from(DataSource.database(this_Db));

      // end::query-syntax-count-only[]


        // tag::query-access-count-only[]
        try {
            for (Result result : listQuery.execute()) {

                // Retrieve count using key 'mycount'
                Integer altDocId = result.getInt("mycount");

                // Alternatively, use the index
                Integer orDocId = result.getInt(0);
            }
            // Or even miss out the for-loop altogether
            Integer resultCount = listQuery.execute().next().getInt("mycount");

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }
        // end::query-access-count-only[]
    }


    public void testQuerySyntaxId() throws CouchbaseLiteException {
      // tag::query-syntax-id[]
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id).as("metaID"))
                      .from(DataSource.database(this_Db));

      // end::query-syntax-id[]


        // tag::query-access-id[]

        try {
            for (Result result : listQuery.execute().allResults()) {

                // get the ID form the result's k-v pair array
                thisDocsId = result.getString("metaID"); <i class="conum" data-value="90"></i><b>(90)</b>

                // Get document from DB using retrieved ID
                Document thisDoc = this_Db.getDocument(thisDocsId);

                // Process document as required
                thisDocsName = thisDoc.getString("Name");

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }

        // end::query-access-id[]

    }


    // tag::query-syntax-pagination-all[]
    public void testQueryPagination() throws CouchbaseLiteException {


        // tag::query-syntax-pagination[]
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        int thisOffset = 0;
        int thisLimit = 20;

        Query listQuery =
                QueryBuilder
                        .select(SelectResult.all())
                        .from(DataSource.database(this_Db))
                        .limit(Expression.intValue(thisLimit),
                                  Expression.intValue(thisOffset)); <i class="conum" data-value="91"></i><b>(91)</b>

        // end::query-syntax-pagination[]

    }

    // end::query-syntax-pagination-all[]



} // class</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>==== Session Authentication</p>
</div>
<div class="paragraph">
<p>Session authentication is another way to authenticate with Sync Gateway.
A user session must first be created through the <a href="../../../sync-gateway/current/rest-api.html#/session/post__db___session" class="page"><code>POST /{tkn-db}/_session</code></a> endpoint on the Public REST API.
The HTTP response contains a session ID which can then be used to authenticate as the user it was created for.</p>
</div>
<div class="paragraph">
<p><a href="#ex-session-auth">[ex-session-auth]</a> shows how to initiate a one-shot replication with the session ID that is returned from the <code>POST /{tkn-db}/_session</code> endpoint.</p>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset9_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset9_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset9_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
val config = ReplicatorConfiguration(database, target)
config.setAuthenticator(SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447"))

// Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
replicator = Replicator(config)
replicator.start()</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset9_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
config.setAuthenticator(new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447"));

// Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
replicator = new Replicator(config);
replicator.start();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="lbl-repl-hdrs" class="paragraph">
<p>=== Custom&#160;Headers</p>
</div>
<div class="paragraph">
<p>Custom headers can be set on the configuration object.
And the replicator will send those header(s) in every request.
As an example, this feature can be useful to pass additional credentials when there is an authentication or authorization step being done by a proxy server (between Couchbase Lite and Sync Gateway).</p>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset10_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset10_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset10_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">val config = ReplicatorConfiguration(database, endpoint)
val headers: MutableMap&lt;String, String&gt; =
    HashMap()
headers["CustomHeaderName"] = "Value"
config.setHeaders(headers)</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset10_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();
headers.put("CustomHeaderName", "Value");
config.setHeaders(headers);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="lbl-repl-fltrs" class="paragraph">
<p>=== Replication Filters</p>
</div>
<div class="paragraph">
<p>Replication Filters allow you to have quick control over which documents are stored as the result of a push and/or pull replication.</p>
</div>
<div class="paragraph">
<p>==== Push Filter</p>
</div>
<div class="paragraph">
<p>A push filter allows an app to push a subset of a database to the server, which can be very useful in some circumstances.
For instance, high-priority documents could be pushed first, or documents in a "draft" state could be skipped.</p>
</div>
<div class="paragraph">
<p>The following example filters out documents whose <code>type</code> property is equal to <code>draft</code>.</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset11_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset11_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset11_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">val config = ReplicatorConfiguration(database, endpoint)
val headers: MutableMap&lt;String, String&gt; =
    HashMap()
headers["CustomHeaderName"] = "Value"
config.setHeaders(headers)</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset11_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();
headers.put("CustomHeaderName", "Value");
config.setHeaders(headers);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The callback should follow the semantics of a <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">pure function</a>.
Otherwise, long running functions would slow down the replicator considerably.
Furthermore, your callback should not make assumptions about what thread it is being called on.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>==== Pull Filter</p>
</div>
<div class="paragraph">
<p>A pull filter gives an app the ability to validate documents being pulled, and skip ones that fail.
This is an important security mechanism in a peer-to-peer topology with peers that are not fully trusted.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Pull replication filters are not a substitute for channels.
Sync Gateway <a href="../../../sync-gateway/current/channels.html" class="page">channels</a> are designed to be scalable (documents are filtered on the server) whereas a pull replication filter is applied to a document once it has been downloaded.
</td>
</tr>
</table>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset12_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset12_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset12_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">val config = ReplicatorConfiguration(database, endpoint)
val headers: MutableMap&lt;String, String&gt; =
    HashMap()
headers["CustomHeaderName"] = "Value"
config.setHeaders(headers)</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset12_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();
headers.put("CustomHeaderName", "Value");
config.setHeaders(headers);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The callback should follow the semantics of a <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">pure function</a>.
Otherwise, long running functions would slow down the replicator considerably.
Furthermore, your callback should not make assumptions about what thread it is being called on.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Losing access to a document (via the Sync Function) also triggers the pull replication filter.
Filtering out such an event would retain the document locally.
As a result, there would be a local copy of the document disjointed from the one that resides on Couchbase Server.
Further updates to the document stored on Couchbase Server would not be received in pull replications and further local edits could be potentially pushed, which would result in 409 errors since access has been revoked.
</td>
</tr>
</table>
</div>
<div id="lbl-repl-chan" class="paragraph">
<p>=== Channels</p>
</div>
<div class="paragraph">
<p>By default, Couchbase Lite gets all the channels to which the configured user account has access.
This behavior is suitable for most apps that rely on <a href="../../../sync-gateway/current/authentication-users.html" class="page">user authentication</a> and the <a href="../../../sync-gateway/current/sync-function.html" class="page">sync function</a> to specify which data to pull for each user.</p>
</div>
<div class="paragraph">
<p>Optionally, it&#8217;s also possible to specify a comma-separated list of channel names on Couchbase Lite&#8217;s replicator configuration object.
In this case, the replication from Sync Gateway will only pull documents tagged with those channels.</p>
</div>
<div id="lbl-repl-delta" class="paragraph">
<p>=== Delta Sync</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This is an <a href="https://www.couchbase.com/products/editions">Enterprise Edition</a> feature.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With Delta Sync <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>, only the changed parts of a Couchbase document are replicated.
This can result in significant savings in bandwidth consumption as well as throughput improvements, especially when network bandwidth is typically constrained.</p>
</div>
<div class="paragraph">
<p>Replications to a Server (for example, a Sync Gateway, or passive listener) automatically use delta sync if the property is enabled at database level by the server&#8201;&#8212;&#8201;see: <a href="#sync-gateway:ROOT:refer/config-properties.adoc#databases-foo_db-delta_sync" class="page unresolved">databases.$db.delta_sync.enabled</a>.</p>
</div>
<div class="paragraph">
<p><a href="dbreplica.html" class="page">Intra-device Data Sync</a> replications automatically <strong>disable</strong> delta sync, whilst <a href="p2psync-websocket.html" class="page">Peer-to-Peer</a> replications automatically <strong>enable</strong> delta sync.</p>
</div>
<div id="lbl-init-repl" class="paragraph">
<p>== Initialize</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">In this section</dt>
<dd>
<p><a href="#lbl-repl-start">[lbl-repl-start]</a>  | <a href="#lbl-repl-ckpt">[lbl-repl-ckpt]</a></p>
</dd>
</dl>
</div>
<div id="lbl-repl-start" class="paragraph">
<p>=== Start Replicator</p>
</div>
<div class="paragraph">
<p>Use the <code><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/Replicator.html">Replicator</a></code> class&#8217;s <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/Replicator.html#Replicator-com.couchbase.lite.ReplicatorConfiguration-">ReplicatorConfiguration(config)</a> constructor, to initialize the replicator with the configuration you have defined.
You can, optionally, add a change listener (see <a href="#lbl-repl-mon">[lbl-repl-mon]</a>) before starting the replicator running using <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.html#start-boolean-">start()</a>.</p>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset13_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset13_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset13_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">// Create replicator
// Consider holding a reference somewhere
// to prevent the Replicator from being GCed
val thisReplicator = Replicator(thisConfig) <i class="conum" data-value="1"></i><b>(1)</b>

// Start replicator
thisReplicator.start(false) <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset13_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">// Create replicator
// Consider holding a reference somewhere
// to prevent the Replicator from being GCed
final Replicator thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="1"></i><b>(1)</b>

// Start replicator
thisReplicator.start(false); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Initialize the replicator with the configuration</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Start the replicator</td>
</tr>
</table>
</div>
<div id="lbl-repl-ckpt" class="paragraph">
<p>=== Checkpoint Starts</p>
</div>
<div class="paragraph">
<p>Replicators use <a href="refer-glossary.html#checkpoint" class="page">checkpoints</a> to keep track of documents sent to the target database.
Without <a href="refer-glossary.html#checkpoint" class="page">checkpoints</a> , Couchbase Lite would replicate the entire database content to the target database on each connection, even though previous replications may already have replicated some or all of that content.</p>
</div>
<div class="paragraph">
<p>This functionality is generally not a concern to application developers.
However, if you do want to force the replication to start again from zero, use the <a href="refer-glossary.html#checkpoint" class="page">checkpoint</a> reset method <code>replicator.resetCheckpoint()</code> <strong>before</strong> starting the replicator.</p>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset14_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset14_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset14_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">replicator.resetCheckpoint()
replicator.start()</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset14_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">replicator.resetCheckpoint();
replicator.start();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="lbl-repl-mon" class="paragraph">
<p>== Monitor</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">In this section</dt>
<dd>
<p><a href="#lbl-repl-chng">[lbl-repl-chng]</a>  |
<a href="#lbl-repl-status">[lbl-repl-status]</a>  |
<a href="#lbl-repl-evnts">[lbl-repl-evnts]</a> |
<a href="#lbl-repl-pend">[lbl-repl-pend]</a></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>You can monitor a replications status by using a combination of <a href="#lbl-repl-chng">[lbl-repl-chng]</a> and the <code>replication.status.activity</code> property&#8201;&#8212;&#8201;see; <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.Status.html#getActivityLevel--">getActivityLevel()</a>.
This enables you to know, for example, when the replication is actively transferring data and when it has stopped.</p>
</div>
<div class="paragraph">
<p>You can also choose to monitor document changes&#8201;&#8212;&#8201;see: <a href="#lbl-repl-evnts">[lbl-repl-evnts]</a>.</p>
</div>
<div id="lbl-repl-chng" class="paragraph">
<p>== Change Listeners
Use this to monitor changes and to inform on sync progress; this is an optional step.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Best Practice</div>
You should register the listener before starting your replication, to avoid having to do a restart to activate it &#8230;&#8203; and don&#8217;t forget to save the token so you can remove the listener later
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Use the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/Replicator.html">Replicator</a> class to add a change listener as a callback to the Replicator (<a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.html#addChangeListener-java.util.concurrent.Executor-com.couchbase.lite.ReplicatorChangeListener-">addChangeListener()</a>)&#8201;&#8212;&#8201;see: <a href="#ex-repl-mon">[ex-repl-mon]</a>.
You will then be asynchronously notified of state changes.</p>
</div>
<div class="paragraph">
<p>Remove your change listener before stopping the replicator&#8201;&#8212;&#8201;use the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.html#removeChangeListener-com.couchbase.lite.ListenerToken-">removeChangeListener(ListenerToken token)</a> method to do this.</p>
</div>
<div id="lbl-repl-status" class="paragraph">
<p>== Replicator Status</p>
</div>
<div class="paragraph">
<p>You can use the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/Replicator.html">Replicator</a> class&#8217;s <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.html#getStatus--">replicator.getStatus</a> property to check the replicator status.
That is, whether it is actively transferring data or if it has stopped&#8201;&#8212;&#8201;see: <a href="#ex-repl-mon">[ex-repl-mon]</a>.</p>
</div>
<div class="paragraph">
<p>The returned <em>ReplicationStatus</em> structure comprises:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.Status.html#getActivityLevel--">getActivityLevel()</a>&#8201;&#8212;&#8201;stopped, offline, connecting, idle or busy&#8201;&#8212;&#8201;see states described in: <a href="#tbl-states">Table 2</a></p>
</li>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.Status.html#getProgress--">getProgress()</a></p>
<div class="ulist">
<ul>
<li>
<p>completed&#8201;&#8212;&#8201;the total number of changes completed</p>
</li>
<li>
<p>total&#8201;&#8212;&#8201;the total number of changes to be processed</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.Status.html#getError--">getError()</a>&#8201;&#8212;&#8201;the current error, if any</p>
</li>
</ul>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset15_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset15_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset15_kotlin">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset16_adding-a-change-listener"></a>Adding a Change Listener</p>
</li>
<li>
<p><a id="tabset16_using-replicator-status"></a>Using replicator.status</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset16_adding-a-change-listener">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">val thisListener: ListenerToken = addChangeListener { change -&gt;
    val err: CouchbaseLiteException = change.getStatus().getError()
    if (err != null) {
        Log.i(
            TAG,
            "Error code ::  " + err.getCode(),
            e
        )
    }
}</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset16_using-replicator-status">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin">Log.i(
    TAG, "The Replicator is currently " +
            thisReplicator.getStatus().getActivityLevel()
)
Log.i(
    TAG,
    "The Replicator has processed $t"
)
if (thisReplicator.getStatus().getActivityLevel() ===
    Replicator.ActivityLevel.BUSY
) {
    Log.i(
        TAG,
        "Replication Processing"
    )
    Log.i(
        TAG, "It has completed " +
                thisReplicator.getStatus().getProgess().getTotal().toString() +
                " changes"
    )
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset15_java">
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset17_adding-a-change-listener"></a>Adding a Change Listener</p>
</li>
<li>
<p><a id="tabset17_using-replicator-status"></a>Using replicator.status</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset17_adding-a-change-listener">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">ListenerToken thisListener =
  new thisReplicator.addChangeListener(change -&gt; {
    final CouchbaseLiteException err =
     change.getStatus().getError();
     if (err != null) {
       Log.i(TAG, "Error code ::  " + err.getCode(), e);
     }
  });</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset17_using-replicator-status">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">
Log.i(TAG, "The Replicator is currently " +
  thisReplicator.getStatus().getActivityLevel());

Log.i(TAG, "The Replicator has processed " + t);

if (thisReplicator.getStatus().getActivityLevel() ==
  Replicator.ActivityLevel.BUSY) {
    Log.i(TAG, "Replication Processing");
    Log.i(TAG, "It has completed " +
      thisReplicator.getStatus().getProgess().getTotal() +
      " changes");
  }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="lbl-repl-states" class="paragraph">
<p>=== Replication States
<a href="#tbl-states">Table 2</a> shows the different states, or activity levels, reported in the API; and the meaning of each.</p>
</div>
<table id="tbl-states" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Replicator activity levels</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top"><p class="tableblock">State</p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock">Meaning</p></th>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>STOPPED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replication is finished or hit a fatal error.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>OFFLINE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replicator is offline as the remote host is unreachable.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>CONNECTING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replicator is connecting to the remote host.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>IDLE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replication caught up with all the changes available from the server.
The <code>IDLE</code> state is only used in continuous replications.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>BUSY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replication is actively transferring data.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The replication change object also has properties to track the progress (<code>change.status.completed</code> and <code>change.status.total</code>).
Since the replication occurs in batches the total count can vary through the course of a replication.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>=== Replication Status and App Life Cycle</p>
</div>
<div class="paragraph">
<p>Couchbase Lite replications will continue running until the app terminates, unless the remote system, or the application, terminates the connection.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Recall that the Android OS may kill an application without warning.
You should explicitly stop replication processes when they are no longer useful (for example, when they are <code>suspended</code> or <code>idle</code>) to avoid socket connections being closed by the OS, which may interfere with the replication process.
</td>
</tr>
</table>
</div>
<div id="lbl-repl-evnts" class="paragraph">
<p>== Monitor Document Changes</p>
</div>
<div class="paragraph">
<p>You can choose to register for document updates during a replication.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You should register the listener before starting your replication, to avoid having to do a restart to activate it.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, the code snippet in <a href="#ex-reg-doc-listener">[ex-reg-doc-listener]</a> registers a listener to monitor document replication performed by the replicator referenced by the variable <code>replicator</code>.
It prints the document ID of each document received and sent.
Stop the listener as shown in <a href="#ex-stop-doc-listener">[ex-stop-doc-listener]</a>.</p>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset18_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset18_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset18_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets

import android.content.Context
import android.util.Log
import android.widget.Toast
import com.couchbase.code_snippets.TensorFlowModel
import com.couchbase.lite.ArrayFunction
import com.couchbase.lite.BasicAuthenticator
import com.couchbase.lite.Blob
import com.couchbase.lite.Conflict
import com.couchbase.lite.ConflictResolver
import com.couchbase.lite.CouchbaseLite
import com.couchbase.lite.CouchbaseLiteException
import com.couchbase.lite.DataSource
import com.couchbase.lite.Database
import com.couchbase.lite.DatabaseConfiguration
import com.couchbase.lite.DatabaseEndpoint
import com.couchbase.lite.Dictionary
import com.couchbase.lite.Document
import com.couchbase.lite.DocumentFlag
import com.couchbase.lite.EncryptionKey
import com.couchbase.lite.Endpoint
import com.couchbase.lite.Expression
import com.couchbase.lite.FullTextExpression
import com.couchbase.lite.FullTextIndexItem
import com.couchbase.lite.Function
import com.couchbase.lite.IndexBuilder
import com.couchbase.lite.Join
import com.couchbase.lite.ListenerToken
import com.couchbase.lite.LogDomain
import com.couchbase.lite.LogFileConfiguration
import com.couchbase.lite.LogLevel
import com.couchbase.lite.Logger
import com.couchbase.lite.Message
import com.couchbase.lite.MessageEndpoint
import com.couchbase.lite.MessageEndpointConnection
import com.couchbase.lite.MessageEndpointDelegate
import com.couchbase.lite.MessageEndpointListener
import com.couchbase.lite.MessageEndpointListenerConfiguration
import com.couchbase.lite.MessagingCloseCompletion
import com.couchbase.lite.MessagingCompletion
import com.couchbase.lite.Meta
import com.couchbase.lite.MutableDictionary
import com.couchbase.lite.MutableDocument
import com.couchbase.lite.Ordering
import com.couchbase.lite.PredictionFunction
import com.couchbase.lite.PredictiveIndex
import com.couchbase.lite.PredictiveModel
import com.couchbase.lite.ProtocolType
import com.couchbase.lite.Query
import com.couchbase.lite.QueryBuilder
import com.couchbase.lite.ReplicatedDocument
import com.couchbase.lite.Replicator
import com.couchbase.lite.ReplicatorConfiguration
import com.couchbase.lite.ReplicatorConnection
import com.couchbase.lite.Result
import com.couchbase.lite.ResultSet
import com.couchbase.lite.SelectResult
import com.couchbase.lite.SessionAuthenticator
import com.couchbase.lite.URLEndpoint
import com.couchbase.lite.ValueIndex
import com.couchbase.lite.ValueIndexItem
import com.couchbase.lite.Where
import java.io.File
import java.io.IOException
import java.io.InputStream
import java.net.URI
import java.net.URISyntaxException
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.*

// tag::example-app[]
class Examples(private val context: Context) {
    private val database: Database? = null
    private var replicator: Replicator? = null

    //@Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {
        // tag::getting-started[]

        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        // Get the database (and create it if it doesnt exist).
        val config = DatabaseConfiguration()
        config.setDirectory(context.filesDir.absolutePath)
        val database = Database("getting-started", config)


        // Create a new document (i.e. a record) in the database.
        var mutableDoc: MutableDocument = MutableDocument()
            .setFloat("version", 2.0f)
            .setString("type", "SDK")

        // Save it to the database.
        database.save(mutableDoc)

        // Update a document.
        mutableDoc = database.getDocument(mutableDoc.getId()).toMutable()
        mutableDoc.setString("language", "Java")
        database.save(mutableDoc)
        val document: Document = database.getDocument(mutableDoc.getId())
        // Log the document ID (generated by the database) and properties
        Log.i(TAG, "Document ID :: " + document.getId())
        Log.i(TAG, "Learning " + document.getString("language"))

        // Create a query to fetch documents of type SDK.
        val query: Query = QueryBuilder.select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("type").equalTo(Expression.string("SDK")))
        val result: ResultSet = query.execute()
        Log.i(
            TAG,
            "Number of rows ::  " + result.allResults().size()
        )

        // Create replicators to push and pull changes to and from the cloud.
        val targetEndpoint: Endpoint =
            URLEndpoint(URI("ws://localhost:4984/getting-started-db"))
        val replConfig = ReplicatorConfiguration(database, targetEndpoint)
        replConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL)

        // Add authentication.
        replConfig.setAuthenticator(BasicAuthenticator("sync-gateway", "password"))

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        val replicator = Replicator(replConfig)

        // Listen to replicator change events.
        replicator.addChangeListener({ change -&gt;
            if (change.getStatus().getError() != null) {
                Log.i(
                    TAG,
                    "Error code ::  " + change.getStatus().getError().getCode()
                )
            }
        })

        // Start replication.
        replicator.start()

        // end::getting-started[]
        database.delete()
    }

    // end::example-app[]
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun test1xAttachments() {
        // if db exist, delete it
        deleteDB("android-sqlite", context.filesDir)
        ZipUtils.unzip(getAsset("replacedb/android140-sqlite.cblite2.zip"), context.filesDir)
        val db = Database("android-sqlite", DatabaseConfiguration())
        try {
            val doc: Document = db.getDocument("doc1")

            // For Validation
            val attachments: Dictionary = doc.getDictionary("_attachments")
            val blob: Blob = attachments.getBlob("attach1")
            val content: ByteArray = blob.getContent()
            // For Validation
            val attach =
                String.format(Locale.ENGLISH, "attach1").toByteArray()
            Arrays.equals(attach, content)
        } finally {
            // close db
            db.close()
            // if db exist, delete it
            deleteDB("android-sqlite", context.filesDir)
        }
        val document: Document = MutableDocument()

        // tag::1x-attachment[]
        val attachments: Dictionary = document.getDictionary("_attachments")
        val blob: Blob?
        blob = if (attachments != null) attachments.getBlob("avatar") else null
        val content: ByteArray?
        content = if (blob != null) blob.getContent() else null
        // end::1x-attachment[]
    }

    // ### Initializer
    fun testInitializer() {
        // tag::sdk-initializer[]
        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)
        // end::sdk-initializer[]
    }

    // ### New Database
    @Throws(CouchbaseLiteException::class)
    fun testNewDatabase() {
        // tag::new-database[]
        val config = DatabaseConfiguration()
        config.setDirectory(context.filesDir.absolutePath) <i class="conum" data-value="1"></i><b>(1)</b>
        val database = Database("my-database", config)
        // end::new-database[]
        database.delete()
    }

    // ### Database Encryption
    @Throws(CouchbaseLiteException::class)
    fun testDatabaseEncryption() {
        // tag::database-encryption[]
        val config = DatabaseConfiguration()
        config.setEncryptionKey(EncryptionKey("PASSWORD"))
        val database = Database("mydb", config)
        // end::database-encryption[]
    }

    // ### Logging
    fun testLogging() {
        // tag::logging[]
        Database.setLogLevel(LogDomain.DATABASE, LogLevel.VERBOSE)
        Database.setLogLevel(LogDomain.QUERY, LogLevel.VERBOSE)
        // end::logging[]
    }

    fun testEnableCustomLogging() {
        // tag::set-custom-logging[]
        // this custom logger will never be asked to log an event
        // with a log level &lt; WARNING
        Database.log.setCustom(LogTestLogger(LogLevel.WARNING)) <i class="conum" data-value="2"></i><b>(2)</b>
        // end::set-custom-logging[]
    }

    // ### Console logging
    @Throws(CouchbaseLiteException::class)
    fun testConsoleLogging() {
        // tag::console-logging[]
        Database.log.getConsole().setDomain(LogDomain.ALL_DOMAINS) <i class="conum" data-value="3"></i><b>(3)</b>
        Database.log.getConsole().setLevel(LogLevel.VERBOSE) <i class="conum" data-value="4"></i><b>(4)</b>
        // end::console-logging[]
    }

    // ### File logging
    @Throws(CouchbaseLiteException::class)
    fun testFileLogging() {
        // tag::file-logging[]
        val path = context.cacheDir
        val LogCfg = LogFileConfiguration(path.toString()) <i class="conum" data-value="5"></i><b>(5)</b>
        LogCfg.setMaxSize(10240) <i class="conum" data-value="6"></i><b>(6)</b>
        LogCfg.setMaxRotateCount(5) <i class="conum" data-value="7"></i><b>(7)</b>
        LogCfg.setUsePlainText(false) <i class="conum" data-value="8"></i><b>(8)</b>
        Database.log.getFile().setConfig(LogCfg)
        Database.log.getFile().setLevel(LogLevel.INFO) <i class="conum" data-value="9"></i><b>(9)</b>
        // end::file-logging[]
    }

    fun writeConsoleLog() {
        // tag::write-console-logmsg[]
        Database.log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message")
        // end::write-console-logmsg[]
    }

    fun writeCustomLog() {
        // tag::write-custom-logmsg[]
        if (Database.log.Custom)
            Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message")
        // end::write-custom-logmsg[]
    }

    fun writeFileLog() {
        // tag::write-file-logmsg[]
        Database.log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message")
        // end::write-file-logmsg[]
    }

    // ### Loading a pre-built database
    @Throws(IOException::class)
    fun testPreBuiltDatabase() {
        // tag::prebuilt-database[]
        // Note: Getting the path to a database is platform-specific.
        // For Android you need to extract it from your
        // assets to a temporary directory and then pass that path to Database.copy()
        val configuration = DatabaseConfiguration()
        if (!Database.exists("travel-sample", context.filesDir)) {
            ZipUtils.unzip(getAsset("travel-sample.cblite2.zip"), context.filesDir)
            val path = File(context.filesDir, "travel-sample")
            try {
                Database.copy(path, "travel-sample", configuration)
            } catch (e: CouchbaseLiteException) {
                e.printStackTrace()
            }
        }
        // end::prebuilt-database[]
    }

    // helper methods
    // if db exist, delete it
    private fun deleteDB(name: String, dir: File) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            // sometimes, db is still in used, wait for a while. Maximum 3 sec
            for (i in 0..9) {
                try {
                    Database.delete(name, dir)
                    break
                } catch (ex: CouchbaseLiteException) {
                    try {
                        Thread.sleep(300)
                    } catch (ignore: InterruptedException) {
                    }
                }
            }
        }
    }

    // ### Initializers
    fun testInitializers() {
        // tag::initializer[]
        val newTask = MutableDocument()
        newTask.setString("type", "task")
        newTask.setString("owner", "todo")
        newTask.setDate("createdAt", Date())
        try {
            database.save(newTask)
        } catch (e: CouchbaseLiteException) {
            Log.e(TAG, e.toString())
        }
        // end::initializer[]
    }

    // ### Mutability
    fun testMutability() {
        try {
            database.save(MutableDocument("xyz"))
        } catch (ignore: CouchbaseLiteException) {
        }

        // tag::update-document[]
        val document: Document = database.getDocument("xyz")
        val mutableDocument: MutableDocument = document.toMutable()
        mutableDocument.setString("name", "apples")
        try {
            database.save(mutableDocument)
        } catch (e: CouchbaseLiteException) {
            Log.e(TAG, e.toString())
        }
        // end::update-document[]
    }

    // ### Typed Accessors
    fun testTypedAccessors() {
        val newTask = MutableDocument()

        // tag::date-getter[]
        newTask.setValue("createdAt", Date())
        val date: Date = newTask.getDate("createdAt")
        // end::date-getter[]
    }

    // ### Batch operations
    fun testBatchOperations() {
        // tag::batch[]
        try {
            database.inBatch({
                for (i in 0..9) {
                    val doc = MutableDocument()
                    doc.setValue("type", "user")
                    doc.setValue("name", "user $i")
                    doc.setBoolean("admin", false)
                    try {
                        database.save(doc)
                    } catch (e: CouchbaseLiteException) {
                        Log.e(TAG, e.toString())
                    }
                    Log.i(
                        TAG,
                        java.lang.String.format("saved user document %s", doc.getString("name"))
                    )
                }
            })
        } catch (e: CouchbaseLiteException) {
            Log.e(TAG, e.toString())
        }
        // end::batch[]
    }

    // ### Document Expiration
    @Throws(CouchbaseLiteException::class)
    fun DocumentExpiration() {
        // tag::document-expiration[]
        // Purge the document one day from now
        val ttl =
            Instant.now().plus(1, ChronoUnit.DAYS)
        database.setDocumentExpiration("doc123", Date(ttl.toEpochMilli()))

        // Reset expiration
        database.setDocumentExpiration("doc1", null)

        // Query documents that will be expired in less than five minutes
        val fiveMinutesFromNow =
            Instant.now().plus(5, ChronoUnit.MINUTES)
        val query: Query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.expiration.lessThan(Expression.doubleValue(fiveMinutesFromNow.toEpochMilli())))
        // end::document-expiration[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testDocumentChangeListener() {
        // tag::document-listener[]
        database.addDocumentChangeListener(
            "user.john",
            { change -&gt;
                val doc: Document = database.getDocument(change.getDocumentID())
                if (doc != null) {
                    Toast.makeText(
                        context,
                        "Status: " + doc.getString("verified_account"),
                        Toast.LENGTH_SHORT
                    ).show()
                }
            })
        // end::document-listener[]
    }

    // ### Blobs
    fun testBlobs() {
        val newTask = MutableDocument()

        // tag::blob[]
        val `is`: InputStream = getAsset("avatar.jpg") ?: return
        try {
            val blob = Blob("image/jpeg", `is`)
            newTask.setBlob("avatar", blob)
            database.save(newTask)
            val taskBlob: Blob = newTask.getBlob("avatar")
            val bytes: ByteArray = taskBlob.getContent()
        } catch (e: CouchbaseLiteException) {
            Log.e(TAG, e.toString())
        } finally {
            try {
                `is`.close()
            } catch (ignore: IOException) {
            }
        }
        // end::blob[]
    }

    // ### Indexing
    @Throws(CouchbaseLiteException::class)
    fun testIndexing() {
        // For Documentation
        run {
            // tag::query-index[]
            database.createIndex(
                "TypeNameIndex",
                IndexBuilder.valueIndex(
                    ValueIndexItem.property("type"),
                    ValueIndexItem.property("name")
                )
            )
            // end::query-index[]
        }
    }

    // ### SELECT statement
    fun testSelectStatement() {
        run {

            // tag::query-select-meta[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("type")
                )
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.expression(Meta.id))
            try {
                val rs: ResultSet = query.execute()
                for (result in rs) {
                    Log.i(
                        "Sample",
                        java.lang.String.format("hotel id -&gt; %s", result.getString("id"))
                    )
                    Log.i(
                        "Sample",
                        java.lang.String.format("hotel name -&gt; %s", result.getString("name"))
                    )
                }
            } catch (e: CouchbaseLiteException) {
                Log.e("Sample", e.getLocalizedMessage())
            }
        }
    }

    // META function
    @Throws(CouchbaseLiteException::class)
    fun testMetaFunction() {
        // For Documentation
        run {
            val query: Query = QueryBuilder
                .select(SelectResult.expression(Meta.id))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport")))
                .orderBy(Ordering.expression(Meta.id))
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.w(
                    "Sample",
                    java.lang.String.format("airport id -&gt; %s", result.getString("id"))
                )
                Log.w(
                    "Sample",
                    java.lang.String.format("airport id -&gt; %s", result.getString(0))
                )
            }
        }
    }

    // ### all(*)
    @Throws(CouchbaseLiteException::class)
    fun testSelectAll() {
        // For Documentation
        run {

            // tag::query-select-all[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
            // end::query-select-all[]

            // tag::live-query[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            val token: ListenerToken = query.addChangeListener({ change -&gt;
                for (result in change.getResults()) {
                    Log.d(TAG, "results: " + result.getKeys())
                    /* Update UI */
                }
            })

            // Start live query.
            query.execute() <i class="conum" data-value="1"></i><b>(1)</b>
            // end::live-query[]

            // tag::stop-live-query[]
            query.removeChangeListener(token)
            // end::stop-live-query[]
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format(
                        "hotel -&gt; %s",
                        result.getDictionary(DATABASE_NAME).toMap()
                    )
                )
            }
        }
    }

    // ###WHERE statement
    @Throws(CouchbaseLiteException::class)
    fun testWhereStatement() {
        // For Documentation
        run {

            // tag::query-where[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .limit(Expression.intValue(10))
            val rs: ResultSet = query.execute()
            for (result in rs) {
                val all: Dictionary = result.getDictionary(DATABASE_NAME)
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", all.getString("name"))
                )
                Log.i(
                    "Sample",
                    java.lang.String.format("type -&gt; %s", all.getString("type"))
                )
            }
            // end::query-where[]
        }
    }

    fun testQueryDeletedDocuments() {
        // tag::query-deleted-documents[]
        // Query documents that have been deleted
        val query: Where = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted)
        // end::query-deleted-documents[]
    }

    // ####Collection Operators
    @Throws(CouchbaseLiteException::class)
    fun testCollectionStatement() {
        // For Documentation
        run {

            // tag::query-collection-operator-contains[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("public_likes")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("hotel"))
                        .and(
                            ArrayFunction
                                .contains(
                                    Expression.property("public_likes"),
                                    Expression.string("Armani Langworth")
                                )
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format(
                        "public_likes -&gt; %s",
                        result.getArray("public_likes").toList()
                    )
                )
            }
            // end::query-collection-operator-contains[]
        }
    }

    // IN operator
    @Throws(CouchbaseLiteException::class)
    fun testInOperator() {
        // For Documentation
        run {

            // tag::query-collection-operator-in[]
            val values: Array&lt;Expression&gt; = arrayOf&lt;Expression&gt;(
                Expression.property("first"),
                Expression.property("last"),
                Expression.property("username")
            )
            val query: Query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.string("Armani").`in`(values))
            // end::query-collection-operator-in[]
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.w(
                    "Sample",
                    java.lang.String.format("%s", result.toMap().toString())
                )
            }
            // end::query-collection-operator-in[]
        }
    }

    // Pattern Matching
    @Throws(CouchbaseLiteException::class)
    fun testPatternMatching() {
        // For Documentation
        run {

            // tag::query-like-operator[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("landmark"))
                        .and(
                            Function.lower(Expression.property("name"))
                                .like(Function.Expression.string("royal engineers museum"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", result.getString("name"))
                )
            }
            // end::query-like-operator[]
        }
    }

    // ### Wildcard Match
    @Throws(CouchbaseLiteException::class)
    fun testWildcardMatch() {
        // For Documentation
        run {

            // tag::query-like-operator-wildcard-match[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("landmark"))
                        .and(
                            Function.lower(Expression.property("name"))
                                .like(Expression.string("eng%e%"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", result.getString("name"))
                )
            }
            // end::query-like-operator-wildcard-match[]
        }
    }

    // Wildcard Character Match
    @Throws(CouchbaseLiteException::class)
    fun testWildCharacterMatch() {
        // For Documentation
        run {

            // tag::query-like-operator-wildcard-character-match[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("landmark"))
                        .and(
                            Function.lower(Expression.property("name"))
                                .like(Expression.string("eng____r"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", result.getString("name"))
                )
            // end::query-like-operator-wildcard-character-match[]
            }
        }
    }

    // ### Regex Match
    @Throws(CouchbaseLiteException::class)
    fun testRegexMatch() {
        // For Documentation
        run {

            // tag::query-regex-operator[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("landmark"))
                        .and(
                            Function.lower(Expression.property("name"))
                                .regex(Expression.string("\\beng.*r\\b"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format("name -&gt; %s", result.getString("name"))
                )
            }
            // end::query-regex-operator[]
        }
    }

    // JOIN statement
    @Throws(CouchbaseLiteException::class)
    fun testJoinStatement() {
        // For Documentation
        run {

            // tag::query-join[]
            val query: Query = QueryBuilder.select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route"))
            )
                .from(DataSource.database(database).`as`("airline"))
                .join(
                    Join.join(DataSource.database(database).`as`("route"))
                        .on(
                            Meta.id.from("airline")
                                .equalTo(Expression.property("airlineid").from("route"))
                        )
                )
                .where(
                    Expression.property("type").from("route").equalTo(Expression.string("route"))
                        .and(
                            Expression.property("type").from("airline")
                                .equalTo(Expression.string("airline"))
                        )
                        .and(
                            Expression.property("sourceairport").from("route")
                                .equalTo(Expression.string("RIX"))
                        )
                )
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.w(
                    "Sample",
                    java.lang.String.format("%s", result.toMap().toString())
                )
            }
            // end::query-join[]
        }
    }

    // ### GROUPBY statement
    @Throws(CouchbaseLiteException::class)
    fun testGroupByStatement() {
        // For Documentation
        run {

            // tag::query-groupby[]
            val query: Query = QueryBuilder.select(
                SelectResult.expression(Function.count(Expression.string("*"))),
                SelectResult.property("country"),
                SelectResult.property("tz")
            )
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").equalTo(Expression.string("airport"))
                        .and(
                            Expression.property("geo.alt")
                                .greaterThanOrEqualTo(Expression.intValue(300))
                        )
                )
                .groupBy(
                    Expression.property("country"),
                    Expression.property("tz")
                )
                .orderBy(Ordering.expression(Function.count(Expression.string("*"))).descending())
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i(
                    "Sample",
                    java.lang.String.format(
                        "There are %d airports on the %s timezone located in %s and above 300ft",
                        result.getInt("$1"),
                        result.getString("tz"),
                        result.getString("country")
                    )
                )
            }
            // end::query-groupby[]
        }
    }

    // ### ORDER BY statement
    @Throws(CouchbaseLiteException::class)
    fun testOrderByStatement() {
        // For Documentation
        run {

            // tag::query-orderby[]
            val query: Query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name")
                )
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.property("name").ascending())
                .limit(Expression.intValue(10))
            val rs: ResultSet = query.execute()
            for (result in rs) {
                Log.i("Sample", java.lang.String.format("%s", result.toMap()))
            }
            // end::query-orderby[]
        }
    }

    // ### EXPLAIN statement
    @Throws(CouchbaseLiteException::class)
    fun testExplainStatement() {
        // For Documentation
        run {

            // tag::query-explain-all[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("university")))
                .groupBy(Expression.property("country"))
                .orderBy(Ordering.property("name").descending()) <i class="conum" data-value="10"></i><b>(10)</b>
            Log.i(query.explain()) <i class="conum" data-value="11"></i><b>(11)</b>
            // end::query-explain-all[]
            // tag::query-explain-like[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("%hotel%"))) <i class="conum" data-value="12"></i><b>(12)</b>
            Log.i(query.explain())
            // end::query-explain-like[]
            // tag::query-explain-nopfx[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(
                    Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="13"></i><b>(13)</b>
                        .and(Expression.property("name").like(Expression.string("%royal%")))
                )
            Log.i(query.explain())
            // end::query-explain-nopfx[]
            // tag::query-explain-function[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(
                    Function.lower(
                        Expression.property("type").equalTo(Expression.string("hotel"))
                    )
                ) <i class="conum" data-value="14"></i><b>(14)</b>
            Log.i(query.explain())
            // end::query-explain-function[]
            // tag::query-explain-nofunction[]
            val query: Query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))) <i class="conum" data-value="15"></i><b>(15)</b>
            Log.i(query.explain())
            // end::query-explain-nofunction[]
        }
    } // end query-explain
    // end::query-explain[]
    @Throws(CouchbaseLiteException::class)
    fun prepareIndex() {
        // tag::fts-index[]
        database.createIndex(
            "nameFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("name")).ignoreAccents(false)
        )
        // end::fts-index[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testFTS() {
        // tag::fts-query[]
        val whereClause: Expression = FullTextExpression.index("nameFTSIndex").match("buy")
        val ftsQuery: Query = QueryBuilder.select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause)
        val ftsQueryResult: ResultSet = ftsQuery.execute()
        for (result in ftsQueryResult) {
            Log.i(
                TAG,
                java.lang.String.format("document properties %s", result.getString(0))
            )
        }
        // end::fts-query[]
    }

    /* The `tag::replication[]` example is inlined in java.adoc */
    fun testTroubleshooting() {
        // tag::replication-logging[]
        Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE)
        // end::replication-logging[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationBasicAuthentication() {
        // tag::basic-authentication[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setAuthenticator(BasicAuthenticator("username", "password"))

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()
        // end::basic-authentication[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationSessionAuthentication() {
        // tag::session-authentication[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setAuthenticator(SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447"))

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()
        // end::session-authentication[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationStatus() {
        val uri = URI("ws://localhost:4984/db")
        val endpoint: Endpoint = URLEndpoint(uri)
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)

        // tag::replication-status[]
        replicator.addChangeListener({ change -&gt;
            if (change.getStatus().getActivityLevel() === Replicator.ActivityLevel.STOPPED) {
                Log.i(TAG, "Replication stopped")
            }
        })
        // end::replication-status[]
    }

    internal inner class PendingDocsExample {
        private val database: Database? = null
        private var replicator: Replicator? = null

        //  BEGIN PendingDocuments IB -- 11/Feb/21 --
        @Throws(URISyntaxException::class, CouchbaseLiteException::class)
        fun testReplicationPendingDocs() {
            // nottag::replication-pendingdocuments[]
            // ... include other code as required
            //
            val endpoint: Endpoint = URLEndpoint(URI("ws://localhost:4984/db"))
            val config: ReplicatorConfiguration = ReplicatorConfiguration(database, endpoint)
                .setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH)
            // tag::replication-push-pendingdocumentids[]
            replicator = Replicator(config)
            val pendingDocs: Set&lt;String&gt; = replicator.getPendingDocumentIds() <i class="conum" data-value="16"></i><b>(16)</b>

            // end::replication-push-pendingdocumentids[]
            replicator.addChangeListener({ change -&gt;
                onStatusChanged(
                    pendingDocs,
                    change.getStatus()
                )
            })
            replicator.start()

            // ... include other code as required
            // notend::replication-pendingdocuments[]
        }

        //
        // tag::replication-pendingdocuments[]
        //
        private fun onStatusChanged(
            @NonNull pendingDocs: Set&lt;String&gt;,
            @NonNull status: Replicator.Status
        ) {
            // ... sample onStatusChanged function
            //
            Log.i(
                Companion.TAG,
                "Replicator activity level is " + status.getActivityLevel().toString()
            )

            // iterate and report-on previously
            // retrieved pending docids 'list'
            val itr = pendingDocs.iterator()
            while (itr.hasNext()) {
                val docId = itr.next()
                try {
                    // tag::replication-push-isdocumentpending[]
                    if (!replicator.isDocumentPending(docId)) {
                        continue
                    } <i class="conum" data-value="17"></i><b>(17)</b>
                    // end::replication-push-isdocumentpending[]
                    itr.remove()
                    Log.i(
                        Companion.TAG,
                        "Doc ID $docId has been pushed"
                    )
                } catch (e: CouchbaseLiteException) {
                    Log.w(
                        Companion.TAG,
                        "isDocumentPending failed",
                        e
                    )
                }
            }
        } // end::replication-pendingdocuments[]

        //  END PendingDocuments BM -- 19/Feb/21 --
        companion object {
            private const val TAG = "SCRATCH"
        }
    }

    @Throws(URISyntaxException::class)
    fun testHandlingNetworkErrors() {
        val endpoint: Endpoint = URLEndpoint(URI("ws://localhost:4984/db"))
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)

        // tag::replication-error-handling[]
        replicator.addChangeListener({ change -&gt;
            val error: CouchbaseLiteException = change.getStatus().getError()
            if (error != null) {
                Log.w(TAG, "Error code:: %d", error)
            }
        })
        replicator.start()
        // end::replication-error-handling[]
        replicator.stop()
    }

    @Throws(URISyntaxException::class)
    fun testReplicatorDocumentEvent() {
        val endpoint: Endpoint = URLEndpoint(URI("ws://localhost:4984/db"))
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)

        // tag::add-document-replication-listener[]
        val token: ListenerToken = replicator.addDocumentReplicationListener({ replication -&gt;
            if (replication.isPush()) Log.i(
                TAG,
                "Replication type: " + "Push"
            ) else Log.i(TAG, "Replication type: " + "Pull")
            for (document in replication.getDocuments()) {
                Log.i(TAG, "Doc ID: " + document.getID())
                val err: CouchbaseLiteException = document.getError()
                if (err != null) {
                    // There was an error
                    Log.e(TAG, "Error replicating document: ", err)
                    return@addDocumentReplicationListener
                }
                if (document.flags().contains(DocumentFlag.DocumentFlagsDeleted)) {
                    Log.i(
                        TAG,
                        "Successfully replicated a deleted document"
                    )
                }
            }
        })
        replicator.start()
        // end::add-document-replication-listener[]

        // tag::remove-document-replication-listener[]
        replicator.removeChangeListener(token)
        // end::remove-document-replication-listener[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationCustomHeader() {
        val uri = URI("ws://localhost:4984/db")
        val endpoint: Endpoint = URLEndpoint(uri)

        // tag::replication-custom-header[]
        val config = ReplicatorConfiguration(database, endpoint)
        val headers: MutableMap&lt;String, String&gt; =
            HashMap()
        headers["CustomHeaderName"] = "Value"
        config.setHeaders(headers)
        // end::replication-custom-header[]
    }

    // ### Certificate Pinning
    @Throws(URISyntaxException::class, IOException::class)
    fun testCertificatePinning() {
        val uri = URI("ws://localhost:4984/db")
        val endpoint: Endpoint = URLEndpoint(uri)
        val config = ReplicatorConfiguration(database, endpoint)

        // tag::certificate-pinning[]
        val `is`: InputStream = getAsset("cert.cer")
        val cert: ByteArray = IOUtils.toByteArray(`is`)
        if (`is` != null) {
            try {
                `is`.close()
            } catch (ignore: IOException) {
            }
        }
        config.setPinnedServerCertificate(cert)
        // end::certificate-pinning[]
    }

    // ### Reset replicator checkpoint
    @Throws(URISyntaxException::class)
    fun testReplicationResetCheckpoint() {
        val uri = URI("ws://localhost:4984/db")
        val endpoint: Endpoint = URLEndpoint(uri)
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()

        // tag::replication-reset-checkpoint[]
        replicator.resetCheckpoint()
        replicator.start()
        // end::replication-reset-checkpoint[]
        replicator.stop()
    }

    @Throws(URISyntaxException::class)
    fun testReplicationPushFilter() {
        // tag::replication-push-filter[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setPushFilter({ document, flags -&gt; flags.contains(DocumentFlag.DocumentFlagsDeleted) }) <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()
        // end::replication-push-filter[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationPullFilter() {
        // tag::replication-pull-filter[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setPullFilter({ document, flags -&gt; "draft" == document.getString("type") }) <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(config)
        replicator.start()
        // end::replication-pull-filter[]
    }

    @Throws(URISyntaxException::class)
    fun testCustomRetryConfig() {
        // tag::replication-retry-config[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)

        //  other config as required . . .
        // tag::replication-heartbeat-config[]
        config.setHeartbeat(150L) <i class="conum" data-value="18"></i><b>(18)</b>
        // end::replication-heartbeat-config[]
        // tag::replication-maxretries-config[]
        config.setMaxRetries(20L) <i class="conum" data-value="19"></i><b>(19)</b>
        // end::replication-maxretries-config[]
        // tag::replication-maxretrywaittime-config[]
        config.setMaxRetryWaitTime(600L) <i class="conum" data-value="20"></i><b>(20)</b>
        // end::replication-maxretrywaittime-config[]
        val repl = Replicator(config)

        // end::replication-retry-config[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testDatabaseReplica() {
        var config: DatabaseConfiguration? = DatabaseConfiguration()
        val database1 = Database("mydb", config)
        config = DatabaseConfiguration()
        val database2 = Database("db2", config)

        /* EE feature: code below might throw a compilation error
           if it's compiled against CBL Android Community. */
        // tag::database-replica[]
        val targetDatabase = DatabaseEndpoint(database2)
        val replicatorConfig =
            ReplicatorConfiguration(database1, targetDatabase)
        replicatorConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH)

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = Replicator(replicatorConfig)
        replicator.start()
        // end::database-replica[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveModel() {
        val config = DatabaseConfiguration()
        val database = Database("mydb", config)

        // tag::register-model[]
        Database.prediction.registerModel("ImageClassifier", ImageClassifierModel())
        // end::register-model[]

        // tag::predictive-query-value-index[]
        val index: ValueIndex =
            IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")))
        database.createIndex("value-index-image-classifier", index)
        // end::predictive-query-value-index[]

        // tag::unregister-model[]
        Database.prediction.unregisterModel("ImageClassifier")
        // end::unregister-model[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveIndex() {
        val config = DatabaseConfiguration()
        val database = Database("mydb", config)

        // tag::predictive-query-predictive-index[]
        val inputMap: MutableMap&lt;String, Any&gt; =
            HashMap()
        inputMap["numbers"] = Expression.property("photo")
        val input: Expression = Expression.map(inputMap)
        val index: PredictiveIndex = IndexBuilder.predictiveIndex("ImageClassifier", input, null)
        database.createIndex("predictive-index-image-classifier", index)
        // end::predictive-query-predictive-index[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testPredictiveQuery() {
        val config = DatabaseConfiguration()
        val database = Database("mydb", config)

        // tag::predictive-query[]
        val inputProperties: MutableMap&lt;String, Any&gt; =
            HashMap()
        inputProperties["photo"] = Expression.property("photo")
        val input: Expression = Expression.map(inputProperties)
        val prediction: PredictionFunction =
            PredictiveModel.predict("ImageClassifier", input) <i class="conum" data-value="1"></i><b>(1)</b>
        val query: Query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(
                Expression.property("label").equalTo(Expression.string("car"))
                    .and(
                        Expression.property("probability")
                            .greaterThanOrEqualTo(Expression.doubleValue(0.8))
                    )
            )

        // Run the query.
        val result: ResultSet = query.execute()
        Log.d(TAG, "Number of rows: " + result.allResults().size())
        // end::predictive-query[]
    }

    @Throws(URISyntaxException::class)
    fun testReplicationWithCustomConflictResolver() {
        // tag::replication-conflict-resolver[]
        val target = URLEndpoint(URI("ws://localhost:4984/mydatabase"))
        val config = ReplicatorConfiguration(database, target)
        config.setConflictResolver(LocalWinConflictResolver())
        val replication = Replicator(config)
        replication.start()
        // end::replication-conflict-resolver[]
    }

    @Throws(CouchbaseLiteException::class)
    fun testSaveWithCustomConflictResolver() {
        // tag::update-document-with-conflict-handler[]
        val doc: Document = database.getDocument("xyz") ?: return
        val mutableDocument: MutableDocument = doc.toMutable()
        mutableDocument.setString("name", "apples")
        database.save(
            mutableDocument,
            { newDoc, curDoc -&gt;  <i class="conum" data-value="21"></i><b>(21)</b>
                if (curDoc == null) {
                    return@save false
                } <i class="conum" data-value="22"></i><b>(22)</b>
                val dataMap: MutableMap&lt;String, Any&gt; =
                    curDoc.toMap()
                dataMap.putAll(newDoc.toMap()) <i class="conum" data-value="23"></i><b>(23)</b>
                newDoc.setData(dataMap)
                true <i class="conum" data-value="24"></i><b>(24)</b>
            }) <i class="conum" data-value="25"></i><b>(25)</b>
        // end::update-document-with-conflict-handler[]
    }

    companion object {
        private const val TAG = "EXAMPLE"
        private const val DATABASE_NAME = "database"
    }

}

// tag::update-document-with-conflict-handler-callouts[]

&lt;.&gt; The conflict handler code is provided as a lambda.

&lt;.&gt; If the handler cannot resolve a conflict, it can return false.
In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.

&lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.

&lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).

&lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method
// end::update-document-with-conflict-handler-callouts[]


// tag::local-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
internal class LocalWinConflictResolver : ConflictResolver {
    fun resolve(conflict: Conflict): Document {
        return conflict.getLocalDocument()
    }
} // end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
internal class RemoteWinConflictResolver : ConflictResolver {
    fun resolve(conflict: Conflict): Document {
        return conflict.getRemoteDocument()
    }
} // end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
// Using replConfig.setConflictResolver(new MergeConflictResolver());
internal class MergeConflictResolver : ConflictResolver {
    fun resolve(conflict: Conflict): Document {
        val merge: MutableMap&lt;String, Any&gt; =
            conflict.getLocalDocument().toMap()
        merge.putAll(conflict.getRemoteDocument().toMap())
        return MutableDocument(conflict.getDocumentId(), merge)
    }
} // end::merge-conflict-resolver[]

/* ----------------------------------------------------------- */ /* ---------------------  ACTIVE SIDE  ----------------------- */ /* ----------------------------------------------------------- */
internal class BrowserSessionManager private constructor(private val context: Context) :
    MessageEndpointDelegate {
    private var replicator: Replicator? = null

    @Throws(CouchbaseLiteException::class)
    fun initCouchbase() {
        // tag::message-endpoint[]
        val databaseConfiguration = DatabaseConfiguration(context)
        val database = Database("mydb", databaseConfiguration)

        // The delegate must implement the `MessageEndpointDelegate` protocol.
        val messageEndpointTarget = MessageEndpoint(
            "UID:123",
            "active",
            ProtocolType.MESSAGE_STREAM,
            this
        )
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        val config =
            ReplicatorConfiguration(database, messageEndpointTarget)

        // Create the replicator object.
        replicator = Replicator(config)
        // Start the replication.
        replicator.start()
        // end::message-endpoint-replicator[]
    }

    // tag::create-connection[]
    /* implementation of MessageEndpointDelegate */
    @NonNull
    fun createConnection(@NonNull endpoint: MessageEndpoint?): MessageEndpointConnection {
        return ActivePeerConnection() /* implements MessageEndpointConnection */
    } // end::create-connection[]

}

internal class ActivePeerConnection : MessageEndpointConnection {
    private var replicatorConnection: ReplicatorConnection? = null
    fun disconnect() {
        // tag::active-replicator-close[]
        replicatorConnection.close(null)
        // end::active-replicator-close[]
    }

    // tag::active-peer-open[]
    /* implementation of MessageEndpointConnection */
    fun open(
        @NonNull connection: ReplicatorConnection?,
        @NonNull completion: MessagingCompletion
    ) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    // end::active-peer-open[]
    // tag::active-peer-close[]
    fun close(
        error: Exception?,
        @NonNull completion: MessagingCloseCompletion
    ) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete()
    }

    // end::active-peer-close[]
    // tag::active-peer-send[]
    /* implementation of MessageEndpointConnection */
    fun send(@NonNull message: Message?, @NonNull completion: MessagingCompletion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null)
    }

    // end::active-peer-send[]
    fun receive(message: Message?) {
        // tag::active-peer-receive[]
        replicatorConnection.receive(message)
        // end::active-peer-receive[]
    }
} /* ----------------------------------------------------------- */ /* ---------------------  PASSIVE SIDE  ---------------------- */ /* ----------------------------------------------------------- */

internal class PassivePeerConnection private constructor(private val context: Context) :
    MessageEndpointConnection {
    private var messageEndpointListener: MessageEndpointListener? = null
    private var replicatorConnection: ReplicatorConnection? = null

    @Throws(CouchbaseLiteException::class)
    fun startListener() {
        // tag::listener[]
        val databaseConfiguration = DatabaseConfiguration()
        val database = Database("mydb", databaseConfiguration)
        val listenerConfiguration =
            MessageEndpointListenerConfiguration(
                database,
                ProtocolType.MESSAGE_STREAM
            )
        messageEndpointListener = MessageEndpointListener(listenerConfiguration)
        // end::listener[]
    }

    fun stopListener() {
        // tag::passive-stop-listener[]
        messageEndpointListener.closeAll()
        // end::passive-stop-listener[]
    }

    fun accept() {
        // tag::advertizer-accept[]
        val connection = PassivePeerConnection(context) /* implements
        MessageEndpointConnection */
        messageEndpointListener.accept(connection)
        // end::advertizer-accept[]
    }

    fun disconnect() {
        // tag::passive-replicator-close[]
        replicatorConnection.close(null)
        // end::passive-replicator-close[]
    }

    // tag::passive-peer-open[]
    /* implementation of MessageEndpointConnection */
    fun open(
        @NonNull connection: ReplicatorConnection?,
        @NonNull completion: MessagingCompletion
    ) {
        replicatorConnection = connection
        completion.complete(true, null)
    }

    // end::passive-peer-open[]
    // tag::passive-peer-close[]
    /* implementation of MessageEndpointConnection */
    fun close(
        error: Exception?,
        @NonNull completion: MessagingCloseCompletion
    ) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete()
    }

    // end::passive-peer-close[]
    // tag::passive-peer-send[]
    /* implementation of MessageEndpointConnection */
    fun send(@NonNull message: Message?, @NonNull completion: MessagingCompletion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null)
    }

    // end::passive-peer-send[]
    fun receive(message: Message?) {
        // tag::passive-peer-receive[]
        replicatorConnection.receive(message)
        // end::passive-peer-receive[]
    }

} // tag::predictive-model[]

// `tensorFlowModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
internal class ImageClassifierModel : PredictiveModel {
    fun predict(@NonNull input: Dictionary): Dictionary? {
        val blob: Blob = input.getBlob("photo") ?: return null

        // `tensorFlowModel` is a fake implementation
        // this would be the implementation of the ml model you have chosen
        return MutableDictionary(TensorFlowModel.predictImage(blob.getContent())) <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

internal object TensorFlowModel {
    fun predictImage(data: ByteArray?): Map&lt;String, Any&gt;? {
        return null
    }
} // end::predictive-model[]

// tag::custom-logging[]
internal class LogTestLogger(@NonNull level: LogLevel) : Logger {
    @NonNull
    private val level: LogLevel

    @NonNull
    fun getLevel(): LogLevel {
        return level
    }

    fun log(
        @NonNull level: LogLevel?,
        @NonNull domain: LogDomain?,
        @NonNull message: String?
    ) {
        // this method will never be called if param level &lt; this.level
        // handle the message, for example piping it to a third party framework
    }

    init {
        this.level = level
    }
}

class CertAuthListener {
    companion object {
        private const val TAG = "PWD"
        private var CERT_ATTRIBUTES: Map&lt;String, String&gt;? = null

        init {
            val m: Map&lt;String, String&gt; =
                HashMap()
            com.couchbase.code_snippets.m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test")
            com.couchbase.code_snippets.m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase")
            com.couchbase.code_snippets.m.put(
                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT,
                "Mobile"
            )
            com.couchbase.code_snippets.m.put(
                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS,
                "lite@couchbase.com"
            )
            CERT_ATTRIBUTES =
                Collections.unmodifiableMap(com.couchbase.code_snippets.m)
        }
    }

    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val serverIdentity: TLSIdentity = TLSIdentity.createIdentity(
            true,
            CERT_ATTRIBUTES,
            null,
            "server"
        )
        val clientIdentity: TLSIdentity = TLSIdentity.createIdentity(
            false,
            CERT_ATTRIBUTES,
            null,
            "client"
        )
        val uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts())
            ?: throw IOException("Failed to start the server")
        Thread(Runnable {
            try {
                startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb)
                Log.e(TAG, "Success!!")
                deleteIdentity("server")
                Log.e(TAG, "Alias deleted: server")
                deleteIdentity("client")
                Log.e(TAG, "Alias deleted: client")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }).start()
    }

    // start a client replicator
    @Throws(CertificateEncodingException::class, InterruptedException::class)
    fun startClient(
        @NonNull uri: URI?,
        @NonNull cert: Certificate,
        @NonNull clientIdentity: TLSIdentity,
        @NonNull db: Database?
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL)
        config.setContinuous(false)
        configureClientCerts(config, cert, clientIdentity)
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)
        repl.addChangeListener({ change -&gt;
            if (change.getStatus()
                    .getActivityLevel() === AbstractReplicator.ActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        })
        repl.start(false)
        completionLatch.await()
    }
    // tag::listener-config-auth-cert-full[]
    /**
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     *
     *
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    @Throws(CouchbaseLiteException::class)
    fun startServer(
        @NonNull db: Database?,
        @NonNull serverId: TLSIdentity?,
        @NonNull certs: List&lt;Certificate?&gt;?
    ): URI? {
        val config = URLEndpointListenerConfiguration(db)
        config.setPort(0) // this is the default
        config.setDisableTls(false)
        config.setTlsIdentity(serverId)
        config.setAuthenticator(ListenerCertificateAuthenticator(certs))
        val listener = URLEndpointListener(config)
        listener.start()
        val urls: List&lt;URI&gt; = listener.getUrls()
        return if (urls.isEmpty()) {
            null
        } else urls[0]
    }
    // end::listener-config-auth-cert-full[]
    // tag::listener-config-delete-cert-full[]
    /**
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    @Throws(
        KeyStoreException::class,
        CertificateException::class,
        NoSuchAlgorithmException::class,
        IOException::class
    )
    fun deleteIdentity(alias: String?) {
        val keyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        keyStore.deleteEntry(alias) <i class="conum" data-value="26"></i><b>(26)</b>
    }
    // end::listener-config-delete-cert-full[]
    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /**
     * Snippet 4: Create a ClientCertificateAuthenticator and use it in a replicator
     * Snippet 5: Specify a pinned certificate as a byte array
     *
     *
     * Configure Client (active) side certificates
     *
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    @Throws(CertificateEncodingException::class)
    private fun configureClientCerts(
        config: ReplicatorConfiguration,
        @NonNull cert: Certificate,
        @NonNull clientIdentity: TLSIdentity
    ) {

        // Snippet 4: create an authenticator that provides the client identity
        config.setAuthenticator(ClientCertificateAuthenticator(clientIdentity))

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded())
    }
    // notend::p2p-tlsid-tlsidentity-with-label[]
    /**
     * Snippet 5 (supplement): Copy a cert from a resource bundle
     *
     *
     * Configure Client (active) side certificates
     *
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    @Throws(IOException::class)
    private fun readCertMaterialFromBundle(
        @NonNull context: Context,
        resId: Int
    ): ByteArray {
        val out = ByteArrayOutputStream()
        val `in` = context.resources.openRawResource(resId)
        val buf = ByteArray(1024)
        var n: Int
        while (`in`.read(buf).also { n = it } &gt;= 0) {
            out.write(buf, 0, n)
        }
        return out.toByteArray()
    }
}

class PasswordAuthListener {
    // start a server and connect to it with a replicator
    @Throws(CouchbaseLiteException::class, IOException::class)
    fun run() {
        val localDb = Database("localDb")
        var doc = MutableDocument()
        doc.setString("dog", "woof")
        localDb.save(doc)
        val remoteDb = Database("remoteDb")
        doc = MutableDocument()
        doc.setString("cat", "meow")
        localDb.save(doc)
        val uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray())
            ?: throw IOException("Failed to start the server")
        Thread(Runnable {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb)
                Log.e(TAG, "Success!!")
            } catch (e: Exception) {
                Log.e(TAG, "Failed!!", e)
            }
        }).start()
    }

    // start a client replicator
    @Throws(InterruptedException::class)
    fun runClient(
        @NonNull uri: URI?,
        @NonNull username: String?,
        @NonNull password: CharArray?,
        @NonNull db: Database?
    ) {
        val config = ReplicatorConfiguration(db, URLEndpoint(uri))
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL)
        config.setContinuous(false)
        config.setAuthenticator(BasicAuthenticator(username, password))
        val completionLatch = CountDownLatch(1)
        val repl = Replicator(config)
        repl.addChangeListener({ change -&gt;
            if (change.getStatus()
                    .getActivityLevel() === AbstractReplicator.ActivityLevel.STOPPED
            ) {
                completionLatch.countDown()
            }
        })
        repl.start(false)
        completionLatch.await()
    }
    // tag::listener-config-client-auth-pwd-full[]
    /**
     *
     * Start a listener for db that accepts connections using exactly the passed username and password
     *
     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    fun startServer(
        @NonNull db: Database?,
        @NonNull username: String?,
        @NonNull password: CharArray?
    ): URI?

    companion object {
        private const val TAG = "PWD"
    }

    init {
        val config = URLEndpointListenerConfiguration(db)
        config.setPort(0) // this is the default
        config.setDisableTls(true)
        config.setAuthenticator(
            ListenerPasswordAuthenticator { validUser, pwd -&gt;
                username.equals(validUser) &amp;&amp; Arrays.equals(
                    validPassword,
                    pwd
                )
            }
        )
        val listener = URLEndpointListener(config)
        listener.start()
        val urls: List&lt;URI&gt; = listener.getUrls()
        return if (urls.isEmpty()) {
            null
        } else urls[0]
    }
    // end::listener-config-client-auth-pwd-full[]
}


class ExamplesP2p(private val context: Context) {
    private val database: Database? = null
    private var replicator: Replicator? = null

    //@Test
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testGettingStarted() {

        // Initialize the Couchbase Lite system
        CouchbaseLite.init(context)

        /* do some stuff here */
    }

    // PASSIVE PEER STUFF
    fun ibListenerSimple() {
        // tag::listener-simple[]
        val thisConfig =
            URLEndpointListenerConfiguration(thisDB) <i class="conum" data-value="27"></i><b>(27)</b>
        thisConfig.setAuthenticator(
            ListenerPasswordAuthenticator { username, password -&gt;
                username.equals("valid.User") &amp;&amp;
                        Arrays.equals(password, valid.password.string)
            }
        ) <i class="conum" data-value="28"></i><b>(28)</b>
        val thisListener = URLEndpointListener(thisConfig) <i class="conum" data-value="29"></i><b>(29)</b>
        thisListener.start() <i class="conum" data-value="30"></i><b>(30)</b>

        // end::listener-simple[]
    }

    fun ibReplicatorSimple() {
        // tag::replicator-simple[]
        var uri: URI? = null
        try {
            uri = URI("wss://10.0.2.2:4984/db")
        } catch (e: URISyntaxException) {
            e.printStackTrace()
        }
        val theListenerEndpoint: Endpoint = URLEndpoint(uri) <i class="conum" data-value="31"></i><b>(31)</b>
        val thisConfig =
            ReplicatorConfiguration(database, theListenerEndpoint) <i class="conum" data-value="32"></i><b>(32)</b>
        thisConfig.setAcceptOnlySelfSignedServerCertificate(true) <i class="conum" data-value="33"></i><b>(33)</b>
        val thisAuth = BasicAuthenticator(
            "valid.user",
            "valid.password.string"
        )
        thisConfig.setAuthenticator(thisAuth) <i class="conum" data-value="34"></i><b>(34)</b>
        replicator = Replicator(config) <i class="conum" data-value="35"></i><b>(35)</b>
        replicator.start() <i class="conum" data-value="36"></i><b>(36)</b>

        // end::replicator-simple[]
    }

    fun ibPassListener() {
// EXAMPLE 1
        // tag::listener-initialize[]
        // tag::listener-config-db[]
        // Initialize the listener config
        val thisConfig =
            URLEndpointListenerConfiguration(thisDB) <i class="conum" data-value="37"></i><b>(37)</b>

        // end::listener-config-db[]
        // tag::listener-config-port[]
        thisConfig.setPort(55990) <i class="conum" data-value="38"></i><b>(38)</b>

        // end::listener-config-port[]
        // tag::listener-config-netw-iface[]
        thisConfig.setNetworkInterface("10.1.1.10") <i class="conum" data-value="39"></i><b>(39)</b>

        // end::listener-config-netw-iface[]
        // tag::listener-config-delta-sync[]
        thisConfig.setEnableDeltaSync(false) <i class="conum" data-value="40"></i><b>(40)</b>

        // end::listener-config-delta-sync[]
        // tag::listener-config-tls-full[]
        // Configure server security
        // tag::listener-config-tls-enable[]
        thisConfig.setDisableTls(false) <i class="conum" data-value="41"></i><b>(41)</b>

        // end::listener-config-tls-enable[]
        // tag::listener-config-tls-id-anon[]
        // Use an Anonymous Self-Signed Cert
        thisConfig.setTlsIdentity(null) <i class="conum" data-value="42"></i><b>(42)</b>

        // end::listener-config-tls-id-anon[]

        // tag::listener-config-client-auth-pwd[]
        // Configure Client Security using an Authenticator
        // For example, Basic Authentication <i class="conum" data-value="43"></i><b>(43)</b>
        thisConfig.setAuthenticator(
            ListenerPasswordAuthenticator { validUser, validPassword -&gt;
                username.equals(validUser) &amp;&amp;
                        Arrays.equals(password, validPassword)
            }
        )

        // end::listener-config-client-auth-pwd[]
        // tag::listener-start[]
        // Initialize the listener
        val thisListener = URLEndpointListener(thisConfig) <i class="conum" data-value="44"></i><b>(44)</b>

        // Start the listener
        thisListener.start() <i class="conum" data-value="45"></i><b>(45)</b>

        // end::listener-start[]
        // end::listener-initialize[]
    }

    fun ibListenerGetNetworkInterfaces() {
        // tag::listener-get-network-interfaces[]
        val thisConfig =
            URLEndpointListenerConfiguration(database)
        val thisListener = URLEndpointListener(thisConfig)
        thisListener.start()
        Log.i(
            TAG,
            "URLS are " + thisListener.getUrls()
        )

        // end::listener-get-network-interfaces[]
    }

    fun ibListenerLocalDb() {
        // tag::listener-local-db[]
        // . . . preceding application logic . . .
        CouchbaseLite.init(context) <i class="conum" data-value="46"></i><b>(46)</b>
        val thisDB = Database("passivepeerdb")

        // end::listener-local-db[]
    }

    fun ibListenerConfigTlsDisable() {
        // tag::listener-config-tls-disable[]
        thisConfig.setDisableTls(true) <i class="conum" data-value="47"></i><b>(47)</b>

        // end::listener-config-tls-disable[]
    }

    fun ibListenerConfigTlsIdFull() {
        // tag::listener-config-tls-id-full[]
        // tag::listener-config-tls-id-caCert[]
        // Use CA Cert
        // Import a key pair into secure storage
        // Create a TLSIdentity from the imported key-pair
        val thisKeyPair: InputStream = FileInputStream()
        thisKeyPair.javaClass.getResourceAsStream("serverkeypair.p12") <i class="conum" data-value="48"></i><b>(48)</b>
        val thisIdentity: TLSIdentity = importIdentity(
            EXTERNAL_KEY_STORE_TYPE,  // KeyStore type, eg: "PKCS12"
            thisKeyPair,  // An InputStream from the keystore
            password,  // The keystore password
            EXTERNAL_KEY_ALIAS,  // The alias to be used (in external keystore)
            null,  // The key password
            "test-alias" // The alias for the imported key
        )

        // end::listener-config-tls-id-caCert[]

        // tag::listener-config-tls-id-set[]
        // Set the TLS Identity
        thisConfig.setTlsIdentity(thisIdentity) <i class="conum" data-value="49"></i><b>(49)</b>

        // end::listener-config-tls-id-set[]
// end::listener-config-tls-id-full[]
    }

    fun ibListenerConfigClientAuthRoot() {
// tag::listener-config-client-root-ca[]
        // tag::listener-config-client-auth-root[]
        // Configure the client authenticator
        // to validate using ROOT CA
        // thisClientID.certs is a list containing a client cert to accept
        // and any other certs needed to complete a chain between the client cert
        // and a CA
        val validId: TLSIdentity =
            TLSIdentity.getIdentity("Our Corporate Id")
                ?: throw IllegalStateException("Cannot find corporate id") // get the identity <i class="conum" data-value="50"></i><b>(50)</b>
        thisConfig.setTlsIdentity(validId)
        thisConfig.setAuthenticator(
            ListenerCertificateAuthenticator(validId.getCerts())
        ) <i class="conum" data-value="51"></i><b>(51)</b>
        // accept only clients signed by the corp cert
        val thisListener = URLEndpointListener(thisConfig)

        // end::listener-config-client-auth-root[]
// end::listener-config-client-root-ca[]
    }

    fun ibListenerConfigTlsDisable() {

        // tag::listener-config-tls-disable[]
        thisConfig.disableTLS(true)

        // end::listener-config-tls-disable[]
    }

    fun ibListenerStatusCheck() {
        // tag::listener-status-check[]
        val connectionCount: Int = thisListener.getStatus().getConnectionCount() <i class="conum" data-value="52"></i><b>(52)</b>
        val activeConnectionCount: Int =
            thisListener.getStatus().getActiveConnectionCount() <i class="conum" data-value="53"></i><b>(53)</b>

        // end::listener-status-check[]
    }

    fun ibListenerStop() {

        // tag::listener-stop[]
        thisListener.stop()

        // end::listener-stop[]
    }

    // ACTIVE PEER STUFF
    // Replication code
    @Throws(CouchbaseLiteException::class, URISyntaxException::class)
    fun testActPeerSync() {
        // tag::p2p-act-rep-func[]
        // tag::p2p-act-rep-initialize[]
        // initialize the replicator configuration
        val thisConfig = ReplicatorConfiguration(
            thisDB,
            URLEndpoint(URI("wss://listener.com:8954"))
        ) <i class="conum" data-value="54"></i><b>(54)</b>

        // end::p2p-act-rep-initialize[]
        // tag::p2p-act-rep-config-type[]
        // Set replicator type
        thisConfig.setReplicatorType(
            ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL
        )

        // end::p2p-act-rep-config-type[]
        // tag::p2p-act-rep-config-cont[]
        // Configure Sync Mode
        thisConfig.setContinuous(false) // default value

        // end::p2p-act-rep-config-cont[]
        // tag::p2p-act-rep-config-self-cert[]
        // Configure Server Authentication --
        // only accept self-signed certs
        thisConfig.setAcceptOnlySelfSignedServerCertificate(true) <i class="conum" data-value="55"></i><b>(55)</b>

        // end::p2p-act-rep-config-self-cert[]
        // tag::p2p-act-rep-auth[]
        // Configure the credentials the
        // client will provide if prompted
        val thisAuth: BasicAuthenticator <i class="conum" data-value="56"></i><b>(56)</b>
        thisAuth = BasicAuthenticator("Our Username", "Our PasswordValue")
        thisConfig.setAuthenticator(thisAuth)

        // end::p2p-act-rep-auth[]
        // tag::p2p-act-rep-config-conflict[]
        /* Optionally set custom conflict resolver call back */thisConfig.setConflictResolver() <i class="conum" data-value="57"></i><b>(57)</b>

        // end::p2p-act-rep-config-conflict[]
        // tag::p2p-act-rep-start-full[]
        // Create replicator
        // Consider holding a reference somewhere
        // to prevent the Replicator from being GCed
        val thisReplicator = Replicator(thisConfig) <i class="conum" data-value="58"></i><b>(58)</b>

        // tag::p2p-act-rep-add-change-listener[]
        // tag::p2p-act-rep-add-change-listener-label[]
        // Optionally add a change listener <i class="conum" data-value="59"></i><b>(59)</b>
        // end::p2p-act-rep-add-change-listener-label[]
        val thisListener: ListenerToken = addChangeListener { change -&gt;
            val err: CouchbaseLiteException = change.getStatus().getError()
            if (err != null) {
                Log.i(
                    TAG,
                    "Error code ::  " + err.getCode(),
                    e
                )
            }
        }

        // end::p2p-act-rep-add-change-listener[]
        // tag::p2p-act-rep-start[]
        // Start replicator
        thisReplicator.start(false) <i class="conum" data-value="60"></i><b>(60)</b>

        // end::p2p-act-rep-start[]
        // end::p2p-act-rep-start-full[]
        // end::p2p-act-rep-func[]         ***** End p2p-act-rep-func
    }

    fun ibReplicatorConfig() {
        // BEGIN additional snippets
        // tag::p2p-act-rep-config-tls-full[]
        // tag::p2p-act-rep-config-cacert[]
        // Configure Server Security
        // -- only accept CA attested certs
        thisConfig.setAcceptOnlySelfSignedServerCertificate(false) <i class="conum" data-value="61"></i><b>(61)</b>

        // end::p2p-act-rep-config-cacert[]
        // tag::p2p-act-rep-config-pinnedcert[]

        // Return the remote pinned cert (the listener's cert)
        val returnedCert: Byte =
            ByteArray(thisConfig.getPinnedCertificate()) // Get listener cert if pinned
        // end::p2p-act-rep-config-pinnedcert[]

        // end::p2p-act-rep-config-tls-full[]
        // tag::p2p-tlsid-tlsidentity-with-label[]
        // ... other replicator configuration
        // Provide a client certificate to the server for authentication
        val thisClientId: TLSIdentity = TLSIdentity.getIdentity("clientId")
            ?: throw IllegalStateException("Cannot find client id") <i class="conum" data-value="62"></i><b>(62)</b>
        thisConfig.setAuthenticator(ClientCertificateAuthenticator(thisClientId)) <i class="conum" data-value="63"></i><b>(63)</b>
        // ... other replicator configuration
        val thisReplicator = Replicator(thisConfig)

        // end::p2p-tlsid-tlsidentity-with-label[]
        // tag::p2p-act-rep-config-cacert-pinned[]

        // Use the pinned certificate from the byte array (cert)
        thisConfig.setPinnedServerCertificate(cert.getEncoded()) <i class="conum" data-value="64"></i><b>(64)</b>
        // end::p2p-act-rep-config-cacert-pinned[]
    }

    fun ibP2pReplicatorStatus() {
        // tag::p2p-act-rep-status[]
        Log.i(
            TAG, "The Replicator is currently " +
                    thisReplicator.getStatus().getActivityLevel()
        )
        Log.i(
            TAG,
            "The Replicator has processed $t"
        )
        if (thisReplicator.getStatus().getActivityLevel() ===
            Replicator.ActivityLevel.BUSY
        ) {
            Log.i(
                TAG,
                "Replication Processing"
            )
            Log.i(
                TAG, "It has completed " +
                        thisReplicator.getStatus().getProgess().getTotal().toString() +
                        " changes"
            )
        }
        // end::p2p-act-rep-status[]
    }

    fun ibP2pReplicatorStop() {
        // tag::p2p-act-rep-stop[]
        // Stop replication.
        thisReplicator.stop() <i class="conum" data-value="65"></i><b>(65)</b>
        // end::p2p-act-rep-stop[]
    }

    fun ibP2pListener() {
        CouchbaseLite.init(context)
        val thisDB = Database("passivepeerdb") <i class="conum" data-value="66"></i><b>(66)</b>
        // Initialize the listener config
        val thisConfig =
            URLEndpointListenerConfiguration(database)
        thisConfig.setPort(55990) /* &lt;.&gt;  Optional; defaults to auto */
        thisConfig.setDisableTls(false) /* &lt;.&gt;  Optional; defaults to false */
        thisConfig.setEnableDeltaSync(true) /* &lt;.&gt; Optional; defaults to false */

        // Configure the client authenticator (if using basic auth)
        val auth = ListenerPasswordAuthenticator(
            "username", "password"
        ) <i class="conum" data-value="67"></i><b>(67)</b>
        thisConfig.setAuthenticator(auth) <i class="conum" data-value="68"></i><b>(68)</b>

        // Initialize the listener
        val listener = URLEndpointListener(thisConfig) <i class="conum" data-value="69"></i><b>(69)</b>

        // Start the listener
        listener.start() <i class="conum" data-value="70"></i><b>(70)</b>


        // tag::createTlsIdentity[]

//        Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
//                TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
//                TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
//                TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
//        );
        val thisIdentity: TLSIdentity = createIdentity(true, X509_ATTRIBUTES, null, "test-alias")

        // end::createTlsIdentity[]

        // tag::p2p-tlsid-store-in-keychain[]
        // end::p2p-tlsid-store-in-keychain[]


        // tag::deleteTlsIdentity[]
        // tag::p2p-tlsid-delete-id-from-keychain[]
        val thisAlias = "alias-to-delete"
        val thisKeyStore: KeyStore = KeyStore.getInstance("AndroidKeyStore")
        thisKeyStore.load(null)
        thisKeyStore.deleteEntry(thisAlias)

        // end::p2p-tlsid-delete-id-from-keychain[]
        // end::deleteTlsIdentity[]

        // tag::retrieveTlsIdentity[]
        // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label
        val thisIdentity: TLSIdentity = getIdentity("couchbase-docs-cert")
        // end::retrieveTlsIdentity[]
    }

    // tag::sgw-repl-pull[]
    fun ibRplicatorPull() {
        var database: Database
        var replicator: Replicator <i class="conum" data-value="71"></i><b>(71)</b>
        var uri: URI? = null
        try {
            uri = URI("wss://10.0.2.2:4984/db") <i class="conum" data-value="72"></i><b>(72)</b>
        } catch (e: URISyntaxException) {
            e.printStackTrace()
        }
        val endpoint: Endpoint = URLEndpoint(uri)
        val config = ReplicatorConfiguration(database, endpoint)
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL)
        this.replicator = Replicator(config)
        this.replicator.start()
    }

    // end::sgw-repl-pull[]
    // tag::sgw-act-rep-initialize[]
    // initialize the replicator configuration
    val thisConfig: ReplicatorConfiguration = ReplicatorConfiguration(
        thisDB,
        URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))
    ) // &lt;.&gt; // end::sgw-act-rep-initialize[]

    /* C A L L O U T S

// Listener Callouts

  // tag::listener-callouts-full[]

    // tag::listener-start-callouts[]
    &lt;.&gt; Initialize the listener instance using the configuration settings.
    &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.

  // end::listener-start-callouts[]

  // tag::listener-status-check-callouts[]

  &lt;.&gt; `connectionCount` -- the total number of connections served by the listener
  &lt;.&gt; `activeConnectionCount` -- the number of active (BUSY) connections currently being served by the listener
  //
  // end::listener-status-check-callouts[]

    // end::listener-callouts-full[]


    // tag::p2p-act-rep-config-cacert-pinned-callouts[]
  &lt;.&gt; Configure the pinned certificate using data from the byte array `cert`
  // end::p2p-act-rep-config-cacert-pinned-callouts[]

  // tag::p2p-tlsid-tlsidentity-with-label-callouts[]
  &lt;.&gt; Attempt to get the identity from secure storage
  &lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity

  // end::p2p-tlsid-tlsidentity-with-label-callouts[]

  // tag::sgw-repl-pull-callouts[]
  &lt;.&gt; A replication is an asynchronous operation.
  To keep a reference to the `replicator` object, you can set it as an instance property.
  &lt;.&gt; The URL scheme for remote database URLs uses `ws:`, or `wss:` for SSL/TLS connections over wb sockets.
  In this example the hostname is `10.0.2.2` because the Android emulator runs in a VM that is generally accessible on `10.0.2.2` from the host machine (see https://developer.android.com/studio/run/emulator-networking[Android Emulator networking] documentation).
  +
  NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
  Although `wss:` protocol URLs are not affected, in order to use the `ws:` protocol, applications must target API 27 or lower, or must configure application network security as described https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted[here].

  // end::sgw-repl-pull-callouts[]
  */
}





    fun testQuerySyntaxAll() {

        // tag::query-syntax-all[]
//        try {
//            this_Db = new Database("hotels");
//        } catch (CouchbaseLiteException e) {
//            e.printStackTrace();
//        }
        val db = openOrCreateDatabaseForUser(currentUser)
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(db!!))
        // end::query-syntax-all[]

        // tag::query-access-all[]
        val hotels: HashMap&lt;String, Hotel&gt; = HashMap&lt;String, Hotel&gt;()
        try {
            for (result in listQuery.execute().allResults()) {
                // get the k-v pairs from the 'hotel' key's value into a dictionary
                val thisDocsProps = result.getDictionary(0) <i class="conum" data-value="73"></i><b>(73)</b>
                val thisDocsId = thisDocsProps!!.getString("id")
                val thisDocsName = thisDocsProps.getString("name")
                val thisDocsType = thisDocsProps.getString("type")
                val thisDocsCity = thisDocsProps.getString("city")

                // Alternatively, access results value dictionary directly
                val hotel = Hotel()
                hotel.id = result.getDictionary(0)!!.getString("id").toString() <i class="conum" data-value="74"></i><b>(74)</b>
                hotel.type = result.getDictionary(0)!!.getString("type").toString()
                hotel.name = result.getDictionary(0)!!.getString("name").toString()
                hotel.city = result.getDictionary(0)!!.getString("city").toString()
                hotel.country = result.getDictionary(0)!!.getString("country").toString()
                hotel.description = result.getDictionary(0)!!.getString("description").toString()
                hotels[hotel.id] = hotel
            }
        } catch (e: CouchbaseLiteException) {
            e.printStackTrace()
        }

        // end::query-access-all[]
    }

    @Throws(CouchbaseLiteException::class, JSONException::class)
    fun testQuerySyntaxJson() {
        val db = openOrCreateDatabaseForUser(currentUser)
        // tag::query-syntax-json[]
        // Example assumes Hotel class object defined elsewhere
//        Database db = null;
//        try {
//                db = new Database(dbName);
//        } catch (CouchbaseLiteException e) {
//            e.printStackTrace();
//        }

        // Build the query
        val listQuery: Query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(db!!))

        // end::query-syntax-json[]

      // tag::query-access-json[]
        // Uses Jackson JSON processor
        val mapper = ObjectMapper();
        val hotels: ArrayList&lt;Hotel&gt; = ArrayList&lt;Hotel&gt;()

        for (result in listQuery.execute()) {

          // Get result as JSON string
          val thisJsonString1: String = result.toJSON() <i class="conum" data-value="75"></i><b>(75)</b>

          // Get Hashmap from JSON string
          val dictFromJSONstring =
              mapper.readValue(thisJsonString, HashMap::class.java) <i class="conum" data-value="76"></i><b>(76)</b>

          // Use created hashmap
          val hotelId = dictFromJSONstring["id"].toString() //
          val hotelType = dictFromJSONstring["type"].toString()
          val hotelname = dictFromJSONstring["name"].toString()


          // Get custom object from JSON strin
          val thisHotel =
              mapper.readValue(thisJsonString, Hotel::class.java) <i class="conum" data-value="77"></i><b>(77)</b>
          hotels.add(thisHotel)

      }
      // end::query-access-json[]
    }
    /* end func testQuerySyntaxJson */</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset18_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">//
// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.support.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;
import com.example.docsnippet.Datastore;
import com.example.docsnippet.Hotel;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

// tag::example-app[]
public class docOnly_Examples {
  private static final String TAG = "EXAMPLE";

  private static final String DATABASE_NAME = "database";

  private final Context context;
  private Database database;
  private Replicator replicator;

  public docOnly_Examples(Context context) { this.context = context; }

  //@Test
  public void testGettingStarted() throws CouchbaseLiteException, URISyntaxException {
    // tag::getting-started[]

    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);

    // Get the database (and create it if it doesnt exist).
    DatabaseConfiguration config = new DatabaseConfiguration();

    config.setDirectory(context.getFilesDir().getAbsolutePath());

    Database database = new Database("getting-started", config);


    // Create a new document (i.e. a record) in the database.
    MutableDocument mutableDoc = new MutableDocument()
    .setFloat("version", 2.0F)
    .setString("type", "SDK");

    // Save it to the database.
    database.save(mutableDoc);

    // Update a document.
    mutableDoc = database.getDocument(mutableDoc.getId()).toMutable();
    mutableDoc.setString("language", "Java");
    database.save(mutableDoc);
    Document document = database.getDocument(mutableDoc.getId());
    // Log the document ID (generated by the database) and properties
    Log.i(TAG, "Document ID :: " + document.getId());
    Log.i(TAG, "Learning " + document.getString("language"));

    // Create a query to fetch documents of type SDK.
    Query query = QueryBuilder.select(SelectResult.all())
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("SDK")));
    ResultSet result = query.execute();
    Log.i(TAG, "Number of rows ::  " + result.allResults().size());

    // Create replicators to push and pull changes to and from the cloud.
    Endpoint targetEndpoint = new URLEndpoint(new URI("ws://localhost:4984/getting-started-db"));
    ReplicatorConfiguration replConfig = new ReplicatorConfiguration(database, targetEndpoint);
    replConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // Add authentication.
    replConfig.setAuthenticator(new BasicAuthenticator("sync-gateway", "password"));

    // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
    Replicator replicator = new Replicator(replConfig);

    // Listen to replicator change events.
    replicator.addChangeListener(change -&gt; {
      if (change.getStatus().getError() != null) {
        Log.i(TAG, "Error code ::  " + change.getStatus().getError().getCode());
      }
    });

    // Start replication.
    replicator.start();

    // end::getting-started[]

    database.delete();
  }
  // end::example-app[]

  public void test1xAttachments() throws CouchbaseLiteException, IOException {
    // if db exist, delete it
    deleteDB("android-sqlite", context.getFilesDir());

    ZipUtils.unzip(getAsset("replacedb/android140-sqlite.cblite2.zip"), context.getFilesDir());

    Database db = new Database("android-sqlite", new DatabaseConfiguration());
    try {

      Document doc = db.getDocument("doc1");

      // For Validation
      Dictionary attachments = doc.getDictionary("_attachments");
      Blob blob = attachments.getBlob("attach1");
      byte[] content = blob.getContent();
      // For Validation

      byte[] attach = String.format(Locale.ENGLISH, "attach1").getBytes();
      Arrays.equals(attach, content);

    } finally {
      // close db
      db.close();
      // if db exist, delete it
      deleteDB("android-sqlite", context.getFilesDir());
    }

    Document document = new MutableDocument();

    // tag::1x-attachment[]
    Dictionary attachments = document.getDictionary("_attachments");
    Blob blob = attachments != null ? attachments.getBlob("avatar") : null;
    byte[] content = blob != null ? blob.getContent() : null;
    // end::1x-attachment[]
  }

  // ### Initializer
  public void testInitializer() {
    // tag::sdk-initializer[]
    // Initialize the Couchbase Lite system
    CouchbaseLite.init(context);
    // end::sdk-initializer[]
  }

  // ### New Database
  public void testNewDatabase() throws CouchbaseLiteException {
    // tag::new-database[]
    final DatabaseConfiguration config = new DatabaseConfiguration();
    config.setDirectory(context.getFilesDir().getAbsolutePath()); <i class="conum" data-value="1"></i><b>(1)</b>

    Database database = new Database("my-database", config);
    // end::new-database[]

    // tag::close-database[]
    database.close();

    // end::close-database[]

    database.delete();
  }

  // ### Database Encryption
  public void testDatabaseEncryption() throws CouchbaseLiteException {
    // tag::database-encryption[]
    DatabaseConfiguration config = new DatabaseConfiguration();
    config.setEncryptionKey(new EncryptionKey("PASSWORD"));
    Database database = new Database("mydb", config);
    // end::database-encryption[]
  }

  // ### Logging
  public void testLogging() {
    // tag::logging[]
    Database.setLogLevel(LogDomain.DATABASE, LogLevel.VERBOSE);
    Database.setLogLevel(LogDomain.QUERY, LogLevel.VERBOSE);
    // end::logging[]
    }

    public void testEnableCustomLogging() {
        // tag::set-custom-logging[]
        Database.log.setCustom(new LogTestLogger(LogLevel.WARNING)); <i class="conum" data-value="2"></i><b>(2)</b>
        // end::set-custom-logging[]
    }

    // ### Console logging
    public void testConsoleLogging() throws CouchbaseLiteException {
      // tag::console-logging[]
          Database.log.getConsole().setDomain(LogDomain.ALL_DOMAINS);  <i class="conum" data-value="3"></i><b>(3)</b>
          Database.log.getConsole().setLevel(LogLevel.VERBOSE); <i class="conum" data-value="4"></i><b>(4)</b>
      // end::console-logging[]
      // tag::console-logging-db[]
          Database.log.getConsole().setDomain(LogDomain.DATABASE);

      // end::console-logging-db[]
    }

    // ### File logging
    public void testFileLogging() throws CouchbaseLiteException {
        // tag::file-logging[]
        final File path = context.getCacheDir();

        LogFileConfiguration LogCfg =
          new LogFileConfiguration(path.toString()); <i class="conum" data-value="5"></i><b>(5)</b>
        LogCfg.setMaxSize(10240); <i class="conum" data-value="6"></i><b>(6)</b>
        LogCfg.setMaxRotateCount(5); <i class="conum" data-value="7"></i><b>(7)</b>
        LogCfg.setUsePlainText(false); <i class="conum" data-value="8"></i><b>(8)</b>
        Database.log.getFile().setConfig(LogCfg);
        Database.log.getFile().setLevel(LogLevel.INFO); <i class="conum" data-value="9"></i><b>(9)</b>
        // end::file-logging[]
    }

    public void writeConsoleLog()
    {
        // tag::write-console-logmsg[]
        Database.log.Console.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
        // end::write-console-logmsg[]
    }
    public void writeCustomLog()
    {
        // tag::write-custom-logmsg[]
        Database.log.Custom?.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
        // end::write-custom-logmsg[]
    }


    public void writeFileLog()
    {
        // tag::write-file-logmsg[]
        Database.log.File.Log(LogLevel.Warning, LogDomain.Replicator, "Any old log message");
        // end::write-file-logmsg[]
    }




    // ### Loading a pre-built database
    public void testPreBuiltDatabase() throws IOException {
      // tag::prebuilt-database[]
      // Note: Getting the path to a database is platform-specific.
      // For Android you need to extract it from your
      // assets to a temporary directory and then pass that path to Database.copy()
      DatabaseConfiguration configuration = new DatabaseConfiguration();
      if (!Database.exists("travel-sample", context.getFilesDir())) {
            ZipUtils.unzip(getAsset("travel-sample.cblite2.zip"), context.getFilesDir());
            File path = new File(context.getFilesDir(), "travel-sample");
            try {
                Database.copy(path, "travel-sample", configuration);
            } catch (CouchbaseLiteException e) {
                e.printStackTrace();
            }
        }
        // end::prebuilt-database[]
    }

    // helper methods

    // if db exist, delete it
    private void deleteDB(String name, File dir) {
        // database exist, delete it
        if (Database.exists(name, dir)) {
            // sometimes, db is still in used, wait for a while. Maximum 3 sec
            for (int i = 0; i &lt; 10; i++) {
                try {
                    Database.delete(name, dir);
                    break;
                } catch (CouchbaseLiteException ex) {
                    try { Thread.sleep(300); }
                    catch (InterruptedException ignore) { }
                }
            }
        }
    }

    // ### Initializers
    public void testInitializers() {
        // tag::initializer[]
        MutableDocument newTask = new MutableDocument();
        newTask.setString("type", "task");
        newTask.setString("owner", "todo");
        newTask.setDate("createdAt", new Date());
        try {
            database.save(newTask);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
        // end::initializer[]
    }

    // ### Mutability
    public void testMutability() {
        try { database.save(new MutableDocument("xyz")); }
        catch (CouchbaseLiteException ignore) { }

        // tag::update-document[]
        Document document = database.getDocument("xyz");
        MutableDocument mutableDocument = document.toMutable();
        mutableDocument.setString("name", "apples");
        try {
            database.save(mutableDocument);
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
        // end::update-document[]
    }

    // ### Typed Accessors
    public void testTypedAccessors() {
        MutableDocument newTask = new MutableDocument();

        // tag::date-getter[]
        newTask.setValue("createdAt", new Date());
        Date date = newTask.getDate("createdAt");
        // end::date-getter[]
    }

    // ### Batch operations
    public void testBatchOperations() {
        // tag::batch[]
        try {
            database.inBatch(() -&gt; {
                for (int i = 0; i &lt; 10; i++) {
                    MutableDocument doc = new MutableDocument();
                    doc.setValue("type", "user");
                    doc.setValue("name", "user " + i);
                    doc.setBoolean("admin", false);
                    try {
                        database.save(doc);
                    } catch (CouchbaseLiteException e) {
                        Log.e(TAG, e.toString());
                    }
                    Log.i(TAG, String.format("saved user document %s", doc.getString("name")));
                }
            });
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        }
        // end::batch[]
    }

    // ### Document Expiration
    public void DocumentExpiration() throws CouchbaseLiteException {
        // tag::document-expiration[]
        // Purge the document one day from now
        Instant ttl = Instant.now().plus(1, ChronoUnit.DAYS);
        database.setDocumentExpiration("doc123", new Date(ttl.toEpochMilli()));

        // Reset expiration
        database.setDocumentExpiration("doc1", null);

        // Query documents that will be expired in less than five minutes
        Instant fiveMinutesFromNow = Instant.now().plus(5, ChronoUnit.MINUTES);
        Query query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.expiration.lessThan(Expression.doubleValue(fiveMinutesFromNow.toEpochMilli())));
        // end::document-expiration[]
    }

    public void testDocumentChangeListener() throws CouchbaseLiteException {
        // tag::document-listener[]
        database.addDocumentChangeListener(
            "user.john",
            change -&gt; {
                Document doc = database.getDocument(change.getDocumentID());
                if (doc != null) {
                    Toast.makeText(context, "Status: " + doc.getString("verified_account"), Toast.LENGTH_SHORT).show();
                }
            });
        // end::document-listener[]
    }

    // ### Blobs
    public void testBlobs() {
        MutableDocument newTask = new MutableDocument();

        // tag::blob[]
        InputStream is = getAsset("avatar.jpg");
        if (is == null) { return; }
        try {
            Blob blob = new Blob("image/jpeg", is);
            newTask.setBlob("avatar", blob);
            database.save(newTask);

            Blob taskBlob = newTask.getBlob("avatar");
            byte[] bytes = taskBlob.getContent();
        } catch (CouchbaseLiteException e) {
            Log.e(TAG, e.toString());
        } finally {
            try { is.close(); }
            catch (IOException ignore) { }
        }
        // end::blob[]
    }

    // ### Indexing
    public void testIndexing() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-index[]
            database.createIndex(
                "TypeNameIndex",
                IndexBuilder.valueIndex(
                    ValueIndexItem.property("type"),
                    ValueIndexItem.property("name")));
            // end::query-index[]
        }
    }

    // ### SELECT statement
    public void testSelectStatement() {
        {
            // tag::query-select-meta[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("type"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .orderBy(Ordering.expression(Meta.id));

            try {
                ResultSet rs = query.execute();
                for (Result result : rs) {
                    Log.i("Sample", String.format("hotel id -&gt; %s", result.getString("id")));
                    Log.i("Sample", String.format("hotel name -&gt; %s", result.getString("name")));
                }
            } catch (CouchbaseLiteException e) {
                Log.e("Sample", e.getLocalizedMessage());
            }
            // end::query-select-meta[]
        }
    }

    // META function
    public void testMetaFunction() throws CouchbaseLiteException {
        // For Documentation
        {
            Query query = QueryBuilder
                .select(SelectResult.expression(Meta.id))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport")))
                .orderBy(Ordering.expression(Meta.id));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.w("Sample", String.format("airport id -&gt; %s", result.getString("id")));
                Log.w("Sample", String.format("airport id -&gt; %s", result.getString(0)));
            }
        }
    }

    // ### all(*)
    public void testSelectAll() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-select-all[]
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")));
            // end::query-select-all[]

            // tag::live-query[]
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database));

            // Adds a query change listener.
            // Changes will be posted on the main queue.
            ListenerToken token = query.addChangeListener(change -&gt; { <i class="conum" data-value="10"></i><b>(10)</b>
                for (Result result : change.getResults()) {
                    Log.d(TAG, "results: " + result.getKeys());
                    /* Update UI */
                }
            });

            // Start live query.
            query.execute(); <i class="conum" data-value="11"></i><b>(11)</b>
            // end::live-query[]

            // tag::stop-live-query[]
            query.removeChangeListener(token); <i class="conum" data-value="12"></i><b>(12)</b>

            // end::stop-live-query[]

            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("hotel -&gt; %s", result.getDictionary(DATABASE_NAME).toMap()));
            }
        }
    }

    // ###WHERE statement
    public void testWhereStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-where[]
            Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel")))
                .limit(Expression.intValue(10));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Dictionary all = result.getDictionary(DATABASE_NAME);
                Log.i("Sample", String.format("name -&gt; %s", all.getString("name")));
                Log.i("Sample", String.format("type -&gt; %s", all.getString("type")));
            }
            // end::query-where[]
        }
    }

    public void testQueryDeletedDocuments() {
        // tag::query-deleted-documents[]
        // Query documents that have been deleted
        Where query = QueryBuilder
            .select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(Meta.deleted);
        // end::query-deleted-documents[]
    }


    // ####Collection Operators
    public void testCollectionStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-collection-operator-contains[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("name"),
                    SelectResult.property("public_likes"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))
                    .and(ArrayFunction
                        .contains(Expression.property("public_likes"), Expression.string("Armani Langworth"))));
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format("public_likes -&gt; %s", result.getArray("public_likes").toList()));
            }
            // end::query-collection-operator-contains[]
        }
    }

    // IN operator
    public void testInOperator() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-collection-operator-in[]
            Expression[] values = new Expression[] {
                Expression.property("first"),
                Expression.property("last"),
                Expression.property("username")
            };

            Query query = QueryBuilder.select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.string("Armani").in(values));
            // end::query-collection-operator-in[]

            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
        }
    }

    // Pattern Matching
    public void testPatternMatching() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-like-operator[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Function.Expression.string("royal engineers museum")))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
            // end::query-like-operator[]
        }
    }

    // ### Wildcard Match
    public void testWildcardMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-like-operator-wildcard-match[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng%e%"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
            // end::query-like-operator-wildcard-match[]
        }
    }

    // Wildcard Character Match
    public void testWildCharacterMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-like-operator-wildcard-character-match[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).like(Expression.string("eng____r"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
            // end::query-like-operator-wildcard-character-match[]
        }
    }

    // ### Regex Match
    public void testRegexMatch() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-regex-operator[]
            Query query = QueryBuilder
                .select(
                    SelectResult.expression(Meta.id),
                    SelectResult.property("country"),
                    SelectResult.property("name"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("landmark"))
                    .and(Function.lower(Expression.property("name")).regex(Expression.string("\\beng.*r\\b"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.i("Sample", String.format("name -&gt; %s", result.getString("name"))); }
            // end::query-regex-operator[]
        }
    }

    // JOIN statement
    public void testJoinStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-join[]
            Query query = QueryBuilder.select(
                SelectResult.expression(Expression.property("name").from("airline")),
                SelectResult.expression(Expression.property("callsign").from("airline")),
                SelectResult.expression(Expression.property("destinationairport").from("route")),
                SelectResult.expression(Expression.property("stops").from("route")),
                SelectResult.expression(Expression.property("airline").from("route")))
                .from(DataSource.database(database).as("airline"))
                .join(Join.join(DataSource.database(database).as("route"))
                    .on(Meta.id.from("airline").equalTo(Expression.property("airlineid").from("route"))))
                .where(Expression.property("type").from("route").equalTo(Expression.string("route"))
                    .and(Expression.property("type").from("airline").equalTo(Expression.string("airline")))
                    .and(Expression.property("sourceairport").from("route").equalTo(Expression.string("RIX"))));
            ResultSet rs = query.execute();
            for (Result result : rs) { Log.w("Sample", String.format("%s", result.toMap().toString())); }
            // end::query-join[]
        }
    }

    // ### GROUPBY statement
    public void testGroupByStatement() throws CouchbaseLiteException {
        // For Documentation
        {
            // tag::query-groupby[]
            Query query = QueryBuilder.select(
                SelectResult.expression(Function.count(Expression.string("*"))),
                SelectResult.property("country"),
                SelectResult.property("tz"))
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("airport"))
                    .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.intValue(300))))
                .groupBy(
                    Expression.property("country"),
                    Expression.property("tz"))
                .orderBy(Ordering.expression(Function.count(Expression.string("*"))).descending());
            ResultSet rs = query.execute();
            for (Result result : rs) {
                Log.i(
                    "Sample",
                    String.format(
                        "There are %d airports on the %s timezone located in %s and above 300ft",
                        result.getInt("$1"),
                        result.getString("tz"),
                        result.getString("country")));
            }
            // end::query-groupby[]
        }
    }

    // ### ORDER BY statement
    public void testOrderByStatement() throws CouchbaseLiteException {
      // For Documentation
      {
        // tag::query-orderby[]
        Query query = QueryBuilder
        .select(
          SelectResult.expression(Meta.id),
          SelectResult.property("name"))
          .from(DataSource.database(database))
          .where(Expression.property("type").equalTo(Expression.string("hotel")))
          .orderBy(Ordering.property("name").ascending())
          .limit(Expression.intValue(10));
          ResultSet rs = query.execute();
          for (Result result : rs) { Log.i("Sample", String.format("%s", result.toMap())); }
          // end::query-orderby[]
        }
      }
      // ### EXPLAIN statement
      public void testExplainStatement() throws CouchbaseLiteException {
          // For Documentation
          {
              // tag::query-explain-all[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("university")))
                .groupBy(Expression.property("country"))
                .orderBy(Ordering.property("name").descending()); <i class="conum" data-value="13"></i><b>(13)</b>
              Log.i(query.explain()); <i class="conum" data-value="14"></i><b>(14)</b>
              // end::query-explain-all[]
              // tag::query-explain-like[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("%hotel%"))); <i class="conum" data-value="15"></i><b>(15)</b>
              Log.i(query.explain());
              // end::query-explain-like[]
              // tag::query-explain-nopfx[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").like(Expression.string("hotel%")) <i class="conum" data-value="16"></i><b>(16)</b>
                  .and(Expression.property("name").like(Expression.string("%royal%"))));
              Log.i(query.explain());
              // end::query-explain-nopfx[]
              // tag::query-explain-function[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Function.lower(Expression.property("type").equalTo(Expression.string("hotel")))); <i class="conum" data-value="17"></i><b>(17)</b>
              Log.i(query.explain());
              // end::query-explain-function[]
              // tag::query-explain-nofunction[]
              Query query = QueryBuilder
                .select(SelectResult.all())
                .from(DataSource.database(database))
                .where(Expression.property("type").equalTo(Expression.string("hotel"))); <i class="conum" data-value="18"></i><b>(18)</b>
              Log.i(query.explain());
              // end::query-explain-nofunction[]
          }
      }
      // end query-explain

    void prepareIndex() throws CouchbaseLiteException {
        // tag::fts-index[]
        database.createIndex(
            "nameFTSIndex",
            IndexBuilder.fullTextIndex(FullTextIndexItem.property("name")).ignoreAccents(false));
        // end::fts-index[]
    }

    public void testFTS() throws CouchbaseLiteException {
        // tag::fts-query[]
        Expression whereClause = FullTextExpression.index("nameFTSIndex").match("buy");
        Query ftsQuery = QueryBuilder.select(SelectResult.expression(Meta.id))
            .from(DataSource.database(database))
            .where(whereClause);
        ResultSet ftsQueryResult = ftsQuery.execute();
        for (Result result : ftsQueryResult) {
            Log.i(
                TAG,
                String.format("document properties %s", result.getString(0)));
        }
        // end::fts-query[]
    }

    /* The `tag::replication[]` example is inlined in java.adoc */

    public void testTroubleshooting() {
        // tag::replication-logging[]
        Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE);
        // end::replication-logging[]
    }

    public void testReplicationBasicAuthentication() throws URISyntaxException {
        // tag::basic-authentication[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new BasicAuthenticator("username", "password"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
        // end::basic-authentication[]
    }

    public void testReplicationSessionAuthentication() throws URISyntaxException {
        // tag::session-authentication[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setAuthenticator(new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447"));

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
        // end::session-authentication[]
    }

    public void testReplicationStatus() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        // tag::replication-status[]
        replicator.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == Replicator.ActivityLevel.STOPPED) {
                Log.i(TAG, "Replication stopped");
            }
          });
          // end::replication-status[]
        }

    //  BEGIN PendingDocuments BM -- 19/Feb/21 --
    import android.support.annotation.NonNull;
    import android.util.Log;

    import java.net.URI;
    import java.net.URISyntaxException;
    import java.util.Iterator;
    import java.util.Set;

    import com.couchbase.lite.CouchbaseLiteException;
    import com.couchbase.lite.Database;
    import com.couchbase.lite.Endpoint;
    import com.couchbase.lite.Replicator;
    import com.couchbase.lite.ReplicatorConfiguration;
    import com.couchbase.lite.URLEndpoint;

    class PendingDocsExample {
        private static final String TAG = "SCRATCH";

        private Database database;
        private Replicator replicator;

        //  BEGIN PendingDocuments IB -- 11/Feb/21 --
        public void testReplicationPendingDocs() throws URISyntaxException, CouchbaseLiteException {
            // nottag::replication-pendingdocuments[]
            // ... include other code as required
            //
            final Endpoint endpoint =
              new URLEndpoint(new URI("ws://localhost:4984/db"));

            final ReplicatorConfiguration config =
              new ReplicatorConfiguration(database, endpoint)
            .setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);
            // tag::replication-push-pendingdocumentids[]

            replicator = new Replicator(config);
            final Set&lt;String&gt; pendingDocs =
              replicator.getPendingDocumentIds(); <i class="conum" data-value="19"></i><b>(19)</b>

            // end::replication-push-pendingdocumentids[]

            replicator.addChangeListener(change -&gt; {
              onStatusChanged(pendingDocs, change.getStatus()); });

            replicator.start();

            // ... include other code as required
            // notend::replication-pendingdocuments[]
          }
        //
        // tag::replication-pendingdocuments[]
        //
        private void onStatusChanged(
          @NonNull final Set&lt;String&gt; pendingDocs,
          @NonNull final Replicator.Status status) {
          // ... sample onStatusChanged function
          //
          Log.i(TAG,
            "Replicator activity level is " + status.getActivityLevel().toString());

          // iterate and report-on previously
          // retrieved pending docids 'list'
          for (Iterator&lt;String&gt; itr = pendingDocs.iterator(); itr.hasNext(); ) {
            final String docId = itr.next();
            try {
              // tag::replication-push-isdocumentpending[]
              if (!replicator.isDocumentPending(docId)) { continue; } <i class="conum" data-value="20"></i><b>(20)</b>
              // end::replication-push-isdocumentpending[]

              itr.remove();
              Log.i(TAG, "Doc ID " + docId + " has been pushed");
            }
            catch (CouchbaseLiteException e) {
              Log.w(TAG, "isDocumentPending failed", e); }
          }
        }
        // end::replication-pendingdocuments[]
        //  END PendingDocuments BM -- 19/Feb/21 --
    }


    public void testHandlingNetworkErrors() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        // tag::replication-error-handling[]
        replicator.addChangeListener(change -&gt; {
            CouchbaseLiteException error = change.getStatus().getError();
            if (error != null) { Log.w(TAG, "Error code:: %d", error); }
        });
        replicator.start();
        // end::replication-error-handling[]

        replicator.stop();
    }

    public void testReplicatorDocumentEvent() throws URISyntaxException {
        Endpoint endpoint = new URLEndpoint(new URI("ws://localhost:4984/db"));
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);

        // tag::add-document-replication-listener[]
        ListenerToken token = replicator.addDocumentReplicationListener(replication -&gt; {

            Log.i(TAG, "Replication type: " + ((replication.isPush()) ? "Push" : "Pull"));
            for (ReplicatedDocument document : replication.getDocuments()) {
                Log.i(TAG, "Doc ID: " + document.getID());

                CouchbaseLiteException err = document.getError();
                if (err != null) {
                    // There was an error
                    Log.e(TAG, "Error replicating document: ", err);
                    return;
                }

                if (document.flags().contains(DocumentFlag.DocumentFlagsDeleted)) {
                    Log.i(TAG, "Successfully replicated a deleted document");
                }
            }
        });

        replicator.start();
        // end::add-document-replication-listener[]

        // tag::remove-document-replication-listener[]
        replicator.removeChangeListener(token);
        // end::remove-document-replication-listener[]
    }

    public void testReplicationCustomHeader() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);

        // tag::replication-custom-header[]
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();
        headers.put("CustomHeaderName", "Value");
        config.setHeaders(headers);
        // end::replication-custom-header[]
    }

    // ### Certificate Pinning

    public void testCertificatePinning() throws URISyntaxException, IOException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);

        // tag::certificate-pinning[]
        InputStream is = getAsset("cert.cer");
        byte[] cert = IOUtils.toByteArray(is);
        if (is != null) {
            try { is.close(); }
            catch (IOException ignore) {}
        }

        config.setPinnedServerCertificate(cert);
        // end::certificate-pinning[]
    }

    // ### Reset replicator checkpoint
    public void testReplicationResetCheckpoint() throws URISyntaxException {
        URI uri = new URI("ws://localhost:4984/db");
        Endpoint endpoint = new URLEndpoint(uri);
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();

        // tag::replication-reset-checkpoint[]
        replicator.resetCheckpoint();
        replicator.start();
        // end::replication-reset-checkpoint[]

        replicator.stop();
    }

    public void testReplicationPushFilter() throws URISyntaxException {
        // tag::replication-push-filter[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPushFilter((document, flags) -&gt; flags.contains(DocumentFlag.DocumentFlagsDeleted)); <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
        // end::replication-push-filter[]
    }

    public void testReplicationPullFilter() throws URISyntaxException {
        // tag::replication-pull-filter[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setPullFilter((document, flags) -&gt; "draft".equals(document.getString("type"))); <i class="conum" data-value="1"></i><b>(1)</b>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(config);
        replicator.start();
        // end::replication-pull-filter[]
    }

    public void testCustomRetryConfig() throws URISyntaxException {
    // tag::replication-retry-config[]
    URLEndpoint target =
    new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

    ReplicatorConfiguration config =
    new ReplicatorConfiguration(database, target);

    //  other config as required . . .
    // tag::replication-heartbeat-config[]
    config.setHeartbeat(150L); <i class="conum" data-value="21"></i><b>(21)</b>
    // end::replication-heartbeat-config[]
    // tag::replication-maxretries-config[]
    config.setMaxRetries(20L); <i class="conum" data-value="22"></i><b>(22)</b>
    // end::replication-maxretries-config[]
    // tag::replication-maxretrywaittime-config[]
    config.setMaxRetryWaitTime(600L); <i class="conum" data-value="23"></i><b>(23)</b>
    // end::replication-maxretrywaittime-config[]

    Replicator repl = new Replicator(config);

    // end::replication-retry-config[]
    }





    public void testDatabaseReplica() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database1 = new Database("mydb", config);

        config = new DatabaseConfiguration();
        Database database2 = new Database("db2", config);

        /* EE feature: code below might throw a compilation error
           if it's compiled against CBL Android Community. */
        // tag::database-replica[]
        DatabaseEndpoint targetDatabase = new DatabaseEndpoint(database2);
        ReplicatorConfiguration replicatorConfig = new ReplicatorConfiguration(database1, targetDatabase);
        replicatorConfig.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH);

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        replicator = new Replicator(replicatorConfig);
        replicator.start();
        // end::database-replica[]
    }

    public void testPredictiveModel() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        // tag::register-model[]
        Database.prediction.registerModel("ImageClassifier", new ImageClassifierModel());
        // end::register-model[]

        // tag::predictive-query-value-index[]
        ValueIndex index = IndexBuilder.valueIndex(ValueIndexItem.expression(Expression.property("label")));
        database.createIndex("value-index-image-classifier", index);
        // end::predictive-query-value-index[]

        // tag::unregister-model[]
        Database.prediction.unregisterModel("ImageClassifier");
        // end::unregister-model[]
    }

    public void testPredictiveIndex() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        // tag::predictive-query-predictive-index[]
        Map&lt;String, Object&gt; inputMap = new HashMap&lt;&gt;();
        inputMap.put("numbers", Expression.property("photo"));
        Expression input = Expression.map(inputMap);

        PredictiveIndex index = IndexBuilder.predictiveIndex("ImageClassifier", input, null);
        database.createIndex("predictive-index-image-classifier", index);
        // end::predictive-query-predictive-index[]
    }

    public void testPredictiveQuery() throws CouchbaseLiteException {
        DatabaseConfiguration config = new DatabaseConfiguration();
        Database database = new Database("mydb", config);

        // tag::predictive-query[]
        Map&lt;String, Object&gt; inputProperties = new HashMap&lt;&gt;();
        inputProperties.put("photo", Expression.property("photo"));
        Expression input = Expression.map(inputProperties);
        PredictionFunction prediction = PredictiveModel.predict("ImageClassifier", input); <i class="conum" data-value="1"></i><b>(1)</b>

        Query query = QueryBuilder
            .select(SelectResult.all())
            .from(DataSource.database(database))
            .where(Expression.property("label").equalTo(Expression.string("car"))
                .and(Expression.property("probability").greaterThanOrEqualTo(Expression.doubleValue(0.8))));

        // Run the query.
        ResultSet result = query.execute();
        Log.d(TAG, "Number of rows: " + result.allResults().size());
        // end::predictive-query[]
    }

    public void testReplicationWithCustomConflictResolver() throws URISyntaxException {
        // tag::replication-conflict-resolver[]
        URLEndpoint target = new URLEndpoint(new URI("ws://localhost:4984/mydatabase"));

        ReplicatorConfiguration config = new ReplicatorConfiguration(database, target);
        config.setConflictResolver(new LocalWinConflictResolver());

        Replicator replication = new Replicator(config);
        replication.start();
        // end::replication-conflict-resolver[]
    }

    public void testSaveWithCustomConflictResolver() throws CouchbaseLiteException {
        // tag::update-document-with-conflict-handler[]
        Document doc = database.getDocument("xyz");
        if (doc == null) { return; }
        MutableDocument mutableDocument = doc.toMutable();
        mutableDocument.setString("name", "apples");

        database.save(
            mutableDocument,
            (newDoc, curDoc) -&gt; { <i class="conum" data-value="24"></i><b>(24)</b>
                if (curDoc == null) { return false; } <i class="conum" data-value="25"></i><b>(25)</b>
                Map&lt;String, Object&gt; dataMap = curDoc.toMap();
                dataMap.putAll(newDoc.toMap()); <i class="conum" data-value="26"></i><b>(26)</b>
                newDoc.setData(dataMap);
                return true; <i class="conum" data-value="27"></i><b>(27)</b>
            }); <i class="conum" data-value="28"></i><b>(28)</b>
        // end::update-document-with-conflict-handler[]
      }
    }

// tag::update-document-with-conflict-handler-callouts[]

&lt;.&gt; The conflict handler code is provided as a lambda.

&lt;.&gt; If the handler cannot resolve a conflict, it can return false.
In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.

&lt;.&gt; Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.

&lt;.&gt; When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).

&lt;.&gt; If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method
// end::update-document-with-conflict-handler-callouts[]

// tag::local-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
class LocalWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getLocalDocument();
    }
}
// end::local-win-conflict-resolver[]

// tag::remote-win-conflict-resolver[]
// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
class RemoteWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getRemoteDocument();
    }
}
// end::remote-win-conflict-resolver[]

// tag::merge-conflict-resolver[]
// Using replConfig.setConflictResolver(new MergeConflictResolver());
class MergeConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        Map&lt;String, Object&gt; merge = conflict.getLocalDocument().toMap();
        merge.putAll(conflict.getRemoteDocument().toMap());
        return new MutableDocument(conflict.getDocumentId(), merge);
    }
}
// end::merge-conflict-resolver[]


/* ----------------------------------------------------------- */
/* ---------------------  ACTIVE SIDE  ----------------------- */
/* ----------------------------------------------------------- */

class BrowserSessionManager implements MessageEndpointDelegate {
    private final Context context;
    private Replicator replicator;

    private BrowserSessionManager(Context context) { this.context = context; }

    public void initCouchbase() throws CouchbaseLiteException {
        // tag::message-endpoint[]
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration(context);
        Database database = new Database("mydb", databaseConfiguration);

        // The delegate must implement the `MessageEndpointDelegate` protocol.
        MessageEndpoint messageEndpointTarget = new MessageEndpoint(
            "UID:123",
            "active",
            ProtocolType.MESSAGE_STREAM,
            this);
        // end::message-endpoint[]

        // tag::message-endpoint-replicator[]
        ReplicatorConfiguration config = new ReplicatorConfiguration(database, messageEndpointTarget);

        // Create the replicator object.
        replicator = new Replicator(config);
        // Start the replication.
        replicator.start();
        // end::message-endpoint-replicator[]
    }

    // tag::create-connection[]
    /* implementation of MessageEndpointDelegate */
    @NonNull
    @Override
    public MessageEndpointConnection createConnection(@NonNull MessageEndpoint endpoint) {
        return new ActivePeerConnection(); /* implements MessageEndpointConnection */
    }
    // end::create-connection[]
}

class ActivePeerConnection implements MessageEndpointConnection {

    private ReplicatorConnection replicatorConnection;

    public void disconnect() {
        // tag::active-replicator-close[]
        replicatorConnection.close(null);
        // end::active-replicator-close[]
    }

    // tag::active-peer-open[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }
    // end::active-peer-open[]

    // tag::active-peer-close[]
    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete();
    }
    // end::active-peer-close[]

    // tag::active-peer-send[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null);
    }
    // end::active-peer-send[]

    public void receive(Message message) {
        // tag::active-peer-receive[]
        replicatorConnection.receive(message);
        // end::active-peer-receive[]
    }

}

/* ----------------------------------------------------------- */
/* ---------------------  PASSIVE SIDE  ---------------------- */
/* ----------------------------------------------------------- */

class PassivePeerConnection implements MessageEndpointConnection {
    private final Context context;

    private MessageEndpointListener messageEndpointListener;
    private ReplicatorConnection replicatorConnection;

    private PassivePeerConnection(Context context) { this.context = context; }

    public void startListener() throws CouchbaseLiteException {
        // tag::listener[]
        DatabaseConfiguration databaseConfiguration = new DatabaseConfiguration();
        Database database = new Database("mydb", databaseConfiguration);
        MessageEndpointListenerConfiguration listenerConfiguration = new MessageEndpointListenerConfiguration(
            database,
            ProtocolType.MESSAGE_STREAM);
        this.messageEndpointListener = new MessageEndpointListener(listenerConfiguration);
        // end::listener[]
    }

    public void stopListener() {
        // tag::passive-stop-listener[]
        messageEndpointListener.closeAll();
        // end::passive-stop-listener[]
    }

    public void accept() {
        // tag::advertizer-accept[]
        PassivePeerConnection connection = new PassivePeerConnection(context); /* implements
        MessageEndpointConnection */
        messageEndpointListener.accept(connection);
        // end::advertizer-accept[]
    }

    public void disconnect() {
        // tag::passive-replicator-close[]
        replicatorConnection.close(null);
        // end::passive-replicator-close[]
    }

    // tag::passive-peer-open[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void open(@NonNull ReplicatorConnection connection, @NonNull MessagingCompletion completion) {
        replicatorConnection = connection;
        completion.complete(true, null);
    }
    // end::passive-peer-open[]

    // tag::passive-peer-close[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void close(Exception error, @NonNull MessagingCloseCompletion completion) {
        /* disconnect with communications framework */
        /* ... */
        /* call completion handler */
        completion.complete();
    }
    // end::passive-peer-close[]

    // tag::passive-peer-send[]
    /* implementation of MessageEndpointConnection */
    @Override
    public void send(@NonNull Message message, @NonNull MessagingCompletion completion) {
        /* send the data to the other peer */
        /* ... */
        /* call the completion handler once the message is sent */
        completion.complete(true, null);
    }
    // end::passive-peer-send[]

    public void receive(Message message) {
        // tag::passive-peer-receive[]
        replicatorConnection.receive(message);
        // end::passive-peer-receive[]
    }
}

// tag::predictive-model[]
// `tensorFlowModel` is a fake implementation
// this would be the implementation of the ml model you have chosen
class ImageClassifierModel implements PredictiveModel {
    @Override
    public Dictionary predict(@NonNull Dictionary input) {
        Blob blob = input.getBlob("photo");
        if (blob == null) { return null; }

        // `tensorFlowModel` is a fake implementation
        // this would be the implementation of the ml model you have chosen
        return new MutableDictionary(TensorFlowModel.predictImage(blob.getContent())); <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

class TensorFlowModel {
    public static Map&lt;String, Object&gt; predictImage(byte[] data) {
        return null;
    }
}
// end::predictive-model[]

// tag::custom-logging[]
class LogTestLogger implements Logger {
    @NonNull
    private final LogLevel level;

    public LogTestLogger(@NonNull LogLevel level) { this.level = level; }

    @NonNull
    @Override
    public LogLevel getLevel() { return level; }

    @Override
    public void log(@NonNull LogLevel level, @NonNull LogDomain domain, @NonNull String message) {
    }
}
// end::custom-logging[]




// tag::certAuthListener-full[]

//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.ClientCertificateAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerCertificateAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.TLSIdentity;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class CertAuthListener {
    private static final String TAG = "PWD";

    private static final Map&lt;String, String&gt; CERT_ATTRIBUTES;
    static {
        final Map&lt;String, String&gt; m = new HashMap&lt;&gt;();
        m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "CBL Test");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
        m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
        m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "lite@couchbase.com");
        CERT_ATTRIBUTES = Collections.unmodifiableMap(m);
    }
    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        TLSIdentity serverIdentity = TLSIdentity.createIdentity(true, CERT_ATTRIBUTES, null, "server");
        TLSIdentity clientIdentity = TLSIdentity.createIdentity(false, CERT_ATTRIBUTES, null, "client");

        final URI uri = startServer(remoteDb, serverIdentity, clientIdentity.getCerts());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread(() -&gt; {
            try {
                startClient(uri, serverIdentity.getCerts().get(0), clientIdentity, localDb);
                Log.e(TAG, "Success!!");
                deleteIdentity("server");
                Log.e(TAG, "Alias deleted: server");
                deleteIdentity("client");
                Log.e(TAG, "Alias deleted: client");
            }
            catch (Exception e) { Log.e(TAG, "Failed!!", e); }
        }).start();
    }

    // start a client replicator
    public void startClient(
        @NonNull URI uri,
        @NonNull Certificate cert,
        @NonNull TLSIdentity clientIdentity,
        @NonNull Database db) throws CertificateEncodingException, InterruptedException {
        final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri));
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);

        configureClientCerts(config, cert, clientIdentity);

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    // tag::listener-config-auth-cert-full[]
    /**
     * Snippet 2: create a ListenerCertificateAuthenticator and configure the listener with it
     * &lt;p&gt;
     * Start a listener for db that accepts connections from a client identified by any of the passed certs
     *
     * @param db    the database to which the listener is attached
     * @param certs the name of the single valid user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull TLSIdentity serverId, @NonNull List&lt;Certificate&gt; certs)
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(false);
      config.setTlsIdentity(serverId);
      config.setAuthenticator(new ListenerCertificateAuthenticator(certs));

      final URLEndpointListener listener = new URLEndpointListener(config);
      listener.start();

      final List&lt;URI&gt; urls = listener.getUrls();
      if (urls.isEmpty()) { return null; }
      return urls.get(0);
    }
    // end::listener-config-auth-cert-full[]
    // tag::listener-config-delete-cert-full[]

    /**
     * Delete an identity from the keystore
     *
     * @param alias the alias for the identity to be deleted
     */
    public void deleteIdentity(String alias)
    throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException {

      final KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
      keyStore.load(null);

      keyStore.deleteEntry(alias); <i class="conum" data-value="29"></i><b>(29)</b>
    }
    // end::listener-config-delete-cert-full[]

    // nottag::p2p-tlsid-tlsidentity-with-label[]
    /* Configure Client (active) side certificates
     * @param config         The replicator configuration
     * @param cert           The expected server side certificate
     * @param clientIdentity the identity offered to the server as authentication
     * @throws CertificateEncodingException on certifcate encoding error
     */
    private void configureClientCerts(
      ReplicatorConfiguration config,
      @NonNull Certificate cert,
      @NonNull TLSIdentity clientIdentity)
      throws CertificateEncodingException {

        // Create an authenticator that provides the client identity
        config.setAuthenticator(new ClientCertificateAuthenticator(clientIdentity));

        // Configure the pinned certificate passing a byte array.
        config.setPinnedServerCertificate(cert.getEncoded());
      }
      // notend::p2p-tlsid-tlsidentity-with-label[]

    /**
     * Copy a cert from a resource bundle
     * @param context Android context
     * @param resId   resource id for resource: R.id.foo
     * @throws IOException on copy error
     */
    private byte[] readCertMaterialFromBundle(@NonNull Context context, int resId) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        final InputStream in = context.getResources().openRawResource(resId);
        final byte buf[] = new byte[1024];
        int n;
        while ((n = in.read(buf)) &gt;= 0) { out.write(buf, 0, n); }
        return out.toByteArray();
    }
}
// end::certAuthListener-full[]


// tag::passwordAuthListener-full[]

//
// Copyright (c) 2020 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.android.fruitsnveg.examples;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

import com.couchbase.lite.AbstractReplicator;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.ListenerPasswordAuthenticator;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.URLEndpointListener;
import com.couchbase.lite.URLEndpointListenerConfiguration;


public class PasswordAuthListener {
    private static final String TAG = "PWD";

    // start a server and connect to it with a replicator
    public void run() throws CouchbaseLiteException, IOException {
        final Database localDb = new Database("localDb");
        MutableDocument doc = new MutableDocument();
        doc.setString("dog", "woof");
        localDb.save(doc);

        Database remoteDb = new Database("remoteDb");
        doc = new MutableDocument();
        doc.setString("cat", "meow");
        localDb.save(doc);

        final URI uri = startServer(remoteDb, "fox", "wa-pa-pa-pa-pa-pow".toCharArray());
        if (uri == null) { throw new IOException("Failed to start the server"); }

        new Thread(() -&gt; {
            try {
                runClient(uri, "fox", "wa-pa-pa-pa-pa-pow".toCharArray(), localDb);
                Log.e(TAG, "Success!!");
            }
            catch (Exception e) { Log.e(TAG, "Failed!!", e); }
        }).start();
    }

    // start a client replicator
    public void runClient(
        @NonNull URI uri,
        @NonNull String username,
        @NonNull char[] password,
        @NonNull Database db) throws InterruptedException {
        final ReplicatorConfiguration config = new ReplicatorConfiguration(db, new URLEndpoint(uri));
        config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);
        config.setContinuous(false);
        config.setAuthenticator(new BasicAuthenticator(username, password));

        final CountDownLatch completionLatch = new CountDownLatch(1);
        final Replicator repl = new Replicator(config);
        repl.addChangeListener(change -&gt; {
            if (change.getStatus().getActivityLevel() == AbstractReplicator.ActivityLevel.STOPPED) {
                completionLatch.countDown();
            }
        });

        repl.start(false);
        completionLatch.await();
    }
    // tag::listener-config-client-auth-pwd-full[]
    /**
     *
     * Start a listener for db that accepts connections using exactly the passed username and password

     *
     * @param db       the database to which the listener is attached
     * @param username the name of the single valid user
     * @param password the password for the user
     * @return the url at which the listener can be reached.
     * @throws CouchbaseLiteException on failure
     */
    @Nullable
    public URI startServer(@NonNull Database db, @NonNull String username, @NonNull char[] password) <i class="conum" data-value="30"></i><b>(30)</b>
    throws CouchbaseLiteException {
      final URLEndpointListenerConfiguration config = new URLEndpointListenerConfiguration(db);

      config.setPort(0); // this is the default
      config.setDisableTls(true);
      config.setAuthenticator(new ListenerPasswordAuthenticator(
        (validUser, pwd) -&gt; username.equals(validUser) &amp;&amp; Arrays.equals(validPassword, pwd)));

        final URLEndpointListener listener = new URLEndpointListener(config);
        listener.start();

        final List&lt;URI&gt; urls = listener.getUrls();
        if (urls.isEmpty()) { return null; }
        return urls.get(0);
      }
      // end::listener-config-client-auth-pwd-full[]
    }


// end::passwordAuthListener-full[]




// Copyright (c) 2019 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.code_snippets;

import android.content.Context;
import android.support.annotation.NonNull;
import android.util.Log;
import android.widget.Toast;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import com.couchbase.lite.ArrayFunction;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Blob;
import com.couchbase.lite.Conflict;
import com.couchbase.lite.ConflictResolver;
import com.couchbase.lite.CouchbaseLite;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.DataSource;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseConfiguration;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.Dictionary;
import com.couchbase.lite.Document;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.EncryptionKey;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.Expression;
import com.couchbase.lite.FullTextExpression;
import com.couchbase.lite.FullTextIndexItem;
import com.couchbase.lite.Function;
import com.couchbase.lite.IndexBuilder;
import com.couchbase.lite.Join;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.LogDomain;
import com.couchbase.lite.LogFileConfiguration;
import com.couchbase.lite.LogLevel;
import com.couchbase.lite.Logger;
import com.couchbase.lite.Message;
import com.couchbase.lite.MessageEndpoint;
import com.couchbase.lite.MessageEndpointConnection;
import com.couchbase.lite.MessageEndpointDelegate;
import com.couchbase.lite.MessageEndpointListener;
import com.couchbase.lite.MessageEndpointListenerConfiguration;
import com.couchbase.lite.MessagingCloseCompletion;
import com.couchbase.lite.MessagingCompletion;
import com.couchbase.lite.Meta;
import com.couchbase.lite.MutableDictionary;
import com.couchbase.lite.MutableDocument;
import com.couchbase.lite.Ordering;
import com.couchbase.lite.PredictionFunction;
import com.couchbase.lite.PredictiveIndex;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.ProtocolType;
import com.couchbase.lite.Query;
import com.couchbase.lite.QueryBuilder;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorConnection;
import com.couchbase.lite.Result;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.SelectResult;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;
import com.couchbase.lite.ValueIndex;
import com.couchbase.lite.ValueIndexItem;
import com.couchbase.lite.Where;

public class docOnly_ReplicationExamples {
  private static final String TAG = "EXAMPLE ACTIVE PEER";
  private static final String thisDBNAME = "local-database";
  private final Context context;
  // private Database database;
  // private Replicator replicator;

  public docOnly_ReplicationExamples(Context context) { this.context = context; }

  String user = "syncuser";
  String password = "sync9455";
  SecCertificate cert=null;
  String passivePeerEndpoint = "10.1.1.12:8920";
  String passivePeerPort = "8920";
  String passiveDbName = "userdb";
  Database thisDB;
  Replicator thisReplicator;
  ListenerToken replicatorListener;




// PASSIVE PEER STUFF
// Stuff I adapted
//
// BEGIN new stuff 90420temp cache
  private URLEndpointListener createListener() {
  final URLEndpointListenerConfiguration listenerConfig = new URLEndpointListenerConfiguration(db);

  listenerConfig.setDisableTls(false);

  listenerConfig.setEnableDeltaSync(true);

  listenerConfig.setTlsIdentity(null); // Use with anonymous self signed cert

  listenerConfig.setAuthenticator(new ListenerPasswordAuthenticator(this::isWhitelistedUser));

  return new URLEndpointListener(listenerConfig);
}

public void startListener(@NotNull URLEndpointListener listener) {
  executor.submit(() -&gt; {
      CouchbaseLiteException err = null;
      try { listener.start(); }
      catch (CouchbaseLiteException e) { err = e; }
      onStart(err);
  });
}

private void stopListener(@NotNull URLEndpointListener listener) {
  listener.stop();
}
// END new stuff 90420temp cache


private void ibListenerSimple() {
  // tag::listener-simple[]
  final URLEndpointListenerConfiguration thisConfig =
    new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="31"></i><b>(31)</b>

  thisConfig.setAuthenticator(
    new ListenerPasswordAuthenticator(
      (username, password) -&gt;
        username.equals("valid.User") &amp;&amp;
        Arrays.equals(password, valid.password.string)
      )
    ); <i class="conum" data-value="32"></i><b>(32)</b>

  final URLEndpointListener thisListener =
    new URLEndpointListener(thisConfig); <i class="conum" data-value="33"></i><b>(33)</b>

  thisListener.start(); <i class="conum" data-value="34"></i><b>(34)</b>

  // end::listener-simple[]
}

private void ibReplicatorSimple() {
  // tag::replicator-simple[]
  URI uri = null;
  try {
      uri = new URI("wss://10.0.2.2:4984/db");
  } catch (URISyntaxException e) {
      e.printStackTrace();
  }
  Endpoint theListenerEndpoint = new URLEndpoint(uri); <i class="conum" data-value="35"></i><b>(35)</b>

  ReplicatorConfiguration thisConfig =
    new ReplicatorConfiguration(database, theListenerEndpoint); <i class="conum" data-value="36"></i><b>(36)</b>

  thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="37"></i><b>(37)</b>

  final BasicAuthenticator thisAuth
  = new BasicAuthenticator(
      "valid.user",
      "valid.password.string");
  thisConfig.setAuthenticator(thisAuth) <i class="conum" data-value="38"></i><b>(38)</b>

  this.replicator = new Replicator(config); <i class="conum" data-value="39"></i><b>(39)</b>
  this.replicator.start(); <i class="conum" data-value="40"></i><b>(40)</b>

  // end::replicator-simple[]
}


private void ibPassListener() {
// EXAMPLE 1
    // tag::listener-initialize[]
    // tag::listener-config-db[]
    // Initialize the listener config
    final URLEndpointListenerConfiguration thisConfig
       = new URLEndpointListenerConfiguration(thisDB); <i class="conum" data-value="41"></i><b>(41)</b>

    // end::listener-config-db[]
    // tag::listener-config-port[]
    thisConfig.setPort(55990); <i class="conum" data-value="42"></i><b>(42)</b>

    // end::listener-config-port[]
    // tag::listener-config-netw-iface[]
    thisConfig.setNetworkInterface("10.1.1.10"); <i class="conum" data-value="43"></i><b>(43)</b>

    // end::listener-config-netw-iface[]
    // tag::listener-config-delta-sync[]
    thisConfig.setEnableDeltaSync(false); <i class="conum" data-value="44"></i><b>(44)</b>

    // end::listener-config-delta-sync[]
    // tag::listener-config-tls-full[]
    // Configure server security
    // tag::listener-config-tls-enable[]
    thisConfig.setDisableTls(false); <i class="conum" data-value="45"></i><b>(45)</b>

    // end::listener-config-tls-enable[]
    // tag::listener-config-tls-id-anon[]
    // Use an Anonymous Self-Signed Cert
    thisConfig.setTlsIdentity(null); <i class="conum" data-value="46"></i><b>(46)</b>

    // end::listener-config-tls-id-anon[]

    // tag::listener-config-client-auth-pwd[]
    // Configure Client Security using an Authenticator
    // For example, Basic Authentication <i class="conum" data-value="47"></i><b>(47)</b>
    thisConfig.setAuthenticator(new ListenerPasswordAuthenticator(
      (validUser, validPassword) -&gt;
        username.equals(validUser) &amp;&amp;
        Arrays.equals(password, validPassword)));

    // end::listener-config-client-auth-pwd[]
    // tag::listener-start[]
    // Initialize the listener
    final URLEndpointListener thisListener
      = new URLEndpointListener(thisConfig); <i class="conum" data-value="48"></i><b>(48)</b>

    // Start the listener
    thisListener.start(); <i class="conum" data-value="49"></i><b>(49)</b>

    // end::listener-start[]
    // end::listener-initialize[]
}

private void ibListenerGetNetworkInterfaces() {
  // tag::listener-get-network-interfaces[]
  final URLEndpointListenerConfiguration thisConfig =
    URLEndpointListenerConfiguration(database: self.oDB)
  final URLEndpointListener thisListener
    = new URLEndpointListener(thisConfig);
  thisListener.start()
  Log.i(TAG, "URLS are " + thisListener.getUrls());

  // end::listener-get-network-interfaces[]
}

private void ibListenerLocalDb() {
// tag::listener-local-db[]
// . . . preceding application logic . . .
CouchbaseLite.init(context); <i class="conum" data-value="50"></i><b>(50)</b>
Database thisDB = new Database("passivepeerdb");

// end::listener-local-db[]
}

private void ibListenerConfigTlsDisable() {
// tag::listener-config-tls-disable[]
thisConfig.setDisableTls(true); <i class="conum" data-value="51"></i><b>(51)</b>

// end::listener-config-tls-disable[]
}

private void ibListenerConfigTlsIdFull() {
// tag::listener-config-tls-id-full[]
  // tag::listener-config-tls-id-caCert[]
  // Use CA Cert
  // Import a key pair into secure storage
  // Create a TLSIdentity from the imported key-pair
  InputStream thisKeyPair = new FileInputStream();

  thisKeyPair.getClass().getResourceAsStream("serverkeypair.p12"); <i class="conum" data-value="52"></i><b>(52)</b>

  TLSIdentity thisIdentity = new TLSIdentity.importIdentity(
    EXTERNAL_KEY_STORE_TYPE,  // KeyStore type, eg: "PKCS12"
    thisKeyPair,              // An InputStream from the keystore
    password,                 // The keystore password
    EXTERNAL_KEY_ALIAS,       // The alias to be used (in external keystore)
    null,                     // The key password
    "test-alias"              // The alias for the imported key
    );

  // end::listener-config-tls-id-caCert[]

  // tag::listener-config-tls-id-SelfSigned[]
  // Use a self-signed certificate
  // Create a TLSIdentity for the server using convenience API.
  // System generates self-signed cert
  // Work-in-progress. Code snippet coming soon.
  private static final Map&lt;String, String&gt; CERT_ATTRIBUTES; <i class="conum" data-value="53"></i><b>(53)</b>
  static {
    final Map&lt;String, String&gt; thisMap = new HashMap&lt;&gt;();
    m.put(TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME, "Couchbase Demo");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION, "Couchbase");
    m.put(TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT, "Mobile");
    m.put(TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS, "noreply@couchbase.com");
    CERT_ATTRIBUTES = Collections.unmodifiableMap(thisMap);
  }

  // Store the TLS identity in secure storage
  // under the label 'couchbase-docs-cert'
  TLSIdentity thisIdentity =
    new TLSIdentity.createIdentity(
      true,
      CERT_ATTRIBUTES,
      null,
      "couchbase-docs-cert"); <i class="conum" data-value="54"></i><b>(54)</b>

  // end::listener-config-tls-id-SelfSigned[]

  // tag::listener-config-tls-id-set[]
  // Set the TLS Identity
  thisConfig.setTlsIdentity(thisIdentity); <i class="conum" data-value="55"></i><b>(55)</b>

  // end::listener-config-tls-id-set[]
// end::listener-config-tls-id-full[]
}

private void ibListenerConfigClientAuthRoot() {
// tag::listener-config-client-root-ca[]
  // tag::listener-config-client-auth-root[]
  // Configure the client authenticator
  // to validate using ROOT CA
  // thisClientID.certs is a list containing a client cert to accept
  // and any other certs needed to complete a chain between the client cert
  // and a CA
  final TLSIdentity validId =
    TLSIdentity.getIdentity("Our Corporate Id");  // get the identity <i class="conum" data-value="56"></i><b>(56)</b>

  if (validId == null) { throw new IllegalStateException("Cannot find corporate id"); }

  thisConfig.setTlsIdentity(validId);

  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(validId.getCerts())); <i class="conum" data-value="57"></i><b>(57)</b> <i class="conum" data-value="58"></i><b>(58)</b>
    // accept only clients signed by the corp cert

  final URLEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

  // end::listener-config-client-auth-root[]
// end::listener-config-client-root-ca[]
}

private void ibListenerConfigClientAuthLambda() {
// tag::listener-config-client-auth-lambda[]
// Configure authentication using application logic
  final TLSIdentity thisCorpId = TLSIdentity.getIdentity("OurCorp"); <i class="conum" data-value="59"></i><b>(59)</b>
  if (thisCorpId == null) {
    throw new IllegalStateException("Cannot find corporate id"); }
  thisConfig.setTlsIdentity(thisCorpId);
  thisConfig.setAuthenticator(
    new ListenerCertificateAuthenticator(
      (thisCorpId.getCerts()) -&gt; {
      // use supplied logic that resolves to boolean
      // true=valid, false=invalid
      }
    )); <i class="conum" data-value="60"></i><b>(60)</b> <i class="conum" data-value="61"></i><b>(61)</b>
  final ULEndpointListener thisListener =
    new URLEndpointListener(thisConfig);

  // end::listener-config-client-auth-lambda[]
}


private void ibListenerConfigTlsDisable() {

  // tag::listener-config-tls-disable[]
  thisConfig.disableTLS(true);

  // end::listener-config-tls-disable[]
}


private void ibListenerStatusCheck() {
  // tag::listener-status-check[]
  int connectionCount =
    thisListener.getStatus().getConnectionCount(); <i class="conum" data-value="62"></i><b>(62)</b>

  int activeConnectionCount =
    thisListener.getStatus().getActiveConnectionCount();  <i class="conum" data-value="63"></i><b>(63)</b>

  // end::listener-status-check[]
}

private void ibListenerStop() {

  // tag::listener-stop[]
  thisListener.stop();

  // end::listener-stop[]
}

// Listener Callouts
/*
  // tag::listener-callouts-full[]

    // tag::listener-start-callouts[]
    &lt;.&gt; Initialize the listener instance using the configuration settings.
    &lt;.&gt; Start the listener, ready to accept connections and incoming data from active peers.

  // end::listener-start-callouts[]

  // tag::listener-status-check-callouts[]

  &lt;.&gt; `connectionCount` -- the total number of connections served by the listener
  &lt;.&gt; `activeConnectionCount` -- the number of active (BUSY) connections currently being served by the listener
  //
  // end::listener-status-check-callouts[]

// end::listener-callouts-full[]
*/
/* END CALLOUTS TEXT */


private void ibP2PUrlEndpointListener() {

// tag::p2p-ws-api-urlendpointlistener[]
  public class URLEndpointListener {
    // Properties <i class="conum" data-value="1"></i><b>(1)</b>
    public let config: URLEndpointListenerConfiguration
    public let port UInt16?
    public let tlsIdentity: TLSIdentity?
    public let urls: Array&lt;URL&gt;?
    public let status: ConnectionStatus?
    // Constructors <i class="conum" data-value="2"></i><b>(2)</b>
    public init(config: URLEndpointListenerConfiguration)
    // Methods <i class="conum" data-value="3"></i><b>(3)</b>
    public func start() throws
    public func stop()
    // end::p2p-ws-api-urlendpointlistener[]
  }
}



// ACTIVE PEER STUFF
// Replication code
//

  //@Test
  public void testActPeerSync() throws CouchbaseLiteException, URISyntaxException {
  // tag::p2p-act-rep-func[]
    // tag::p2p-act-rep-initialize[]
    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://listener.com:8954"))); <i class="conum" data-value="64"></i><b>(64)</b>

    // end::p2p-act-rep-initialize[]
    // tag::p2p-act-rep-config-type[]
    // Set replicator type
    thisConfig.setReplicatorType(
      ReplicatorConfiguration.ReplicatorType.PUSH_AND_PULL);

    // end::p2p-act-rep-config-type[]
    // tag::p2p-act-rep-config-cont[]
    // Configure Sync Mode
    thisConfig.setContinuous(false); // default value

    // end::p2p-act-rep-config-cont[]
    // tag::p2p-act-rep-config-self-cert[]
    // Configure Server Authentication --
    // only accept self-signed certs
    thisConfig.setAcceptOnlySelfSignedServerCertificate(true); <i class="conum" data-value="65"></i><b>(65)</b>

    // end::p2p-act-rep-config-self-cert[]
    // tag::p2p-act-rep-auth[]
    // Configure the credentials the
    // client will provide if prompted
    final BasicAuthenticator thisAuth
      = new BasicAuthenticator(
          "Our Username",
          "Our PasswordValue")); <i class="conum" data-value="66"></i><b>(66)</b>

    thisConfig.setAuthenticator(thisAuth)

    // end::p2p-act-rep-auth[]
    // tag::p2p-act-rep-config-conflict[]
    /* Optionally set custom conflict resolver call back */
    thisConfig.setConflictResolver( /* define resolver function */); <i class="conum" data-value="67"></i><b>(67)</b>

    // end::p2p-act-rep-config-conflict[]
    // tag::p2p-act-rep-start-full[]
    // Create replicator
    // Consider holding a reference somewhere
    // to prevent the Replicator from being GCed
    final Replicator thisReplicator = new Replicator(thisConfig); <i class="conum" data-value="68"></i><b>(68)</b>

    // tag::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-add-change-listener-label[]
    // Optionally add a change listener <i class="conum" data-value="69"></i><b>(69)</b>
    // end::p2p-act-rep-add-change-listener-label[]
    ListenerToken thisListener =
      new thisReplicator.addChangeListener(change -&gt; {
        final CouchbaseLiteException err =
         change.getStatus().getError();
         if (err != null) {
           Log.i(TAG, "Error code ::  " + err.getCode(), e);
         }
      });

    // end::p2p-act-rep-add-change-listener[]
    // tag::p2p-act-rep-start[]
    // Start replicator
    thisReplicator.start(false); <i class="conum" data-value="70"></i><b>(70)</b>

    // end::p2p-act-rep-start[]
    // end::p2p-act-rep-start-full[]
    // end::p2p-act-rep-func[]         ***** End p2p-act-rep-func

  public void ibReplicatorConfig() {
  // BEGIN additional snippets
      // tag::p2p-act-rep-config-tls-full[]
      // tag::p2p-act-rep-config-cacert[]
      // Configure Server Security
      // -- only accept CA attested certs
      thisConfig.setAcceptOnlySelfSignedServerCertificate(false); <i class="conum" data-value="71"></i><b>(71)</b>

      // end::p2p-act-rep-config-cacert[]
      // tag::p2p-act-rep-config-pinnedcert[]

    // Return the remote pinned cert (the listener's cert)
    byte returnedCert
     = new byte(thisConfig.getPinnedCertificate()); // Get listener cert if pinned
    // end::p2p-act-rep-config-pinnedcert[]

    // end::p2p-act-rep-config-tls-full[]
    // tag::p2p-tlsid-tlsidentity-with-label[]
    // ... your other replicator configuration

    // Provide a client certificate to the server for authentication
    final TLSIdentity thisClientId = TLSIdentity.getIdentity("clientId"); <i class="conum" data-value="72"></i><b>(72)</b>

    if (thisClientId == null) { throw new IllegalStateException("Cannot find client id"); }

    thisConfig.setAuthenticator(new ClientCertificateAuthenticator(thisClientId)); <i class="conum" data-value="73"></i><b>(73)</b>

    // ... your other replicator configuration
    final thisReplicator= new Replicator(thisConfig);

    // end::p2p-tlsid-tlsidentity-with-label[]
    // tag::p2p-act-rep-config-cacert-pinned[]

    // Use the pinned certificate from the byte array (cert)
    thisConfig.setPinnedServerCertificate(cert.getEncoded()); <i class="conum" data-value="74"></i><b>(74)</b>
    // end::p2p-act-rep-config-cacert-pinned[]
}
// END additional snippets







// tag::p2p-act-rep-status[]

    Log.i(TAG, "The Replicator is currently " +
      thisReplicator.getStatus().getActivityLevel());

    Log.i(TAG, "The Replicator has processed " + t);

    if (thisReplicator.getStatus().getActivityLevel() ==
      Replicator.ActivityLevel.BUSY) {
        Log.i(TAG, "Replication Processing");
        Log.i(TAG, "It has completed " +
          thisReplicator.getStatus().getProgess().getTotal() +
          " changes");
      }
      // end::p2p-act-rep-status[]

      // tag::p2p-act-rep-stop[]
      // Stop replication.
      thisReplicator.stop(); <i class="conum" data-value="75"></i><b>(75)</b>
      // end::p2p-act-rep-stop[]


  CouchbaseLite.init(context);
  Database thisDB = new Database("passivepeerdb");  <i class="conum" data-value="76"></i><b>(76)</b>
  // Initialize the listener config
  final URLEndpointListenerConfiguration thisConfig = new URLEndpointListenerConfiguration(database);
  thisConfig.setPort(55990)           // &lt;.&gt; Optional; defaults to auto
  thisConfig.setDisableTls(false)     // &lt;.&gt; Optional; defaults to false
  thisConfig.setEnableDeltaSync(true) // &lt;.&gt; Optional; Defaults to false

  // Configure the client authenticator (if using basic auth)
  ListenerPasswordAuthenticator auth = new ListenerPasswordAuthenticator { "username", "password"}; <i class="conum" data-value="77"></i><b>(77)</b>
  thisConfig.setAuthenticator(auth); <i class="conum" data-value="78"></i><b>(78)</b>

  // Initialize the listener
  final URLEndpointListener listener = new URLEndpointListener( thisConfig ); <i class="conum" data-value="79"></i><b>(79)</b>

  // Start the listener
  listener.start(); <i class="conum" data-value="80"></i><b>(80)</b>



  // tag::createTlsIdentity[]

  Map&lt;String, String&gt; X509_ATTRIBUTES = mapOf(
            TLSIdentity.CERT_ATTRIBUTE_COMMON_NAME to "Couchbase Demo",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION to "Couchbase",
            TLSIdentity.CERT_ATTRIBUTE_ORGANIZATION_UNIT to "Mobile",
            TLSIdentity.CERT_ATTRIBUTE_EMAIL_ADDRESS to "noreply@couchbase.com"
        )

  TLSIdentity thisIdentity = new TLSIdentity.createIdentity(true, X509_ATTRIBUTES, null, "test-alias");

  // end::createTlsIdentity[]

  // tag::p2p-tlsid-store-in-keychain[]
  // end::p2p-tlsid-store-in-keychain[]


  // tag::deleteTlsIdentity[]
  // tag::p2p-tlsid-delete-id-from-keychain[]
  String thisAlias = "alias-to-delete";
  final KeyStore thisKeyStore
    =  KeyStore.getInstance("AndroidKeyStore");
  thisKeyStore.load(null);
  thisKeyStore.deleteEntry(thisAlias);

  // end::p2p-tlsid-delete-id-from-keychain[]
  // end::deleteTlsIdentity[]

  // tag::retrieveTlsIdentity[]
  // OPTIONALLY:: Retrieve a stored TLS identity using its alias/label

  TLSIdentity thisIdentity =
    new TLSIdentity.getIdentity("couchbase-docs-cert")
  // end::retrieveTlsIdentity[]


  // tag::sgw-repl-pull[]
  public void ibRplicatorPull() {
    Database database;
    Replicator replicator; <i class="conum" data-value="81"></i><b>(81)</b>

    URI uri = null;
    try {
        uri = new URI("wss://10.0.2.2:4984/db"); <i class="conum" data-value="82"></i><b>(82)</b>
    } catch (URISyntaxException e) {
        e.printStackTrace();
    }
    Endpoint endpoint = new URLEndpoint(uri);
    ReplicatorConfiguration config = new ReplicatorConfiguration(database, endpoint);
    config.setReplicatorType(ReplicatorConfiguration.ReplicatorType.PULL);
    this.replicator = new Replicator(config);
    this.replicator.start();
  }
  // end::sgw-repl-pull[]

    // tag::sgw-act-rep-initialize[]
    // initialize the replicator configuration
    final ReplicatorConfiguration thisConfig
       = new ReplicatorConfiguration(
          thisDB,
          URLEndpoint(URI("wss://10.0.2.2:8954/travel-sample"))); <i class="conum" data-value="83"></i><b>(83)</b>

    // end::sgw-act-rep-initialize[]


  /* C A L L O U T S

  // tag::p2p-act-rep-config-cacert-pinned-callouts[]
  &lt;.&gt; Configure the pinned certificate using data from the byte array `cert`
  // end::p2p-act-rep-config-cacert-pinned-callouts[]

  // tag::p2p-tlsid-tlsidentity-with-label-callouts[]
  &lt;.&gt; Attempt to get the identity from secure storage
  &lt;.&gt; Set the authenticator to ClientCertificateAuthenticator and configure it to use the retrieved identity

  // end::p2p-tlsid-tlsidentity-with-label-callouts[]

  // tag::sgw-repl-pull-callouts[]
  &lt;.&gt; A replication is an asynchronous operation.
  To keep a reference to the `replicator` object, you can set it as an instance property.
  &lt;.&gt; The URL scheme for remote database URLs uses `ws:`, or `wss:` for SSL/TLS connections over wb sockets.
  In this example the hostname is `10.0.2.2` because the Android emulator runs in a VM that is generally accessible on `10.0.2.2` from the host machine (see https://developer.android.com/studio/run/emulator-networking[Android Emulator networking] documentation).
  +
  NOTE: As of Android Pie, version 9, API 28, cleartext support is disabled, by default.
  Although `wss:` protocol URLs are not affected, in order to use the `ws:` protocol, applications must target API 27 or lower, or must configure application network security as described https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted[here].

  // end::sgw-repl-pull-callouts[]
  */

}
/*

Snippets demonstrating use of resultsets

*/
package com.example.docsnippet;
        import android.app.Application.*;
        import android.content.Context;
        import android.content.Context.*;
        import java.lang.Object;
        import java.security.Key;
        import java.util.*;
        import com.couchbase.lite.*;
        import com.couchbase.lite.Dictionary;

public class TestQueries {

    // For Documentation

    Datastore ds = new Datastore();

    Database this_Db = ds.getDB();

    String dbName = this_Db.getName();

    HashMap&lt;String, Object&gt; hotels = new HashMap&lt;&gt;();

    Dictionary thisDocsProps;
    String thisDocsId;
    String thisDocsName;
    String thisDocsType;
    String thisDocsCity;



    static {
        init();
    }

    private static void init() {
    }



    public void testQuerySyntaxAll() throws CouchbaseLiteException {

        // tag::query-syntax-all[]
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

      Query listQuery = QueryBuilder.select(SelectResult.all())
              .from(DataSource.database(this_Db));
        // end::query-syntax-all[]

        // tag::query-access-all[]
        try {
            for (Result result : listQuery.execute().allResults()) {
                             // get the k-v pairs from the 'hotel' key's value into a dictionary
                thisDocsProps = result.getDictionary(0)); <i class="conum" data-value="84"></i><b>(84)</b>
                thisDocsId = thisDocsProps.getString("id");
                thisDocsName = thisDocsProps.getString("Name");
                thisDocsType = thisDocsProps.getString("Type");
                thisDocsCity = thisDocsProps.getString("City");

                // Alternatively, access results value dictionary directly
                final Hotel hotel = new Hotel();
                hotel.Id = result.getDictionary(0).getString("id"); <i class="conum" data-value="85"></i><b>(85)</b>
                hotel.Type = result.getDictionary(0).getString("Type");
                hotel.Name = result.getDictionary(0).getString("Name");
                hotel.City = result.getDictionary(0).getString("City");
                hotel.Country= result.getDictionary(0).getString("Country");
                hotel.Description = result.getDictionary(0).getString("Description");
                hotels.put(hotel.Id, hotel);

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }

        // end::query-access-all[]
      }

// tag::query-access-json[]
    // Uses Jackson JSON processor

    ArrayList&lt;Hotel&gt; hotels = new ArrayList&lt;Hotel&gt;();
    HashMap&lt;String, Object&gt; dictFromJSONstring;
    for (Result result : listQuery.execute()) {

      // Get result as JSON string
      String thisJsonString = result.toJSON(); <i class="conum" data-value="86"></i><b>(86)</b>

      // Get Java  Hashmap from JSON string
      HashMap&lt;String, Object&gt; dictFromJSONstring =
              mapper.readValue(thisJsonString, HashMap.class); <i class="conum" data-value="87"></i><b>(87)</b>


      // Use created hashmap
      String hotelId = dictFromJSONstring.get("id").toString();
      String hotelType = dictFromJSONstring.get("type").toString();
      String hotelname = dictFromJSONstring.get("name").toString();


      // Get custom object from JSON string
      Hotel thisHotel =
              mapper.readValue(thisJsonString, Hotel.class); <i class="conum" data-value="88"></i><b>(88)</b>
      hotels.add(thisHotel);

    }

  // end::query-access-json[]
            }


    public void testQuerySyntaxProps() throws CouchbaseLiteException {

        // tag::query-syntax-props[]
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        Query listQuery =
                QueryBuilder.select(SelectResult.expression(Meta.id),
                        SelectResult.property("name"),
                        SelectResult.property("Name"),
                        SelectResult.property("Type"),
                        SelectResult.property("City"))
                        .from(DataSource.database(this_Db));

        // end::query-syntax-props[]

        // tag::query-access-props[]

        try {
            for (Result result : listQuery.execute().allResults()) {

                // get data direct from result k-v pairs
                final Hotel hotel = new Hotel();
                hotel.Id = result.getString("id");
                hotel.Type = result.getString("Type");
                hotel.Name = result.getString("Name");
                hotel.City = result.getString("City");

                // Store created hotel object in a hashmap of hotels
                hotels.put(hotel.Id, hotel);

                // Get result k-v pairs into a 'dictionary' object
                Map &lt;String, Object&gt; thisDocsProps = result.toMap();
                thisDocsId =
                        thisDocsProps.getOrDefault("id",null).toString();
                thisDocsName =
                        thisDocsProps.getOrDefault("Name",null).toString();
                thisDocsType =
                        thisDocsProps.getOrDefault("Type",null).toString();
                thisDocsCity =
                        thisDocsProps.getOrDefault("City",null).toString();

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }

        // end::query-access-props[]
    }


    public void testQuerySyntaxCount() throws CouchbaseLiteException {
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      // tag::query-syntax-count-only[]
      Query listQuery = QueryBuilder.select(
              SelectResult.expression(Function.count(Expression.string("*"))).as("mycount")) <i class="conum" data-value="89"></i><b>(89)</b>
              .from(DataSource.database(this_Db));

      // end::query-syntax-count-only[]


        // tag::query-access-count-only[]
        try {
            for (Result result : listQuery.execute()) {

                // Retrieve count using key 'mycount'
                Integer altDocId = result.getInt("mycount");

                // Alternatively, use the index
                Integer orDocId = result.getInt(0);
            }
            // Or even miss out the for-loop altogether
            Integer resultCount = listQuery.execute().next().getInt("mycount");

        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }
        // end::query-access-count-only[]
    }


    public void testQuerySyntaxId() throws CouchbaseLiteException {
      // tag::query-syntax-id[]
      try {
        this_Db = new Database("hotels");
      } catch (CouchbaseLiteException e) {
        e.printStackTrace();
      }

      Query listQuery =
              QueryBuilder.select(SelectResult.expression(Meta.id).as("metaID"))
                      .from(DataSource.database(this_Db));

      // end::query-syntax-id[]


        // tag::query-access-id[]

        try {
            for (Result result : listQuery.execute().allResults()) {

                // get the ID form the result's k-v pair array
                thisDocsId = result.getString("metaID"); <i class="conum" data-value="90"></i><b>(90)</b>

                // Get document from DB using retrieved ID
                Document thisDoc = this_Db.getDocument(thisDocsId);

                // Process document as required
                thisDocsName = thisDoc.getString("Name");

            }
        } catch (CouchbaseLiteException e) {
            e.printStackTrace();
        }

        // end::query-access-id[]

    }


    // tag::query-syntax-pagination-all[]
    public void testQueryPagination() throws CouchbaseLiteException {


        // tag::query-syntax-pagination[]
        try {
          this_Db = new Database("hotels");
        } catch (CouchbaseLiteException e) {
          e.printStackTrace();
        }

        int thisOffset = 0;
        int thisLimit = 20;

        Query listQuery =
                QueryBuilder
                        .select(SelectResult.all())
                        .from(DataSource.database(this_Db))
                        .limit(Expression.intValue(thisLimit),
                                  Expression.intValue(thisOffset)); <i class="conum" data-value="91"></i><b>(91)</b>

        // end::query-syntax-pagination[]

    }

    // end::query-syntax-pagination-all[]



} // class</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">

</div>
</div>
<div class="paragraph">
<p>{param-leader}</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset19_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset19_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset19_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">replicator.removeChangeListener(token)</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset19_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">replicator.removeChangeListener(token);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>=== Document Access Removal Behavior</p>
</div>
<div class="paragraph">
<p>When access to a document is removed on Sync Gateway (see: Sync Gateway&#8217;s <a href="../../../sync-gateway/current/sync-function.html" class="page">Sync Function</a>), the document replication listener sends a notification with the <code>AccessRemoved</code> flag set to <code>true</code> and subsequently purges the document from the database.</p>
</div>
<div id="lbl-repl-pend" class="paragraph">
<p>== Documents Pending Push</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.html#isDocumentPending-java.lang.String-">Replicator.isDocumentPending()</a> is quicker and more efficient.
Use it in preference to returning a list of pending document IDs, where possible.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can check whether documents are waiting to be pushed in any forthcoming sync by using either of the following API methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.html#getPendingDocumentIds--">Replicator.getPendingDocumentIds()</a> method, which returns a list of document IDs that have local changes, but which have not yet been pushed to the server.</p>
<div class="paragraph">
<p>This can be very useful in tracking the progress of a push sync, enabling the app to provide a visual indicator to the end user on its status, or decide when it is safe to exit.</p>
</div>
</li>
<li>
<p>Use the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.html#isDocumentPending-java.lang.String-">Replicator.isDocumentPending()</a> method to quickly check whether an individual document is pending a push.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset20_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset20_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset20_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">//
private fun onStatusChanged(
    @NonNull pendingDocs: Set&lt;String&gt;,
    @NonNull status: Replicator.Status
) {
    // ... sample onStatusChanged function
    //
    Log.i(
        Companion.TAG,
        "Replicator activity level is " + status.getActivityLevel().toString()
    )

    // iterate and report-on previously
    // retrieved pending docids 'list'
    val itr = pendingDocs.iterator()
    while (itr.hasNext()) {
        val docId = itr.next()
        try {
            if (!replicator.isDocumentPending(docId)) {
                continue
            } <i class="conum" data-value="1"></i><b>(1)</b>
            itr.remove()
            Log.i(
                Companion.TAG,
                "Doc ID $docId has been pushed"
            )
        } catch (e: CouchbaseLiteException) {
            Log.w(
                Companion.TAG,
                "isDocumentPending failed",
                e
            )
        }
    }</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset20_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">//
private void onStatusChanged(
  @NonNull final Set&lt;String&gt; pendingDocs,
  @NonNull final Replicator.Status status) {
  // ... sample onStatusChanged function
  //
  Log.i(TAG,
    "Replicator activity level is " + status.getActivityLevel().toString());

  // iterate and report-on previously
  // retrieved pending docids 'list'
  for (Iterator&lt;String&gt; itr = pendingDocs.iterator(); itr.hasNext(); ) {
    final String docId = itr.next();
    try {
      if (!replicator.isDocumentPending(docId)) { continue; } <i class="conum" data-value="1"></i><b>(1)</b>

      itr.remove();
      Log.i(TAG, "Doc ID " + docId + " has been pushed");
    }
    catch (CouchbaseLiteException e) {
      Log.w(TAG, "isDocumentPending failed", e); }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.html#getPendingDocumentIds--">Replicator.getPendingDocumentIds()</a> returns a list of the document IDs for all documents waiting to be pushed.
This is a snapshot and may have changed by the time the response is received and processed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.html#isDocumentPending-java.lang.String-">Replicator.isDocumentPending()</a> returns <code>true</code> if the document is waiting to be pushed, and <code>false</code> otherwise.</td>
</tr>
</table>
</div>
<div id="lbl-repl-stop" class="paragraph">
<p>== Stop</p>
</div>
<div class="paragraph">
<p>Stopping a replication is straightforward.
It is done using <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.html#stop--">stop()</a>.
This initiates an asynchronous operation and so is not necessarily immediate.
Your app should account for this potential delay before attempting any subsequent operations, for example closing the database.</p>
</div>
<div class="paragraph">
<p>You can find further information on database operations in {xref-cbl-gp-database}.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Best Practice</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>When you start a change listener, save the returned token, you will need it when you remove the listener</p>
</li>
<li>
<p>Remove any active change listener prior to stopping your replication</p>
</li>
<li>
<p>Ensure the replication has completely stopped by checking for a replication status = STOPPED, before closing any associated database</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset21_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset21_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset21_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">// Stop replication.
thisReplicator.stop() <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset21_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">// Stop replication.
thisReplicator.stop(); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First we stop our change listener</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here we initiate the stopping of the replication using the <a href="https://ibsoln.github.io/api/mobile/3.0/couchbase-lite-android/index.html?com/couchbase/lite/AbstractReplicator.html#stop--">stop()</a> method.<br>
Remove any active <a href="#lbl-repl-chng">change listener</a> before stopping the replicator.</td>
</tr>
</table>
</div>
<div id="lbl-nwk-errs" class="paragraph">
<p>== Error Handling</p>
</div>
<div class="paragraph">
<p>When <em>replicator</em> detects a network error it updates its status depending on the error type (permanent or temporary) and returns an appropriate HTTP error code.</p>
</div>
<div class="paragraph">
<p>The following code snippet adds a <code>Change Listener</code>, which monitors a replication for errors and logs the the returned error code.</p>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset22_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset22_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset22_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">replicator.addChangeListener({ change -&gt;
    val error: CouchbaseLiteException = change.getStatus().getError()
    if (error != null) {
        Log.w(TAG, "Error code:: %d", error)
    }
})
replicator.start()</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset22_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">replicator.addChangeListener(change -&gt; {
    CouchbaseLiteException error = change.getStatus().getError();
    if (error != null) { Log.w(TAG, "Error code:: %d", error); }
});
replicator.start();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>For permanent network errors</strong> (for example, <code>404</code> not found, or <code>401</code> unauthorized):
<em>Replicator</em> will stop permanently, whether <code>setContinuous</code>  is <em>true</em> or <em>false</em>. Of course, it sets its status to <code>STOPPED</code></p>
</div>
<div class="paragraph">
<p><strong>For recoverable or temporary errors:</strong> <em>Replicator</em> sets its status to <code>OFFLINE</code>, then:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>setContinuous=<em>true</em></code> it retries the connection indefinitely</p>
</li>
<li>
<p>If <code>setContinuous=<em>false</em></code> (one-shot) it retries the connection a limited number of times.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following error codes are considered temporary by the Couchbase Lite replicator and thus will trigger a connection retry.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>408</code>: Request Timeout</p>
</li>
<li>
<p><code>429</code>: Too Many Requests</p>
</li>
<li>
<p><code>500</code>: Internal Server Error</p>
</li>
<li>
<p><code>502</code>: Bad Gateway</p>
</li>
<li>
<p><code>503</code>: Service Unavailable</p>
</li>
<li>
<p><code>504</code>: Gateway Timeout</p>
</li>
<li>
<p><code>1001</code>: DNS resolution error</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>== Load Balancers</p>
</div>
<div class="paragraph">
<p>Couchbase Lite <sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup> uses WebSockets as the communication protocol to transmit data.
Some load balancers are not configured for WebSocket connections by default (NGINX for example);
so it might be necessary to explicitly enable them in the load balancer&#8217;s configuration (see <a href="../../../sync-gateway/current/load-balancer.html" class="page">Load Balancers</a>).</p>
</div>
<div class="paragraph">
<p>By default, the WebSocket protocol uses compression to optimize for speed and bandwidth utilization.
The level of compression is set on Sync Gateway and can be tuned in the configuration file (<a href="#sync-gateway:ROOT:refer/config-properties.adoc#replicator_compression" class="page unresolved"><code>replicator_compression</code></a>).</p>
</div>
<div id="lbl-cert-pinning" class="paragraph">
<p>== Certificate Pinning</p>
</div>
<div class="paragraph">
<p>Couchbase Lite for Android supports certificate pinning.</p>
</div>
<div class="paragraph">
<p>Certificate pinning is a technique that can be used by applications to "pin" a host to its certificate.
The certificate is typically delivered to the client by an out-of-band channel and bundled with the client.
In this case, Couchbase Lite uses this embedded certificate to verify the trustworthiness of the server (for example, a Sync Gateway) and no longer needs to rely on a trusted third party for that (commonly referred to as the Certificate Authority).</p>
</div>
<div class="paragraph">
<p>The following steps describe how to configure certificate pinning between Couchbase Lite and Sync Gateway.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="../../../sync-gateway/current/authentication-certs.html#creating-your-own-self-signed-certificate" class="page">Create your own self-signed certificate</a> with the <code>openssl</code> command.
After completing this step, you should have 3 files: <code>cert.pem</code>, <code>cert.cer</code> and <code>privkey.pem</code>.</p>
</li>
<li>
<p><a href="../../../sync-gateway/current/authentication-certs.html#installing-the-certificate" class="page">Configure Sync Gateway</a> with the <code>cert.pem</code> and <code>privkey.pem</code> files.
After completing this step, Sync Gateway is reachable over <code>https</code>/<code>wss</code>.</p>
</li>
<li>
<p>On the Couchbase Lite side, the replication must point to a URL with the <code>wss</code> scheme and configured with the <code>cert.cer</code> file created in step 1.</p>
<div class="paragraph">
<p>This example loads the certificate from the application sandbox, then converts it to the appropriate type to configure the replication object.</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset23_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset23_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset23_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">val `is`: InputStream = getAsset("cert.cer")
val cert: ByteArray = IOUtils.toByteArray(`is`)
if (`is` != null) {
    try {
        `is`.close()
    } catch (ignore: IOException) {
    }
}
config.setPinnedServerCertificate(cert)</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset23_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">InputStream is = getAsset("cert.cer");
byte[] cert = IOUtils.toByteArray(is);
if (is != null) {
    try { is.close(); }
    catch (IOException ignore) {}
}

config.setPinnedServerCertificate(cert);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Build and run your app.
The replication should now run successfully over https/wss with certificate pinning.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For more on pinning certificates see the blog entry: <a href="https://blog.couchbase.com/certificate-pinning-android-with-couchbase-mobile/" target="_blank" rel="noopener">Certificate Pinning with Couchbase Mobile</a></p>
</div>
<div id="lbl-trouble" class="paragraph">
<p>== Troubleshooting</p>
</div>
<div class="paragraph">
<p>=== Logs
As always, when there is a problem with replication, logging is your friend.
You can increase the log output for activity related to replication with Sync Gateway&#8201;&#8212;&#8201;see <a href="#ex-logs">[ex-logs]</a>.</p>
</div>
</div>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset24_kotlin"></a>Kotlin</p>
</li>
<li>
<p><a id="tabset24_java"></a>Java</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset24_kotlin">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin hljs" data-lang="Kotlin" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/kotlin/com/couchbase/code_snippets/Examples.kt">Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE)</code></pre>
</div>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset24_java">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java" data-source-url="https://github.com/ibsoln/docs-couchbase-lite/blob/undefined/modules/android/examples/snippets/app/src/main/java/com/couchbase/code_snippets/Examples.java">Database.setLogLevel(LogDomain.REPLICATOR, LogLevel.VERBOSE);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>For more on troubleshooting with logs, see: <a href="troubleshooting-logs.html" class="page">Using Logs</a>.</p>
</div>
<div class="paragraph">
<p>=== Authentication Errors
If Sync Gateway is configured with a self signed certificate but your app points to a <code>ws</code> scheme instead of <code>wss</code> you will encounter an error with status code <code>11006</code>&#8201;&#8212;&#8201;see: <a href="#ex-11006">[ex-11006]</a></p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">CouchbaseLite Replicator ERROR: {Repl#2} Got LiteCore error: WebSocket error 1006 "connection closed abnormally"</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>If Sync Gateway is configured with a self signed certificate, and your app points to a <code>wss</code> scheme but the replicator configuration isn&#8217;t using the certificate you will encounter an error with status code <code>5011</code>&#8201;&#8212;&#8201;see: <a href="#ex-5011">[ex-5011]</a></p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">CouchbaseLite Replicator ERROR: {Repl#2} Got LiteCore error: Network error 11 "server TLS certificate is self-signed or has unknown root cert"</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>== Related Content</p>
</div>
<div class="card-row three-column-row">
<div class="paragraph column">
<p>====== 
.Learn more &#8230;&#8203;</p>
</div>
<div class="paragraph column">
<div class="title"></div>
<p>====== 
.Reference material &#8230;&#8203;
.</p>
</div>
<div class="paragraph column">
<p>====== 
.Community Resources &#8230;&#8203;</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Prior to version 2.6
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. Couchbase Mobile 2.5+
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. From 2.0
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase">
          </a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="facebook" class="cls-1" d="M29,0H3A2.652,2.652,0,0,0,0,3V29a2.652,2.652,0,0,0,3,3H16V18H12V14h4V12a6.452,6.452,0,0,1,6-6h4v4H22a2.151,2.151,0,0,0-2,2v2h6l-1,4H20V32h9a2.652,2.652,0,0,0,3-3V3A2.652,2.652,0,0,0,29,0Z"/></svg>
            <a href="https://www.facebook.com/Couchbase" class="icon">
            Facebook
            </a>
          </li>
          <li>
            <svg  width="14" height="14" viewBox="0 0 32.1 26.1"> <path id="twitter" class="cls-1" d="M32,7.1a11.836,11.836,0,0,1-3.8,1,6.462,6.462,0,0,0,2.9-3.6,12.606,12.606,0,0,1-4.2,1.6A6.492,6.492,0,0,0,22.1,4a6.594,6.594,0,0,0-6.6,6.6,7.719,7.719,0,0,0,.2,1.5A18.458,18.458,0,0,1,2.2,5.2a6.294,6.294,0,0,0-.9,3.3A6.765,6.765,0,0,0,4.2,14a6.109,6.109,0,0,1-3-.8v.1a6.543,6.543,0,0,0,5.3,6.4,4.678,4.678,0,0,1-1.7.2,4.869,4.869,0,0,1-1.2-.1,6.679,6.679,0,0,0,6.1,4.6,12.917,12.917,0,0,1-8.2,2.8,9.151,9.151,0,0,1-1.6-.1,18.438,18.438,0,0,0,10.1,3c12.1,0,18.7-10,18.7-18.7v-.8A13.336,13.336,0,0,0,32,7.2Z" transform="translate(0.1 -4)"/></svg>
            <a href="https://twitter.com/couchbase" class="icon">
              Twitter
            </a>
          </li>
          <li>
          <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="linkedin" class="cls-1" d="M29,0H3A3.076,3.076,0,0,0,0,3V29a3.009,3.009,0,0,0,3,3H29a2.946,2.946,0,0,0,3-3V3A3.009,3.009,0,0,0,29,0ZM12,26H8V12h4ZM10,10a2,2,0,1,1,2-2A2.006,2.006,0,0,1,10,10ZM26,26H22V18a2,2,0,0,0-4,0v8H14V12h4v2.5c.8-1.1,2.1-2.5,3.5-2.5A4.736,4.736,0,0,1,26,17Z"/></svg>
              <a href="https://www.linkedin.com/company/couchbase" class="icon">
             Linkedin
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <div class="footer-terms-copyright">
          <span> 2021 Couchbase, Inc. Couchbase, Couchbase Lite and the Couchbase logo are registered trademarks of Couchbase, Inc.</span>
      </div>
      <div class="footer-terms-links">
        <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
        <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
        <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
        <a href="https://www.couchbase.com/support-policy">Support Policy</a>
        <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
      </div>
    </div>
  </div>
</footer>
<script id="site-script" src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/fontawesome-icon-defs.js"></script>
<script async src="../../../_/js/vendor/fontawesome.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
</body>
</html>
