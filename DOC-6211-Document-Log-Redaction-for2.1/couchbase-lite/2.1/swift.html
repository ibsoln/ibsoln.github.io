<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>Swift | Couchbase Docs</title>
    <link rel="canonical" href="https://ibsoln.github.io/staging/DOC-6211-Document-Log-Redaction-for2.1/couchbase-lite/2.1/swift.html">
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="schema.dcterms" href="https://purl.org/dc/terms/">
    <meta name="dcterms.subject" content="couchbase-lite">
    <meta name="dcterms.identifier" content="2.1">
    <meta name="generator" content="Antora 2.0.1">
    <link rel="icon" href="../../_/img/favicon.ico" type="image/x-icon">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar" id="topbar">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item" href="https://www.couchbase.com"><img src="../../_/img/logo.svg" alt="Couchbase"></a>
        <button class="navbar-burger" data-target="topbar-menu">
          <span></span>
          <span></span>
          <span></span>
        </button>
      </div>
      <div id="topbar-menu" class="navbar-menu">
        <div class="navbar-start">
          <div class="navbar-item has-dropdown">
            <a class="navbar-link" href="https://ibsoln.github.io/staging/DOC-6211-Document-Log-Redaction-for2.1">Docs</a>
            <div class="navbar-dropdown explore">
              <div class="title">Couchbase Documentation Overview</div>
              <div class="cols">
                <ul>
                  <li class="heading"><a href="#">Server</a></li>
                  <li><a href="../../server//n1ql/n1ql-language-reference/index.html">N1QL</a></li>
                  <li><a href="../../server//fts/full-text-intro.html">Full Text Search</a></li>
                  <li><a href="../../server//analytics/introduction.html">Analytics</a></li>
                  <li><a href="../../server//eventing/eventing-overview.html">Eventing</a></li>
                  <li><a href="#">Autonomous Operator</a></li>
                </ul>
                <ul>
                  <li class="heading">Mobile</li>
                  <li><a href="index.html">Lite</a></li>
                  <li><a href="../../sync-gateway/2.7/index.html">Sync Gateway</a></li>
                </ul>
                <ul class="two-cols">
                  <li class="heading"><a href="../../server//sdk/overview.html">SDKs</a></li>
                  <li><a href="#">C</a></li>
                  <li><a href="#">.NET</a></li>
                  <li><a href="#">Go</a></li>
                  <li><a href="#">Java</a></li>
                  <li><a href="#">Node.js</a></li>
                  <li><a href="#">PHP</a></li>
                  <li><a href="#">Python</a></li>
                  <li><a href="#">Scala</a></li>
                </ul>
                <ul>
                  <li class="heading"><a href="../../server//connectors/intro.html">Connectors</a></li>
                  <li><a href="#">Elasticsearch</a></li>
                  <li><a href="../../server//connectors/hadoop-1.2/hadoop.html">Hadoop</a></li>
                  <li><a href="#">Kafka</a></li>
                  <li><a href="#">Spark</a></li>
                  <li><a href="#">Talend</a></li>
                  <li><a href="../../server//connectors/odbc-jdbc-drivers.html">ODBC/JDBC</a></li>
                </ul>
              </div>
            </div>
          </div>
          <a class="navbar-item component" href="index.html"><span class="title">Couchbase Lite</span> <span class="version">2.1</span></a>
        </div>
        <div class="navbar-end">
          <div class="navbar-item">
            <a class="btn red-btn" href="https://www.couchbase.com/downloads">Downloads</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body container">
<nav class="nav">
<div class="nav-menu">
<ul class="nav-list">
  <li class="nav-item is-current-path is-active" data-depth="0">
    <span class="nav-line">
    <button class="nav-toggle"></button>
    <span class="nav-text">Couchbase Lite</span>
    </span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="introduction.html">Introduction</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="index.html">What&#8217;s New</a>
    </span>
  </li>
  <li class="nav-item is-current-page is-active" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="swift.html">Swift</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="java.html">Java</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="csharp.html">C#</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="objc.html">Objective-C</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="samples.html">Samples</a>
    </span>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-line">
    <a class="nav-link" href="compatibility.html">Compatibility</a>
    </span>
  </li>
</ul>
  </li>
</ul>
</div>
</nav>
<aside class="toc sidebar">
  <div class="toc-menu"></div>
</aside>
<main class="article" data-ceiling="topbar">
  <div class="article-header">
<button class="nav-control"></button>
<nav class="crumbs" aria-label="breadcrumbs">
  <ul>
    <li class="crumb">Couchbase Lite</li>
    <li class="crumb"><a href="swift.html">Swift</a></li>
  </ul>
</nav>
<div class="tools" role="navigation">
  <ul>
    <li class="tool edit"><a href="file:///Users/ianbridge/Documents/CouchbaseDocs/cbl/modules/ROOT/pages/swift.adoc" title="Edit Page" target="_blank" rel="noopener">Edit</a></li>
  </ul>
</div>
  </div>
<article class="doc">
<h1 class="page">Swift</h1>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>Getting Started</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="xcode-project"><a class="anchor" href="#xcode-project"></a>Xcode project</h3>
<div class="paragraph">
<p>Create or open an existing Xcode project and install Couchbase Lite using one of the following methods.</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset1_frameworks"></a>Frameworks</p>
</li>
<li>
<p><a id="tabset1_carthage"></a>Carthage</p>
</li>
<li>
<p><a id="tabset1_cocoapods"></a>CocoaPods</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset1_frameworks">
<div class="ulist">
<ul>
<li>
<p><a href="https://www.couchbase.com/downloads">Download</a> Couchbase Lite.</p>
</li>
<li>
<p>Unzip the file and drag <strong>CouchbaseLiteSwift.framework</strong> from your Finder to the Xcode navigator.</p>
</li>
<li>
<p>Click on <strong>Project &gt; General &gt; Embedded Binary</strong> and add <strong>CouchbaseLiteSwift.framework</strong> to this section.</p>
</li>
<li>
<p>Import the framework and start using it in your project.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">import CouchbaseLiteSwift
...</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset1_carthage">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://github.com/Carthage/Carthage#installing-carthage">Install Carthage</a></p>
</li>
<li>
<p>In your <strong>Cartfile</strong>, add the following.</p>
<div class="listingblock">
<div class="title">Couchbase Lite Community Edition</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ruby hljs" data-lang="ruby">binary "https://packages.couchbase.com/releases/couchbase-lite-ios/carthage/CouchbaseLite-Community.json" ~&gt; {version}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Couchbase Lite Enterprise Edition</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ruby hljs" data-lang="ruby">binary "https://packages.couchbase.com/releases/couchbase-lite-ios/carthage/CouchbaseLite-Enterprise.json" ~&gt; {version}</code></pre>
</div>
</div>
</li>
<li>
<p>Run <code>carthage update --platform ios</code>.</p>
</li>
<li>
<p>Drag <strong>CouchbaseLiteSwift.framework</strong> from <strong>Carthage/Build/</strong> to the Xcode navigator.</p>
</li>
<li>
<p>Click on Project &gt; General &gt; Embedded Binary and add <strong>CouchbaseLiteSwift.framework</strong> to this section.</p>
</li>
</ol>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset1_cocoapods">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://guides.cocoapods.org/using/getting-started.html">Install Cocoapods</a></p>
</li>
<li>
<p>In your <strong>Podfile</strong>, add the following.</p>
<div class="listingblock">
<div class="title">Couchbase Lite Community Edition</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ruby hljs" data-lang="ruby">target 'Example' do
  use_frameworks!
  pod 'CouchbaseLite-Swift', '~&gt; {version}'
end</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Couchbase Lite Enterprise Edition</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-ruby hljs" data-lang="ruby">target 'Example' do
  use_frameworks!
  pod 'CouchbaseLite-Swift-Enterprise', '~&gt; {version}'
end</code></pre>
</div>
</div>
</li>
<li>
<p>Install the pods and open the .xcworkspace file generated by Cocoapods.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">pod install</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="starter-code"><a class="anchor" href="#starter-code"></a>Starter code</h3>
<div class="paragraph">
<p>Open <strong>ViewController.swift</strong> in Xcode and copy the following code in the <code>viewDidLoad</code> method.
This snippet demonstrates how to run basic CRUD operations, a simple Query and running bi-directional replications with Sync Gateway.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Get the database (and create it if it doesnâ€™t exist).
let database: Database
do {
    database = try Database(name: "mydb")
} catch {
    fatalError("Error opening database")
}

// Create a new document (i.e. a record) in the database.
let mutableDoc = MutableDocument()
    .setFloat(2.0, forKey: "version")
    .setString("SDK", forKey: "type")

// Save it to the database.
do {
    try database.saveDocument(mutableDoc)
} catch {
    fatalError("Error saving document")
}

// Update a document.
if let mutableDoc = database.document(withID: mutableDoc.id)?.toMutable() {
    mutableDoc.setString("Swift", forKey: "language")
    do {
        try database.saveDocument(mutableDoc)

        let document = database.document(withID: mutableDoc.id)!
        // Log the document ID (generated by the database)
        // and properties
        print("Document ID :: \(document.id)")
        print("Learning \(document.string(forKey: "language")!)")
    } catch {
        fatalError("Error updating document")
    }
}

// Create a query to fetch documents of type SDK.
let query = QueryBuilder
    .select(SelectResult.all())
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("SDK")))

// Run the query.
do {
    let result = try query.execute()
    print("Number of rows :: \(result.allResults().count)")
} catch {
    fatalError("Error running the query")
}

// Create replicators to push and pull changes to and from the cloud.
let targetEndpoint = URLEndpoint(url: URL(string: "ws://localhost:4984/example_sg_db")!)
let replConfig = ReplicatorConfiguration(database: database, target: targetEndpoint)
replConfig.replicatorType = .pushAndPull

// Add authentication.
replConfig.authenticator = BasicAuthenticator(username: "john", password: "pass")

// Create replicator.
let replicator = Replicator(config: replConfig)

// Listen to replicator change events.
replicator.addChangeListener { (change) in
    if let error = change.status.error as NSError? {
        print("Error code :: \(error.code)")
    }
}

// Start replication.
replicator.start()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Build and run.
You should see the document ID and property printed to the console.
The document was successfully persisted to the database.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/getting-started-ios.png" alt="getting started ios">
</div>
</div>
<div class="paragraph">
<p>In the next step, you will setup Sync Gateway.
Before synchronizing documents to Sync Gateway you will need to disable App Transport Security (ATS) on iOS.
App Transport Security is enabled by default since iOS 9 and enforces applications to use HTTPS exclusively.
For this getting started guide, you will disable it but we recommend to enable it in production (and <a href="../../sync-gateway/2.7/security.html#connection-to-sync-gateway" class="page">enable HTTPS on Sync Gateway</a>).
In the Xcode navigator, right-click on <strong>Info.plist</strong> and open it as a source file.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/info-plist.png" alt="info plist">
</div>
</div>
<div class="paragraph">
<p>Append the following inside of the <code>&lt;dict&gt;</code> XML tags to disable ATS.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;
&lt;dict&gt;
&lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;&lt;true/&gt;
&lt;/dict&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="../../sync-gateway/2.7/getting-started.html#installation" class="page">Installing Sync Gateway &#8594;</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="couchbase-lite-framework-size"><a class="anchor" href="#couchbase-lite-framework-size"></a>Couchbase Lite Framework Size</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Although the size of the Couchbase Lite framework that is downloaded is around 50MB, note that the framework would add only around 3.5MB to the size of the app when it is installed from the App Store.
This is because when the user installs your app from the App Store, only the bits that are relevant to the device architecture are delivered.</p>
</div>
<div class="sect2">
<h3 id="why-is-the-original-size-so-large"><a class="anchor" href="#why-is-the-original-size-so-large"></a>Why is the original size so large?</h3>
<div class="paragraph">
<p>The Couchbase Lite framework  includes a "fat" binary that contains slices for both device (<code>armv7</code>, <code>arm64</code>) and simulator (<code>i386</code> and <code>x86_64</code>) CPU architectures.
The fat binary allows you to link your app to the same framework and run your app on the simulator or a real device.
In addition, the bitcode that is included with the framework contributes to the majority of the download size.
<a href="https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f">Bitcode</a> is an intermediate code representation that allows Apple to recompile the app after App submission and to deliver a thin version of the app specific to the device architecture.</p>
</div>
</div>
<div class="sect2">
<h3 id="architecture-stripping"><a class="anchor" href="#architecture-stripping"></a>Architecture Stripping</h3>
<div class="paragraph">
<p>When submitting a build of your application to the App Store you must ensure that it doesn&#8217;t contain any simulator architecture otherwise the upload will fail with the error message "Unsupported Architecture.
Your executable contains unsupported architecture '[x86_64, i386]'."</p>
</div>
<div class="paragraph">
<p>The steps to remove the simulator architecture (x86_64) from <strong>CouchbaseLite.framework</strong> are outlined below.
They depend on the method you chose to install Couchbase Lite:</p>
</div>
<div class="tabset is-loading">
<div class="ulist tabs">
<ul>
<li>
<p><a id="tabset2_frameworks"></a>Frameworks</p>
</li>
<li>
<p><a id="tabset2_carthage"></a>Carthage</p>
</li>
</ul>
</div>
<div class="content">
<div class="tab-pane" aria-labelledby="tabset2_frameworks">
<div class="paragraph">
<p>The Couchbase Lite framework available on the <a href="https://couchbase.com/downloads">downloads page</a> contains a build for both the simulator (x86_64) and iOS devices (ARM).
The following steps describe how to set up a build phase in Xcode to do this automatically.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In Xcode, open the <strong>Build Phases</strong> tab, then select the <strong>+</strong> &gt; <strong>Add Run Script Build Phase</strong> option.</p>
<div class="paragraph">
<p><span class="image"><img src="_images/run-script-phase.png" alt="run script phase"></span></p>
</div>
</li>
<li>
<p>Copy the contents of <a href="https://raw.githubusercontent.com/couchbase/couchbase-lite-ios/master/Scripts/strip_frameworks.sh">strip_framework.sh</a> in the <strong>Run Script</strong> editor window.</p>
<div class="imageblock">
<div class="content">
<img src="_images/run-script-copy.png" alt="run script copy">
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>That&#8217;s it, now every time you build and run your application, Xcode will remove binary architectures that do not match the target&#8217;s architecture type (emulator or device).</p>
</div>
</div>
<div class="tab-pane" aria-labelledby="tabset2_carthage">
<div class="paragraph">
<p>The <a href="https://github.com/Carthage/Carthage/blob/5fd867c4895b4f59d70181dec169a1644f4430e3/README.md#adding-frameworks-to-an-application">following link</a> describes how to set up a build phase in Xcode and run a Carthage script in order to remove the simulator architecture (x86_64).</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="should-you-disable-bitcode"><a class="anchor" href="#should-you-disable-bitcode"></a>Should you disable bitcode?</h3>
<div class="paragraph">
<p>Although you can disable bitcode within your app and strip away bitcode from the Couchbase Lite framework, it is not necessary to do so.
In fact, it is probably best to leave it enabled to be future proof.
This is because the bitcode is never downloaded by the user even though it is uploaded during App submission.</p>
</div>
</div>
<div class="sect2">
<h3 id="other-resource-to-reduce-the-size-of-your-app"><a class="anchor" href="#other-resource-to-reduce-the-size-of-your-app"></a>Other resource to reduce the size of your app</h3>
<div class="paragraph">
<p>More information is available on this <a href="https://developer.apple.com/library/archive/qa/qa1795/_index.html">Apple Q&amp;A</a> page.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="supported-versions"><a class="anchor" href="#supported-versions"></a>Supported Versions</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Platform</th>
<th class="tableblock halign-left valign-top">Minimum OS version</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">iOS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">9.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">macOS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.9</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="api-references"><a class="anchor" href="#api-references"></a>API References</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://docs.couchbase.com/mobile/2.1/couchbase-lite-swift">Swift SDK API References</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="upgrading"><a class="anchor" href="#upgrading"></a>Upgrading</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="xcode"><a class="anchor" href="#xcode"></a>Xcode</h3>
<div class="paragraph">
<p>The API has changed in Couchbase Lite 2.0 and will require porting an application that is using Couchbase Lite 1.x API to the Couchbase Lite 2.0 API.
To update an Xcode project built with Couchbase Lite 1.x:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Remove the existing <strong>CouchbaseLite.framework</strong> dependency from the Xcode project.</p>
</li>
<li>
<p>Remove all the Couchbase Lite 1.x dependencies (see the <a href="#">1.4@swift.adoc#getting-started</a>).</p>
</li>
<li>
<p>Install the Couchbase Lite 2.0 framework in your project (see the <a href="#getting-started">Getting Started</a> section).
At this point, there will be many compiler warnings.
Refer to the examples on this page to learn about the new API.</p>
</li>
<li>
<p>Build &amp; run your application.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="database-upgrade"><a class="anchor" href="#database-upgrade"></a>Database Upgrade</h3>
<div class="paragraph">
<p>Databases that were created with Couchbase Lite 1.2 or later can be used with Couchbase Lite 2.0.
Upon detecting it is a 1.x database file, Couchbase Lite will automatically upgrade it to 2.0.
This feature is only available for the default storage type (i.e., not a ForestDB database).
Additionally, the automatic migration feature does not support encrypted databases, so if the 1.x database is encrypted you will first need to disable encryption using the Couchbase Lite 1.x API (see the <a href="#">1.4@swift.adoc#database-encryption</a>).</p>
</div>
<div class="sect3">
<h4 id="handling-of-existing-conflicts"><a class="anchor" href="#handling-of-existing-conflicts"></a>Handling of Existing Conflicts</h4>
<div class="paragraph">
<p>For conflicts in the 1.x database, the automatic upgrade process copies the default winning revision to the new 2.0 database and does NOT copy any conflicting revisions.
This functionality is related to the way conflicts are being handled in Couchbase Lite 2.0 (see <a href="#handling-conflicts">Handling Conflicts</a>).
Optionally, existing conflicts in the 1.x database can be resolved with the <a href="#">1.4@swift.adoc#resolving-conflicts</a> prior to the database being upgraded to 2.0.</p>
</div>
</div>
<div class="sect3">
<h4 id="handling-of-existing-attachments"><a class="anchor" href="#handling-of-existing-attachments"></a>Handling of Existing Attachments</h4>
<div class="paragraph">
<p>Attachments that were persisted in the 1.x database will be copied to the 2.0 database.
In Couchbase Lite 2.0, the <code>Attachment</code> API has been renamed to <code>Blob</code> API.
The functionally is identical but the internal schema for attachments has changed.
In 1.x they were stored under the <code>_attachments</code> field and in Couchbase Lite 2.0 they are stored anywhere in the document like other value types.
The automatic upgrade functionality will not update the internal schema for attachments, so they will still be accessible under the <code>_attachments</code> field.
The following example shows how to retrieve an attachment that was created in a 1.x database with the 2.0 API.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let attachments = document.dictionary(forKey: "_attachments")
let avatar = attachments?.blob(forKey: "avatar")
let content = avatar?.content</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="replication-compatibility"><a class="anchor" href="#replication-compatibility"></a>Replication Compatibility</h3>
<div class="paragraph">
<p>The replication protocol used in Couchbase Lite 2.0 has been re-designed from the ground up and it is not backwards compatible with the 1.x replication protocol.
Therefore, to use replication with Couchbase Lite 2.x, the target Sync Gateway instance must also be upgraded to 2.x.</p>
</div>
<div class="paragraph">
<p>Sync Gateway 2.x will continue to accept clients that connect through the 1.x protocol.
It will automatically use the 1.x replication protocol when a Couchbase Lite 1.x client connects through http://localhost:4984/db and the 2.0 replication protocol when a Couchbase Lite 2.0 client connects through ws://localhost:4984/db.
This allows for a smoother transition to get all your user base onto a version of your application built with Couchbase Lite 2.x.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="database"><a class="anchor" href="#database"></a>Database</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="new-database"><a class="anchor" href="#new-database"></a>New Database</h3>
<div class="paragraph">
<p>As the top-level entity in the API, new databases can be created using the <code>Database</code> class by passing in a name, configuration, or both.
The following example creates a database using the <code>Database(name: String)</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">do {
    self.database = try Database(name: "my-database")
} catch {
    print(error)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just as before, the database will be created in a default location.
Alternatively, the <code>Database(name: Strings, config: DatabaseConfiguration?)</code> initializer can be used to provide specific options in the <a href="http://docs.couchbase.com/mobile/2.0/couchbase-lite-swift/db022/Classes/DatabaseConfiguration.html"><code>DatabaseConfiguration</code></a> object such as the database directory.</p>
</div>
</div>
<div class="sect2">
<h3 id="database-encryption"><a class="anchor" href="#database-encryption"></a>Database Encryption</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Enterprise Edition only</div>
Database encryption is an <a href="https://www.couchbase.com/products/editions">Enterprise Edition</a> feature.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Couchbase Lite 2.1 release includes the ability to encrypt Couchbase Lite databases.
This allows mobile applications to secure the data at rest, when it is being stored on the device.
The algorithm used to encrypt the database is 128-bit AES.</p>
</div>
<div class="paragraph">
<p>To enable encryption, you must set the <code>DatabaseConfiguration.encryptionKey</code> property with the encryption key of your choice.
The encryption key is then required every time the database is opened.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let config = DatabaseConfiguration()
config.encryptionKey = EncryptionKey.password("secretpassword")
self.database = try Database(name: "my-database", config: config)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Couchbase Lite does not persist the key.
It is the application&#8217;s responsibility to manage the key and store it in a platform specific secure store such as Apple&#8217;s <a href="https://developer.apple.com/documentation/security/keychain_services">Keychain</a> or Android&#8217;s <a href="https://developer.android.com/training/articles/keystore">Keystore</a>.</p>
</div>
<div class="paragraph">
<p>An encrypted database can only be opened with the same language SDK that was used to encrypt it in the first place (Swift, C#, Java or Objective-C).
For example, if a database is encrypted with the Swift SDK and then exported, it will only be readable with the Swift SDK.</p>
</div>
<div class="sect3">
<h4 id="upgrading-from-1-x-when-encryption-is-enabled"><a class="anchor" href="#upgrading-from-1-x-when-encryption-is-enabled"></a>Upgrading from 1.x when Encryption is Enabled</h4>
<div class="paragraph">
<p>If you&#8217;re migrating an application from Couchbase Lite 1.x to 2.x, note that the <a href="#database-upgrade">automatic database upgrade</a> functionality is <strong>not supported</strong> for encrypted databases.
Thus, to upgrade an encrypted 1.x database, you should do the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Disable encryption using the Couchbase Lite 1.x framework (see <a href="#">1.4@swift.adoc#database-encryption</a>)</p>
</li>
<li>
<p>Open the database file with encryption enabled using the Couchbase Lite 2.x framework (see <a href="#database-encryption">database encryption</a>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Since it is not possible to package Couchbase Lite 1.x and Couchbase Lite 2.x in the same application this upgrade path would require two successive upgrades.
If you are using Sync Gateway to synchronize the database content, it may be preferable to run a pull replication from a new 2.x database with encryption enabled and delete the 1.x local database.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="finding-a-database-file"><a class="anchor" href="#finding-a-database-file"></a>Finding a Database File</h3>
<div class="paragraph">
<p>When the application is running on the iOS simulator, you can locate the application&#8217;s sandbox directory using the <a href="https://simpholders.com/3/">SimPholders</a> utility.</p>
</div>
</div>
<div class="sect2">
<h3 id="cli-tool"><a class="anchor" href="#cli-tool"></a>CLI tool</h3>
<div class="paragraph">
<p><code>cblite</code> is a command-line tool for inspecting and querying Couchbase Lite 2.x databases.</p>
</div>
<div class="paragraph">
<p>You can download and build it from the couchbaselabs <a href="https://github.com/couchbaselabs/couchbase-mobile-tools/blob/master/README.cblite.md">GitHub repository</a>.
Note that the <code>cblite</code> tool is not supported by the <a href="https://www.couchbase.com/support-policy">Couchbase Support Policy</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="logging"><a class="anchor" href="#logging"></a>Logging</h3>
<div class="paragraph">
<p>Couchbase Lite&#8217;s logging strategy provides for the redaction of sensitive information in CBL logs.
This redaction requires no configuration.
It will operate whenever logging is enabled&#8201;&#8212;&#8201;that is when <code>LogLevel</code> is not <code>None</code>.</p>
</div>
<div class="paragraph">
<p>The log messages are split into different domains (<code>LogDomains</code>). Each log domain&#8217;s logging level can be set independently of any other domain&#8217;s logging level.</p>
</div>
<div class="paragraph">
<p>For more on logging configuration, see:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://docs.couchbase.com/mobile/2.1/couchbase-lite-swift/Classes/Database.html#/s:18CouchbaseLiteSwift8DatabaseC11setLogLevelyAA0fG0O_AA0F6DomainO6domaintFZ" target="_blank" rel="noopener">Set Log Level</a></p>
</li>
<li>
<p><a href="http://docs.couchbase.com/mobile/2.1/couchbase-lite-swift/Enums/LogLevel.html" target="_blank" rel="noopener">Log Level Enum</a></p>
</li>
<li>
<p><a href="http://docs.couchbase.com/mobile/2.1/couchbase-lite-swift/Enums/LogDomain.html" target="_blank" rel="noopener">Set Log Domain</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The example code snippet below sets the logging level to <code>verbose</code> for both the <code>replicator</code>, and <code>query</code> domains.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">Database.setLogLevel(.verbose, domain: .replicator)
Database.setLogLevel(.verbose, domain: .query)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="loading-a-pre-built-database"><a class="anchor" href="#loading-a-pre-built-database"></a>Loading a pre-built database</h3>
<div class="paragraph">
<p>If your app needs to sync a lot of data initially, but that data is fairly static and won&#8217;t change much, it can be a lot more efficient to bundle a database in your application and install it on the first launch.
Even if some of the content changes on the server after you create the app, the app&#8217;s first pull replication will bring the database up to date.</p>
</div>
<div class="paragraph">
<p>To use a prebuilt database, you need to set up the database, build the database into your app bundle as a resource, and install the database during the initial launch.
After your app launches, it needs to check whether the database exists.
If the database does not exist, the app should copy it from the app bundle using the <a href="http://docs.couchbase.com/mobile/2.0/couchbase-lite-swift/db022/Classes/Database.html#/s:18CouchbaseLiteSwift8DatabaseC4copyySS8fromPath_SS02toD0AA0D13ConfigurationVSg10withConfigtKFZ"><code>Database.copy(fromPath:toDatabase:withConfig:)</code></a> method as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Note: Getting the path to a database is platform-specific.
// For iOS you need to get the path from the main bundle.
let path = Bundle.main.path(forResource: "travel-sample", ofType: "cblite2")!
if !Database.exists(withName: "travel-sample") {
    do {
        try Database.copy(fromPath: path, toDatabase: "travel-sample", withConfig: nil)
    } catch {
        fatalError("Could not load pre-built database")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="document"><a class="anchor" href="#document"></a>Document</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Couchbase Lite, a document&#8217;s body takes the form of a JSON object&#8212;&#8203;a collection of key/value pairs where the values can be different types of data such as numbers, strings, arrays or even nested objects.
Every document is identified by a document ID, which can be automatically generated (as a UUID) or specified programmatically;
the only constraints are that it must be unique within the database, and it can&#8217;t be changed.</p>
</div>
<div class="sect2">
<h3 id="initializers"><a class="anchor" href="#initializers"></a>Initializers</h3>
<div class="paragraph">
<p>The following methods/initializers can be used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>MutableDocument()</code> initializer can be used to create a new document where the document ID is randomly generated by the database.</p>
</li>
<li>
<p>The <code>MutableDocument(withID: String)</code> initializer can be used to create a new document with a specific ID.</p>
</li>
<li>
<p>The <code>database.document(withID: String)</code> method can be used to get a document.
If it doesn&#8217;t exist in the database, it will return <code>nil</code>.
This method can be used to check if a document with a given ID already exists in the database.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following code example creates a document and persists it to the database.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let newTask = MutableDocument()
    .setString("task", forKey: "type")
    .setString("todo", forKey: "owner")
    .setDate(Date(), forKey: "createdAt")
try database.saveDocument(newTask)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mutability"><a class="anchor" href="#mutability"></a>Mutability</h3>
<div class="paragraph">
<p>By default, when a document is read from the database it is immutable.
The <code>document.toMutable()</code> method should be used to create an instance of the document which can be updated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">guard let document = database.document(withID: "xyz") else { return }
let mutableDocument = document.toMutable()
mutableDocument.setString("apples", forKey: "name")
try database.saveDocument(mutableDocument)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes to the document are persisted to the database when the <code>saveDocument</code> method is called.</p>
</div>
</div>
<div class="sect2">
<h3 id="typed-accessors"><a class="anchor" href="#typed-accessors"></a>Typed Accessors</h3>
<div class="paragraph">
<p>The <code>Document</code> class now offers a set of <a href="http://docs.couchbase.com/mobile/2.0/couchbase-lite-swift/db022/Classes/Document.html#/DictionaryProtocol"><code>property accessors</code></a> for various scalar types, including boolean, integers, floating-point and strings.
These accessors take care of converting to/from JSON encoding, and make sure you get the type you&#8217;re expecting.</p>
</div>
<div class="paragraph">
<p>In addition, as a convenience we offer <code>Date</code> accessors.
Dates are a common data type, but JSON doesn&#8217;t natively support them, so the convention is to store them as strings in ISO-8601 format.
The following example sets the date on the <code>createdAt</code> property and reads it back using the <code>document.date(forKey: String)</code> accessor method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">newTask.setValue(Date(), forKey: "createdAt")
let date = newTask.date(forKey: "createdAt")</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the property doesn&#8217;t exist in the document it will return the default value for that  getter method (0 for <code>getInt</code>, 0.0 for <code>getFloat</code> etc.).</p>
</div>
<div class="paragraph">
<p>If you need to determine whether a given property exists in the document, you should use the <a href="http://docs.couchbase.com/mobile/2.0/couchbase-lite-swift/db022/Classes/Document.html#/s:18CouchbaseLiteSwift8DocumentC8containsSbSS3key_tF"><code>Document.Contains(key: String)</code></a> method.</p>
</div>
<div class="paragraph">
<p>A <code>Document</code> can be converted to a plain dictionary type.
That&#8217;s often useful to pass the document contents as a plain object to another method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">newTask.toDictionary() // returns a Dictionary&lt;String, Any&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="batch-operations"><a class="anchor" href="#batch-operations"></a>Batch operations</h3>
<div class="paragraph">
<p>If you&#8217;re making multiple changes to a database at once, it&#8217;s faster to group them together.
The following example persists a few documents in batch.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">do {
    try database.inBatch {
        for i in 0...10 {
            let doc = MutableDocument()
            doc.setValue("user", forKey: "type")
            doc.setValue("user \(i)", forKey: "name")
            doc.setBoolean(false, forKey: "admin")
            try database.saveDocument(doc)
            print("saved user document \(doc.string(forKey: "name")!)")
        }
    }
} catch let error {
    print(error.localizedDescription)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the <strong>local</strong> level this operation is still transactional: no other <code>Database</code> instances, including ones managed by the replicator can make changes during the execution of the block, and other instances will not see partial changes.
But Couchbase Mobile is a distributed system, and due to the way replication works, there&#8217;s no guarantee that Sync Gateway or other devices will receive your changes all at once.</p>
</div>
</div>
<div class="sect2">
<h3 id="document-change-events"><a class="anchor" href="#document-change-events"></a>Document change events</h3>
<div class="paragraph">
<p>It&#8217;s also possible to register for document changes.
The following example registers for changes to the document with ID <code>user.john</code> and prints the <code>verified_account</code> property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">database.addDocumentChangeListener(withID: "user.john") { (change) in
    if let document = self.database.document(withID: change.documentID) {
        print("Status :: \(document.string(forKey: "verified_account")!)")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="blobs"><a class="anchor" href="#blobs"></a>Blobs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We&#8217;ve renamed "attachments" to "blobs".
The new behavior should be clearer too: a <code>Blob</code> is now a normal object that can appear in a document as a property value.
In other words, you just instantiate a <code>Blob</code> and set it as the value of a property, and then later you can get the property value, which will be a <code>Blob</code> object.
The following code example adds a blob to the document under the <code>avatar</code> property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let appleImage = UIImage(named: "avatar.jpg")!
let imageData = UIImageJPEGRepresentation(appleImage, 1)!

let blob = Blob(contentType: "image/jpeg", data: imageData)
newTask.setBlob(blob, forKey: "avatar")
try database.saveDocument(newTask)

if let taskBlob = newTask.blob(forKey: "image") {
    image = UIImage(data: taskBlob.content!)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Blob</code> API lets you access the contents as in-memory data (a <code>Data</code> object) or as a <code>InputStream</code>.
It also supports an optional <code>type</code> property that by convention stores the MIME type of the contents.</p>
</div>
<div class="paragraph">
<p>In the example above, "image/jpeg" is the MIME type and "avatar" is the key which references that <code>Blob</code>.
That key can be used to retrieve the <code>Blob</code> object at a later time.</p>
</div>
<div class="paragraph">
<p>On Couchbase Lite, blobs can be arbitrarily large, and are only read on demand, not when you load a <code>Document</code> object.
On Sync Gateway, the maximum content size is 20 MB per blob.
If a document&#8217;s blob is over 20 MB, the document will be replicated but not the blob.</p>
</div>
<div class="paragraph">
<p>When a document is synchronized, the Couchbase Lite replicator will add an <code>_attachments</code> dictionary to the document&#8217;s properties if it contains a blob.
A random access name will be generated for each <code>Blob</code> which is different to the "avatar" key that was used in the example above.
On the image below, the document now contains the <code>_attachments</code> dictionary when viewed in the Couchbase Server Admin Console.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/attach_replicated.png" alt="attach replicated" width="500">
</div>
</div>
<div class="paragraph">
<p>A blob also has properties such as <code>"digest"</code> (a SHA-1 digest of the data), <code>"length"</code> (the length in bytes), and optionally <code>"content_type"</code> (the MIME type).
The data is not stored in the document, but in a separate content-addressable store, indexed by the digest.</p>
</div>
<div class="paragraph">
<p>This <code>Blob</code> can be retrieved on the Sync Gateway REST API at http://localhost:4984/justdoit/user.david/blob_1.
Notice that the blob identifier in the URL path is "blob_1" (not "avatar").</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="query"><a class="anchor" href="#query"></a>Query</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Database queries have changed significantly.
Instead of the map/reduce views used in 1.x, they&#8217;re now based on expressions, of the form "return ____ from documents where ____, ordered by ____", with semantics based on Couchbase&#8217;s N1QL query language.</p>
</div>
<div class="paragraph">
<p>There are several parts to specifying a query:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">SELECT</dt>
<dd>
<p>Specifies the projection, which is the part of the document that is to be returned.</p>
</dd>
<dt class="hdlist1">FROM</dt>
<dd>
<p>Specifies the database to query the documents from.</p>
</dd>
<dt class="hdlist1">JOIN</dt>
<dd>
<p>Specifies the matching criteria in which to join multiple documents.</p>
</dd>
<dt class="hdlist1">WHERE</dt>
<dd>
<p>Specifies the query criteria that the result must satisfy.</p>
</dd>
<dt class="hdlist1">GROUP BY</dt>
<dd>
<p>Specifies the query criteria to group rows by.</p>
</dd>
<dt class="hdlist1">ORDER BY</dt>
<dd>
<p>Specifies the query criteria to sort the rows in the result.</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="select-statement"><a class="anchor" href="#select-statement"></a>SELECT statement</h3>
<div class="paragraph">
<p>With the SELECT statement, you can query and manipulate JSON data.
With projections, you retrieve just the fields that you need and not the entire document.</p>
</div>
<div class="paragraph">
<p>A SelectResult represents a single return value of the query statement.
You can specify a comma separated list of <code>SelectResult</code> expressions in the select statement of your query.
For instance the following select statement queries for the document <code>_id</code> as well as the <code>type</code> and <code>name</code> properties of all documents in the database.
In the query result, we print the <code>_id</code> and <code>name</code> properties of each row using the property name getter method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "_id": "hotel123",
    "type": "hotel",
    "name": "Apple Droid"
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let query = QueryBuilder
    .select(
        SelectResult.expression(Meta.id),
        SelectResult.property("type"),
        SelectResult.property("name")
    )
    .from(DataSource.database(database))

do {
    for result in try query.execute() {
        print("document id :: \(result.string(forKey: "id")!)")
        print("document name :: \(result.string(forKey: "name")!)")
    }
} catch {
    print(error)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>SelectResult.all()</code> method can be used to query all the properties of a document.
In this case, the document in the result is embedded in a dictionary where the key is the database name.
The following snippet shows the same query using <code>SelectResult.all()</code> and the result in JSON.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let query = QueryBuilder
    .select(SelectResult.all())
    .from(DataSource.database(database))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">[
    {
        "travel-sample": {
            "callsign": "MILE-AIR",
            "country": "United States",
            "iata": "Q5",
            "icao": "MLA",
            "id": 10,
            "name": "40-Mile Air",
            "type": "airline"
        }
    },
    {
        "travel-sample": {
            "callsign": "TXW",
            "country": "United States",
            "iata": "TQ",
            "icao": "TXW",
            "id": 10123,
            "name": "Texas Wings",
            "type": "airline"
        }
    }
]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="where-statement"><a class="anchor" href="#where-statement"></a>WHERE statement</h3>
<div class="paragraph">
<p>Similar to SQL, you can use the where clause to filter the documents to be returned as part of the query.
The select statement takes in an <code>Expression</code>.
You can chain any number of Expressions in order to implement sophisticated filtering capabilities.</p>
</div>
<div class="sect3">
<h4 id="comparison"><a class="anchor" href="#comparison"></a>Comparison</h4>
<div class="paragraph">
<p>The <a href="http://docs.couchbase.com/mobile/2.0/couchbase-lite-swift/db022/Classes/Expression.html#/Comparison%20Operators">comparison operators</a> can be used in the WHERE statement to specify on which property to match documents.
In the example below, we use the <code>equalTo</code> operator to query documents where the <code>type</code> property equals "hotel".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "_id": "hotel123",
    "type": "hotel",
    "name": "Apple Droid"
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let query = QueryBuilder
    .select(SelectResult.all())
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("hotel")))
    .limit(Expression.int(10))

do {
    for result in try query.execute() {
        if let dict = result.dictionary(forKey: "travel-sample") {
            print("document name :: \(dict.string(forKey: "name")!)")
        }
    }
} catch {
    print(error)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="collection-operators"><a class="anchor" href="#collection-operators"></a>Collection Operators</h4>
<div class="paragraph">
<p><a href="http://docs.couchbase.com/mobile/2.0/couchbase-lite-swift/db022/Classes/Expression.html#/Collection%20operators:">Collection operators</a> are useful to check if a given value is present in an array.</p>
</div>
<div class="sect4">
<h5 id="contains-operator"><a class="anchor" href="#contains-operator"></a>CONTAINS Operator</h5>
<div class="paragraph">
<p>The following example uses the <code>Function.arrayContains</code> to find documents whose <code>public_likes</code> array property contain a value equal to "Armani Langworth".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "_id": "hotel123",
    "name": "Apple Droid",
    "public_likes": ["Armani Langworth", "Elfrieda Gutkowski", "Maureen Ruecker"]
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let query = QueryBuilder
    .select(
        SelectResult.expression(Meta.id),
        SelectResult.property("name"),
        SelectResult.property("public_likes")
    )
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("hotel"))
        .and(ArrayFunction.contains(Expression.property("public_likes"), value: Expression.string("Armani Langworth")))
)

do {
     for result in try query.execute() {
        print("public_likes :: \(result.array(forKey: "public_likes")!.toArray())")
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="in-operator"><a class="anchor" href="#in-operator"></a>IN Operator</h5>
<div class="paragraph">
<p>The <code>IN</code> operator is useful when you need to explicitly list out the values to test against.
The following example looks for documents whose <code>first</code>, <code>last</code> or <code>username</code> property value equals "Armani".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let values = [Expression.property("first"), Expression.property("last"), Expression.property("username")]

QueryBuilder
    .select(SelectResult.all())
    .from(DataSource.database(database))
    .where(Expression.string("Armani").in(values))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="like-operator"><a class="anchor" href="#like-operator"></a>Like Operator</h4>
<div class="paragraph">
<p>The <a href="http://docs.couchbase.com/mobile/2.0/couchbase-lite-swift/db022/Classes/Expression.html#/s:18CouchbaseLiteSwift10ExpressionC4likeACypF"><code>like</code></a> operator can be used for string matching.
Use the <code>like</code> operator for case insensitive matches and the <code>regex</code> operator (see below) for case sensitive matches.</p>
</div>
<div class="paragraph">
<p>In the example below, we are looking for documents of type <code>landmark</code> where the name property exactly matches the string "Royal engineers museum".
Note that since <code>like</code> does a case insensitive match, the following query will return "landmark" type documents with name matching "Royal Engineers Museum", "royal engineers museum", "ROYAL ENGINEERS MUSEUM" and so on.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let query = QueryBuilder
    .select(
        SelectResult.expression(Meta.id),
        SelectResult.property("country"),
        SelectResult.property("name")
    )
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("landmark"))
        .and( Expression.property("name").like(Expression.string("Royal engineers museum")))
    )
    .limit(Expression.int(10))

do {
    for result in try query.execute() {
        print("name property :: \(result.string(forKey: "name")!)")
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="wildcard-match"><a class="anchor" href="#wildcard-match"></a>Wildcard Match</h4>
<div class="paragraph">
<p>We can use <code>%</code> sign within a <code>like</code> expression to do a wildcard match against zero or more characters.
Using wildcards allows you to have some fuzziness in your search string.</p>
</div>
<div class="paragraph">
<p>In the example below, we are looking for documents of <code>type</code> "landmark" where the name property matches any string that begins with "eng" followed by zero or more characters, the letter "e", followed by zero or more characters.
The following query will return "landmark" type documents with name matching "Engineers", "engine", "english egg" , "England Eagle" and so on.
Notice that the matches may span word boundaries.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let query = QueryBuilder
    .select(
        SelectResult.expression(Meta.id),
        SelectResult.property("country"),
        SelectResult.property("name")
    )
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("landmark"))
        .and(Expression.property("name").like(Expression.string("eng%e%")))
    )
    .limit(Expression.int(10))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="wildcard-character-match"><a class="anchor" href="#wildcard-character-match"></a>Wildcard Character Match</h4>
<div class="paragraph">
<p>We can use <code>_</code> sign within a like expression to do a wildcard match against a single character.</p>
</div>
<div class="paragraph">
<p>In the example below, we are looking for documents of type "landmark" where the <code>name</code> property matches any string that begins with "eng" followed by exactly 4 wildcard characters and ending in the letter "r".
The following query will return "landmark" <code>type</code> documents with the <code>name</code> matching "Engineer", "engineer" and so on.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let query = QueryBuilder
    .select(
        SelectResult.expression(Meta.id),
        SelectResult.property("country"),
        SelectResult.property("name")
    )
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("landmark"))
        .and(Expression.property("name").like(Expression.string("eng____r")))
    )
    .limit(Expression.int(10))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="regex-operator"><a class="anchor" href="#regex-operator"></a>Regex Operator</h4>
<div class="paragraph">
<p>The <a href="http://docs.couchbase.com/mobile/2.0/couchbase-lite-swift/db022/Classes/Expression.html#/s:18CouchbaseLiteSwift10ExpressionC5regexACypF"><code>regex</code></a> operator can be used for case sensitive matches.
Similar to wildcard <code>like</code> expressions, <code>regex</code> expressions based pattern matching allow you to have some fuzziness in your search string.</p>
</div>
<div class="paragraph">
<p>In the example below, we are looking for documents of <code>type</code> "landmark" where the name property matches any string (on word boundaries) that begins with "eng" followed by exactly 4 wildcard characters and ending in the letter "r".
The following query will return "landmark" type documents with name matching "Engine", "engine" and so on.
Note that the <code>\b</code> specifies that the match must occur on word boundaries.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let query = QueryBuilder
    .select(
        SelectResult.expression(Meta.id),
        SelectResult.property("name")
    )
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("landmark"))
        .and(Expression.property("name").like(Expression.string("\\bEng.*e\\b")))
    )
    .limit(Expression.int(10))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="join-statement"><a class="anchor" href="#join-statement"></a>JOIN statement</h3>
<div class="paragraph">
<p>The JOIN clause enables you to create new input objects by combining two or more source objects.</p>
</div>
<div class="paragraph">
<p>The following example uses a JOIN clause to find the airline details which have routes that start from RIX.
This example JOINS the document of type "route" with documents of type "airline" using the document ID (<code>_id</code>) on the "airline" document and <code>airlineid</code> on the "route" document.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let query = QueryBuilder
    .select(
        SelectResult.expression(Expression.property("name").from("airline")),
        SelectResult.expression(Expression.property("callsign").from("airline")),
        SelectResult.expression(Expression.property("destinationairport").from("route")),
        SelectResult.expression(Expression.property("stops").from("route")),
        SelectResult.expression(Expression.property("airline").from("route"))
    )
    .from(
        DataSource.database(database!).as("airline")
    )
    .join(
        Join.join(DataSource.database(database!).as("route"))
            .on(
                Meta.id.from("airline")
                    .equalTo(Expression.property("airlineid").from("route"))
        )
    )
    .where(
        Expression.property("type").from("route").equalTo(Expression.string("route"))
            .and(Expression.property("type").from("airline").equalTo(Expression.string("airline")))
            .and(Expression.property("sourceairport").from("route").equalTo(Expression.string("RIX")))
)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="group-by-statement"><a class="anchor" href="#group-by-statement"></a>GROUP BY statement</h3>
<div class="paragraph">
<p>You can perform further processing on the data in your result set before the final projection is generated.
The following example looks for the number of airports at an altitude of 300 ft or higher and groups the results by country and timezone.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "_id": "airport123",
    "type": "airport",
    "country": "United States",
    "geo": { "alt": 456 },
    "tz": "America/Anchorage"
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let query = QueryBuilder
    .select(
        SelectResult.expression(Function.count(Expression.all())),
        SelectResult.property("country"),
        SelectResult.property("tz"))
    .from(DataSource.database(database))
    .where(
        Expression.property("type").equalTo(Expression.string("airport"))
            .and(Expression.property("geo.alt").greaterThanOrEqualTo(Expression.int(300)))
    ).groupBy(
        Expression.property("country"),
        Expression.property("tz")
)

do {
    for result in try query.execute() {
        print("There are \(result.int(forKey: "$1")) airports on the \(result.string(forKey: "tz")!) timezone located in \(result.string(forKey: "country")!) and above 300 ft")
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">There are 138 airports on the Europe/Paris timezone located in France and above 300 ft
There are 29 airports on the Europe/London timezone located in United Kingdom and above 300 ft
There are 50 airports on the America/Anchorage timezone located in United States and above 300 ft
There are 279 airports on the America/Chicago timezone located in United States and above 300 ft
There are 123 airports on the America/Denver timezone located in United States and above 300 ft</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="order-by-statement"><a class="anchor" href="#order-by-statement"></a>ORDER BY statement</h3>
<div class="paragraph">
<p>It is possible to sort the results of a query based on a given expression result.
The example below returns documents of type equal to "hotel" sorted in ascending order by the value of the title property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let query = QueryBuilder
    .select(
        SelectResult.expression(Meta.id),
        SelectResult.property("title"))
    .from(DataSource.database(database))
    .where(Expression.property("type").equalTo(Expression.string("hotel")))
    .orderBy(Ordering.property("title").ascending())
    .limit(Expression.int(10))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Aberdyfi
Achiltibuie
Altrincham
Ambleside
Annan
ArdÃ¨che
Armagh
Avignon</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="live-query"><a class="anchor" href="#live-query"></a>Live Query</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A live query stays active and monitors the database for changes.
A live query is a great way to build reactive user interfaces, especially table/list views, that keep themselves up to date.
For example, as the replicator runs and pulls new data from the server, a live query-driven UI will automatically update to show the data without the user having to manually refresh.
This helps your app feel quick and responsive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let query = QueryBuilder
    .select(SelectResult.all())
    .from(DataSource.database(database))

// Adds a query change listener.
// Changes will be posted on the main queue.
let token = query.addChangeListener { (change) in
    for result in change.results! {
        print(result.keys)
        /* Update UI */
    }
}

// Start live query.
query.execute(); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>To start a live query, you must call <code>query.execute()</code>.
This will immediately execute the query and post the result to the change listener.
When there&#8217;s a change it re-runs itself automatically, and posts the new query result to any observers (change listeners).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example stops the live query with the token from the previous example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">query.removeChangeListener(withToken: token)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="indexing"><a class="anchor" href="#indexing"></a>Indexing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Creating indexes can speed up the performance of queries.
While indexes make queries faster, they also make writes slightly slower, and the Couchbase Lite database file slightly larger.
As such, it is best to only create indexes when you need to optimize a specific case for better query performance.</p>
</div>
<div class="paragraph">
<p>The following example creates a new index for the <code>type</code> and <code>name</code> properties.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "_id": "hotel123",
    "type": "hotel",
    "name": "Apple Droid"
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let index = IndexBuilder.valueIndex(items:
    ValueIndexItem.expression(Expression.property("type")),
    ValueIndexItem.expression(Expression.property("name")))
try database.createIndex(index, withName: "TypeNameIndex")</code></pre>
</div>
</div>
<div class="paragraph">
<p>If there are multiple expressions, the first one will be the primary key, the second the secondary key, etc.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Every index has to be updated whenever a document is updated, so too many indexes can hurt performance.
Thus, good performance depends on designing and creating the <em>right</em> indexes to go along with your queries.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="full-text-search"><a class="anchor" href="#full-text-search"></a>Full-Text Search</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To run a full-text search (FTS) query, you must have created a full-text index on the expression being matched.
Unlike queries, the index is not optional.
The following example inserts documents and creates an FTS index on the <code>name</code> property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Insert documents
let tasks = ["buy groceries", "play chess", "book travels", "buy museum tickets"]
for task in tasks {
    let doc = MutableDocument()
    doc.setString("task", forKey: "type")
    doc.setString(task, forKey: "name")
    try database.saveDocument(doc)
}

// Create index
do {
    let index = IndexBuilder.fullTextIndex(items: FullTextIndexItem.property("name")).ignoreAccents(false)
    try database.createIndex(index, withName: "nameFTSIndex")
} catch let error {
    print(error.localizedDescription)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multiple properties to index can be specified in the <code>Index.fullTextIndex(withItems: [FullTextIndexItem])</code> method.</p>
</div>
<div class="paragraph">
<p>With the index created, an FTS query on the property that is being indexed can be constructed and ran.
The full-text search criteria is defined as a <code>FullTextExpression</code>.
The left-hand side is the full-text index to use and the right-hand side is the pattern to match.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let whereClause = FullTextExpression.index("nameFTSIndex").match("'buy'")
let query = QueryBuilder
    .select(SelectResult.expression(Meta.id))
    .from(DataSource.database(database))
    .where(whereClause)

do {
    for result in try query.execute() {
        print("document id \(result.string(at: 0)!)")
    }
} catch let error {
    print(error.localizedDescription)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, the pattern to match is a word, the full-text search query matches all documents that contain the word "buy" in the value of the <code>doc.name</code> property.</p>
</div>
<div class="paragraph">
<p>Search is supported for all languages that use whitespace to separate words.</p>
</div>
<div class="paragraph">
<p>Stemming, which is the process of fuzzy matching parts of speech, like "fast" and "faster", is supported in the following languages: danish, dutch, english, finnish, french, german, hungarian, italian, norwegian, portuguese, romanian, russian, spanish, swedish and turkish.</p>
</div>
<div class="paragraph">
<p>The pattern to match can also be in the following forms:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">prefix queries</dt>
<dd>
<p>The query expression used to search for a term prefix is the prefix itself with a "*" character appended to it.
For example:</p>
<div class="literalblock">
<div class="content">
<pre>"'lin*'"
-- Query for all documents containing a term with the prefix "lin". This will match
-- all documents that contain "linux", but also those that contain terms "linear",
--"linker", "linguistic" and so on.</pre>
</div>
</div>
</dd>
<dt class="hdlist1">overriding the property name that is being indexed</dt>
<dd>
<p>Normally, a token or token prefix query is matched against the document property specified as the left-hand side of the <code>match</code> operator.
This may be overridden by specifying a property name followed by a ":" character before a basic term query.
There may be space between the ":" and the term to query for, but not between the property name and the ":" character.
For example:</p>
<div class="literalblock">
<div class="content">
<pre>'title:linux problems'
-- Query the database for documents for which the term "linux" appears in
-- the document title, and the term "problems" appears in either the title
-- or body of the document.</pre>
</div>
</div>
</dd>
<dt class="hdlist1">phrase queries</dt>
<dd>
<p>A phrase query is a query that retrieves all documents that contain a nominated set of terms or term prefixes in a specified order with no intervening tokens.
Phrase queries are specified by enclosing a space separated sequence of terms or term prefixes in double quotes (").
For example:</p>
<div class="literalblock">
<div class="content">
<pre>"'"linux applications"'"
-- Query for all documents that contain the phrase "linux applications".</pre>
</div>
</div>
</dd>
<dt class="hdlist1">NEAR queries</dt>
<dd>
<p>A NEAR query is a query that returns documents that contain a two or more nominated terms or phrases within a specified proximity of each other (by default with 10 or less intervening terms).
A NEAR query is specified by putting the keyword "NEAR" between two phrase, token or token prefix queries.
To specify a proximity other than the default, an operator of the form "NEAR/" may be used, where is the maximum number of intervening terms allowed.
For example:</p>
<div class="literalblock">
<div class="content">
<pre>"'database NEAR/2 "replication"'"
-- Search for a document that contains the phrase "replication" and the term
-- "database" with not more than 2 terms separating the two.</pre>
</div>
</div>
</dd>
<dt class="hdlist1">AND, OR &amp; NOT query operators</dt>
<dd>
<p>The enhanced query syntax supports the AND, OR and NOT binary set operators.
Each of the two operands to an operator may be a basic FTS query, or the result of another AND, OR or NOT set operation.
Operators must be entered using capital letters.
Otherwise, they are interpreted as basic term queries instead of set operators.
For example:</p>
<div class="literalblock">
<div class="content">
<pre>'couchbase AND database'
-- Return the set of documents that contain the term "couchbase", and the
-- term "database". This query will return the document with docid 3 only.</pre>
</div>
</div>
<div class="paragraph">
<p>When using the enhanced query syntax, parenthesis may be used to specify the precedence of the various operators.
For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>'("couchbase database" OR "sqlite library") AND linux'
-- Query for the set of documents that contains the term "linux", and at least
-- one of the phrases "couchbase database" and "sqlite library".</pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="ordering-results"><a class="anchor" href="#ordering-results"></a>Ordering results</h3>
<div class="paragraph">
<p>It&#8217;s very common to sort full-text results in descending order of relevance.
This can be a very difficult heuristic to define, but Couchbase Lite comes with a ranking function you can use.
In the <code>OrderBy</code> array, use a string of the form <code>Rank(X)</code>, where <code>X</code> is the property or expression being searched, to represent the ranking of the result.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="replication"><a class="anchor" href="#replication"></a>Replication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Couchbase Mobile 2.0 uses a new replication protocol based on WebSockets.</p>
</div>
<div class="paragraph">
<p>The replicator is designed to send documents from a source to a target database.
The target can be one of the following:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="#starting-sync-gateway">URLEndpoint</a></dt>
<dd>
<p>To replicate data between a local Couchbase Lite database and remote Sync Gateway database.</p>
</dd>
<dt class="hdlist1"><a href="#database-replicas">DatabaseEndpoint</a></dt>
<dd>
<p>To replicate data between two local Couchbase Lite databases to store data on secondary storage.</p>
</dd>
<dt class="hdlist1"><a href="#peer-to-peer-sync">MessageEndpoint</a></dt>
<dd>
<p>To replicate with another Couchbase Lite database via a custom transportation protocol such iOS Multipeer Connectivity, Android WiFi Direct, Android NearByConnection, socket based transportation etc.</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="compatibility"><a class="anchor" href="#compatibility"></a>Compatibility</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The new protocol is <strong>incompatible</strong> with CouchDB-based databases.
And since Couchbase Lite 2 only supports the new protocol, you will need to run a version of Sync Gateway that <a href="../../sync-gateway/2.7/compatibility-matrix.html" class="page">supports it</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use this protocol with Couchbase Lite 2.0, the replication URL should specify WebSockets as the URL scheme (see the "Starting a Replication" section below).
Mobile clients using Couchbase Lite 1.x can continue to use <strong>http</strong> as the URL scheme.
Sync Gateway 2.0 will automatically use the 1.x replication protocol when a Couchbase Lite 1.x client connects through "http://localhost:4984/db" and the 2.0 replication protocol when a Couchbase Lite 2.0 client connects through "ws://localhost:4984/db".</p>
</div>
</div>
<div class="sect2">
<h3 id="starting-sync-gateway"><a class="anchor" href="#starting-sync-gateway"></a>Starting Sync Gateway</h3>
<div class="paragraph">
<p><a href="https://www.couchbase.com/downloads">Download Sync Gateway</a> and start it from the command line with the configuration file created above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">~/Downloads/couchbase-sync-gateway/bin/sync_gateway</code></pre>
</div>
</div>
<div class="paragraph">
<p>For platform specific installation instructions, refer to the Sync Gateway <a href="../../sync-gateway/2.7/getting-started.html#installation" class="page">installation guide</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="starting-a-replication"><a class="anchor" href="#starting-a-replication"></a>Starting a Replication</h3>
<div class="paragraph">
<p>Replication can be bidirectional, this means you can start a <code>push</code>/<code>pull</code> replication with a single instance.
The replication&#8217;s parameters can be specified through the <a href="http://docs.couchbase.com/mobile/2.0/couchbase-lite-swift/db022/Classes/ReplicatorConfiguration.html"><code>ReplicatorConfiguration</code></a> object;
for example, if you wish to start a <code>push</code> only or <code>pull</code> only replication.</p>
</div>
<div class="paragraph">
<p>The following example creates a <code>pull</code> replication with Sync Gateway.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">class MyClass {
    var database: Database?
    var replicator: Replicator? <i class="conum" data-value="1"></i><b>(1)</b>

    func startReplicator() {
        let url = URL(string: "ws://localhost:4984/db")! <i class="conum" data-value="2"></i><b>(2)</b>
        let target = URLEndpoint(url: url)
        let config = ReplicatorConfiguration(database: database!, target: target)
        config.replicatorType = .pull

        self.replicator = Replicator(config: config)
        self.replicator?.start()
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A replication is an asynchronous operation.
To keep a reference to the <code>replicator</code> object, you can set it as an instance property.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The URL scheme for remote database URLs has changed in Couchbase Lite 2.0.
You should now use <code>ws:</code>, or <code>wss:</code> for SSL/TLS connections.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To verify that documents have been replicated, you can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Monitor the Sync Gateway sequence number returned by the database endpoint (<a href="../../sync-gateway/2.7/rest-api.html#/database/get__db__" class="page"><code>GET /{db}/</code></a>).
The sequence number increments for every change that happens on the Sync Gateway database.</p>
</li>
<li>
<p>Query a document by ID on the Sync Gateway REST API (<a href="../../sync-gateway/2.7/rest-api.html#/document/get__db___doc_" class="page"><code>GET /{db}/{id}</code></a>).</p>
</li>
<li>
<p>Query a document from the Query Workbench on the Couchbase Server Console.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Couchbase Lite 2.0 uses WebSockets as the communication protocol to transmit data.
Some load balancers are not configured for WebSocket connections by default (NGINX for example);
so it might be necessary to explicitly enable them in the load balancer&#8217;s configuration (see <a href="../../sync-gateway/2.7/load-balancer.html" class="page">Load Balancers</a>).</p>
</div>
<div class="paragraph">
<p>By default, the WebSocket protocol uses compression to optimize for speed and bandwidth utilization.
The level of compression is set on Sync Gateway and can be tuned in the configuration file (<a href="../../sync-gateway/2.7/config-properties.html#replicator_compression" class="page"><code>replicator_compression</code></a>).</p>
</div>
<div class="sect3">
<h4 id="replication-ordering"><a class="anchor" href="#replication-ordering"></a>Replication Ordering</h4>
<div class="paragraph">
<p>To optimize for speed, the replication protocol doesn&#8217;t guarantee that documents will be received in a particular order.
So we don&#8217;t recommend to rely on that when using the replication or database change listeners for example.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="troubleshooting"><a class="anchor" href="#troubleshooting"></a>Troubleshooting</h3>
<div class="paragraph">
<p>As always, when there is a problem with replication, logging is your friend.
The following example increases the log output for activity related to replication with Sync Gateway.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">// Replicator
Database.setLogLevel(.verbose, domain: .replicator)
// Network
Database.setLogLevel(.verbose, domain: .network)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="authentication"><a class="anchor" href="#authentication"></a>Authentication</h3>
<div class="paragraph">
<p>By default, Sync Gateway does not enable authentication.
This is to make it easier to get up and running with synchronization.
You can enable authentication with the following properties in the configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "databases": {
    "mydatabase": {
      "users": {
        "GUEST": {"disabled": true}
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To authenticate with Sync Gateway, an associated user must first be created.
Sync Gateway users can be created through the <a href="../../sync-gateway/2.7/admin-rest-api.html#/user/post__db___user_" class="page"><code>POST /{db}/_user</code></a> endpoint on the Admin REST API.
Provided that the user exists on Sync Gateway, there are two ways to authenticate from a Couchbase Lite client: Basic Authentication or Session Authentication.</p>
</div>
<div class="sect3">
<h4 id="basic-authentication"><a class="anchor" href="#basic-authentication"></a>Basic Authentication</h4>
<div class="paragraph">
<p>You can provide a user name and password to the basic authenticator class method.
Under the hood, the replicator will send the credentials in the first request to retrieve a <code>SyncGatewaySession</code> cookie and use it for all subsequent requests during the replication.
This is the recommended way of using basic authentication.
The following example initiates a one-shot replication as the user <strong>john</strong> with the password <strong>pass</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let url = URL(string: "ws://localhost:4984/mydatabase")!
let target = URLEndpoint(url: url)
let config = ReplicatorConfiguration(database: database, target: target)
config.authenticator = BasicAuthenticator(username: "john", password: "pass")

self.replicator = Replicator(config: config)
self.replicator.start()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="session-authentication"><a class="anchor" href="#session-authentication"></a>Session Authentication</h4>
<div class="paragraph">
<p>Session authentication is another way to authenticate with Sync Gateway.
A user session must first be created through the <a href="../../sync-gateway/2.7/rest-api.html#/session/post__db___session" class="page"><code>POST /{db}/_session</code></a> endpoint on the Public REST API.
The HTTP response contains a session ID which can then be used to authenticate as the user it was created for.
The following example initiates a one-shot replication with the session ID that is returned from the <code>POST /{db}/_session</code> endpoint.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let url = URL(string: "ws://localhost:4984/mydatabase")!
let target = URLEndpoint(url: url)
let config = ReplicatorConfiguration(database: database, target: target)
config.authenticator = SessionAuthenticator(sessionID: "904ac010862f37c8dd99015a33ab5a3565fd8447")

self.replicator = Replicator(config: config)
self.replicator.start()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="replication-status"><a class="anchor" href="#replication-status"></a>Replication Status</h3>
<div class="paragraph">
<p>The <code>replication.status.activity</code> property can be used to check the status of a replication.
For example, when the replication is actively transferring data and when it has stopped.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">self.replicator.addChangeListener { (change) in
    if change.status.activity == .stopped {
        print("Replication stopped")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following table lists the different activity levels in the API and the meaning of each one.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">State</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>STOPPED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replication is finished or hit a fatal error.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OFFLINE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replicator is offline as the remote host is unreachable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONNECTING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replicator is connecting to the remote host.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IDLE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replication caught up with all the changes available from the server.
The <code>IDLE</code> state is only used in continuous replications.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BUSY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The replication is actively transferring data.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The replication change object also has properties to track the progress (<code>change.status.completed</code> and <code>change.status.total</code>).
But since the replication occurs in batches and the total count can vary through the course of a replication, those progress indicators are not very useful from the standpoint of an app user.
Hence, these should not be used for tracking the actual progress of the replication.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="handling-network-errors"><a class="anchor" href="#handling-network-errors"></a>Handling Network Errors</h3>
<div class="paragraph">
<p>If an error occurs, the replication status will be updated with an <code>Error</code> which follows the standard HTTP error codes.
The following example monitors the replication for errors and logs the error code to the console.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">self.replicator.addChangeListener { (change) in
    if let error = change.status.error as NSError? {
        print("Error code :: \(error.code)")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a permanent error occurs (i.e., <code>404</code>: not found, <code>401</code>: unauthorized), the replicator (continuous or one-shot) will stop permanently.
If the error is temporary (i.e., waiting for the network to recover), a continuous replication will retry to connect indefinitely and if the replication is one-shot it will retry for a limited number of times.
The following error codes are considered temporary by the Couchbase Lite replicator and thus will trigger a connection retry.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>408</code>: Request Timeout</p>
</li>
<li>
<p><code>429</code>: Too Many Requests</p>
</li>
<li>
<p><code>500</code>: Internal Server Error</p>
</li>
<li>
<p><code>502</code>: Bad Gateway</p>
</li>
<li>
<p><code>503</code>: Service Unavailable</p>
</li>
<li>
<p><code>504</code>: Gateway Timeout</p>
</li>
<li>
<p><code>1001</code>: DNS resolution error</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="custom-headers"><a class="anchor" href="#custom-headers"></a>Custom Headers</h3>
<div class="paragraph">
<p>Custom headers can be set on the configuration object.
And the replicator will send those header(s) in every request.
As an example, this feature can be useful to pass additional credentials when there is an authentication or authorization step being done by a proxy server (between Couchbase Lite and Sync Gateway).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let config = ReplicatorConfiguration(database: database, target: target)
config.headers = ["CustomHeaderName": "Value"]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="replication-checkpoint-reset"><a class="anchor" href="#replication-checkpoint-reset"></a>Replication Checkpoint Reset</h3>
<div class="paragraph">
<p>Checkpoints are used by the replicator to keep track of documents that are sent to the target database.
Without checkpoints, Couchbase Lite would send the entire database content every time it connects to the target database, even though the target database may already have the majority of the database content from previous replications.</p>
</div>
<div class="paragraph">
<p>This functionality is generally not a concern to application developers.
But if you require the replication to start again from zero then you may call the checkpoint reset method <strong>before</strong> starting the replicator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">self.replicator.resetCheckpoint()
self.replicator.start()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="handling-conflicts"><a class="anchor" href="#handling-conflicts"></a>Handling Conflicts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Document conflicts can occur when changes are made to the same version of a document by multiple peers in a distributed system.
With Couchbase Mobile, this can be a Couchbase Lite or Sync Gateway database instance, and conflicts can occur in the following scenarios:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When a replication is in progress, or</p>
</li>
<li>
<p>When saving a document</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following sections discuss each scenario in more detail.</p>
</div>
<div class="sect2">
<h3 id="case-1-conflicts-when-a-replication-is-in-progress"><a class="anchor" href="#case-1-conflicts-when-a-replication-is-in-progress"></a>Case 1: Conflicts when a replication is in progress</h3>
<div class="paragraph">
<p>There&#8217;s no practical way to prevent a conflict when two updates to a document are made on different instances of the app.
Neither app even knows that the other one has changed the document, until later on when replication propagates their incompatible changes to each other.
A typical scenario is:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Molly creates DocumentA.</p>
</li>
<li>
<p>DocumentA is synced to Naomi&#8217;s device.</p>
</li>
<li>
<p>Molly updates DocumentA, let&#8217;s call it ChangeX for the purpose of this example.</p>
</li>
<li>
<p>Naomi makes a different change to DocumentA, let&#8217;s call it ChangeY.</p>
</li>
<li>
<p>ChangeY is synced to Molly&#8217;s device, which already has ChangeX, putting the document in conflict.</p>
</li>
<li>
<p>ChangeX is synced to Naomi&#8217;s device, which already has ChangeY, similarly putting the local document in conflict.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Couchbase Lite uses the following rules to handle the conflicts occurring in steps 5 and 6.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A deleted document (i.e tombstone) always wins over a document update.</p>
</li>
<li>
<p>If both changes are document updates, the Last-Write-Win (LWW) algorithm is used to pick the winning update.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The result is saved internally by the Couchbase Lite replicator.
Those rules describe the internal behavior of the replicator.
There is currently no other way to handle conflicts when a replication is in progress.</p>
</div>
</div>
<div class="sect2">
<h3 id="case-2-conflicts-when-saving-a-document"><a class="anchor" href="#case-2-conflicts-when-saving-a-document"></a>Case 2: Conflicts when saving a document</h3>
<div class="paragraph">
<p>When updating a document, you need to consider the possibility of update conflicts.
Update conflicts can occur when you try to update a document thatâ€™s been updated since you read it.
Here&#8217;s a typical sequence of events that would create an update conflict:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Your code reads the document&#8217;s current properties, and constructs a modified copy to save.</p>
</li>
<li>
<p>Another thread (perhaps the replicator) updates the document, creating a new revision with different properties.</p>
</li>
<li>
<p>Your code updates the document (by calling <code>save(document: MutableDocument)</code>) with its modified properties.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In Couchbase Lite 2.0, by default, the conflict is automatically resolved and only one document update is stored in the database.
The Last-Write-Win (LWW) algorithm is used to pick the winning update.
So in effect, the changes from step 2 would be overwritten and lost.</p>
</div>
<div class="paragraph">
<p>If the probability of update conflicts is high in your app and you wish to avoid the possibility of overwritten data, the <code>save</code> and <code>delete</code> APIs provide additional method signatures with concurrency control:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>save(document: MutableDocument, concurrencyControl: ConcurrencyControl)</code>: attempts to save the document with a concurrency control.
The concurrency control parameter has two possible values:</p>
<div class="ulist">
<ul>
<li>
<p><code>lastWriteWins</code> (default): The last operation wins if there is a conflict.</p>
</li>
<li>
<p><code>failOnConflict</code>: The operation will fail if there is a conflict.
In this case, the app can detect the error that is being thrown, and handle it by re-reading the document, making the necessary conflict resolution, then trying again.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Similarly to the save operation, the delete operation also has two method signatures to specify how to handle a possible conflict:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>delete(document: Document)</code>: The last write will win if there is a conflict.</p>
</li>
<li>
<p><code>delete(document: Document, concurrencyControl: ConcurrencyControl)</code>: attempts to delete the document with a concurrency control.
The concurrency control parameter has two possible values:</p>
<div class="ulist">
<ul>
<li>
<p><code>lastWriteWins</code> (default): The last operation wins if there is a conflict.</p>
</li>
<li>
<p><code>failOnConflict</code>: The operation will fail if there is a conflict.
In this case, the app can detect the error that is being thrown, and handle it by re-reading the document, making the necessary conflict resolution, then trying again.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="database-replicas"><a class="anchor" href="#database-replicas"></a>Database Replicas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Database replicas is available in the <strong>Enterprise Edition</strong> only (<a href="https://www.couchbase.com/downloads" class="bare">https://www.couchbase.com/downloads</a>).
Starting in Couchbase Lite 2.0, replication between two local databases is now supported.
It allows a Couchbase Lite replicator to store data on secondary storage.
It would be especially useful in scenarios where a user&#8217;s device is damaged and the data needs to be moved to a different device.
Note that the code below won&#8217;t compile if you&#8217;re running the <strong>Community Edition</strong> of Couchbase Lite.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let targetDatabase = DatabaseEndpoint(database: database2)
let config = ReplicatorConfiguration(database: database, target: targetDatabase)
config.replicatorType = .push

self.replicator = Replicator(config: config)
self.replicator.start()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="certificate-pinning"><a class="anchor" href="#certificate-pinning"></a>Certificate Pinning</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Couchbase Lite supports certificate pinning.
Certificate pinning is a technique that can be used by applications to "pin" a host to its certificate.
The certificate is typically delivered to the client by an out-of-band channel and bundled with the client.
In this case, Couchbase Lite uses this embedded certificate to verify the trustworthiness of the server and no longer needs to rely on a trusted third party for that (commonly referred to as the Certificate Authority).</p>
</div>
<div class="paragraph">
<p>The <code>openssl</code> command can be used to create a new self-signed certificate and convert the <code>.pem</code> file to a <code>.cert</code> file (see <a href="../../sync-gateway/2.7/security.html#creating-your-own-self-signed-certificate" class="page">creating your own self-signed certificate</a>).
You should then have 3 files: <code>cert.pem</code>, <code>cert.cer</code> and <code>key.pem</code>.</p>
</div>
<div class="paragraph">
<p>The <code>cert.pem</code> and <code>key.pem</code> can be used in the Sync Gateway configuration (see <a href="../../sync-gateway/2.7/security.html#installing-the-certificate" class="page">installing the certificate</a>).</p>
</div>
<div class="paragraph">
<p>On the Couchbase Lite side, the replication must be configured with the <code>cert.cer</code> file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let data = try self.dataFromResource(name: "cert", ofType: "cer")
let certificate = SecCertificateCreateWithData(nil, data)

let config = ReplicatorConfiguration(database: database, target: target)
config.pinnedServerCertificate = certificate</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example loads the certificate from the application sandbox, then converts it to the appropriate type to configure the replication object.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="peer-to-peer-sync"><a class="anchor" href="#peer-to-peer-sync"></a>Peer-to-Peer Sync</h2>
<div class="sectionbody">
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="title">Enterprise Edition only</div>
Peer-to-peer sync is an <a href="https://www.couchbase.com/products/editions">Enterprise Edition</a> feature.
You must purchase the Enterprise License which includes official <a href="https://www.couchbase.com/support-policy">Couchbase Support</a> to use it in production (also see the <a href="https://www.couchbase.com/licensing-and-support-faq">FAQ</a>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Peer-to-peer sync allows devices running Couchbase Lite to directly sync data with each other.
As part of this, Couchbase Lite is responsible for storing the data and keeping track of the data exchange, but isn&#8217;t responsible for the data transfer itself.
Sending and receiving data must be handled by the platform APIs or a third party framework.
In this section, we will refer to these third party frameworks as communication frameworks.</p>
</div>
<div class="paragraph">
<p>On iOS, Apple&#8217;s <a href="https://developer.apple.com/documentation/multipeerconnectivity">Multipeer Connectivity Framework</a> would be a good choice for the Communication Framework.</p>
</div>
<div class="paragraph">
<p>Thus, to enable peer-to-peer sync with Couchbase Lite, the application must use the Communication Framework with Couchbase Lite.
The following sections describe a typical peer-to-peer workflow.
Where applicable, we discuss how to integrate Couchbase Lite into the workflow.</p>
</div>
<div class="paragraph">
<p>In Couchbase Lite, a peer can take on one of these two roles:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Active Peer</dt>
<dd>
<p>The peer that initializes the connection and replication (i.e the "client" side).</p>
</dd>
<dt class="hdlist1">Passive Peer</dt>
<dd>
<p>The passive side reacts to things that it receives but does not initiate any communication on its own (i.e. the "server" side).</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="peer-discovery"><a class="anchor" href="#peer-discovery"></a>Peer Discovery</h3>
<div class="paragraph">
<p>Peer discovery is the first step.
The communication framework will generally include a peer discovery API for devices to advertise themselves on the network and to browse for other peers.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/discovery.png" alt="discovery">
</div>
</div>
<div class="sect3">
<h4 id="active-peer"><a class="anchor" href="#active-peer"></a>Active Peer</h4>
<div class="paragraph">
<p>The first step is to initialize the Couchbase Lite database.</p>
</div>
</div>
<div class="sect3">
<h4 id="passive-peer"><a class="anchor" href="#passive-peer"></a>Passive Peer</h4>
<div class="paragraph">
<p>In addition to initializing the database, the passive peer must initialize the <code>MessageEndpointListener</code>.
The <code>MessageEndpointListener</code> acts as as a listener for incoming connections.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let database = try! Database(name: "mydb")
let config = MessageEndpointListenerConfiguration(database: database, protocolType: .messageStream)
messageEndpointListener = MessageEndpointListener(config: config)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="peer-selection-and-connection-setup"><a class="anchor" href="#peer-selection-and-connection-setup"></a>Peer Selection and Connection Setup</h3>
<div class="paragraph">
<p>Once a peer device is found, it is the application code&#8217;s responsibility to decide whether it should establish a connection with that peer.
This step includes inviting a peer to a session and peer authentication.</p>
</div>
<div class="paragraph">
<p>This is handled by the Communication Framework.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/selection.png" alt="selection">
</div>
</div>
<div class="paragraph">
<p>Once the remote peer has been authenticated, the next step is to connect with that peer and initialize the Message Endpoint API.</p>
</div>
</div>
<div class="sect2">
<h3 id="replication-setup"><a class="anchor" href="#replication-setup"></a>Replication Setup</h3>
<div class="imageblock">
<div class="content">
<img src="_images/connection.png" alt="connection">
</div>
</div>
<div class="sect3">
<h4 id="active-peer-2"><a class="anchor" href="#active-peer-2"></a>Active Peer</h4>
<div class="paragraph">
<p>When the connection is established, the active peer must instantiate a <code>MessageEndpoint</code> object corresponding to the remote peer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let database = try Database(name: "dbname")

// The delegate must implement the `MessageEndpointDelegate` protocol.
let messageEndpointTarget = MessageEndpoint(uid: "UID:123", target: id, protocolType: .messageStream, delegate: self)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>MessageEndpoint</code> initializer takes the following arguments.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>uid</code>: a unique ID that represents the remote active peer.</p>
</li>
<li>
<p><code>target</code>: This represents the remote passive peer and could be any suitable representation of the remote peer.
It could be an Id, URL etc.
If using the MultiPeerConnectivity Framework, this could be the MCPeerID.</p>
</li>
<li>
<p><code>protocolType</code>: specifies the kind of transport you intend to implement.
There are two options.</p>
<div class="ulist">
<ul>
<li>
<p>The default (<code>MessageStream</code>) means that you want to "send a series of messages", or in other words the Communication Framework will control the formatting of messages so that there are clear boundaries between messages.</p>
</li>
<li>
<p>The alternative (<code>ByteStream</code>) means that you just want to send raw bytes over the stream and Couchbase should format for you to ensure that messages get delivered in full.</p>
<div class="paragraph">
<p>Typically, the Communication Framework will handle message assembly and disassembly so you would use the <code>MessageType</code> option in most cases.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>delegate</code>: the delegate that will implement the <code>MessageEndpointDelegate</code> protocol, which is a factory for <code>MessageEndpointConnection</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Then, a <code>Replicator</code> is instantiated with the initialized <code>MessageEndpoint</code> as the target.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let config = ReplicatorConfiguration(database: database, target: messageEndpointTarget)

// Create the replicator object.
let replicator = Replicator(config: config)
// Start the replication.
replicator.start()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, Couchbase Lite will call back the application code through the <code>MessageEndpointDelegate.createConnection</code> interface method.
When the application receives the callback, it must create an instance of <code>MessageEndpointConnection</code> and return it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">/* implementation of MessageEndpointDelegate */
func createConnection(endpoint: MessageEndpoint) -&gt; MessageEndpointConnection {
    let connection = ActivePeerConnection() /* implements MessageEndpointConnection */
    return connection
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, Couchbase Lite will call back the application code through the <code>MessageEndpointConnection.open</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">/* implementation of MessageEndpointConnection */
func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
    replicatorConnection = connection
    completion(true, nil)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The connection argument is then set on an instance variable.
The application code must keep track of every <code>ReplicatorConnection</code> associated with every <code>MessageEndpointConnection</code>.</p>
</div>
<div class="paragraph">
<p>The <code>MessageError</code> argument in the completion block is used to specify if the error is recoverable or not.
If it is a recoverable error, the replicator will kick off a retry process which will result to creating a new <code>MessageEndpointConnection</code> instance.</p>
</div>
</div>
<div class="sect3">
<h4 id="passive-peer-2"><a class="anchor" href="#passive-peer-2"></a>Passive Peer</h4>
<div class="paragraph">
<p>The first step after connection establishment on the passive peer is to initialize a new <code>MessageEndpointConnection</code> and pass it to the listener.
This tells the listener to accept incoming data from that peer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let connection = PassivePeerConnection() /* implements MessageEndpointConnection */
messageEndpointListener?.accept(connection: connection)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>messageEndpointListener</code> is the instance of the <code>MessageEndpointListener</code> that was created in the first step (<a href="#peer-discovery">Peer Discovery</a>)</p>
</div>
<div class="paragraph">
<p>Couchbase Lite will then call back the application code through the <code>MessageEndpointConnection.open</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">/* implementation of MessageEndpointConnection */
func open(connection: ReplicatorConnection, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
    replicatorConnection = connection
    completion(true, nil)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>connection</code> argument is then set on an instance variable.
The application code must keep track of every <code>ReplicatorConnection</code> associated with every <code>MessageEndpointConnection</code>.</p>
</div>
<div class="paragraph">
<p>At this point, the connection is established and both peers are ready to exchange data.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pushpull-replication"><a class="anchor" href="#pushpull-replication"></a>Push/Pull Replication</h3>
<div class="paragraph">
<p>Typically, an application needs to send data and receive data.
Directionality of the replication could be any of the following.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Push only:</strong> The data is pushed from the local database to the remote database.</p>
</li>
<li>
<p><strong>Pull only:</strong> The data is pulled from the remote database to the local database.</p>
</li>
<li>
<p><strong>Push and Pull:</strong> The data is exchanged both ways.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Usually, the remote is a Sync Gateway database which is identified through a URL.
In the context of peer-to-peer syncing, the remote is another Couchbase Lite database.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/replication.png" alt="replication">
</div>
</div>
<div class="paragraph">
<p>The replication lifecycle is handled through the <code>MessageEndpointConnection</code>.</p>
</div>
<div class="sect3">
<h4 id="active-peer-3"><a class="anchor" href="#active-peer-3"></a>Active Peer</h4>
<div class="paragraph">
<p>When Couchbase Lite calls back the application code through the <code>MessageEndpointConnection.send</code> method, you should send that data to the other peer using the communication framework.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">/* implementation of MessageEndpointConnection */
func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
    var data = message.toData()
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(true, nil)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once the data is sent, call the completion block to acknowledge the completion.
You can use the <code>MessageError</code> in the completion block to specify if the error is recoverable or not.
If it is a recoverable error, the replicator will kick off a retry process which will result to creating a new <code>MessageEndpointConnection</code>.</p>
</div>
<div class="paragraph">
<p>When data is received from the passive peer via the Communication Framework, you call the <code>ReplicatorConnection.receive</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let message = Message.fromData(data)
replicatorConnection?.receive(message: message)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The replication connection&#8217;s <code>receive</code> method is called which then processes the data in order to persist it to the local database.</p>
</div>
</div>
<div class="sect3">
<h4 id="passive-peer-3"><a class="anchor" href="#passive-peer-3"></a>Passive Peer</h4>
<div class="paragraph">
<p>As in the case of the active peer, the passive peer must implement the <code>MessageEndpointConnection.send</code> method to send data to the other peer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">/* implementation of MessageEndpointConnection */
func send(message: Message, completion: @escaping (Bool, MessagingError?) -&gt; Void) {
    var data = Data()
    data.append(message.toData())
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(true, nil)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once the data is sent, call the completion block to acknowledge the completion.
You can use the <code>MessageError</code> in the completion block to specify if the error is recoverable or not.
If it is a recoverable error, the replicator will kick off a retry process which will result to creating a new <code>MessageEndpointConnection</code>.</p>
</div>
<div class="paragraph">
<p>When data is received from the active peer via the Communication Framework, you call the <code>ReplicatorConnection.receive</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">let message = Message.fromData(data)
replicatorConnection?.receive(message: message)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="connection-teardown"><a class="anchor" href="#connection-teardown"></a>Connection Teardown</h3>
<div class="paragraph">
<p>When a peer disconnects from a peer-to-peer network, all connected peers are notified.
The disconnect notification is a good opportunity to close and remove a replication connection.
The steps to teardown the connection are slightly different depending on whether it is the active or passive peer that disconnects first.
We will cover each case below.</p>
</div>
<div class="sect3">
<h4 id="initiated-by-active-peer"><a class="anchor" href="#initiated-by-active-peer"></a>Initiated by Active Peer</h4>
<div class="imageblock">
<div class="content">
<img src="_images/dis-active.png" alt="dis active">
</div>
</div>
<div class="sect4">
<h5 id="active-peer-4"><a class="anchor" href="#active-peer-4"></a>Active Peer</h5>
<div class="paragraph">
<p>When an active peer disconnects, it must call the <code>ReplicatorConnection.close</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">replicatorConnection?.close(error: nil)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, Couchbase Lite will call back your code through the <code>MessageEndpointConnection.close</code> to give the application a chance to disconnect with the Communication Framework.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">/* implementation of MessageEndpointConnection */
func close(error: Error?, completion: @escaping () -&gt; Void) {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="passive-peer-4"><a class="anchor" href="#passive-peer-4"></a>Passive Peer</h5>
<div class="paragraph">
<p>When the passive peer receives the corresponding disconnect notification from the Communication Framework, it must call the <code>ReplicatorConnection.close</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">replicatorConnection?.close(error: nil)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, Couchbase Lite will call back your code through the <code>MessageEndpointConnection.close</code> to give the application a chance to disconnect with the Communication Framework.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">/* implementation of MessageEndpointConnection */
func close(error: Error?, completion: @escaping () -&gt; Void) {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="initiated-by-passive-peer"><a class="anchor" href="#initiated-by-passive-peer"></a>Initiated by Passive Peer</h4>
<div class="imageblock">
<div class="content">
<img src="_images/dis-passive.png" alt="dis passive">
</div>
</div>
<div class="sect4">
<h5 id="passive-peer-5"><a class="anchor" href="#passive-peer-5"></a>Passive Peer</h5>
<div class="paragraph">
<p>When the passive disconnects, it must class the <code>MessageEndpointListener.closeAll</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">messageEndpointListener?.closeAll()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, Couchbase Lite will call back your code through the <code>MessageEndpointConnection.close</code> to give the application a chance to disconnect with the Communication Framework.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">/* implementation of MessageEndpointConnection */
func close(error: Error?, completion: @escaping () -&gt; Void) {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="active-peer-5"><a class="anchor" href="#active-peer-5"></a>Active Peer</h5>
<div class="paragraph">
<p>When the active peer receives the corresponding disconnect notification from the Communication Framework, it must call the <code>ReplicatorConnection.close</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">replicatorConnection?.close(error: nil)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, Couchbase Lite will call back your code through the <code>MessageEndpointConnection.close</code> to give the application a chance to disconnect with the Communication Framework.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-swift hljs" data-lang="swift">/* implementation of MessageEndpointConnection */
func close(error: Error?, completion: @escaping () -&gt; Void) {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="thread-safety"><a class="anchor" href="#thread-safety"></a>Thread Safety</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Couchbase Lite API is thread safe except for calls to mutable objects: <code>MutableDocument</code>, <code>MutableDictionary</code> and <code>MutableArray</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="release-notes"><a class="anchor" href="#release-notes"></a>Release Notes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="2-1-6"><a class="anchor" href="#2-1-6"></a>2.1.6</h3>
<div class="ulist">
<ul>
<li>
<p>This release is compiled with Xcode 10.2.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="2-1-5"><a class="anchor" href="#2-1-5"></a>2.1.5</h3>
<div class="ulist">
<div class="title">Bugs</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-core/issues/714"><strong>#714</strong></a> docIDs starting with <code>_design/</code> cause the upgrade to 1.x to fail</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-core/issues/712"><strong>#712</strong></a> fleece::Scope throws an exception on a background thread while updating a live query</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="2-1-3"><a class="anchor" href="#2-1-3"></a>2.1.3</h3>
<div class="ulist">
<ul>
<li>
<p>This release is compiled with Xcode 10.1. It will now work with Swift 4.2.1</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Bugs</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2230"><strong>#2230</strong></a> Incompatible Swift version, Swift 4.2.1</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="2-1-2"><a class="anchor" href="#2-1-2"></a>2.1.2</h3>
<div class="ulist">
<div class="title">Bugs</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2205"><strong>#2205</strong></a> Crash when using 2.1 to pull attachments from 2.0</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2216"><strong>#2216</strong></a> Auth Header from BasicAuthenticator not getting sent if SG Guest user is enabled</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="2-1-1"><a class="anchor" href="#2-1-1"></a>2.1.1</h3>
<div class="ulist">
<ul>
<li>
<p>This release is compiled with Xcode 10.0. It will now work with Swift 4.2.1</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="2-1"><a class="anchor" href="#2-1"></a>2.1</h3>
<div class="ulist">
<div class="title">Performance Improvements</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2127"><strong>#2127</strong></a> CBLReplicator always runs on main queue</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Enhancements</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1610"><strong>#1610</strong></a> 2.0: Provide a script to strip simulator architecture frameworks for app submission</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2117"><strong>#2117</strong></a> Implement Database Encryption (EE feature)</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2118"><strong>#2118</strong></a> Support Peer-to-Peer replication through MessageEndpoint API (EE feature)</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2139"><strong>#2139</strong></a> Implement Replicator reset checkpoint feature</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Bugs</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1926"><strong>#1926</strong></a> Swift Replicator.addChangeListener crashes</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2140"><strong>#2140</strong></a> 2.0 : TIC Read Status 1:57 error spam</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2149"><strong>#2149</strong></a> Swift DictionaryObject and ArrayObject not having toMutable() method</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2162"><strong>#2162</strong></a> 2.1 DB1: Crash when inserting image Blobs to objects in embedded array in Swift</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2188"><strong>#2188</strong></a> Replicator not getting stopped when using MessageEndpoint</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Known Issues</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2112"><strong>#2112</strong></a> HTTP proxy support</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2122"><strong>#2122</strong></a> IOS 9 - Got LiteCore error: connection closed abnormally - eventual crash</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="2-0-3"><a class="anchor" href="#2-0-3"></a>2.0.3</h3>
<div class="paragraph">
<div class="title">New Feature&#8201;&#8212;&#8201;Swift Compatibility</div>
<p>This release adds compatibility for Swift 4.1.2 (as part of Xcode 9.4).</p>
</div>
</div>
<div class="sect2">
<h3 id="2-0-2"><a class="anchor" href="#2-0-2"></a>2.0.2</h3>
<div class="paragraph">
<div class="title">New Feature&#8201;&#8212;&#8201;Log redaction</div>
<p>This release adds out-of-the-box support for the redaction of sensitive information in CBL logs.
The redaction requires no configuration.
It will operate whenever logging is enabled.</p>
</div>
<div class="paragraph">
<p>For more on adjusting the logging-levels see <a href="#logging">Logging</a></p>
</div>
</div>
<div class="sect2">
<h3 id="2-0-0"><a class="anchor" href="#2-0-0"></a>2.0.0</h3>
<div class="ulist">
<div class="title">Bugs</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1701"><strong>#1701</strong></a> 2:0 swift expression based query returning empty results</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1836"><strong>#1836</strong></a> 2.0: Database Listener callbacks not always getting called on main thread</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1854"><strong>#1854</strong></a> 2.0 : Dictionary, Array, and Fragment have duplicate definitions</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/1862"><strong>#1862</strong></a> 2.0: CBLQueryExpression "and:" and "or:" methods cause syntax errors in Obj-C++</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2005"><strong>#2005</strong></a> 2.0: Make CBLDatabase query/replication tracking thread-safe</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2035"><strong>#2035</strong></a> Cross Join Not Returning expected results</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2061"><strong>#2061</strong></a> Swift 2.0: LiteCore error trying to copy prebuilt DB</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2085"><strong>#2085</strong></a> Crashed in CBLWebSocket</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2094"><strong>#2094</strong></a> TestSelfSignedSSLFailure_SG failed on iOS 10.2</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2104"><strong>#2104</strong></a> Set Immutable Dictionary or Array to Document causes toDictionary() to crash in Swift</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Known Issues</div>
<ul>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2112"><strong>#2112</strong></a> HTTP proxy support</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2122"><strong>#2122</strong></a> IOS 9 - Got LiteCore error: connection closed abnormally - eventual crash</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2196"><strong>#2196</strong></a> Crash with wifi disabled and bad network</p>
</li>
<li>
<p><a href="https://github.com/couchbase/couchbase-lite-ios/issues/2197"><strong>#2197</strong></a> <code>WebSocket C4 dispatch</code> crash during sync</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../_/img/logo.svg" alt="Couchbase">
          </a>
        </div>
        <div class="contact">
          <p class="address">3250 Olcott Street
Santa Clara, CA 95054
United States</p>
          <a href="https://www.couchbase.com/contact" class="btn white-btn">Contact Us</a>
          <a class="tel" href="tel:1-650-417-7500">1-650-417-7500</a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><span class="heading">Company</span></li>
          <li><a href="https://www.couchbase.com/about">About</a></li>
          <li><a href="https://www.couchbase.com/leadership">Leadership</a></li>
          <li><a href="https://www.couchbase.com/news-and-press-releases">News &amp; Press</a></li>
          <li><a href="https://www.couchbase.com/careers">Careers</a></li>
          <li><a href="https://www.couchbase.com/resources/events">Events</a></li>
          <li><a href="https://www.couchbase.com/contact">Contact Us</a></li>
          <li><a href="https://www.couchbase.com/request-pricing">Pricing</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><span class="heading">Support</span></li>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://www.couchbase.com/services">Professional Services</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support Login</a></li>
          <li><a href="https://learn.couchbase.com/store" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><span class="heading">Quicklinks</span></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Online Training</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
          <li><a href="https://www.couchbase.com/nosql-resources/why-nosql">Why NoSQL</a></li>
          <li><a href="https://www.couchbase.com/resources/security">Security</a></li>
          <li><a href="https://www.couchbase.com/resources/gdpr">GDPR</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <a href="https://www.facebook.com/Couchbase" class="icon">
              <svg width="50px" height="50px" viewBox="26.363 116.363 560.215 560.215"><path d="m586.58 209.58c0-48.96-44.252-93.212-93.212-93.212h-373.79c-48.96 0-93.212 44.252-93.212 93.212v373.79c0 48.96 44.252 93.212 93.212 93.212h186.42v-211.85h-68.732v-93.212h68.732v-36.72c0-63.083 47.077-119.58 105.45-119.58h75.323v93.212h-75.323c-8.474 0-17.889 10.357-17.889 25.422v37.662h93.212v93.212h-93.212v211.85h99.803c48.96 0 93.212-44.252 93.212-93.212v-373.79z"/></svg>
            </a>
          </li>
          <li>
            <a href="https://twitter.com/couchbase" class="icon">
              <svg width="50px" height="50px" viewBox="32.012 176.622 542.326 437.815"><path d="m574.34 227.46c-19.772 8.474-41.428 15.065-64.025 17.889 22.597-14.123 40.486-35.778 48.96-61.2-21.655 13.182-45.194 21.655-70.615 27.305-20.714-21.655-48.96-34.837-80.972-34.837-61.2 0-111.1 49.902-111.1 111.1 0 8.474 0.942 16.948 2.825 25.422-92.271-5.649-174.18-49.902-229.74-117.69-9.415 16.006-15.065 35.778-15.065 55.551 0 38.603 19.772 72.498 49.902 92.271-17.889-0.942-35.778-5.649-50.843-14.123v0.942c0 53.668 38.603 98.862 89.446 109.22-9.415 2.825-18.831 3.766-29.188 3.766-7.532 0-14.123-0.942-20.714-1.883 14.123 44.252 55.551 76.265 103.57 77.206-37.662 30.129-85.68 48.018-138.41 48.018-9.415 0-17.889-0.941-26.363-1.883 48.96 32.012 107.34 49.902 170.42 49.902 204.31 0 316.36-169.48 316.36-316.36v-14.123c21.656-14.125 40.487-33.897 55.551-56.494z"/></svg>
            </a>
          </li>
          <li>
            <a href="https://www.linkedin.com/company/couchbase" class="icon">
              <svg width="50px" height="50px" viewBox="31.071 119.188 539.537 540.443"><path d="m531.97 119.19h-461.35c-21.655 0-39.545 16.948-39.545 38.603v463.24c0 21.655 17.889 38.603 39.545 38.603h460.41c21.655 0 39.545-16.948 39.545-38.603v-463.24c0.942-21.656-16.947-38.603-38.603-38.603zm-337.07 451.94h-81.914v-243.86h81.914v243.86zm-40.486-276.81c-28.246 0-46.135-18.831-46.135-42.369s17.889-42.369 46.135-42.369 45.194 17.889 45.194 42.369c0.942 23.538-16.948 42.369-45.194 42.369zm335.19 276.81h-81.914v-129.93c0-32.954-12.24-55.551-41.428-55.551-22.597 0-35.778 15.065-41.428 30.129-1.883 5.649-2.825 12.24-2.825 19.772v136.52h-81.914s0.942-221.26 0-243.86h81.914v34.837c11.298-16.948 30.129-40.486 73.44-40.486 53.668 0 94.154 34.837 94.154 110.16l1e-3 138.41zm-168.54-208.08s0.941-0.941 0 0z"/></svg>
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <span>2018 COUCHBASE All rights reserved.</span>
      <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
      <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
      <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
      <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
    </div>
  </div>
</footer>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
